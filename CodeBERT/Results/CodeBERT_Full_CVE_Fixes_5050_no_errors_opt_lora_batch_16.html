<!DOCTYPE html>

<html lang="en">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>CodeBERT_Full_CVE_Fixes_5050_no_errors_opt_lora_batch_16</title><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<style type="text/css">
    pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: var(--jp-cell-editor-active-background) }
.highlight { background: var(--jp-cell-editor-background); color: var(--jp-mirror-editor-variable-color) }
.highlight .c { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment */
.highlight .err { color: var(--jp-mirror-editor-error-color) } /* Error */
.highlight .k { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword */
.highlight .o { color: var(--jp-mirror-editor-operator-color); font-weight: bold } /* Operator */
.highlight .p { color: var(--jp-mirror-editor-punctuation-color) } /* Punctuation */
.highlight .ch { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Multiline */
.highlight .cp { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Single */
.highlight .cs { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Special */
.highlight .kc { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Type */
.highlight .m { color: var(--jp-mirror-editor-number-color) } /* Literal.Number */
.highlight .s { color: var(--jp-mirror-editor-string-color) } /* Literal.String */
.highlight .ow { color: var(--jp-mirror-editor-operator-color); font-weight: bold } /* Operator.Word */
.highlight .pm { color: var(--jp-mirror-editor-punctuation-color) } /* Punctuation.Marker */
.highlight .w { color: var(--jp-mirror-editor-variable-color) } /* Text.Whitespace */
.highlight .mb { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Bin */
.highlight .mf { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Float */
.highlight .mh { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Hex */
.highlight .mi { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Integer */
.highlight .mo { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Oct */
.highlight .sa { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Affix */
.highlight .sb { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Backtick */
.highlight .sc { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Char */
.highlight .dl { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Delimiter */
.highlight .sd { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Doc */
.highlight .s2 { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Double */
.highlight .se { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Escape */
.highlight .sh { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Heredoc */
.highlight .si { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Interpol */
.highlight .sx { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Other */
.highlight .sr { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Regex */
.highlight .s1 { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Single */
.highlight .ss { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Symbol */
.highlight .il { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Integer.Long */
  </style>
<style type="text/css">
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*
 * Mozilla scrollbar styling
 */

/* use standard opaque scrollbars for most nodes */
[data-jp-theme-scrollbars='true'] {
  scrollbar-color: rgb(var(--jp-scrollbar-thumb-color))
    var(--jp-scrollbar-background-color);
}

/* for code nodes, use a transparent style of scrollbar. These selectors
 * will match lower in the tree, and so will override the above */
[data-jp-theme-scrollbars='true'] .CodeMirror-hscrollbar,
[data-jp-theme-scrollbars='true'] .CodeMirror-vscrollbar {
  scrollbar-color: rgba(var(--jp-scrollbar-thumb-color), 0.5) transparent;
}

/* tiny scrollbar */

.jp-scrollbar-tiny {
  scrollbar-color: rgba(var(--jp-scrollbar-thumb-color), 0.5) transparent;
  scrollbar-width: thin;
}

/* tiny scrollbar */

.jp-scrollbar-tiny::-webkit-scrollbar,
.jp-scrollbar-tiny::-webkit-scrollbar-corner {
  background-color: transparent;
  height: 4px;
  width: 4px;
}

.jp-scrollbar-tiny::-webkit-scrollbar-thumb {
  background: rgba(var(--jp-scrollbar-thumb-color), 0.5);
}

.jp-scrollbar-tiny::-webkit-scrollbar-track:horizontal {
  border-left: 0 solid transparent;
  border-right: 0 solid transparent;
}

.jp-scrollbar-tiny::-webkit-scrollbar-track:vertical {
  border-top: 0 solid transparent;
  border-bottom: 0 solid transparent;
}

/*
 * Lumino
 */

.lm-ScrollBar[data-orientation='horizontal'] {
  min-height: 16px;
  max-height: 16px;
  min-width: 45px;
  border-top: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='vertical'] {
  min-width: 16px;
  max-width: 16px;
  min-height: 45px;
  border-left: 1px solid #a0a0a0;
}

.lm-ScrollBar-button {
  background-color: #f0f0f0;
  background-position: center center;
  min-height: 15px;
  max-height: 15px;
  min-width: 15px;
  max-width: 15px;
}

.lm-ScrollBar-button:hover {
  background-color: #dadada;
}

.lm-ScrollBar-button.lm-mod-active {
  background-color: #cdcdcd;
}

.lm-ScrollBar-track {
  background: #f0f0f0;
}

.lm-ScrollBar-thumb {
  background: #cdcdcd;
}

.lm-ScrollBar-thumb:hover {
  background: #bababa;
}

.lm-ScrollBar-thumb.lm-mod-active {
  background: #a0a0a0;
}

.lm-ScrollBar[data-orientation='horizontal'] .lm-ScrollBar-thumb {
  height: 100%;
  min-width: 15px;
  border-left: 1px solid #a0a0a0;
  border-right: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='vertical'] .lm-ScrollBar-thumb {
  width: 100%;
  min-height: 15px;
  border-top: 1px solid #a0a0a0;
  border-bottom: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='horizontal']
  .lm-ScrollBar-button[data-action='decrement'] {
  background-image: var(--jp-icon-caret-left);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='horizontal']
  .lm-ScrollBar-button[data-action='increment'] {
  background-image: var(--jp-icon-caret-right);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='vertical']
  .lm-ScrollBar-button[data-action='decrement'] {
  background-image: var(--jp-icon-caret-up);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='vertical']
  .lm-ScrollBar-button[data-action='increment'] {
  background-image: var(--jp-icon-caret-down);
  background-size: 17px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-Widget {
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
}

.lm-Widget.lm-mod-hidden {
  display: none !important;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.lm-AccordionPanel[data-orientation='horizontal'] > .lm-AccordionPanel-title {
  /* Title is rotated for horizontal accordion panel using CSS */
  display: block;
  transform-origin: top left;
  transform: rotate(-90deg) translate(-100%);
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-CommandPalette {
  display: flex;
  flex-direction: column;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-CommandPalette-search {
  flex: 0 0 auto;
}

.lm-CommandPalette-content {
  flex: 1 1 auto;
  margin: 0;
  padding: 0;
  min-height: 0;
  overflow: auto;
  list-style-type: none;
}

.lm-CommandPalette-header {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.lm-CommandPalette-item {
  display: flex;
  flex-direction: row;
}

.lm-CommandPalette-itemIcon {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemContent {
  flex: 1 1 auto;
  overflow: hidden;
}

.lm-CommandPalette-itemShortcut {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemLabel {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.lm-close-icon {
  border: 1px solid transparent;
  background-color: transparent;
  position: absolute;
  z-index: 1;
  right: 3%;
  top: 0;
  bottom: 0;
  margin: auto;
  padding: 7px 0;
  display: none;
  vertical-align: middle;
  outline: 0;
  cursor: pointer;
}
.lm-close-icon:after {
  content: 'X';
  display: block;
  width: 15px;
  height: 15px;
  text-align: center;
  color: #000;
  font-weight: normal;
  font-size: 12px;
  cursor: pointer;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-DockPanel {
  z-index: 0;
}

.lm-DockPanel-widget {
  z-index: 0;
}

.lm-DockPanel-tabBar {
  z-index: 1;
}

.lm-DockPanel-handle {
  z-index: 2;
}

.lm-DockPanel-handle.lm-mod-hidden {
  display: none !important;
}

.lm-DockPanel-handle:after {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  content: '';
}

.lm-DockPanel-handle[data-orientation='horizontal'] {
  cursor: ew-resize;
}

.lm-DockPanel-handle[data-orientation='vertical'] {
  cursor: ns-resize;
}

.lm-DockPanel-handle[data-orientation='horizontal']:after {
  left: 50%;
  min-width: 8px;
  transform: translateX(-50%);
}

.lm-DockPanel-handle[data-orientation='vertical']:after {
  top: 50%;
  min-height: 8px;
  transform: translateY(-50%);
}

.lm-DockPanel-overlay {
  z-index: 3;
  box-sizing: border-box;
  pointer-events: none;
}

.lm-DockPanel-overlay.lm-mod-hidden {
  display: none !important;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-Menu {
  z-index: 10000;
  position: absolute;
  white-space: nowrap;
  overflow-x: hidden;
  overflow-y: auto;
  outline: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-Menu-content {
  margin: 0;
  padding: 0;
  display: table;
  list-style-type: none;
}

.lm-Menu-item {
  display: table-row;
}

.lm-Menu-item.lm-mod-hidden,
.lm-Menu-item.lm-mod-collapsed {
  display: none !important;
}

.lm-Menu-itemIcon,
.lm-Menu-itemSubmenuIcon {
  display: table-cell;
  text-align: center;
}

.lm-Menu-itemLabel {
  display: table-cell;
  text-align: left;
}

.lm-Menu-itemShortcut {
  display: table-cell;
  text-align: right;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-MenuBar {
  outline: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-MenuBar-content {
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: row;
  list-style-type: none;
}

.lm-MenuBar-item {
  box-sizing: border-box;
}

.lm-MenuBar-itemIcon,
.lm-MenuBar-itemLabel {
  display: inline-block;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-ScrollBar {
  display: flex;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-ScrollBar[data-orientation='horizontal'] {
  flex-direction: row;
}

.lm-ScrollBar[data-orientation='vertical'] {
  flex-direction: column;
}

.lm-ScrollBar-button {
  box-sizing: border-box;
  flex: 0 0 auto;
}

.lm-ScrollBar-track {
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
  flex: 1 1 auto;
}

.lm-ScrollBar-thumb {
  box-sizing: border-box;
  position: absolute;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-SplitPanel-child {
  z-index: 0;
}

.lm-SplitPanel-handle {
  z-index: 1;
}

.lm-SplitPanel-handle.lm-mod-hidden {
  display: none !important;
}

.lm-SplitPanel-handle:after {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  content: '';
}

.lm-SplitPanel[data-orientation='horizontal'] > .lm-SplitPanel-handle {
  cursor: ew-resize;
}

.lm-SplitPanel[data-orientation='vertical'] > .lm-SplitPanel-handle {
  cursor: ns-resize;
}

.lm-SplitPanel[data-orientation='horizontal'] > .lm-SplitPanel-handle:after {
  left: 50%;
  min-width: 8px;
  transform: translateX(-50%);
}

.lm-SplitPanel[data-orientation='vertical'] > .lm-SplitPanel-handle:after {
  top: 50%;
  min-height: 8px;
  transform: translateY(-50%);
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-TabBar {
  display: flex;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-TabBar[data-orientation='horizontal'] {
  flex-direction: row;
  align-items: flex-end;
}

.lm-TabBar[data-orientation='vertical'] {
  flex-direction: column;
  align-items: flex-end;
}

.lm-TabBar-content {
  margin: 0;
  padding: 0;
  display: flex;
  flex: 1 1 auto;
  list-style-type: none;
}

.lm-TabBar[data-orientation='horizontal'] > .lm-TabBar-content {
  flex-direction: row;
}

.lm-TabBar[data-orientation='vertical'] > .lm-TabBar-content {
  flex-direction: column;
}

.lm-TabBar-tab {
  display: flex;
  flex-direction: row;
  box-sizing: border-box;
  overflow: hidden;
  touch-action: none; /* Disable native Drag/Drop */
}

.lm-TabBar-tabIcon,
.lm-TabBar-tabCloseIcon {
  flex: 0 0 auto;
}

.lm-TabBar-tabLabel {
  flex: 1 1 auto;
  overflow: hidden;
  white-space: nowrap;
}

.lm-TabBar-tabInput {
  user-select: all;
  width: 100%;
  box-sizing: border-box;
}

.lm-TabBar-tab.lm-mod-hidden {
  display: none !important;
}

.lm-TabBar-addButton.lm-mod-hidden {
  display: none !important;
}

.lm-TabBar.lm-mod-dragging .lm-TabBar-tab {
  position: relative;
}

.lm-TabBar.lm-mod-dragging[data-orientation='horizontal'] .lm-TabBar-tab {
  left: 0;
  transition: left 150ms ease;
}

.lm-TabBar.lm-mod-dragging[data-orientation='vertical'] .lm-TabBar-tab {
  top: 0;
  transition: top 150ms ease;
}

.lm-TabBar.lm-mod-dragging .lm-TabBar-tab.lm-mod-dragging {
  transition: none;
}

.lm-TabBar-tabLabel .lm-TabBar-tabInput {
  user-select: all;
  width: 100%;
  box-sizing: border-box;
  background: inherit;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-TabPanel-tabBar {
  z-index: 1;
}

.lm-TabPanel-stackedPanel {
  z-index: 0;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Collapse {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}

.jp-Collapse-header {
  padding: 1px 12px;
  background-color: var(--jp-layout-color1);
  border-bottom: solid var(--jp-border-width) var(--jp-border-color2);
  color: var(--jp-ui-font-color1);
  cursor: pointer;
  display: flex;
  align-items: center;
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  text-transform: uppercase;
  user-select: none;
}

.jp-Collapser-icon {
  height: 16px;
}

.jp-Collapse-header-collapsed .jp-Collapser-icon {
  transform: rotate(-90deg);
  margin: auto 0;
}

.jp-Collapser-title {
  line-height: 25px;
}

.jp-Collapse-contents {
  padding: 0 12px;
  background-color: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  overflow: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* This file was auto-generated by ensureUiComponents() in @jupyterlab/buildutils */

/**
 * (DEPRECATED) Support for consuming icons as CSS background images
 */

/* Icons urls */

:root {
  --jp-icon-add-above: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzN18xOTQ5MikiPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGQ9Ik00Ljc1IDQuOTMwNjZINi42MjVWNi44MDU2NkM2LjYyNSA3LjAxMTkxIDYuNzkzNzUgNy4xODA2NiA3IDcuMTgwNjZDNy4yMDYyNSA3LjE4MDY2IDcuMzc1IDcuMDExOTEgNy4zNzUgNi44MDU2NlY0LjkzMDY2SDkuMjVDOS40NTYyNSA0LjkzMDY2IDkuNjI1IDQuNzYxOTEgOS42MjUgNC41NTU2NkM5LjYyNSA0LjM0OTQxIDkuNDU2MjUgNC4xODA2NiA5LjI1IDQuMTgwNjZINy4zNzVWMi4zMDU2NkM3LjM3NSAyLjA5OTQxIDcuMjA2MjUgMS45MzA2NiA3IDEuOTMwNjZDNi43OTM3NSAxLjkzMDY2IDYuNjI1IDIuMDk5NDEgNi42MjUgMi4zMDU2NlY0LjE4MDY2SDQuNzVDNC41NDM3NSA0LjE4MDY2IDQuMzc1IDQuMzQ5NDEgNC4zNzUgNC41NTU2NkM0LjM3NSA0Ljc2MTkxIDQuNTQzNzUgNC45MzA2NiA0Ljc1IDQuOTMwNjZaIiBmaWxsPSIjNjE2MTYxIiBzdHJva2U9IiM2MTYxNjEiIHN0cm9rZS13aWR0aD0iMC43Ii8+CjwvZz4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjUgOS41VjExLjVMMi41IDExLjVWOS41TDExLjUgOS41Wk0xMiA4QzEyLjU1MjMgOCAxMyA4LjQ0NzcyIDEzIDlWMTJDMTMgMTIuNTUyMyAxMi41NTIzIDEzIDEyIDEzTDIgMTNDMS40NDc3MiAxMyAxIDEyLjU1MjMgMSAxMlY5QzEgOC40NDc3MiAxLjQ0NzcxIDggMiA4TDEyIDhaIiBmaWxsPSIjNjE2MTYxIi8+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzN18xOTQ5MiI+CjxyZWN0IGNsYXNzPSJqcC1pY29uMyIgd2lkdGg9IjYiIGhlaWdodD0iNiIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0ibWF0cml4KC0xIDAgMCAxIDEwIDEuNTU1NjYpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==);
  --jp-icon-add-below: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzN18xOTQ5OCkiPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGQ9Ik05LjI1IDEwLjA2OTNMNy4zNzUgMTAuMDY5M0w3LjM3NSA4LjE5NDM0QzcuMzc1IDcuOTg4MDkgNy4yMDYyNSA3LjgxOTM0IDcgNy44MTkzNEM2Ljc5Mzc1IDcuODE5MzQgNi42MjUgNy45ODgwOSA2LjYyNSA4LjE5NDM0TDYuNjI1IDEwLjA2OTNMNC43NSAxMC4wNjkzQzQuNTQzNzUgMTAuMDY5MyA0LjM3NSAxMC4yMzgxIDQuMzc1IDEwLjQ0NDNDNC4zNzUgMTAuNjUwNiA0LjU0Mzc1IDEwLjgxOTMgNC43NSAxMC44MTkzTDYuNjI1IDEwLjgxOTNMNi42MjUgMTIuNjk0M0M2LjYyNSAxMi45MDA2IDYuNzkzNzUgMTMuMDY5MyA3IDEzLjA2OTNDNy4yMDYyNSAxMy4wNjkzIDcuMzc1IDEyLjkwMDYgNy4zNzUgMTIuNjk0M0w3LjM3NSAxMC44MTkzTDkuMjUgMTAuODE5M0M5LjQ1NjI1IDEwLjgxOTMgOS42MjUgMTAuNjUwNiA5LjYyNSAxMC40NDQzQzkuNjI1IDEwLjIzODEgOS40NTYyNSAxMC4wNjkzIDkuMjUgMTAuMDY5M1oiIGZpbGw9IiM2MTYxNjEiIHN0cm9rZT0iIzYxNjE2MSIgc3Ryb2tlLXdpZHRoPSIwLjciLz4KPC9nPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMi41IDUuNUwyLjUgMy41TDExLjUgMy41TDExLjUgNS41TDIuNSA1LjVaTTIgN0MxLjQ0NzcyIDcgMSA2LjU1MjI4IDEgNkwxIDNDMSAyLjQ0NzcyIDEuNDQ3NzIgMiAyIDJMMTIgMkMxMi41NTIzIDIgMTMgMi40NDc3MiAxMyAzTDEzIDZDMTMgNi41NTIyOSAxMi41NTIzIDcgMTIgN0wyIDdaIiBmaWxsPSIjNjE2MTYxIi8+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzN18xOTQ5OCI+CjxyZWN0IGNsYXNzPSJqcC1pY29uMyIgd2lkdGg9IjYiIGhlaWdodD0iNiIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0ibWF0cml4KDEgMS43NDg0NmUtMDcgMS43NDg0NmUtMDcgLTEgNCAxMy40NDQzKSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=);
  --jp-icon-add: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE5IDEzaC02djZoLTJ2LTZINXYtMmg2VjVoMnY2aDZ2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-bell: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiPgogICA8cGF0aCBjbGFzcz0ianAtaWNvbjIganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMzMzMzMzIgogICAgICBkPSJtOCAwLjI5Yy0xLjQgMC0yLjcgMC43My0zLjYgMS44LTEuMiAxLjUtMS40IDMuNC0xLjUgNS4yLTAuMTggMi4yLTAuNDQgNC0yLjMgNS4zbDAuMjggMS4zaDVjMC4wMjYgMC42NiAwLjMyIDEuMSAwLjcxIDEuNSAwLjg0IDAuNjEgMiAwLjYxIDIuOCAwIDAuNTItMC40IDAuNi0xIDAuNzEtMS41aDVsMC4yOC0xLjNjLTEuOS0wLjk3LTIuMi0zLjMtMi4zLTUuMy0wLjEzLTEuOC0wLjI2LTMuNy0xLjUtNS4yLTAuODUtMS0yLjItMS44LTMuNi0xLjh6bTAgMS40YzAuODggMCAxLjkgMC41NSAyLjUgMS4zIDAuODggMS4xIDEuMSAyLjcgMS4yIDQuNCAwLjEzIDEuNyAwLjIzIDMuNiAxLjMgNS4yaC0xMGMxLjEtMS42IDEuMi0zLjQgMS4zLTUuMiAwLjEzLTEuNyAwLjMtMy4zIDEuMi00LjQgMC41OS0wLjcyIDEuNi0xLjMgMi41LTEuM3ptLTAuNzQgMTJoMS41Yy0wLjAwMTUgMC4yOCAwLjAxNSAwLjc5LTAuNzQgMC43OS0wLjczIDAuMDAxNi0wLjcyLTAuNTMtMC43NC0wLjc5eiIgLz4KPC9zdmc+Cg==);
  --jp-icon-bug-dot: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiPgogICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTcuMTkgOEgyMFYxMEgxNy45MUMxNy45NiAxMC4zMyAxOCAxMC42NiAxOCAxMVYxMkgyMFYxNEgxOC41SDE4VjE0LjAyNzVDMTUuNzUgMTQuMjc2MiAxNCAxNi4xODM3IDE0IDE4LjVDMTQgMTkuMjA4IDE0LjE2MzUgMTkuODc3OSAxNC40NTQ5IDIwLjQ3MzlDMTMuNzA2MyAyMC44MTE3IDEyLjg3NTcgMjEgMTIgMjFDOS43OCAyMSA3Ljg1IDE5Ljc5IDYuODEgMThINFYxNkg2LjA5QzYuMDQgMTUuNjcgNiAxNS4zNCA2IDE1VjE0SDRWMTJINlYxMUM2IDEwLjY2IDYuMDQgMTAuMzMgNi4wOSAxMEg0VjhINi44MUM3LjI2IDcuMjIgNy44OCA2LjU1IDguNjIgNi4wNEw3IDQuNDFMOC40MSAzTDEwLjU5IDUuMTdDMTEuMDQgNS4wNiAxMS41MSA1IDEyIDVDMTIuNDkgNSAxMi45NiA1LjA2IDEzLjQyIDUuMTdMMTUuNTkgM0wxNyA0LjQxTDE1LjM3IDYuMDRDMTYuMTIgNi41NSAxNi43NCA3LjIyIDE3LjE5IDhaTTEwIDE2SDE0VjE0SDEwVjE2Wk0xMCAxMkgxNFYxMEgxMFYxMloiIGZpbGw9IiM2MTYxNjEiLz4KICAgICAgICA8cGF0aCBkPSJNMjIgMTguNUMyMiAyMC40MzMgMjAuNDMzIDIyIDE4LjUgMjJDMTYuNTY3IDIyIDE1IDIwLjQzMyAxNSAxOC41QzE1IDE2LjU2NyAxNi41NjcgMTUgMTguNSAxNUMyMC40MzMgMTUgMjIgMTYuNTY3IDIyIDE4LjVaIiBmaWxsPSIjNjE2MTYxIi8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-bug: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0yMCA4aC0yLjgxYy0uNDUtLjc4LTEuMDctMS40NS0xLjgyLTEuOTZMMTcgNC40MSAxNS41OSAzbC0yLjE3IDIuMTdDMTIuOTYgNS4wNiAxMi40OSA1IDEyIDVjLS40OSAwLS45Ni4wNi0xLjQxLjE3TDguNDEgMyA3IDQuNDFsMS42MiAxLjYzQzcuODggNi41NSA3LjI2IDcuMjIgNi44MSA4SDR2MmgyLjA5Yy0uMDUuMzMtLjA5LjY2LS4wOSAxdjFINHYyaDJ2MWMwIC4zNC4wNC42Ny4wOSAxSDR2MmgyLjgxYzEuMDQgMS43OSAyLjk3IDMgNS4xOSAzczQuMTUtMS4yMSA1LjE5LTNIMjB2LTJoLTIuMDljLjA1LS4zMy4wOS0uNjYuMDktMXYtMWgydi0yaC0ydi0xYzAtLjM0LS4wNC0uNjctLjA5LTFIMjBWOHptLTYgOGgtNHYtMmg0djJ6bTAtNGgtNHYtMmg0djJ6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-build: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE0LjkgMTcuNDVDMTYuMjUgMTcuNDUgMTcuMzUgMTYuMzUgMTcuMzUgMTVDMTcuMzUgMTMuNjUgMTYuMjUgMTIuNTUgMTQuOSAxMi41NUMxMy41NCAxMi41NSAxMi40NSAxMy42NSAxMi40NSAxNUMxMi40NSAxNi4zNSAxMy41NCAxNy40NSAxNC45IDE3LjQ1Wk0yMC4xIDE1LjY4TDIxLjU4IDE2Ljg0QzIxLjcxIDE2Ljk1IDIxLjc1IDE3LjEzIDIxLjY2IDE3LjI5TDIwLjI2IDE5LjcxQzIwLjE3IDE5Ljg2IDIwIDE5LjkyIDE5LjgzIDE5Ljg2TDE4LjA5IDE5LjE2QzE3LjczIDE5LjQ0IDE3LjMzIDE5LjY3IDE2LjkxIDE5Ljg1TDE2LjY0IDIxLjdDMTYuNjIgMjEuODcgMTYuNDcgMjIgMTYuMyAyMkgxMy41QzEzLjMyIDIyIDEzLjE4IDIxLjg3IDEzLjE1IDIxLjdMMTIuODkgMTkuODVDMTIuNDYgMTkuNjcgMTIuMDcgMTkuNDQgMTEuNzEgMTkuMTZMOS45NjAwMiAxOS44NkM5LjgxMDAyIDE5LjkyIDkuNjIwMDIgMTkuODYgOS41NDAwMiAxOS43MUw4LjE0MDAyIDE3LjI5QzguMDUwMDIgMTcuMTMgOC4wOTAwMiAxNi45NSA4LjIyMDAyIDE2Ljg0TDkuNzAwMDIgMTUuNjhMOS42NTAwMSAxNUw5LjcwMDAyIDE0LjMxTDguMjIwMDIgMTMuMTZDOC4wOTAwMiAxMy4wNSA4LjA1MDAyIDEyLjg2IDguMTQwMDIgMTIuNzFMOS41NDAwMiAxMC4yOUM5LjYyMDAyIDEwLjEzIDkuODEwMDIgMTAuMDcgOS45NjAwMiAxMC4xM0wxMS43MSAxMC44NEMxMi4wNyAxMC41NiAxMi40NiAxMC4zMiAxMi44OSAxMC4xNUwxMy4xNSA4LjI4OTk4QzEzLjE4IDguMTI5OTggMTMuMzIgNy45OTk5OCAxMy41IDcuOTk5OThIMTYuM0MxNi40NyA3Ljk5OTk4IDE2LjYyIDguMTI5OTggMTYuNjQgOC4yODk5OEwxNi45MSAxMC4xNUMxNy4zMyAxMC4zMiAxNy43MyAxMC41NiAxOC4wOSAxMC44NEwxOS44MyAxMC4xM0MyMCAxMC4wNyAyMC4xNyAxMC4xMyAyMC4yNiAxMC4yOUwyMS42NiAxMi43MUMyMS43NSAxMi44NiAyMS43MSAxMy4wNSAyMS41OCAxMy4xNkwyMC4xIDE0LjMxTDIwLjE1IDE1TDIwLjEgMTUuNjhaIi8+CiAgICA8cGF0aCBkPSJNNy4zMjk2NiA3LjQ0NDU0QzguMDgzMSA3LjAwOTU0IDguMzM5MzIgNi4wNTMzMiA3LjkwNDMyIDUuMjk5ODhDNy40NjkzMiA0LjU0NjQzIDYuNTA4MSA0LjI4MTU2IDUuNzU0NjYgNC43MTY1NkM1LjM5MTc2IDQuOTI2MDggNS4xMjY5NSA1LjI3MTE4IDUuMDE4NDkgNS42NzU5NEM0LjkxMDA0IDYuMDgwNzEgNC45NjY4MiA2LjUxMTk4IDUuMTc2MzQgNi44NzQ4OEM1LjYxMTM0IDcuNjI4MzIgNi41NzYyMiA3Ljg3OTU0IDcuMzI5NjYgNy40NDQ1NFpNOS42NTcxOCA0Ljc5NTkzTDEwLjg2NzIgNC45NTE3OUMxMC45NjI4IDQuOTc3NDEgMTEuMDQwMiA1LjA3MTMzIDExLjAzODIgNS4xODc5M0wxMS4wMzg4IDYuOTg4OTNDMTEuMDQ1NSA3LjEwMDU0IDEwLjk2MTYgNy4xOTUxOCAxMC44NTUgNy4yMTA1NEw5LjY2MDAxIDcuMzgwODNMOS4yMzkxNSA4LjEzMTg4TDkuNjY5NjEgOS4yNTc0NUM5LjcwNzI5IDkuMzYyNzEgOS42NjkzNCA5LjQ3Njk5IDkuNTc0MDggOS41MzE5OUw4LjAxNTIzIDEwLjQzMkM3LjkxMTMxIDEwLjQ5MiA3Ljc5MzM3IDEwLjQ2NzcgNy43MjEwNSAxMC4zODI0TDYuOTg3NDggOS40MzE4OEw2LjEwOTMxIDkuNDMwODNMNS4zNDcwNCAxMC4zOTA1QzUuMjg5MDkgMTAuNDcwMiA1LjE3MzgzIDEwLjQ5MDUgNS4wNzE4NyAxMC40MzM5TDMuNTEyNDUgOS41MzI5M0MzLjQxMDQ5IDkuNDc2MzMgMy4zNzY0NyA5LjM1NzQxIDMuNDEwNzUgOS4yNTY3OUwzLjg2MzQ3IDguMTQwOTNMMy42MTc0OSA3Ljc3NDg4TDMuNDIzNDcgNy4zNzg4M0wyLjIzMDc1IDcuMjEyOTdDMi4xMjY0NyA3LjE5MjM1IDIuMDQwNDkgNy4xMDM0MiAyLjA0MjQ1IDYuOTg2ODJMMi4wNDE4NyA1LjE4NTgyQzIuMDQzODMgNS4wNjkyMiAyLjExOTA5IDQuOTc5NTggMi4yMTcwNCA0Ljk2OTIyTDMuNDIwNjUgNC43OTM5M0wzLjg2NzQ5IDQuMDI3ODhMMy40MTEwNSAyLjkxNzMxQzMuMzczMzcgMi44MTIwNCAzLjQxMTMxIDIuNjk3NzYgMy41MTUyMyAyLjYzNzc2TDUuMDc0MDggMS43Mzc3NkM1LjE2OTM0IDEuNjgyNzYgNS4yODcyOSAxLjcwNzA0IDUuMzU5NjEgMS43OTIzMUw2LjExOTE1IDIuNzI3ODhMNi45ODAwMSAyLjczODkzTDcuNzI0OTYgMS43ODkyMkM3Ljc5MTU2IDEuNzA0NTggNy45MTU0OCAxLjY3OTIyIDguMDA4NzkgMS43NDA4Mkw5LjU2ODIxIDIuNjQxODJDOS42NzAxNyAyLjY5ODQyIDkuNzEyODUgMi44MTIzNCA5LjY4NzIzIDIuOTA3OTdMOS4yMTcxOCA0LjAzMzgzTDkuNDYzMTYgNC4zOTk4OEw5LjY1NzE4IDQuNzk1OTNaIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down-empty-thin: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iOS45LDEzLjYgMy42LDcuNCA0LjQsNi42IDkuOSwxMi4yIDE1LjQsNi43IDE2LjEsNy40ICIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down-empty: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik01LjIsNS45TDksOS43bDMuOC0zLjhsMS4yLDEuMmwtNC45LDVsLTQuOS01TDUuMiw1Ljl6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik01LjIsNy41TDksMTEuMmwzLjgtMy44SDUuMnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-caret-left: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwYXRoIGQ9Ik0xMC44LDEyLjhMNy4xLDlsMy44LTMuOGwwLDcuNkgxMC44eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-caret-right: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik03LjIsNS4yTDEwLjksOWwtMy44LDMuOFY1LjJINy4yeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-caret-up-empty-thin: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iMTUuNCwxMy4zIDkuOSw3LjcgNC40LDEzLjIgMy42LDEyLjUgOS45LDYuMyAxNi4xLDEyLjYgIi8+Cgk8L2c+Cjwvc3ZnPgo=);
  --jp-icon-caret-up: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwYXRoIGQ9Ik01LjIsMTAuNUw5LDYuOGwzLjgsMy44SDUuMnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-case-sensitive: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0MTQxNDEiPgogICAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiAgPC9nPgogIDxnIGNsYXNzPSJqcC1pY29uLWFjY2VudDIiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTcuNiw4aDAuOWwzLjUsOGgtMS4xTDEwLDE0SDZsLTAuOSwySDRMNy42LDh6IE04LDkuMUw2LjQsMTNoMy4yTDgsOS4xeiIvPgogICAgPHBhdGggZD0iTTE2LjYsOS44Yy0wLjIsMC4xLTAuNCwwLjEtMC43LDAuMWMtMC4yLDAtMC40LTAuMS0wLjYtMC4yYy0wLjEtMC4xLTAuMi0wLjQtMC4yLTAuNyBjLTAuMywwLjMtMC42LDAuNS0wLjksMC43Yy0wLjMsMC4xLTAuNywwLjItMS4xLDAuMmMtMC4zLDAtMC41LDAtMC43LTAuMWMtMC4yLTAuMS0wLjQtMC4yLTAuNi0wLjNjLTAuMi0wLjEtMC4zLTAuMy0wLjQtMC41IGMtMC4xLTAuMi0wLjEtMC40LTAuMS0wLjdjMC0wLjMsMC4xLTAuNiwwLjItMC44YzAuMS0wLjIsMC4zLTAuNCwwLjQtMC41QzEyLDcsMTIuMiw2LjksMTIuNSw2LjhjMC4yLTAuMSwwLjUtMC4xLDAuNy0wLjIgYzAuMy0wLjEsMC41LTAuMSwwLjctMC4xYzAuMiwwLDAuNC0wLjEsMC42LTAuMWMwLjIsMCwwLjMtMC4xLDAuNC0wLjJjMC4xLTAuMSwwLjItMC4yLDAuMi0wLjRjMC0xLTEuMS0xLTEuMy0xIGMtMC40LDAtMS40LDAtMS40LDEuMmgtMC45YzAtMC40LDAuMS0wLjcsMC4yLTFjMC4xLTAuMiwwLjMtMC40LDAuNS0wLjZjMC4yLTAuMiwwLjUtMC4zLDAuOC0wLjNDMTMuMyw0LDEzLjYsNCwxMy45LDQgYzAuMywwLDAuNSwwLDAuOCwwLjFjMC4zLDAsMC41LDAuMSwwLjcsMC4yYzAuMiwwLjEsMC40LDAuMywwLjUsMC41QzE2LDUsMTYsNS4yLDE2LDUuNnYyLjljMCwwLjIsMCwwLjQsMCwwLjUgYzAsMC4xLDAuMSwwLjIsMC4zLDAuMmMwLjEsMCwwLjIsMCwwLjMsMFY5Ljh6IE0xNS4yLDYuOWMtMS4yLDAuNi0zLjEsMC4yLTMuMSwxLjRjMCwxLjQsMy4xLDEsMy4xLTAuNVY2Ljl6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-check: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-circle-empty: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyIDJDNi40NyAyIDIgNi40NyAyIDEyczQuNDcgMTAgMTAgMTAgMTAtNC40NyAxMC0xMFMxNy41MyAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-circle: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-clear: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8bWFzayBpZD0iZG9udXRIb2xlIj4KICAgIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiIC8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiBmaWxsPSJibGFjayIvPgogIDwvbWFzaz4KCiAgPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxyZWN0IGhlaWdodD0iMTgiIHdpZHRoPSIyIiB4PSIxMSIgeT0iMyIgdHJhbnNmb3JtPSJyb3RhdGUoMzE1LCAxMiwgMTIpIi8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCIgbWFzaz0idXJsKCNkb251dEhvbGUpIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-close: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1ub25lIGpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIGpwLWljb24zLWhvdmVyIiBmaWxsPSJub25lIj4KICAgIDxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjExIi8+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIGpwLWljb24tYWNjZW50Mi1ob3ZlciIgZmlsbD0iIzYxNjE2MSI+CiAgICA8cGF0aCBkPSJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyeiIvPgogIDwvZz4KCiAgPGcgY2xhc3M9ImpwLWljb24tbm9uZSBqcC1pY29uLWJ1c3kiIGZpbGw9Im5vbmUiPgogICAgPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iNyIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-code-check: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICA8cGF0aCBkPSJNNi41OSwzLjQxTDIsOEw2LjU5LDEyLjZMOCwxMS4xOEw0LjgyLDhMOCw0LjgyTDYuNTksMy40MU0xMi40MSwzLjQxTDExLDQuODJMMTQuMTgsOEwxMSwxMS4xOEwxMi40MSwxMi42TDE3LDhMMTIuNDEsMy40MU0yMS41OSwxMS41OUwxMy41LDE5LjY4TDkuODMsMTZMOC40MiwxNy40MUwxMy41LDIyLjVMMjMsMTNMMjEuNTksMTEuNTlaIiAvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-code: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyOCAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTExLjQgMTguNkw2LjggMTRMMTEuNCA5LjRMMTAgOEw0IDE0TDEwIDIwTDExLjQgMTguNlpNMTYuNiAxOC42TDIxLjIgMTRMMTYuNiA5LjRMMTggOEwyNCAxNEwxOCAyMEwxNi42IDE4LjZWMTguNloiLz4KCTwvZz4KPC9zdmc+Cg==);
  --jp-icon-collapse-all: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTggMmMxIDAgMTEgMCAxMiAwczIgMSAyIDJjMCAxIDAgMTEgMCAxMnMwIDItMiAyQzIwIDE0IDIwIDQgMjAgNFMxMCA0IDYgNGMwLTIgMS0yIDItMnoiIC8+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTE4IDhjMC0xLTEtMi0yLTJTNSA2IDQgNnMtMiAxLTIgMmMwIDEgMCAxMSAwIDEyczEgMiAyIDJjMSAwIDExIDAgMTIgMHMyLTEgMi0yYzAtMSAwLTExIDAtMTJ6bS0yIDB2MTJINFY4eiIgLz4KICAgICAgICA8cGF0aCBkPSJNNiAxM3YyaDh2LTJ6IiAvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-console: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwMCAyMDAiPgogIDxnIGNsYXNzPSJqcC1jb25zb2xlLWljb24tYmFja2dyb3VuZC1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiMwMjg4RDEiPgogICAgPHBhdGggZD0iTTIwIDE5LjhoMTYwdjE1OS45SDIweiIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtY29uc29sZS1pY29uLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIiBmaWxsPSIjZmZmIj4KICAgIDxwYXRoIGQ9Ik0xMDUgMTI3LjNoNDB2MTIuOGgtNDB6TTUxLjEgNzdMNzQgOTkuOWwtMjMuMyAyMy4zIDEwLjUgMTAuNSAyMy4zLTIzLjNMOTUgOTkuOSA4NC41IDg5LjQgNjEuNiA2Ni41eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-copy: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTExLjksMUgzLjJDMi40LDEsMS43LDEuNywxLjcsMi41djEwLjJoMS41VjIuNWg4LjdWMXogTTE0LjEsMy45aC04Yy0wLjgsMC0xLjUsMC43LTEuNSwxLjV2MTAuMmMwLDAuOCwwLjcsMS41LDEuNSwxLjVoOCBjMC44LDAsMS41LTAuNywxLjUtMS41VjUuNEMxNS41LDQuNiwxNC45LDMuOSwxNC4xLDMuOXogTTE0LjEsMTUuNWgtOFY1LjRoOFYxNS41eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-copyright: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI0IDI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCI+CiAgPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0xMS44OCw5LjE0YzEuMjgsMC4wNiwxLjYxLDEuMTUsMS42MywxLjY2aDEuNzljLTAuMDgtMS45OC0xLjQ5LTMuMTktMy40NS0zLjE5QzkuNjQsNy42MSw4LDksOCwxMi4xNCBjMCwxLjk0LDAuOTMsNC4yNCwzLjg0LDQuMjRjMi4yMiwwLDMuNDEtMS42NSwzLjQ0LTIuOTVoLTEuNzljLTAuMDMsMC41OS0wLjQ1LDEuMzgtMS42MywxLjQ0QzEwLjU1LDE0LjgzLDEwLDEzLjgxLDEwLDEyLjE0IEMxMCw5LjI1LDExLjI4LDkuMTYsMTEuODgsOS4xNHogTTEyLDJDNi40OCwyLDIsNi40OCwyLDEyczQuNDgsMTAsMTAsMTBzMTAtNC40OCwxMC0xMFMxNy41MiwyLDEyLDJ6IE0xMiwyMGMtNC40MSwwLTgtMy41OS04LTggczMuNTktOCw4LThzOCwzLjU5LDgsOFMxNi40MSwyMCwxMiwyMHoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-cut: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkuNjQgNy42NGMuMjMtLjUuMzYtMS4wNS4zNi0xLjY0IDAtMi4yMS0xLjc5LTQtNC00UzIgMy43OSAyIDZzMS43OSA0IDQgNGMuNTkgMCAxLjE0LS4xMyAxLjY0LS4zNkwxMCAxMmwtMi4zNiAyLjM2QzcuMTQgMTQuMTMgNi41OSAxNCA2IDE0Yy0yLjIxIDAtNCAxLjc5LTQgNHMxLjc5IDQgNCA0IDQtMS43OSA0LTRjMC0uNTktLjEzLTEuMTQtLjM2LTEuNjRMMTIgMTRsNyA3aDN2LTFMOS42NCA3LjY0ek02IDhjLTEuMSAwLTItLjg5LTItMnMuOS0yIDItMiAyIC44OSAyIDItLjkgMi0yIDJ6bTAgMTJjLTEuMSAwLTItLjg5LTItMnMuOS0yIDItMiAyIC44OSAyIDItLjkgMi0yIDJ6bTYtNy41Yy0uMjggMC0uNS0uMjItLjUtLjVzLjIyLS41LjUtLjUuNS4yMi41LjUtLjIyLjUtLjUuNXpNMTkgM2wtNiA2IDIgMiA3LTdWM3oiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-delete: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCI+CiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIiAvPgogICAgPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjI2MjYyIiBkPSJNNiAxOWMwIDEuMS45IDIgMiAyaDhjMS4xIDAgMi0uOSAyLTJWN0g2djEyek0xOSA0aC0zLjVsLTEtMWgtNWwtMSAxSDV2MmgxNFY0eiIgLz4KPC9zdmc+Cg==);
  --jp-icon-download: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE5IDloLTRWM0g5djZINWw3IDcgNy03ek01IDE4djJoMTR2LTJINXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-duplicate: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIuNzk5OTggMC44NzVIOC44OTU4MkM5LjIwMDYxIDAuODc1IDkuNDQ5OTggMS4xMzkxNCA5LjQ0OTk4IDEuNDYxOThDOS40NDk5OCAxLjc4NDgyIDkuMjAwNjEgMi4wNDg5NiA4Ljg5NTgyIDIuMDQ4OTZIMy4zNTQxNUMzLjA0OTM2IDIuMDQ4OTYgMi43OTk5OCAyLjMxMzEgMi43OTk5OCAyLjYzNTk0VjkuNjc5NjlDMi43OTk5OCAxMC4wMDI1IDIuNTUwNjEgMTAuMjY2NyAyLjI0NTgyIDEwLjI2NjdDMS45NDEwMyAxMC4yNjY3IDEuNjkxNjUgMTAuMDAyNSAxLjY5MTY1IDkuNjc5NjlWMi4wNDg5NkMxLjY5MTY1IDEuNDAzMjggMi4xOTA0IDAuODc1IDIuNzk5OTggMC44NzVaTTUuMzY2NjUgMTEuOVY0LjU1SDExLjA4MzNWMTEuOUg1LjM2NjY1Wk00LjE0MTY1IDQuMTQxNjdDNC4xNDE2NSAzLjY5MDYzIDQuNTA3MjggMy4zMjUgNC45NTgzMiAzLjMyNUgxMS40OTE3QzExLjk0MjcgMy4zMjUgMTIuMzA4MyAzLjY5MDYzIDEyLjMwODMgNC4xNDE2N1YxMi4zMDgzQzEyLjMwODMgMTIuNzU5NCAxMS45NDI3IDEzLjEyNSAxMS40OTE3IDEzLjEyNUg0Ljk1ODMyQzQuNTA3MjggMTMuMTI1IDQuMTQxNjUgMTIuNzU5NCA0LjE0MTY1IDEyLjMwODNWNC4xNDE2N1oiIGZpbGw9IiM2MTYxNjEiLz4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNOS40MzU3NCA4LjI2NTA3SDguMzY0MzFWOS4zMzY1QzguMzY0MzEgOS40NTQzNSA4LjI2Nzg4IDkuNTUwNzggOC4xNTAwMiA5LjU1MDc4QzguMDMyMTcgOS41NTA3OCA3LjkzNTc0IDkuNDU0MzUgNy45MzU3NCA5LjMzNjVWOC4yNjUwN0g2Ljg2NDMxQzYuNzQ2NDUgOC4yNjUwNyA2LjY1MDAyIDguMTY4NjQgNi42NTAwMiA4LjA1MDc4QzYuNjUwMDIgNy45MzI5MiA2Ljc0NjQ1IDcuODM2NSA2Ljg2NDMxIDcuODM2NUg3LjkzNTc0VjYuNzY1MDdDNy45MzU3NCA2LjY0NzIxIDguMDMyMTcgNi41NTA3OCA4LjE1MDAyIDYuNTUwNzhDOC4yNjc4OCA2LjU1MDc4IDguMzY0MzEgNi42NDcyMSA4LjM2NDMxIDYuNzY1MDdWNy44MzY1SDkuNDM1NzRDOS41NTM2IDcuODM2NSA5LjY1MDAyIDcuOTMyOTIgOS42NTAwMiA4LjA1MDc4QzkuNjUwMDIgOC4xNjg2NCA5LjU1MzYgOC4yNjUwNyA5LjQzNTc0IDguMjY1MDdaIiBmaWxsPSIjNjE2MTYxIiBzdHJva2U9IiM2MTYxNjEiIHN0cm9rZS13aWR0aD0iMC41Ii8+Cjwvc3ZnPgo=);
  --jp-icon-edit: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTMgMTcuMjVWMjFoMy43NUwxNy44MSA5Ljk0bC0zLjc1LTMuNzVMMyAxNy4yNXpNMjAuNzEgNy4wNGMuMzktLjM5LjM5LTEuMDIgMC0xLjQxbC0yLjM0LTIuMzRjLS4zOS0uMzktMS4wMi0uMzktMS40MSAwbC0xLjgzIDEuODMgMy43NSAzLjc1IDEuODMtMS44M3oiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-ellipses: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPGNpcmNsZSBjeD0iNSIgY3k9IjEyIiByPSIyIi8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIyIi8+CiAgICA8Y2lyY2xlIGN4PSIxOSIgY3k9IjEyIiByPSIyIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-error: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjE5IiByPSIyIi8+PHBhdGggZD0iTTEwIDNoNHYxMmgtNHoiLz48L2c+CjxwYXRoIGZpbGw9Im5vbmUiIGQ9Ik0wIDBoMjR2MjRIMHoiLz4KPC9zdmc+Cg==);
  --jp-icon-expand-all: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTggMmMxIDAgMTEgMCAxMiAwczIgMSAyIDJjMCAxIDAgMTEgMCAxMnMwIDItMiAyQzIwIDE0IDIwIDQgMjAgNFMxMCA0IDYgNGMwLTIgMS0yIDItMnoiIC8+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTE4IDhjMC0xLTEtMi0yLTJTNSA2IDQgNnMtMiAxLTIgMmMwIDEgMCAxMSAwIDEyczEgMiAyIDJjMSAwIDExIDAgMTIgMHMyLTEgMi0yYzAtMSAwLTExIDAtMTJ6bS0yIDB2MTJINFY4eiIgLz4KICAgICAgICA8cGF0aCBkPSJNMTEgMTBIOXYzSDZ2MmgzdjNoMnYtM2gzdi0yaC0zeiIgLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-extension: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwLjUgMTFIMTlWN2MwLTEuMS0uOS0yLTItMmgtNFYzLjVDMTMgMi4xMiAxMS44OCAxIDEwLjUgMVM4IDIuMTIgOCAzLjVWNUg0Yy0xLjEgMC0xLjk5LjktMS45OSAydjMuOEgzLjVjMS40OSAwIDIuNyAxLjIxIDIuNyAyLjdzLTEuMjEgMi43LTIuNyAyLjdIMlYyMGMwIDEuMS45IDIgMiAyaDMuOHYtMS41YzAtMS40OSAxLjIxLTIuNyAyLjctMi43IDEuNDkgMCAyLjcgMS4yMSAyLjcgMi43VjIySDE3YzEuMSAwIDItLjkgMi0ydi00aDEuNWMxLjM4IDAgMi41LTEuMTIgMi41LTIuNVMyMS44OCAxMSAyMC41IDExeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-fast-forward: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTQgMThsOC41LTZMNCA2djEyem05LTEydjEybDguNS02TDEzIDZ6Ii8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-file-upload: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkgMTZoNnYtNmg0bC03LTctNyA3aDR6bS00IDJoMTR2Mkg1eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-file: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkuMyA4LjJsLTUuNS01LjVjLS4zLS4zLS43LS41LTEuMi0uNUgzLjljLS44LjEtMS42LjktMS42IDEuOHYxNC4xYzAgLjkuNyAxLjYgMS42IDEuNmgxNC4yYy45IDAgMS42LS43IDEuNi0xLjZWOS40Yy4xLS41LS4xLS45LS40LTEuMnptLTUuOC0zLjNsMy40IDMuNmgtMy40VjQuOXptMy45IDEyLjdINC43Yy0uMSAwLS4yIDAtLjItLjJWNC43YzAtLjIuMS0uMy4yLS4zaDcuMnY0LjRzMCAuOC4zIDEuMWMuMy4zIDEuMS4zIDEuMS4zaDQuM3Y3LjJzLS4xLjItLjIuMnoiLz4KPC9zdmc+Cg==);
  --jp-icon-filter-dot: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTE0LDEyVjE5Ljg4QzE0LjA0LDIwLjE4IDEzLjk0LDIwLjUgMTMuNzEsMjAuNzFDMTMuMzIsMjEuMSAxMi42OSwyMS4xIDEyLjMsMjAuNzFMMTAuMjksMTguN0MxMC4wNiwxOC40NyA5Ljk2LDE4LjE2IDEwLDE3Ljg3VjEySDkuOTdMNC4yMSw0LjYyQzMuODcsNC4xOSAzLjk1LDMuNTYgNC4zOCwzLjIyQzQuNTcsMy4wOCA0Ljc4LDMgNSwzVjNIMTlWM0MxOS4yMiwzIDE5LjQzLDMuMDggMTkuNjIsMy4yMkMyMC4wNSwzLjU2IDIwLjEzLDQuMTkgMTkuNzksNC42MkwxNC4wMywxMkgxNFoiIC8+CiAgPC9nPgogIDxnIGNsYXNzPSJqcC1pY29uLWRvdCIgZmlsbD0iI0ZGRiI+CiAgICA8Y2lyY2xlIGN4PSIxOCIgY3k9IjE3IiByPSIzIj48L2NpcmNsZT4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-filter-list: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEwIDE4aDR2LTJoLTR2MnpNMyA2djJoMThWNkgzem0zIDdoMTJ2LTJINnYyeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-filter: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTE0LDEyVjE5Ljg4QzE0LjA0LDIwLjE4IDEzLjk0LDIwLjUgMTMuNzEsMjAuNzFDMTMuMzIsMjEuMSAxMi42OSwyMS4xIDEyLjMsMjAuNzFMMTAuMjksMTguN0MxMC4wNiwxOC40NyA5Ljk2LDE4LjE2IDEwLDE3Ljg3VjEySDkuOTdMNC4yMSw0LjYyQzMuODcsNC4xOSAzLjk1LDMuNTYgNC4zOCwzLjIyQzQuNTcsMy4wOCA0Ljc4LDMgNSwzVjNIMTlWM0MxOS4yMiwzIDE5LjQzLDMuMDggMTkuNjIsMy4yMkMyMC4wNSwzLjU2IDIwLjEzLDQuMTkgMTkuNzksNC42MkwxNC4wMywxMkgxNFoiIC8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-folder-favorite: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCIgZmlsbD0iIzAwMDAwMCI+CiAgPHBhdGggZD0iTTAgMGgyNHYyNEgwVjB6IiBmaWxsPSJub25lIi8+PHBhdGggY2xhc3M9ImpwLWljb24zIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzYxNjE2MSIgZD0iTTIwIDZoLThsLTItMkg0Yy0xLjEgMC0yIC45LTIgMnYxMmMwIDEuMS45IDIgMiAyaDE2YzEuMSAwIDItLjkgMi0yVjhjMC0xLjEtLjktMi0yLTJ6bS0yLjA2IDExTDE1IDE1LjI4IDEyLjA2IDE3bC43OC0zLjMzLTIuNTktMi4yNCAzLjQxLS4yOUwxNSA4bDEuMzQgMy4xNCAzLjQxLjI5LTIuNTkgMi4yNC43OCAzLjMzeiIvPgo8L3N2Zz4K);
  --jp-icon-folder: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY4YzAtMS4xLS45LTItMi0yaC04bC0yLTJ6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-home: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCIgZmlsbD0iIzAwMDAwMCI+CiAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjxwYXRoIGNsYXNzPSJqcC1pY29uMyBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xMCAyMHYtNmg0djZoNXYtOGgzTDEyIDMgMiAxMmgzdjh6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-html5: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxwYXRoIGNsYXNzPSJqcC1pY29uMCBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiMwMDAiIGQ9Ik0xMDguNCAwaDIzdjIyLjhoMjEuMlYwaDIzdjY5aC0yM1Y0NmgtMjF2MjNoLTIzLjJNMjA2IDIzaC0yMC4zVjBoNjMuN3YyM0gyMjl2NDZoLTIzbTUzLjUtNjloMjQuMWwxNC44IDI0LjNMMzEzLjIgMGgyNC4xdjY5aC0yM1YzNC44bC0xNi4xIDI0LjgtMTYuMS0yNC44VjY5aC0yMi42bTg5LjItNjloMjN2NDYuMmgzMi42VjY5aC01NS42Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI2U0NGQyNiIgZD0iTTEwNy42IDQ3MWwtMzMtMzcwLjRoMzYyLjhsLTMzIDM3MC4yTDI1NS43IDUxMiIvPgogIDxwYXRoIGNsYXNzPSJqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNmMTY1MjkiIGQ9Ik0yNTYgNDgwLjVWMTMxaDE0OC4zTDM3NiA0NDciLz4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNlYmViZWIiIGQ9Ik0xNDIgMTc2LjNoMTE0djQ1LjRoLTY0LjJsNC4yIDQ2LjVoNjB2NDUuM0gxNTQuNG0yIDIyLjhIMjAybDMuMiAzNi4zIDUwLjggMTMuNnY0Ny40bC05My4yLTI2Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIiBmaWxsPSIjZmZmIiBkPSJNMzY5LjYgMTc2LjNIMjU1Ljh2NDUuNGgxMDkuNm0tNC4xIDQ2LjVIMjU1Ljh2NDUuNGg1NmwtNS4zIDU5LTUwLjcgMTMuNnY0Ny4ybDkzLTI1LjgiLz4KPC9zdmc+Cg==);
  --jp-icon-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1icmFuZDQganAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNGRkYiIGQ9Ik0yLjIgMi4yaDE3LjV2MTcuNUgyLjJ6Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzNGNTFCNSIgZD0iTTIuMiAyLjJ2MTcuNWgxNy41bC4xLTE3LjVIMi4yem0xMi4xIDIuMmMxLjIgMCAyLjIgMSAyLjIgMi4ycy0xIDIuMi0yLjIgMi4yLTIuMi0xLTIuMi0yLjIgMS0yLjIgMi4yLTIuMnpNNC40IDE3LjZsMy4zLTguOCAzLjMgNi42IDIuMi0zLjIgNC40IDUuNEg0LjR6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-info: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUwLjk3OCA1MC45NzgiPgoJPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KCQk8cGF0aCBkPSJNNDMuNTIsNy40NThDMzguNzExLDIuNjQ4LDMyLjMwNywwLDI1LjQ4OSwwQzE4LjY3LDAsMTIuMjY2LDIuNjQ4LDcuNDU4LDcuNDU4CgkJCWMtOS45NDMsOS45NDEtOS45NDMsMjYuMTE5LDAsMzYuMDYyYzQuODA5LDQuODA5LDExLjIxMiw3LjQ1NiwxOC4wMzEsNy40NThjMCwwLDAuMDAxLDAsMC4wMDIsMAoJCQljNi44MTYsMCwxMy4yMjEtMi42NDgsMTguMDI5LTcuNDU4YzQuODA5LTQuODA5LDcuNDU3LTExLjIxMiw3LjQ1Ny0xOC4wM0M1MC45NzcsMTguNjcsNDguMzI4LDEyLjI2Niw0My41Miw3LjQ1OHoKCQkJIE00Mi4xMDYsNDIuMTA1Yy00LjQzMiw0LjQzMS0xMC4zMzIsNi44NzItMTYuNjE1LDYuODcyaC0wLjAwMmMtNi4yODUtMC4wMDEtMTIuMTg3LTIuNDQxLTE2LjYxNy02Ljg3MgoJCQljLTkuMTYyLTkuMTYzLTkuMTYyLTI0LjA3MSwwLTMzLjIzM0MxMy4zMDMsNC40NCwxOS4yMDQsMiwyNS40ODksMmM2LjI4NCwwLDEyLjE4NiwyLjQ0LDE2LjYxNyw2Ljg3MgoJCQljNC40MzEsNC40MzEsNi44NzEsMTAuMzMyLDYuODcxLDE2LjYxN0M0OC45NzcsMzEuNzcyLDQ2LjUzNiwzNy42NzUsNDIuMTA2LDQyLjEwNXoiLz4KCQk8cGF0aCBkPSJNMjMuNTc4LDMyLjIxOGMtMC4wMjMtMS43MzQsMC4xNDMtMy4wNTksMC40OTYtMy45NzJjMC4zNTMtMC45MTMsMS4xMS0xLjk5NywyLjI3Mi0zLjI1MwoJCQljMC40NjgtMC41MzYsMC45MjMtMS4wNjIsMS4zNjctMS41NzVjMC42MjYtMC43NTMsMS4xMDQtMS40NzgsMS40MzYtMi4xNzVjMC4zMzEtMC43MDcsMC40OTUtMS41NDEsMC40OTUtMi41CgkJCWMwLTEuMDk2LTAuMjYtMi4wODgtMC43NzktMi45NzljLTAuNTY1LTAuODc5LTEuNTAxLTEuMzM2LTIuODA2LTEuMzY5Yy0xLjgwMiwwLjA1Ny0yLjk4NSwwLjY2Ny0zLjU1LDEuODMyCgkJCWMtMC4zMDEsMC41MzUtMC41MDMsMS4xNDEtMC42MDcsMS44MTRjLTAuMTM5LDAuNzA3LTAuMjA3LDEuNDMyLTAuMjA3LDIuMTc0aC0yLjkzN2MtMC4wOTEtMi4yMDgsMC40MDctNC4xMTQsMS40OTMtNS43MTkKCQkJYzEuMDYyLTEuNjQsMi44NTUtMi40ODEsNS4zNzgtMi41MjdjMi4xNiwwLjAyMywzLjg3NCwwLjYwOCw1LjE0MSwxLjc1OGMxLjI3OCwxLjE2LDEuOTI5LDIuNzY0LDEuOTUsNC44MTEKCQkJYzAsMS4xNDItMC4xMzcsMi4xMTEtMC40MSwyLjkxMWMtMC4zMDksMC44NDUtMC43MzEsMS41OTMtMS4yNjgsMi4yNDNjLTAuNDkyLDAuNjUtMS4wNjgsMS4zMTgtMS43MywyLjAwMgoJCQljLTAuNjUsMC42OTctMS4zMTMsMS40NzktMS45ODcsMi4zNDZjLTAuMjM5LDAuMzc3LTAuNDI5LDAuNzc3LTAuNTY1LDEuMTk5Yy0wLjE2LDAuOTU5LTAuMjE3LDEuOTUxLTAuMTcxLDIuOTc5CgkJCUMyNi41ODksMzIuMjE4LDIzLjU3OCwzMi4yMTgsMjMuNTc4LDMyLjIxOHogTTIzLjU3OCwzOC4yMnYtMy40ODRoMy4wNzZ2My40ODRIMjMuNTc4eiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-inspector: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaW5zcGVjdG9yLWljb24tY29sb3IganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMjAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0tNSAxNEg0di00aDExdjR6bTAtNUg0VjloMTF2NHptNSA1aC00VjloNHY5eiIvPgo8L3N2Zz4K);
  --jp-icon-json: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtanNvbi1pY29uLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI0Y5QTgyNSI+CiAgICA8cGF0aCBkPSJNMjAuMiAxMS44Yy0xLjYgMC0xLjcuNS0xLjcgMSAwIC40LjEuOS4xIDEuMy4xLjUuMS45LjEgMS4zIDAgMS43LTEuNCAyLjMtMy41IDIuM2gtLjl2LTEuOWguNWMxLjEgMCAxLjQgMCAxLjQtLjggMC0uMyAwLS42LS4xLTEgMC0uNC0uMS0uOC0uMS0xLjIgMC0xLjMgMC0xLjggMS4zLTItMS4zLS4yLTEuMy0uNy0xLjMtMiAwLS40LjEtLjguMS0xLjIuMS0uNC4xLS43LjEtMSAwLS44LS40LS43LTEuNC0uOGgtLjVWNC4xaC45YzIuMiAwIDMuNS43IDMuNSAyLjMgMCAuNC0uMS45LS4xIDEuMy0uMS41LS4xLjktLjEgMS4zIDAgLjUuMiAxIDEuNyAxdjEuOHpNMS44IDEwLjFjMS42IDAgMS43LS41IDEuNy0xIDAtLjQtLjEtLjktLjEtMS4zLS4xLS41LS4xLS45LS4xLTEuMyAwLTEuNiAxLjQtMi4zIDMuNS0yLjNoLjl2MS45aC0uNWMtMSAwLTEuNCAwLTEuNC44IDAgLjMgMCAuNi4xIDEgMCAuMi4xLjYuMSAxIDAgMS4zIDAgMS44LTEuMyAyQzYgMTEuMiA2IDExLjcgNiAxM2MwIC40LS4xLjgtLjEgMS4yLS4xLjMtLjEuNy0uMSAxIDAgLjguMy44IDEuNC44aC41djEuOWgtLjljLTIuMSAwLTMuNS0uNi0zLjUtMi4zIDAtLjQuMS0uOS4xLTEuMy4xLS41LjEtLjkuMS0xLjMgMC0uNS0uMi0xLTEuNy0xdi0xLjl6Ii8+CiAgICA8Y2lyY2xlIGN4PSIxMSIgY3k9IjEzLjgiIHI9IjIuMSIvPgogICAgPGNpcmNsZSBjeD0iMTEiIGN5PSI4LjIiIHI9IjIuMSIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-julia: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDMyNSAzMDAiPgogIDxnIGNsYXNzPSJqcC1icmFuZDAganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjY2IzYzMzIj4KICAgIDxwYXRoIGQ9Ik0gMTUwLjg5ODQzOCAyMjUgQyAxNTAuODk4NDM4IDI2Ni40MjE4NzUgMTE3LjMyMDMxMiAzMDAgNzUuODk4NDM4IDMwMCBDIDM0LjQ3NjU2MiAzMDAgMC44OTg0MzggMjY2LjQyMTg3NSAwLjg5ODQzOCAyMjUgQyAwLjg5ODQzOCAxODMuNTc4MTI1IDM0LjQ3NjU2MiAxNTAgNzUuODk4NDM4IDE1MCBDIDExNy4zMjAzMTIgMTUwIDE1MC44OTg0MzggMTgzLjU3ODEyNSAxNTAuODk4NDM4IDIyNSIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzM4OTgyNiI+CiAgICA8cGF0aCBkPSJNIDIzNy41IDc1IEMgMjM3LjUgMTE2LjQyMTg3NSAyMDMuOTIxODc1IDE1MCAxNjIuNSAxNTAgQyAxMjEuMDc4MTI1IDE1MCA4Ny41IDExNi40MjE4NzUgODcuNSA3NSBDIDg3LjUgMzMuNTc4MTI1IDEyMS4wNzgxMjUgMCAxNjIuNSAwIEMgMjAzLjkyMTg3NSAwIDIzNy41IDMzLjU3ODEyNSAyMzcuNSA3NSIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzk1NThiMiI+CiAgICA8cGF0aCBkPSJNIDMyNC4xMDE1NjIgMjI1IEMgMzI0LjEwMTU2MiAyNjYuNDIxODc1IDI5MC41MjM0MzggMzAwIDI0OS4xMDE1NjIgMzAwIEMgMjA3LjY3OTY4OCAzMDAgMTc0LjEwMTU2MiAyNjYuNDIxODc1IDE3NC4xMDE1NjIgMjI1IEMgMTc0LjEwMTU2MiAxODMuNTc4MTI1IDIwNy42Nzk2ODggMTUwIDI0OS4xMDE1NjIgMTUwIEMgMjkwLjUyMzQzOCAxNTAgMzI0LjEwMTU2MiAxODMuNTc4MTI1IDMyNC4xMDE1NjIgMjI1Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-jupyter-favicon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUyIiBoZWlnaHQ9IjE2NSIgdmlld0JveD0iMCAwIDE1MiAxNjUiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgPGcgY2xhc3M9ImpwLWp1cHl0ZXItaWNvbi1jb2xvciIgZmlsbD0iI0YzNzcyNiI+CiAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjA3ODk0NywgMTEwLjU4MjkyNykiIGQ9Ik03NS45NDIyODQyLDI5LjU4MDQ1NjEgQzQzLjMwMjM5NDcsMjkuNTgwNDU2MSAxNC43OTY3ODMyLDE3LjY1MzQ2MzQgMCwwIEM1LjUxMDgzMjExLDE1Ljg0MDY4MjkgMTUuNzgxNTM4OSwyOS41NjY3NzMyIDI5LjM5MDQ5NDcsMzkuMjc4NDE3MSBDNDIuOTk5Nyw0OC45ODk4NTM3IDU5LjI3MzcsNTQuMjA2NzgwNSA3NS45NjA1Nzg5LDU0LjIwNjc4MDUgQzkyLjY0NzQ1NzksNTQuMjA2NzgwNSAxMDguOTIxNDU4LDQ4Ljk4OTg1MzcgMTIyLjUzMDY2MywzOS4yNzg0MTcxIEMxMzYuMTM5NDUzLDI5LjU2Njc3MzIgMTQ2LjQxMDI4NCwxNS44NDA2ODI5IDE1MS45MjExNTgsMCBDMTM3LjA4Nzg2OCwxNy42NTM0NjM0IDEwOC41ODI1ODksMjkuNTgwNDU2MSA3NS45NDIyODQyLDI5LjU4MDQ1NjEgTDc1Ljk0MjI4NDIsMjkuNTgwNDU2MSBaIiAvPgogICAgPHBhdGggdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMzczNjgsIDAuNzA0ODc4KSIgZD0iTTc1Ljk3ODQ1NzksMjQuNjI2NDA3MyBDMTA4LjYxODc2MywyNC42MjY0MDczIDEzNy4xMjQ0NTgsMzYuNTUzNDQxNSAxNTEuOTIxMTU4LDU0LjIwNjc4MDUgQzE0Ni40MTAyODQsMzguMzY2MjIyIDEzNi4xMzk0NTMsMjQuNjQwMTMxNyAxMjIuNTMwNjYzLDE0LjkyODQ4NzggQzEwOC45MjE0NTgsNS4yMTY4NDM5IDkyLjY0NzQ1NzksMCA3NS45NjA1Nzg5LDAgQzU5LjI3MzcsMCA0Mi45OTk3LDUuMjE2ODQzOSAyOS4zOTA0OTQ3LDE0LjkyODQ4NzggQzE1Ljc4MTUzODksMjQuNjQwMTMxNyA1LjUxMDgzMjExLDM4LjM2NjIyMiAwLDU0LjIwNjc4MDUgQzE0LjgzMzA4MTYsMzYuNTg5OTI5MyA0My4zMzg1Njg0LDI0LjYyNjQwNzMgNzUuOTc4NDU3OSwyNC42MjY0MDczIEw3NS45Nzg0NTc5LDI0LjYyNjQwNzMgWiIgLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-jupyter: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzkiIGhlaWdodD0iNTEiIHZpZXdCb3g9IjAgMCAzOSA1MSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTYzOCAtMjI4MSkiPgogICAgIDxnIGNsYXNzPSJqcC1qdXB5dGVyLWljb24tY29sb3IiIGZpbGw9IiNGMzc3MjYiPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM5Ljc0IDIzMTEuOTgpIiBkPSJNIDE4LjI2NDYgNy4xMzQxMUMgMTAuNDE0NSA3LjEzNDExIDMuNTU4NzIgNC4yNTc2IDAgMEMgMS4zMjUzOSAzLjgyMDQgMy43OTU1NiA3LjEzMDgxIDcuMDY4NiA5LjQ3MzAzQyAxMC4zNDE3IDExLjgxNTIgMTQuMjU1NyAxMy4wNzM0IDE4LjI2OSAxMy4wNzM0QyAyMi4yODIzIDEzLjA3MzQgMjYuMTk2MyAxMS44MTUyIDI5LjQ2OTQgOS40NzMwM0MgMzIuNzQyNCA3LjEzMDgxIDM1LjIxMjYgMy44MjA0IDM2LjUzOCAwQyAzMi45NzA1IDQuMjU3NiAyNi4xMTQ4IDcuMTM0MTEgMTguMjY0NiA3LjEzNDExWiIvPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM5LjczIDIyODUuNDgpIiBkPSJNIDE4LjI3MzMgNS45MzkzMUMgMjYuMTIzNSA1LjkzOTMxIDMyLjk3OTMgOC44MTU4MyAzNi41MzggMTMuMDczNEMgMzUuMjEyNiA5LjI1MzAzIDMyLjc0MjQgNS45NDI2MiAyOS40Njk0IDMuNjAwNEMgMjYuMTk2MyAxLjI1ODE4IDIyLjI4MjMgMCAxOC4yNjkgMEMgMTQuMjU1NyAwIDEwLjM0MTcgMS4yNTgxOCA3LjA2ODYgMy42MDA0QyAzLjc5NTU2IDUuOTQyNjIgMS4zMjUzOSA5LjI1MzAzIDAgMTMuMDczNEMgMy41Njc0NSA4LjgyNDYzIDEwLjQyMzIgNS45MzkzMSAxOC4yNzMzIDUuOTM5MzFaIi8+CiAgICA8L2c+CiAgICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjY5LjMgMjI4MS4zMSkiIGQ9Ik0gNS44OTM1MyAyLjg0NEMgNS45MTg4OSAzLjQzMTY1IDUuNzcwODUgNC4wMTM2NyA1LjQ2ODE1IDQuNTE2NDVDIDUuMTY1NDUgNS4wMTkyMiA0LjcyMTY4IDUuNDIwMTUgNC4xOTI5OSA1LjY2ODUxQyAzLjY2NDMgNS45MTY4OCAzLjA3NDQ0IDYuMDAxNTEgMi40OTgwNSA1LjkxMTcxQyAxLjkyMTY2IDUuODIxOSAxLjM4NDYzIDUuNTYxNyAwLjk1NDg5OCA1LjE2NDAxQyAwLjUyNTE3IDQuNzY2MzMgMC4yMjIwNTYgNC4yNDkwMyAwLjA4MzkwMzcgMy42Nzc1N0MgLTAuMDU0MjQ4MyAzLjEwNjExIC0wLjAyMTIzIDIuNTA2MTcgMC4xNzg3ODEgMS45NTM2NEMgMC4zNzg3OTMgMS40MDExIDAuNzM2ODA5IDAuOTIwODE3IDEuMjA3NTQgMC41NzM1MzhDIDEuNjc4MjYgMC4yMjYyNTkgMi4yNDA1NSAwLjAyNzU5MTkgMi44MjMyNiAwLjAwMjY3MjI5QyAzLjYwMzg5IC0wLjAzMDcxMTUgNC4zNjU3MyAwLjI0OTc4OSA0Ljk0MTQyIDAuNzgyNTUxQyA1LjUxNzExIDEuMzE1MzEgNS44NTk1NiAyLjA1Njc2IDUuODkzNTMgMi44NDRaIi8+CiAgICAgIDxwYXRoIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MzkuOCAyMzIzLjgxKSIgZD0iTSA3LjQyNzg5IDMuNTgzMzhDIDcuNDYwMDggNC4zMjQzIDcuMjczNTUgNS4wNTgxOSA2Ljg5MTkzIDUuNjkyMTNDIDYuNTEwMzEgNi4zMjYwNyA1Ljk1MDc1IDYuODMxNTYgNS4yODQxMSA3LjE0NDZDIDQuNjE3NDcgNy40NTc2MyAzLjg3MzcxIDcuNTY0MTQgMy4xNDcwMiA3LjQ1MDYzQyAyLjQyMDMyIDcuMzM3MTIgMS43NDMzNiA3LjAwODcgMS4yMDE4NCA2LjUwNjk1QyAwLjY2MDMyOCA2LjAwNTIgMC4yNzg2MSA1LjM1MjY4IDAuMTA1MDE3IDQuNjMyMDJDIC0wLjA2ODU3NTcgMy45MTEzNSAtMC4wMjYyMzYxIDMuMTU0OTQgMC4yMjY2NzUgMi40NTg1NkMgMC40Nzk1ODcgMS43NjIxNyAwLjkzMTY5NyAxLjE1NzEzIDEuNTI1NzYgMC43MjAwMzNDIDIuMTE5ODMgMC4yODI5MzUgMi44MjkxNCAwLjAzMzQzOTUgMy41NjM4OSAwLjAwMzEzMzQ0QyA0LjU0NjY3IC0wLjAzNzQwMzMgNS41MDUyOSAwLjMxNjcwNiA2LjIyOTYxIDAuOTg3ODM1QyA2Ljk1MzkzIDEuNjU4OTYgNy4zODQ4NCAyLjU5MjM1IDcuNDI3ODkgMy41ODMzOEwgNy40Mjc4OSAzLjU4MzM4WiIvPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM4LjM2IDIyODYuMDYpIiBkPSJNIDIuMjc0NzEgNC4zOTYyOUMgMS44NDM2MyA0LjQxNTA4IDEuNDE2NzEgNC4zMDQ0NSAxLjA0Nzk5IDQuMDc4NDNDIDAuNjc5MjY4IDMuODUyNCAwLjM4NTMyOCAzLjUyMTE0IDAuMjAzMzcxIDMuMTI2NTZDIDAuMDIxNDEzNiAyLjczMTk4IC0wLjA0MDM3OTggMi4yOTE4MyAwLjAyNTgxMTYgMS44NjE4MUMgMC4wOTIwMDMxIDEuNDMxOCAwLjI4MzIwNCAxLjAzMTI2IDAuNTc1MjEzIDAuNzEwODgzQyAwLjg2NzIyMiAwLjM5MDUxIDEuMjQ2OTEgMC4xNjQ3MDggMS42NjYyMiAwLjA2MjA1OTJDIDIuMDg1NTMgLTAuMDQwNTg5NyAyLjUyNTYxIC0wLjAxNTQ3MTQgMi45MzA3NiAwLjEzNDIzNUMgMy4zMzU5MSAwLjI4Mzk0MSAzLjY4NzkyIDAuNTUxNTA1IDMuOTQyMjIgMC45MDMwNkMgNC4xOTY1MiAxLjI1NDYyIDQuMzQxNjkgMS42NzQzNiA0LjM1OTM1IDIuMTA5MTZDIDQuMzgyOTkgMi42OTEwNyA0LjE3Njc4IDMuMjU4NjkgMy43ODU5NyAzLjY4NzQ2QyAzLjM5NTE2IDQuMTE2MjQgMi44NTE2NiA0LjM3MTE2IDIuMjc0NzEgNC4zOTYyOUwgMi4yNzQ3MSA0LjM5NjI5WiIvPgogICAgPC9nPgogIDwvZz4+Cjwvc3ZnPgo=);
  --jp-icon-jupyterlab-wordmark: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIHZpZXdCb3g9IjAgMCAxODYwLjggNDc1Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0RTRFNEUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ4MC4xMzY0MDEsIDY0LjI3MTQ5MykiPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDU4Ljg3NTU2NikiPgogICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjA4NzYwMywgMC4xNDAyOTQpIj4KICAgICAgICA8cGF0aCBkPSJNLTQyNi45LDE2OS44YzAsNDguNy0zLjcsNjQuNy0xMy42LDc2LjRjLTEwLjgsMTAtMjUsMTUuNS0zOS43LDE1LjVsMy43LDI5IGMyMi44LDAuMyw0NC44LTcuOSw2MS45LTIzLjFjMTcuOC0xOC41LDI0LTQ0LjEsMjQtODMuM1YwSC00Mjd2MTcwLjFMLTQyNi45LDE2OS44TC00MjYuOSwxNjkuOHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU1LjA0NTI5NiwgNTYuODM3MTA0KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuNTYyNDUzLCAxLjc5OTg0MikiPgogICAgICAgIDxwYXRoIGQ9Ik0tMzEyLDE0OGMwLDIxLDAsMzkuNSwxLjcsNTUuNGgtMzEuOGwtMi4xLTMzLjNoLTAuOGMtNi43LDExLjYtMTYuNCwyMS4zLTI4LDI3LjkgYy0xMS42LDYuNi0yNC44LDEwLTM4LjIsOS44Yy0zMS40LDAtNjktMTcuNy02OS04OVYwaDM2LjR2MTEyLjdjMCwzOC43LDExLjYsNjQuNyw0NC42LDY0LjdjMTAuMy0wLjIsMjAuNC0zLjUsMjguOS05LjQgYzguNS01LjksMTUuMS0xNC4zLDE4LjktMjMuOWMyLjItNi4xLDMuMy0xMi41LDMuMy0xOC45VjAuMmgzNi40VjE0OEgtMzEyTC0zMTIsMTQ4eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzOTAuMDEzMzIyLCA1My40Nzk2MzgpIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS43MDY0NTgsIDAuMjMxNDI1KSI+CiAgICAgICAgPHBhdGggZD0iTS00NzguNiw3MS40YzAtMjYtMC44LTQ3LTEuNy02Ni43aDMyLjdsMS43LDM0LjhoMC44YzcuMS0xMi41LDE3LjUtMjIuOCwzMC4xLTI5LjcgYzEyLjUtNywyNi43LTEwLjMsNDEtOS44YzQ4LjMsMCw4NC43LDQxLjcsODQuNywxMDMuM2MwLDczLjEtNDMuNywxMDkuMi05MSwxMDkuMmMtMTIuMSwwLjUtMjQuMi0yLjItMzUtNy44IGMtMTAuOC01LjYtMTkuOS0xMy45LTI2LjYtMjQuMmgtMC44VjI5MWgtMzZ2LTIyMEwtNDc4LjYsNzEuNEwtNDc4LjYsNzEuNHogTS00NDIuNiwxMjUuNmMwLjEsNS4xLDAuNiwxMC4xLDEuNywxNS4xIGMzLDEyLjMsOS45LDIzLjMsMTkuOCwzMS4xYzkuOSw3LjgsMjIuMSwxMi4xLDM0LjcsMTIuMWMzOC41LDAsNjAuNy0zMS45LDYwLjctNzguNWMwLTQwLjctMjEuMS03NS42LTU5LjUtNzUuNiBjLTEyLjksMC40LTI1LjMsNS4xLTM1LjMsMTMuNGMtOS45LDguMy0xNi45LDE5LjctMTkuNiwzMi40Yy0xLjUsNC45LTIuMywxMC0yLjUsMTUuMVYxMjUuNkwtNDQyLjYsMTI1LjZMLTQ0Mi42LDEyNS42eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2MDYuNzQwNzI2LCA1Ni44MzcxMDQpIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC43NTEyMjYsIDEuOTg5Mjk5KSI+CiAgICAgICAgPHBhdGggZD0iTS00NDAuOCwwbDQzLjcsMTIwLjFjNC41LDEzLjQsOS41LDI5LjQsMTIuOCw0MS43aDAuOGMzLjctMTIuMiw3LjktMjcuNywxMi44LTQyLjQgbDM5LjctMTE5LjJoMzguNUwtMzQ2LjksMTQ1Yy0yNiw2OS43LTQzLjcsMTA1LjQtNjguNiwxMjcuMmMtMTIuNSwxMS43LTI3LjksMjAtNDQuNiwyMy45bC05LjEtMzEuMSBjMTEuNy0zLjksMjIuNS0xMC4xLDMxLjgtMTguMWMxMy4yLTExLjEsMjMuNy0yNS4yLDMwLjYtNDEuMmMxLjUtMi44LDIuNS01LjcsMi45LTguOGMtMC4zLTMuMy0xLjItNi42LTIuNS05LjdMLTQ4MC4yLDAuMSBoMzkuN0wtNDQwLjgsMEwtNDQwLjgsMHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODIyLjc0ODEwNCwgMC4wMDAwMDApIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS40NjQwNTAsIDAuMzc4OTE0KSI+CiAgICAgICAgPHBhdGggZD0iTS00MTMuNywwdjU4LjNoNTJ2MjguMmgtNTJWMTk2YzAsMjUsNywzOS41LDI3LjMsMzkuNWM3LjEsMC4xLDE0LjItMC43LDIxLjEtMi41IGwxLjcsMjcuN2MtMTAuMywzLjctMjEuMyw1LjQtMzIuMiw1Yy03LjMsMC40LTE0LjYtMC43LTIxLjMtMy40Yy02LjgtMi43LTEyLjktNi44LTE3LjktMTIuMWMtMTAuMy0xMC45LTE0LjEtMjktMTQuMS01Mi45IFY4Ni41aC0zMVY1OC4zaDMxVjkuNkwtNDEzLjcsMEwtNDEzLjcsMHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTc0LjQzMzI4NiwgNTMuNDc5NjM4KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuOTkwMDM0LCAwLjYxMDMzOSkiPgogICAgICAgIDxwYXRoIGQ9Ik0tNDQ1LjgsMTEzYzAuOCw1MCwzMi4yLDcwLjYsNjguNiw3MC42YzE5LDAuNiwzNy45LTMsNTUuMy0xMC41bDYuMiwyNi40IGMtMjAuOSw4LjktNDMuNSwxMy4xLTY2LjIsMTIuNmMtNjEuNSwwLTk4LjMtNDEuMi05OC4zLTEwMi41Qy00ODAuMiw0OC4yLTQ0NC43LDAtMzg2LjUsMGM2NS4yLDAsODIuNyw1OC4zLDgyLjcsOTUuNyBjLTAuMSw1LjgtMC41LDExLjUtMS4yLDE3LjJoLTE0MC42SC00NDUuOEwtNDQ1LjgsMTEzeiBNLTMzOS4yLDg2LjZjMC40LTIzLjUtOS41LTYwLjEtNTAuNC02MC4xIGMtMzYuOCwwLTUyLjgsMzQuNC01NS43LDYwLjFILTMzOS4yTC0zMzkuMiw4Ni42TC0zMzkuMiw4Ni42eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjAxLjk2MTA1OCwgNTMuNDc5NjM4KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuMTc5NjQwLCAwLjcwNTA2OCkiPgogICAgICAgIDxwYXRoIGQ9Ik0tNDc4LjYsNjhjMC0yMy45LTAuNC00NC41LTEuNy02My40aDMxLjhsMS4yLDM5LjloMS43YzkuMS0yNy4zLDMxLTQ0LjUsNTUuMy00NC41IGMzLjUtMC4xLDcsMC40LDEwLjMsMS4ydjM0LjhjLTQuMS0wLjktOC4yLTEuMy0xMi40LTEuMmMtMjUuNiwwLTQzLjcsMTkuNy00OC43LDQ3LjRjLTEsNS43LTEuNiwxMS41LTEuNywxNy4ydjEwOC4zaC0zNlY2OCBMLTQ3OC42LDY4eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbi13YXJuMCIgZmlsbD0iI0YzNzcyNiI+CiAgICA8cGF0aCBkPSJNMTM1Mi4zLDMyNi4yaDM3VjI4aC0zN1YzMjYuMnogTTE2MDQuOCwzMjYuMmMtMi41LTEzLjktMy40LTMxLjEtMy40LTQ4Ljd2LTc2IGMwLTQwLjctMTUuMS04My4xLTc3LjMtODMuMWMtMjUuNiwwLTUwLDcuMS02Ni44LDE4LjFsOC40LDI0LjRjMTQuMy05LjIsMzQtMTUuMSw1My0xNS4xYzQxLjYsMCw0Ni4yLDMwLjIsNDYuMiw0N3Y0LjIgYy03OC42LTAuNC0xMjIuMywyNi41LTEyMi4zLDc1LjZjMCwyOS40LDIxLDU4LjQsNjIuMiw1OC40YzI5LDAsNTAuOS0xNC4zLDYyLjItMzAuMmgxLjNsMi45LDI1LjZIMTYwNC44eiBNMTU2NS43LDI1Ny43IGMwLDMuOC0wLjgsOC0yLjEsMTEuOGMtNS45LDE3LjItMjIuNywzNC00OS4yLDM0Yy0xOC45LDAtMzQuOS0xMS4zLTM0LjktMzUuM2MwLTM5LjUsNDUuOC00Ni42LDg2LjItNDUuOFYyNTcuN3ogTTE2OTguNSwzMjYuMiBsMS43LTMzLjZoMS4zYzE1LjEsMjYuOSwzOC43LDM4LjIsNjguMSwzOC4yYzQ1LjQsMCw5MS4yLTM2LjEsOTEuMi0xMDguOGMwLjQtNjEuNy0zNS4zLTEwMy43LTg1LjctMTAzLjcgYy0zMi44LDAtNTYuMywxNC43LTY5LjMsMzcuNGgtMC44VjI4aC0zNi42djI0NS43YzAsMTguMS0wLjgsMzguNi0xLjcsNTIuNUgxNjk4LjV6IE0xNzA0LjgsMjA4LjJjMC01LjksMS4zLTEwLjksMi4xLTE1LjEgYzcuNi0yOC4xLDMxLjEtNDUuNCw1Ni4zLTQ1LjRjMzkuNSwwLDYwLjUsMzQuOSw2MC41LDc1LjZjMCw0Ni42LTIzLjEsNzguMS02MS44LDc4LjFjLTI2LjksMC00OC4zLTE3LjYtNTUuNS00My4zIGMtMC44LTQuMi0xLjctOC44LTEuNy0xMy40VjIwOC4yeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-kernel: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgZmlsbD0iIzYxNjE2MSIgZD0iTTE1IDlIOXY2aDZWOXptLTIgNGgtMnYtMmgydjJ6bTgtMlY5aC0yVjdjMC0xLjEtLjktMi0yLTJoLTJWM2gtMnYyaC0yVjNIOXYySDdjLTEuMSAwLTIgLjktMiAydjJIM3YyaDJ2MkgzdjJoMnYyYzAgMS4xLjkgMiAyIDJoMnYyaDJ2LTJoMnYyaDJ2LTJoMmMxLjEgMCAyLS45IDItMnYtMmgydi0yaC0ydi0yaDJ6bS00IDZIN1Y3aDEwdjEweiIvPgo8L3N2Zz4K);
  --jp-icon-keyboard: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMjAgNUg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMTdjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY3YzAtMS4xLS45LTItMi0yem0tOSAzaDJ2MmgtMlY4em0wIDNoMnYyaC0ydi0yek04IDhoMnYySDhWOHptMCAzaDJ2Mkg4di0yem0tMSAySDV2LTJoMnYyem0wLTNINVY4aDJ2MnptOSA3SDh2LTJoOHYyem0wLTRoLTJ2LTJoMnYyem0wLTNoLTJWOGgydjJ6bTMgM2gtMnYtMmgydjJ6bTAtM2gtMlY4aDJ2MnoiLz4KPC9zdmc+Cg==);
  --jp-icon-launch: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzIgMzIiIHdpZHRoPSIzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0yNiwyOEg2YTIuMDAyNywyLjAwMjcsMCwwLDEtMi0yVjZBMi4wMDI3LDIuMDAyNywwLDAsMSw2LDRIMTZWNkg2VjI2SDI2VjE2aDJWMjZBMi4wMDI3LDIuMDAyNywwLDAsMSwyNiwyOFoiLz4KICAgIDxwb2x5Z29uIHBvaW50cz0iMjAgMiAyMCA0IDI2LjU4NiA0IDE4IDEyLjU4NiAxOS40MTQgMTQgMjggNS40MTQgMjggMTIgMzAgMTIgMzAgMiAyMCAyIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-launcher: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkgMTlINVY1aDdWM0g1YTIgMiAwIDAwLTIgMnYxNGEyIDIgMCAwMDIgMmgxNGMxLjEgMCAyLS45IDItMnYtN2gtMnY3ek0xNCAzdjJoMy41OWwtOS44MyA5LjgzIDEuNDEgMS40MUwxOSA2LjQxVjEwaDJWM2gtN3oiLz4KPC9zdmc+Cg==);
  --jp-icon-line-form: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGZpbGw9IndoaXRlIiBkPSJNNS44OCA0LjEyTDEzLjc2IDEybC03Ljg4IDcuODhMOCAyMmwxMC0xMEw4IDJ6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-link: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTMuOSAxMmMwLTEuNzEgMS4zOS0zLjEgMy4xLTMuMWg0VjdIN2MtMi43NiAwLTUgMi4yNC01IDVzMi4yNCA1IDUgNWg0di0xLjlIN2MtMS43MSAwLTMuMS0xLjM5LTMuMS0zLjF6TTggMTNoOHYtMkg4djJ6bTktNmgtNHYxLjloNGMxLjcxIDAgMy4xIDEuMzkgMy4xIDMuMXMtMS4zOSAzLjEtMy4xIDMuMWgtNFYxN2g0YzIuNzYgMCA1LTIuMjQgNS01cy0yLjI0LTUtNS01eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-list: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xOSA1djE0SDVWNWgxNG0xLjEtMkgzLjljLS41IDAtLjkuNC0uOS45djE2LjJjMCAuNC40LjkuOS45aDE2LjJjLjQgMCAuOS0uNS45LS45VjMuOWMwLS41LS41LS45LS45LS45ek0xMSA3aDZ2MmgtNlY3em0wIDRoNnYyaC02di0yem0wIDRoNnYyaC02ek03IDdoMnYySDd6bTAgNGgydjJIN3ptMCA0aDJ2Mkg3eiIvPgo8L3N2Zz4K);
  --jp-icon-markdown: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDAganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjN0IxRkEyIiBkPSJNNSAxNC45aDEybC02LjEgNnptOS40LTYuOGMwLTEuMy0uMS0yLjktLjEtNC41LS40IDEuNC0uOSAyLjktMS4zIDQuM2wtMS4zIDQuM2gtMkw4LjUgNy45Yy0uNC0xLjMtLjctMi45LTEtNC4zLS4xIDEuNi0uMSAzLjItLjIgNC42TDcgMTIuNEg0LjhsLjctMTFoMy4zTDEwIDVjLjQgMS4yLjcgMi43IDEgMy45LjMtMS4yLjctMi42IDEtMy45bDEuMi0zLjdoMy4zbC42IDExaC0yLjRsLS4zLTQuMnoiLz4KPC9zdmc+Cg==);
  --jp-icon-move-down: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNMTIuNDcxIDcuNTI4OTlDMTIuNzYzMiA3LjIzNjg0IDEyLjc2MzIgNi43NjMxNiAxMi40NzEgNi40NzEwMVY2LjQ3MTAxQzEyLjE3OSA2LjE3OTA1IDExLjcwNTcgNi4xNzg4NCAxMS40MTM1IDYuNDcwNTRMNy43NSAxMC4xMjc1VjEuNzVDNy43NSAxLjMzNTc5IDcuNDE0MjEgMSA3IDFWMUM2LjU4NTc5IDEgNi4yNSAxLjMzNTc5IDYuMjUgMS43NVYxMC4xMjc1TDIuNTk3MjYgNi40NjgyMkMyLjMwMzM4IDYuMTczODEgMS44MjY0MSA2LjE3MzU5IDEuNTMyMjYgNi40Njc3NFY2LjQ2Nzc0QzEuMjM4MyA2Ljc2MTcgMS4yMzgzIDcuMjM4MyAxLjUzMjI2IDcuNTMyMjZMNi4yOTI4OSAxMi4yOTI5QzYuNjgzNDIgMTIuNjgzNCA3LjMxNjU4IDEyLjY4MzQgNy43MDcxMSAxMi4yOTI5TDEyLjQ3MSA3LjUyODk5WiIgZmlsbD0iIzYxNjE2MSIvPgo8L3N2Zz4K);
  --jp-icon-move-up: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNMS41Mjg5OSA2LjQ3MTAxQzEuMjM2ODQgNi43NjMxNiAxLjIzNjg0IDcuMjM2ODQgMS41Mjg5OSA3LjUyODk5VjcuNTI4OTlDMS44MjA5NSA3LjgyMDk1IDIuMjk0MjYgNy44MjExNiAyLjU4NjQ5IDcuNTI5NDZMNi4yNSAzLjg3MjVWMTIuMjVDNi4yNSAxMi42NjQyIDYuNTg1NzkgMTMgNyAxM1YxM0M3LjQxNDIxIDEzIDcuNzUgMTIuNjY0MiA3Ljc1IDEyLjI1VjMuODcyNUwxMS40MDI3IDcuNTMxNzhDMTEuNjk2NiA3LjgyNjE5IDEyLjE3MzYgNy44MjY0MSAxMi40Njc3IDcuNTMyMjZWNy41MzIyNkMxMi43NjE3IDcuMjM4MyAxMi43NjE3IDYuNzYxNyAxMi40Njc3IDYuNDY3NzRMNy43MDcxMSAxLjcwNzExQzcuMzE2NTggMS4zMTY1OCA2LjY4MzQyIDEuMzE2NTggNi4yOTI4OSAxLjcwNzExTDEuNTI4OTkgNi40NzEwMVoiIGZpbGw9IiM2MTYxNjEiLz4KPC9zdmc+Cg==);
  --jp-icon-new-folder: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwIDZoLThsLTItMkg0Yy0xLjExIDAtMS45OS44OS0xLjk5IDJMMiAxOGMwIDEuMTEuODkgMiAyIDJoMTZjMS4xMSAwIDItLjg5IDItMlY4YzAtMS4xMS0uODktMi0yLTJ6bS0xIDhoLTN2M2gtMnYtM2gtM3YtMmgzVjloMnYzaDN2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-not-trusted: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI1IDI1Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMgMykiIGQ9Ik0xLjg2MDk0IDExLjQ0MDlDMC44MjY0NDggOC43NzAyNyAwLjg2Mzc3OSA2LjA1NzY0IDEuMjQ5MDcgNC4xOTkzMkMyLjQ4MjA2IDMuOTMzNDcgNC4wODA2OCAzLjQwMzQ3IDUuNjAxMDIgMi44NDQ5QzcuMjM1NDkgMi4yNDQ0IDguODU2NjYgMS41ODE1IDkuOTg3NiAxLjA5NTM5QzExLjA1OTcgMS41ODM0MSAxMi42MDk0IDIuMjQ0NCAxNC4yMTggMi44NDMzOUMxNS43NTAzIDMuNDEzOTQgMTcuMzk5NSAzLjk1MjU4IDE4Ljc1MzkgNC4yMTM4NUMxOS4xMzY0IDYuMDcxNzcgMTkuMTcwOSA4Ljc3NzIyIDE4LjEzOSAxMS40NDA5QzE3LjAzMDMgMTQuMzAzMiAxNC42NjY4IDE3LjE4NDQgOS45OTk5OSAxOC45MzU0QzUuMzMzMTkgMTcuMTg0NCAyLjk2OTY4IDE0LjMwMzIgMS44NjA5NCAxMS40NDA5WiIvPgogICAgPHBhdGggY2xhc3M9ImpwLWljb24yIiBzdHJva2U9IiMzMzMzMzMiIHN0cm9rZS13aWR0aD0iMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOS4zMTU5MiA5LjMyMDMxKSIgZD0iTTcuMzY4NDIgMEwwIDcuMzY0NzkiLz4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDkuMzE1OTIgMTYuNjgzNikgc2NhbGUoMSAtMSkiIGQ9Ik03LjM2ODQyIDBMMCA3LjM2NDc5Ii8+Cjwvc3ZnPgo=);
  --jp-icon-notebook: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtbm90ZWJvb2staWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNFRjZDMDAiPgogICAgPHBhdGggZD0iTTE4LjcgMy4zdjE1LjRIMy4zVjMuM2gxNS40bTEuNS0xLjVIMS44djE4LjNoMTguM2wuMS0xOC4zeiIvPgogICAgPHBhdGggZD0iTTE2LjUgMTYuNWwtNS40LTQuMy01LjYgNC4zdi0xMWgxMXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-numbering: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyOCAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTQgMTlINlYxOS41SDVWMjAuNUg2VjIxSDRWMjJIN1YxOEg0VjE5Wk01IDEwSDZWNkg0VjdINVYxMFpNNCAxM0g1LjhMNCAxNS4xVjE2SDdWMTVINS4yTDcgMTIuOVYxMkg0VjEzWk05IDdWOUgyM1Y3SDlaTTkgMjFIMjNWMTlIOVYyMVpNOSAxNUgyM1YxM0g5VjE1WiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-offline-bolt: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyIDIuMDJjLTUuNTEgMC05Ljk4IDQuNDctOS45OCA5Ljk4czQuNDcgOS45OCA5Ljk4IDkuOTggOS45OC00LjQ3IDkuOTgtOS45OFMxNy41MSAyLjAyIDEyIDIuMDJ6TTExLjQ4IDIwdi02LjI2SDhMMTMgNHY2LjI2aDMuMzVMMTEuNDggMjB6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-palette: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE4IDEzVjIwSDRWNkg5LjAyQzkuMDcgNS4yOSA5LjI0IDQuNjIgOS41IDRINEMyLjkgNCAyIDQuOSAyIDZWMjBDMiAyMS4xIDIuOSAyMiA0IDIySDE4QzE5LjEgMjIgMjAgMjEuMSAyMCAyMFYxNUwxOCAxM1pNMTkuMyA4Ljg5QzE5Ljc0IDguMTkgMjAgNy4zOCAyMCA2LjVDMjAgNC4wMSAxNy45OSAyIDE1LjUgMkMxMy4wMSAyIDExIDQuMDEgMTEgNi41QzExIDguOTkgMTMuMDEgMTEgMTUuNDkgMTFDMTYuMzcgMTEgMTcuMTkgMTAuNzQgMTcuODggMTAuM0wyMSAxMy40MkwyMi40MiAxMkwxOS4zIDguODlaTTE1LjUgOUMxNC4xMiA5IDEzIDcuODggMTMgNi41QzEzIDUuMTIgMTQuMTIgNCAxNS41IDRDMTYuODggNCAxOCA1LjEyIDE4IDYuNUMxOCA3Ljg4IDE2Ljg4IDkgMTUuNSA5WiIvPgogICAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDZIOS4wMTg5NEM5LjAwNjM5IDYuMTY1MDIgOSA2LjMzMTc2IDkgNi41QzkgOC44MTU3NyAxMC4yMTEgMTAuODQ4NyAxMi4wMzQzIDEySDlWMTRIMTZWMTIuOTgxMUMxNi41NzAzIDEyLjkzNzcgMTcuMTIgMTIuODIwNyAxNy42Mzk2IDEyLjYzOTZMMTggMTNWMjBINFY2Wk04IDhINlYxMEg4VjhaTTYgMTJIOFYxNEg2VjEyWk04IDE2SDZWMThIOFYxNlpNOSAxNkgxNlYxOEg5VjE2WiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-paste: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTE5IDJoLTQuMThDMTQuNC44NCAxMy4zIDAgMTIgMGMtMS4zIDAtMi40Ljg0LTIuODIgMkg1Yy0xLjEgMC0yIC45LTIgMnYxNmMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjRjMC0xLjEtLjktMi0yLTJ6bS03IDBjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptNyAxOEg1VjRoMnYzaDEwVjRoMnYxNnoiLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-pdf: url(data:image/svg+xml;base64,PHN2ZwogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMiAyMiIgd2lkdGg9IjE2Ij4KICAgIDxwYXRoIHRyYW5zZm9ybT0icm90YXRlKDQ1KSIgY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI0ZGMkEyQSIKICAgICAgIGQ9Im0gMjIuMzQ0MzY5LC0zLjAxNjM2NDIgaCA1LjYzODYwNCB2IDEuNTc5MjQzMyBoIC0zLjU0OTIyNyB2IDEuNTA4NjkyOTkgaCAzLjMzNzU3NiBWIDEuNjUwODE1NCBoIC0zLjMzNzU3NiB2IDMuNDM1MjYxMyBoIC0yLjA4OTM3NyB6IG0gLTcuMTM2NDQ0LDEuNTc5MjQzMyB2IDQuOTQzOTU0MyBoIDAuNzQ4OTIgcSAxLjI4MDc2MSwwIDEuOTUzNzAzLC0wLjYzNDk1MzUgMC42NzgzNjksLTAuNjM0OTUzNSAwLjY3ODM2OSwtMS44NDUxNjQxIDAsLTEuMjA0NzgzNTUgLTAuNjcyOTQyLC0xLjgzNDMxMDExIC0wLjY3Mjk0MiwtMC42Mjk1MjY1OSAtMS45NTkxMywtMC42Mjk1MjY1OSB6IG0gLTIuMDg5Mzc3LC0xLjU3OTI0MzMgaCAyLjIwMzM0MyBxIDEuODQ1MTY0LDAgMi43NDYwMzksMC4yNjU5MjA3IDAuOTA2MzAxLDAuMjYwNDkzNyAxLjU1MjEwOCwwLjg5MDAyMDMgMC41Njk4MywwLjU0ODEyMjMgMC44NDY2MDUsMS4yNjQ0ODAwNiAwLjI3Njc3NCwwLjcxNjM1NzgxIDAuMjc2Nzc0LDEuNjIyNjU4OTQgMCwwLjkxNzE1NTEgLTAuMjc2Nzc0LDEuNjM4OTM5OSAtMC4yNzY3NzUsMC43MTYzNTc4IC0wLjg0NjYwNSwxLjI2NDQ4IC0wLjY1MTIzNCwwLjYyOTUyNjYgLTEuNTYyOTYyLDAuODk1NDQ3MyAtMC45MTE3MjgsMC4yNjA0OTM3IC0yLjczNTE4NSwwLjI2MDQ5MzcgaCAtMi4yMDMzNDMgeiBtIC04LjE0NTg1NjUsMCBoIDMuNDY3ODIzIHEgMS41NDY2ODE2LDAgMi4zNzE1Nzg1LDAuNjg5MjIzIDAuODMwMzI0LDAuNjgzNzk2MSAwLjgzMDMyNCwxLjk1MzcwMzE0IDAsMS4yNzUzMzM5NyAtMC44MzAzMjQsMS45NjQ1NTcwNiBRIDkuOTg3MTk2MSwyLjI3NDkxNSA4LjQ0MDUxNDUsMi4yNzQ5MTUgSCA3LjA2MjA2ODQgViA1LjA4NjA3NjcgSCA0Ljk3MjY5MTUgWiBtIDIuMDg5Mzc2OSwxLjUxNDExOTkgdiAyLjI2MzAzOTQzIGggMS4xNTU5NDEgcSAwLjYwNzgxODgsMCAwLjkzODg2MjksLTAuMjkzMDU1NDcgMC4zMzEwNDQxLC0wLjI5ODQ4MjQxIDAuMzMxMDQ0MSwtMC44NDExNzc3MiAwLC0wLjU0MjY5NTMxIC0wLjMzMTA0NDEsLTAuODM1NzUwNzQgLTAuMzMxMDQ0MSwtMC4yOTMwNTU1IC0wLjkzODg2MjksLTAuMjkzMDU1NSB6IgovPgo8L3N2Zz4K);
  --jp-icon-python: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iLTEwIC0xMCAxMzEuMTYxMzYxNjk0MzM1OTQgMTMyLjM4ODk5OTkzODk2NDg0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMzA2OTk4IiBkPSJNIDU0LjkxODc4NSw5LjE5Mjc0MjFlLTQgQyA1MC4zMzUxMzIsMC4wMjIyMTcyNyA0NS45NTc4NDYsMC40MTMxMzY5NyA0Mi4xMDYyODUsMS4wOTQ2NjkzIDMwLjc2MDA2OSwzLjA5OTE3MzEgMjguNzAwMDM2LDcuMjk0NzcxNCAyOC43MDAwMzUsMTUuMDMyMTY5IHYgMTAuMjE4NzUgaCAyNi44MTI1IHYgMy40MDYyNSBoIC0yNi44MTI1IC0xMC4wNjI1IGMgLTcuNzkyNDU5LDAgLTE0LjYxNTc1ODgsNC42ODM3MTcgLTE2Ljc0OTk5OTgsMTMuNTkzNzUgLTIuNDYxODE5OTgsMTAuMjEyOTY2IC0yLjU3MTAxNTA4LDE2LjU4NjAyMyAwLDI3LjI1IDEuOTA1OTI4Myw3LjkzNzg1MiA2LjQ1NzU0MzIsMTMuNTkzNzQ4IDE0LjI0OTk5OTgsMTMuNTkzNzUgaCA5LjIxODc1IHYgLTEyLjI1IGMgMCwtOC44NDk5MDIgNy42NTcxNDQsLTE2LjY1NjI0OCAxNi43NSwtMTYuNjU2MjUgaCAyNi43ODEyNSBjIDcuNDU0OTUxLDAgMTMuNDA2MjUzLC02LjEzODE2NCAxMy40MDYyNSwtMTMuNjI1IHYgLTI1LjUzMTI1IGMgMCwtNy4yNjYzMzg2IC02LjEyOTk4LC0xMi43MjQ3NzcxIC0xMy40MDYyNSwtMTMuOTM3NDk5NyBDIDY0LjI4MTU0OCwwLjMyNzk0Mzk3IDU5LjUwMjQzOCwtMC4wMjAzNzkwMyA1NC45MTg3ODUsOS4xOTI3NDIxZS00IFogbSAtMTQuNSw4LjIxODc1MDEyNTc5IGMgMi43Njk1NDcsMCA1LjAzMTI1LDIuMjk4NjQ1NiA1LjAzMTI1LDUuMTI0OTk5NiAtMmUtNiwyLjgxNjMzNiAtMi4yNjE3MDMsNS4wOTM3NSAtNS4wMzEyNSw1LjA5Mzc1IC0yLjc3OTQ3NiwtMWUtNiAtNS4wMzEyNSwtMi4yNzc0MTUgLTUuMDMxMjUsLTUuMDkzNzUgLTEwZS03LC0yLjgyNjM1MyAyLjI1MTc3NCwtNS4xMjQ5OTk2IDUuMDMxMjUsLTUuMTI0OTk5NiB6Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI2ZmZDQzYiIgZD0ibSA4NS42Mzc1MzUsMjguNjU3MTY5IHYgMTEuOTA2MjUgYyAwLDkuMjMwNzU1IC03LjgyNTg5NSwxNi45OTk5OTkgLTE2Ljc1LDE3IGggLTI2Ljc4MTI1IGMgLTcuMzM1ODMzLDAgLTEzLjQwNjI0OSw2LjI3ODQ4MyAtMTMuNDA2MjUsMTMuNjI1IHYgMjUuNTMxMjQ3IGMgMCw3LjI2NjM0NCA2LjMxODU4OCwxMS41NDAzMjQgMTMuNDA2MjUsMTMuNjI1MDA0IDguNDg3MzMxLDIuNDk1NjEgMTYuNjI2MjM3LDIuOTQ2NjMgMjYuNzgxMjUsMCA2Ljc1MDE1NSwtMS45NTQzOSAxMy40MDYyNTMsLTUuODg3NjEgMTMuNDA2MjUsLTEzLjYyNTAwNCBWIDg2LjUwMDkxOSBoIC0yNi43ODEyNSB2IC0zLjQwNjI1IGggMjYuNzgxMjUgMTMuNDA2MjU0IGMgNy43OTI0NjEsMCAxMC42OTYyNTEsLTUuNDM1NDA4IDEzLjQwNjI0MSwtMTMuNTkzNzUgMi43OTkzMywtOC4zOTg4ODYgMi42ODAyMiwtMTYuNDc1Nzc2IDAsLTI3LjI1IC0xLjkyNTc4LC03Ljc1NzQ0MSAtNS42MDM4NywtMTMuNTkzNzUgLTEzLjQwNjI0MSwtMTMuNTkzNzUgeiBtIC0xNS4wNjI1LDY0LjY1NjI1IGMgMi43Nzk0NzgsM2UtNiA1LjAzMTI1LDIuMjc3NDE3IDUuMDMxMjUsNS4wOTM3NDcgLTJlLTYsMi44MjYzNTQgLTIuMjUxNzc1LDUuMTI1MDA0IC01LjAzMTI1LDUuMTI1MDA0IC0yLjc2OTU1LDAgLTUuMDMxMjUsLTIuMjk4NjUgLTUuMDMxMjUsLTUuMTI1MDA0IDJlLTYsLTIuODE2MzMgMi4yNjE2OTcsLTUuMDkzNzQ3IDUuMDMxMjUsLTUuMDkzNzQ3IHoiLz4KPC9zdmc+Cg==);
  --jp-icon-r-kernel: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMjE5NkYzIiBkPSJNNC40IDIuNWMxLjItLjEgMi45LS4zIDQuOS0uMyAyLjUgMCA0LjEuNCA1LjIgMS4zIDEgLjcgMS41IDEuOSAxLjUgMy41IDAgMi0xLjQgMy41LTIuOSA0LjEgMS4yLjQgMS43IDEuNiAyLjIgMyAuNiAxLjkgMSAzLjkgMS4zIDQuNmgtMy44Yy0uMy0uNC0uOC0xLjctMS4yLTMuN3MtMS4yLTIuNi0yLjYtMi42aC0uOXY2LjRINC40VjIuNXptMy43IDYuOWgxLjRjMS45IDAgMi45LS45IDIuOS0yLjNzLTEtMi4zLTIuOC0yLjNjLS43IDAtMS4zIDAtMS42LjJ2NC41aC4xdi0uMXoiLz4KPC9zdmc+Cg==);
  --jp-icon-react: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMTUwIDE1MCA1NDEuOSAyOTUuMyI+CiAgPGcgY2xhc3M9ImpwLWljb24tYnJhbmQyIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzYxREFGQiI+CiAgICA8cGF0aCBkPSJNNjY2LjMgMjk2LjVjMC0zMi41LTQwLjctNjMuMy0xMDMuMS04Mi40IDE0LjQtNjMuNiA4LTExNC4yLTIwLjItMTMwLjQtNi41LTMuOC0xNC4xLTUuNi0yMi40LTUuNnYyMi4zYzQuNiAwIDguMy45IDExLjQgMi42IDEzLjYgNy44IDE5LjUgMzcuNSAxNC45IDc1LjctMS4xIDkuNC0yLjkgMTkuMy01LjEgMjkuNC0xOS42LTQuOC00MS04LjUtNjMuNS0xMC45LTEzLjUtMTguNS0yNy41LTM1LjMtNDEuNi01MCAzMi42LTMwLjMgNjMuMi00Ni45IDg0LTQ2LjlWNzhjLTI3LjUgMC02My41IDE5LjYtOTkuOSA1My42LTM2LjQtMzMuOC03Mi40LTUzLjItOTkuOS01My4ydjIyLjNjMjAuNyAwIDUxLjQgMTYuNSA4NCA0Ni42LTE0IDE0LjctMjggMzEuNC00MS4zIDQ5LjktMjIuNiAyLjQtNDQgNi4xLTYzLjYgMTEtMi4zLTEwLTQtMTkuNy01LjItMjktNC43LTM4LjIgMS4xLTY3LjkgMTQuNi03NS44IDMtMS44IDYuOS0yLjYgMTEuNS0yLjZWNzguNWMtOC40IDAtMTYgMS44LTIyLjYgNS42LTI4LjEgMTYuMi0zNC40IDY2LjctMTkuOSAxMzAuMS02Mi4yIDE5LjItMTAyLjcgNDkuOS0xMDIuNyA4Mi4zIDAgMzIuNSA0MC43IDYzLjMgMTAzLjEgODIuNC0xNC40IDYzLjYtOCAxMTQuMiAyMC4yIDEzMC40IDYuNSAzLjggMTQuMSA1LjYgMjIuNSA1LjYgMjcuNSAwIDYzLjUtMTkuNiA5OS45LTUzLjYgMzYuNCAzMy44IDcyLjQgNTMuMiA5OS45IDUzLjIgOC40IDAgMTYtMS44IDIyLjYtNS42IDI4LjEtMTYuMiAzNC40LTY2LjcgMTkuOS0xMzAuMSA2Mi0xOS4xIDEwMi41LTQ5LjkgMTAyLjUtODIuM3ptLTEzMC4yLTY2LjdjLTMuNyAxMi45LTguMyAyNi4yLTEzLjUgMzkuNS00LjEtOC04LjQtMTYtMTMuMS0yNC00LjYtOC05LjUtMTUuOC0xNC40LTIzLjQgMTQuMiAyLjEgMjcuOSA0LjcgNDEgNy45em0tNDUuOCAxMDYuNWMtNy44IDEzLjUtMTUuOCAyNi4zLTI0LjEgMzguMi0xNC45IDEuMy0zMCAyLTQ1LjIgMi0xNS4xIDAtMzAuMi0uNy00NS0xLjktOC4zLTExLjktMTYuNC0yNC42LTI0LjItMzgtNy42LTEzLjEtMTQuNS0yNi40LTIwLjgtMzkuOCA2LjItMTMuNCAxMy4yLTI2LjggMjAuNy0zOS45IDcuOC0xMy41IDE1LjgtMjYuMyAyNC4xLTM4LjIgMTQuOS0xLjMgMzAtMiA0NS4yLTIgMTUuMSAwIDMwLjIuNyA0NSAxLjkgOC4zIDExLjkgMTYuNCAyNC42IDI0LjIgMzggNy42IDEzLjEgMTQuNSAyNi40IDIwLjggMzkuOC02LjMgMTMuNC0xMy4yIDI2LjgtMjAuNyAzOS45em0zMi4zLTEzYzUuNCAxMy40IDEwIDI2LjggMTMuOCAzOS44LTEzLjEgMy4yLTI2LjkgNS45LTQxLjIgOCA0LjktNy43IDkuOC0xNS42IDE0LjQtMjMuNyA0LjYtOCA4LjktMTYuMSAxMy0yNC4xek00MjEuMiA0MzBjLTkuMy05LjYtMTguNi0yMC4zLTI3LjgtMzIgOSAuNCAxOC4yLjcgMjcuNS43IDkuNCAwIDE4LjctLjIgMjcuOC0uNy05IDExLjctMTguMyAyMi40LTI3LjUgMzJ6bS03NC40LTU4LjljLTE0LjItMi4xLTI3LjktNC43LTQxLTcuOSAzLjctMTIuOSA4LjMtMjYuMiAxMy41LTM5LjUgNC4xIDggOC40IDE2IDEzLjEgMjQgNC43IDggOS41IDE1LjggMTQuNCAyMy40ek00MjAuNyAxNjNjOS4zIDkuNiAxOC42IDIwLjMgMjcuOCAzMi05LS40LTE4LjItLjctMjcuNS0uNy05LjQgMC0xOC43LjItMjcuOC43IDktMTEuNyAxOC4zLTIyLjQgMjcuNS0zMnptLTc0IDU4LjljLTQuOSA3LjctOS44IDE1LjYtMTQuNCAyMy43LTQuNiA4LTguOSAxNi0xMyAyNC01LjQtMTMuNC0xMC0yNi44LTEzLjgtMzkuOCAxMy4xLTMuMSAyNi45LTUuOCA0MS4yLTcuOXptLTkwLjUgMTI1LjJjLTM1LjQtMTUuMS01OC4zLTM0LjktNTguMy01MC42IDAtMTUuNyAyMi45LTM1LjYgNTguMy01MC42IDguNi0zLjcgMTgtNyAyNy43LTEwLjEgNS43IDE5LjYgMTMuMiA0MCAyMi41IDYwLjktOS4yIDIwLjgtMTYuNiA0MS4xLTIyLjIgNjAuNi05LjktMy4xLTE5LjMtNi41LTI4LTEwLjJ6TTMxMCA0OTBjLTEzLjYtNy44LTE5LjUtMzcuNS0xNC45LTc1LjcgMS4xLTkuNCAyLjktMTkuMyA1LjEtMjkuNCAxOS42IDQuOCA0MSA4LjUgNjMuNSAxMC45IDEzLjUgMTguNSAyNy41IDM1LjMgNDEuNiA1MC0zMi42IDMwLjMtNjMuMiA0Ni45LTg0IDQ2LjktNC41LS4xLTguMy0xLTExLjMtMi43em0yMzcuMi03Ni4yYzQuNyAzOC4yLTEuMSA2Ny45LTE0LjYgNzUuOC0zIDEuOC02LjkgMi42LTExLjUgMi42LTIwLjcgMC01MS40LTE2LjUtODQtNDYuNiAxNC0xNC43IDI4LTMxLjQgNDEuMy00OS45IDIyLjYtMi40IDQ0LTYuMSA2My42LTExIDIuMyAxMC4xIDQuMSAxOS44IDUuMiAyOS4xem0zOC41LTY2LjdjLTguNiAzLjctMTggNy0yNy43IDEwLjEtNS43LTE5LjYtMTMuMi00MC0yMi41LTYwLjkgOS4yLTIwLjggMTYuNi00MS4xIDIyLjItNjAuNiA5LjkgMy4xIDE5LjMgNi41IDI4LjEgMTAuMiAzNS40IDE1LjEgNTguMyAzNC45IDU4LjMgNTAuNi0uMSAxNS43LTIzIDM1LjYtNTguNCA1MC42ek0zMjAuOCA3OC40eiIvPgogICAgPGNpcmNsZSBjeD0iNDIwLjkiIGN5PSIyOTYuNSIgcj0iNDUuNyIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-redo: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE4LjQgMTAuNkMxNi41NSA4Ljk5IDE0LjE1IDggMTEuNSA4Yy00LjY1IDAtOC41OCAzLjAzLTkuOTYgNy4yMkwzLjkgMTZjMS4wNS0zLjE5IDQuMDUtNS41IDcuNi01LjUgMS45NSAwIDMuNzMuNzIgNS4xMiAxLjg4TDEzIDE2aDlWN2wtMy42IDMuNnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-refresh: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTkgMTMuNWMtMi40OSAwLTQuNS0yLjAxLTQuNS00LjVTNi41MSA0LjUgOSA0LjVjMS4yNCAwIDIuMzYuNTIgMy4xNyAxLjMzTDEwIDhoNVYzbC0xLjc2IDEuNzZDMTIuMTUgMy42OCAxMC42NiAzIDkgMyA1LjY5IDMgMy4wMSA1LjY5IDMuMDEgOVM1LjY5IDE1IDkgMTVjMi45NyAwIDUuNDMtMi4xNiA1LjktNWgtMS41MmMtLjQ2IDItMi4yNCAzLjUtNC4zOCAzLjV6Ii8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-regex: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0MTQxNDEiPgogICAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbi1hY2NlbnQyIiBmaWxsPSIjRkZGIj4KICAgIDxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjUuNSIgY3k9IjE0LjUiIHI9IjEuNSIvPgogICAgPHJlY3QgeD0iMTIiIHk9IjQiIGNsYXNzPSJzdDIiIHdpZHRoPSIxIiBoZWlnaHQ9IjgiLz4KICAgIDxyZWN0IHg9IjguNSIgeT0iNy41IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg2NiAtMC41IDAuNSAwLjg2NiAtMi4zMjU1IDcuMzIxOSkiIGNsYXNzPSJzdDIiIHdpZHRoPSI4IiBoZWlnaHQ9IjEiLz4KICAgIDxyZWN0IHg9IjEyIiB5PSI0IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjUgLTAuODY2IDAuODY2IDAuNSAtMC42Nzc5IDE0LjgyNTIpIiBjbGFzcz0ic3QyIiB3aWR0aD0iMSIgaGVpZ2h0PSI4Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-run: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTggNXYxNGwxMS03eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-running: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICA8cGF0aCBkPSJNMjU2IDhDMTE5IDggOCAxMTkgOCAyNTZzMTExIDI0OCAyNDggMjQ4IDI0OC0xMTEgMjQ4LTI0OFMzOTMgOCAyNTYgOHptOTYgMzI4YzAgOC44LTcuMiAxNi0xNiAxNkgxNzZjLTguOCAwLTE2LTcuMi0xNi0xNlYxNzZjMC04LjggNy4yLTE2IDE2LTE2aDE2MGM4LjggMCAxNiA3LjIgMTYgMTZ2MTYweiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-save: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTE3IDNINWMtMS4xMSAwLTIgLjktMiAydjE0YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjdsLTQtNHptLTUgMTZjLTEuNjYgMC0zLTEuMzQtMy0zczEuMzQtMyAzLTMgMyAxLjM0IDMgMy0xLjM0IDMtMyAzem0zLTEwSDVWNWgxMHY0eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-search: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjEsMTAuOWgtMC43bC0wLjItMC4yYzAuOC0wLjksMS4zLTIuMiwxLjMtMy41YzAtMy0yLjQtNS40LTUuNC01LjRTMS44LDQuMiwxLjgsNy4xczIuNCw1LjQsNS40LDUuNCBjMS4zLDAsMi41LTAuNSwzLjUtMS4zbDAuMiwwLjJ2MC43bDQuMSw0LjFsMS4yLTEuMkwxMi4xLDEwLjl6IE03LjEsMTAuOWMtMi4xLDAtMy43LTEuNy0zLjctMy43czEuNy0zLjcsMy43LTMuN3MzLjcsMS43LDMuNywzLjcgUzkuMiwxMC45LDcuMSwxMC45eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-settings: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkuNDMgMTIuOThjLjA0LS4zMi4wNy0uNjQuMDctLjk4cy0uMDMtLjY2LS4wNy0uOThsMi4xMS0xLjY1Yy4xOS0uMTUuMjQtLjQyLjEyLS42NGwtMi0zLjQ2Yy0uMTItLjIyLS4zOS0uMy0uNjEtLjIybC0yLjQ5IDFjLS41Mi0uNC0xLjA4LS43My0xLjY5LS45OGwtLjM4LTIuNjVBLjQ4OC40ODggMCAwMDE0IDJoLTRjLS4yNSAwLS40Ni4xOC0uNDkuNDJsLS4zOCAyLjY1Yy0uNjEuMjUtMS4xNy41OS0xLjY5Ljk4bC0yLjQ5LTFjLS4yMy0uMDktLjQ5IDAtLjYxLjIybC0yIDMuNDZjLS4xMy4yMi0uMDcuNDkuMTIuNjRsMi4xMSAxLjY1Yy0uMDQuMzItLjA3LjY1LS4wNy45OHMuMDMuNjYuMDcuOThsLTIuMTEgMS42NWMtLjE5LjE1LS4yNC40Mi0uMTIuNjRsMiAzLjQ2Yy4xMi4yMi4zOS4zLjYxLjIybDIuNDktMWMuNTIuNCAxLjA4LjczIDEuNjkuOThsLjM4IDIuNjVjLjAzLjI0LjI0LjQyLjQ5LjQyaDRjLjI1IDAgLjQ2LS4xOC40OS0uNDJsLjM4LTIuNjVjLjYxLS4yNSAxLjE3LS41OSAxLjY5LS45OGwyLjQ5IDFjLjIzLjA5LjQ5IDAgLjYxLS4yMmwyLTMuNDZjLjEyLS4yMi4wNy0uNDktLjEyLS42NGwtMi4xMS0xLjY1ek0xMiAxNS41Yy0xLjkzIDAtMy41LTEuNTctMy41LTMuNXMxLjU3LTMuNSAzLjUtMy41IDMuNSAxLjU3IDMuNSAzLjUtMS41NyAzLjUtMy41IDMuNXoiLz4KPC9zdmc+Cg==);
  --jp-icon-share: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTSAxOCAyIEMgMTYuMzU0OTkgMiAxNSAzLjM1NDk5MDQgMTUgNSBDIDE1IDUuMTkwOTUyOSAxNS4wMjE3OTEgNS4zNzcxMjI0IDE1LjA1NjY0MSA1LjU1ODU5MzggTCA3LjkyMTg3NSA5LjcyMDcwMzEgQyA3LjM5ODUzOTkgOS4yNzc4NTM5IDYuNzMyMDc3MSA5IDYgOSBDIDQuMzU0OTkwNCA5IDMgMTAuMzU0OTkgMyAxMiBDIDMgMTMuNjQ1MDEgNC4zNTQ5OTA0IDE1IDYgMTUgQyA2LjczMjA3NzEgMTUgNy4zOTg1Mzk5IDE0LjcyMjE0NiA3LjkyMTg3NSAxNC4yNzkyOTcgTCAxNS4wNTY2NDEgMTguNDM5NDUzIEMgMTUuMDIxNTU1IDE4LjYyMTUxNCAxNSAxOC44MDgzODYgMTUgMTkgQyAxNSAyMC42NDUwMSAxNi4zNTQ5OSAyMiAxOCAyMiBDIDE5LjY0NTAxIDIyIDIxIDIwLjY0NTAxIDIxIDE5IEMgMjEgMTcuMzU0OTkgMTkuNjQ1MDEgMTYgMTggMTYgQyAxNy4yNjc0OCAxNiAxNi42MDE1OTMgMTYuMjc5MzI4IDE2LjA3ODEyNSAxNi43MjI2NTYgTCA4Ljk0MzM1OTQgMTIuNTU4NTk0IEMgOC45NzgyMDk1IDEyLjM3NzEyMiA5IDEyLjE5MDk1MyA5IDEyIEMgOSAxMS44MDkwNDcgOC45NzgyMDk1IDExLjYyMjg3OCA4Ljk0MzM1OTQgMTEuNDQxNDA2IEwgMTYuMDc4MTI1IDcuMjc5Mjk2OSBDIDE2LjYwMTQ2IDcuNzIyMTQ2MSAxNy4yNjc5MjMgOCAxOCA4IEMgMTkuNjQ1MDEgOCAyMSA2LjY0NTAwOTYgMjEgNSBDIDIxIDMuMzU0OTkwNCAxOS42NDUwMSAyIDE4IDIgeiBNIDE4IDQgQyAxOC41NjQxMjkgNCAxOSA0LjQzNTg3MDYgMTkgNSBDIDE5IDUuNTY0MTI5NCAxOC41NjQxMjkgNiAxOCA2IEMgMTcuNDM1ODcxIDYgMTcgNS41NjQxMjk0IDE3IDUgQyAxNyA0LjQzNTg3MDYgMTcuNDM1ODcxIDQgMTggNCB6IE0gNiAxMSBDIDYuNTY0MTI5NCAxMSA3IDExLjQzNTg3MSA3IDEyIEMgNyAxMi41NjQxMjkgNi41NjQxMjk0IDEzIDYgMTMgQyA1LjQzNTg3MDYgMTMgNSAxMi41NjQxMjkgNSAxMiBDIDUgMTEuNDM1ODcxIDUuNDM1ODcwNiAxMSA2IDExIHogTSAxOCAxOCBDIDE4LjU2NDEyOSAxOCAxOSAxOC40MzU4NzEgMTkgMTkgQyAxOSAxOS41NjQxMjkgMTguNTY0MTI5IDIwIDE4IDIwIEMgMTcuNDM1ODcxIDIwIDE3IDE5LjU2NDEyOSAxNyAxOSBDIDE3IDE4LjQzNTg3MSAxNy40MzU4NzEgMTggMTggMTggeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-spreadsheet: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDEganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNENBRjUwIiBkPSJNMi4yIDIuMnYxNy42aDE3LjZWMi4ySDIuMnptMTUuNCA3LjdoLTUuNVY0LjRoNS41djUuNXpNOS45IDQuNHY1LjVINC40VjQuNGg1LjV6bS01LjUgNy43aDUuNXY1LjVINC40di01LjV6bTcuNyA1LjV2LTUuNWg1LjV2NS41aC01LjV6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-stop: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik02IDZoMTJ2MTJINnoiLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-tab: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIxIDNIM2MtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxOGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDNWNWgxMHY0aDh2MTB6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-table-rows: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik0yMSw4SDNWNGgxOFY4eiBNMjEsMTBIM3Y0aDE4VjEweiBNMjEsMTZIM3Y0aDE4VjE2eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-tag: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCA0MyAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTI4LjgzMzIgMTIuMzM0TDMyLjk5OTggMTYuNTAwN0wzNy4xNjY1IDEyLjMzNEgyOC44MzMyWiIvPgoJCTxwYXRoIGQ9Ik0xNi4yMDk1IDIxLjYxMDRDMTUuNjg3MyAyMi4xMjk5IDE0Ljg0NDMgMjIuMTI5OSAxNC4zMjQ4IDIxLjYxMDRMNi45ODI5IDE0LjcyNDVDNi41NzI0IDE0LjMzOTQgNi4wODMxMyAxMy42MDk4IDYuMDQ3ODYgMTMuMDQ4MkM1Ljk1MzQ3IDExLjUyODggNi4wMjAwMiA4LjYxOTQ0IDYuMDY2MjEgNy4wNzY5NUM2LjA4MjgxIDYuNTE0NzcgNi41NTU0OCA2LjA0MzQ3IDcuMTE4MDQgNi4wMzA1NUM5LjA4ODYzIDUuOTg0NzMgMTMuMjYzOCA1LjkzNTc5IDEzLjY1MTggNi4zMjQyNUwyMS43MzY5IDEzLjYzOUMyMi4yNTYgMTQuMTU4NSAyMS43ODUxIDE1LjQ3MjQgMjEuMjYyIDE1Ljk5NDZMMTYuMjA5NSAyMS42MTA0Wk05Ljc3NTg1IDguMjY1QzkuMzM1NTEgNy44MjU2NiA4LjYyMzUxIDcuODI1NjYgOC4xODI4IDguMjY1QzcuNzQzNDYgOC43MDU3MSA3Ljc0MzQ2IDkuNDE3MzMgOC4xODI4IDkuODU2NjdDOC42MjM4MiAxMC4yOTY0IDkuMzM1ODIgMTAuMjk2NCA5Ljc3NTg1IDkuODU2NjdDMTAuMjE1NiA5LjQxNzMzIDEwLjIxNTYgOC43MDUzMyA5Ljc3NTg1IDguMjY1WiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-terminal: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0IiA+CiAgICA8cmVjdCBjbGFzcz0ianAtdGVybWluYWwtaWNvbi1iYWNrZ3JvdW5kLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZSIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyIDIpIiBmaWxsPSIjMzMzMzMzIi8+CiAgICA8cGF0aCBjbGFzcz0ianAtdGVybWluYWwtaWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUtaW52ZXJzZSIgZD0iTTUuMDU2NjQgOC43NjE3MkM1LjA1NjY0IDguNTk3NjYgNS4wMzEyNSA4LjQ1MzEyIDQuOTgwNDcgOC4zMjgxMkM0LjkzMzU5IDguMTk5MjIgNC44NTU0NyA4LjA4MjAzIDQuNzQ2MDkgNy45NzY1NkM0LjY0MDYyIDcuODcxMDkgNC41IDcuNzc1MzkgNC4zMjQyMiA3LjY4OTQ1QzQuMTUyMzQgNy41OTk2MSAzLjk0MzM2IDcuNTExNzIgMy42OTcyNyA3LjQyNTc4QzMuMzAyNzMgNy4yODUxNiAyLjk0MzM2IDcuMTM2NzIgMi42MTkxNCA2Ljk4MDQ3QzIuMjk0OTIgNi44MjQyMiAyLjAxNzU4IDYuNjQyNTggMS43ODcxMSA2LjQzNTU1QzEuNTYwNTUgNi4yMjg1MiAxLjM4NDc3IDUuOTg4MjggMS4yNTk3NyA1LjcxNDg0QzEuMTM0NzcgNS40Mzc1IDEuMDcyMjcgNS4xMDkzOCAxLjA3MjI3IDQuNzMwNDdDMS4wNzIyNyA0LjM5ODQ0IDEuMTI4OTEgNC4wOTU3IDEuMjQyMTkgMy44MjIyN0MxLjM1NTQ3IDMuNTQ0OTIgMS41MTU2MiAzLjMwNDY5IDEuNzIyNjYgMy4xMDE1NkMxLjkyOTY5IDIuODk4NDQgMi4xNzk2OSAyLjczNDM3IDIuNDcyNjYgMi42MDkzOEMyLjc2NTYyIDIuNDg0MzggMy4wOTE4IDIuNDA0MyAzLjQ1MTE3IDIuMzY5MTRWMS4xMDkzOEg0LjM4ODY3VjIuMzgwODZDNC43NDAyMyAyLjQyNzczIDUuMDU2NjQgMi41MjM0NCA1LjMzNzg5IDIuNjY3OTdDNS42MTkxNCAyLjgxMjUgNS44NTc0MiAzLjAwMTk1IDYuMDUyNzMgMy4yMzYzM0M2LjI1MTk1IDMuNDY2OCA2LjQwNDMgMy43NDAyMyA2LjUwOTc3IDQuMDU2NjRDNi42MTkxNCA0LjM2OTE0IDYuNjczODMgNC43MjA3IDYuNjczODMgNS4xMTEzM0g1LjA0NDkyQzUuMDQ0OTIgNC42Mzg2NyA0LjkzNzUgNC4yODEyNSA0LjcyMjY2IDQuMDM5MDZDNC41MDc4MSAzLjc5Mjk3IDQuMjE2OCAzLjY2OTkyIDMuODQ5NjEgMy42Njk5MkMzLjY1MDM5IDMuNjY5OTIgMy40NzY1NiAzLjY5NzI3IDMuMzI4MTIgMy43NTE5NUMzLjE4MzU5IDMuODAyNzMgMy4wNjQ0NSAzLjg3Njk1IDIuOTcwNyAzLjk3NDYxQzIuODc2OTUgNC4wNjgzNiAyLjgwNjY0IDQuMTc5NjkgMi43NTk3NyA0LjMwODU5QzIuNzE2OCA0LjQzNzUgMi42OTUzMSA0LjU3ODEyIDIuNjk1MzEgNC43MzA0N0MyLjY5NTMxIDQuODgyODEgMi43MTY4IDUuMDE5NTMgMi43NTk3NyA1LjE0MDYyQzIuODA2NjQgNS4yNTc4MSAyLjg4MjgxIDUuMzY3MTkgMi45ODgyOCA1LjQ2ODc1QzMuMDk3NjYgNS41NzAzMSAzLjI0MDIzIDUuNjY3OTcgMy40MTYwMiA1Ljc2MTcyQzMuNTkxOCA1Ljg1MTU2IDMuODEwNTUgNS45NDMzNiA0LjA3MjI3IDYuMDM3MTFDNC40NjY4IDYuMTg1NTUgNC44MjQyMiA2LjMzOTg0IDUuMTQ0NTMgNi41QzUuNDY0ODQgNi42NTYyNSA1LjczODI4IDYuODM5ODQgNS45NjQ4NCA3LjA1MDc4QzYuMTk1MzEgNy4yNTc4MSA2LjM3MTA5IDcuNSA2LjQ5MjE5IDcuNzc3MzRDNi42MTcxOSA4LjA1MDc4IDYuNjc5NjkgOC4zNzUgNi42Nzk2OSA4Ljc1QzYuNjc5NjkgOS4wOTM3NSA2LjYyMzA1IDkuNDA0MyA2LjUwOTc3IDkuNjgxNjRDNi4zOTY0OCA5Ljk1NTA4IDYuMjM0MzggMTAuMTkxNCA2LjAyMzQ0IDEwLjM5MDZDNS44MTI1IDEwLjU4OTggNS41NTg1OSAxMC43NSA1LjI2MTcyIDEwLjg3MTFDNC45NjQ4NCAxMC45ODgzIDQuNjMyODEgMTEuMDY0NSA0LjI2NTYyIDExLjA5OTZWMTIuMjQ4SDMuMzMzOThWMTEuMDk5NkMzLjAwMTk1IDExLjA2ODQgMi42Nzk2OSAxMC45OTYxIDIuMzY3MTkgMTAuODgyOEMyLjA1NDY5IDEwLjc2NTYgMS43NzczNCAxMC41OTc3IDEuNTM1MTYgMTAuMzc4OUMxLjI5Njg4IDEwLjE2MDIgMS4xMDU0NyA5Ljg4NDc3IDAuOTYwOTM4IDkuNTUyNzNDMC44MTY0MDYgOS4yMTY4IDAuNzQ0MTQxIDguODE0NDUgMC43NDQxNDEgOC4zNDU3SDIuMzc4OTFDMi4zNzg5MSA4LjYyNjk1IDIuNDE5OTIgOC44NjMyOCAyLjUwMTk1IDkuMDU0NjlDMi41ODM5OCA5LjI0MjE5IDIuNjg5NDUgOS4zOTI1OCAyLjgxODM2IDkuNTA1ODZDMi45NTExNyA5LjYxNTIzIDMuMTAxNTYgOS42OTMzNiAzLjI2OTUzIDkuNzQwMjNDMy40Mzc1IDkuNzg3MTEgMy42MDkzOCA5LjgxMDU1IDMuNzg1MTYgOS44MTA1NUM0LjIwMzEyIDkuODEwNTUgNC41MTk1MyA5LjcxMjg5IDQuNzM0MzggOS41MTc1OEM0Ljk0OTIyIDkuMzIyMjcgNS4wNTY2NCA5LjA3MDMxIDUuMDU2NjQgOC43NjE3MlpNMTMuNDE4IDEyLjI3MTVIOC4wNzQyMlYxMUgxMy40MThWMTIuMjcxNVoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuOTUyNjQgNikiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=);
  --jp-icon-text-editor: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtdGV4dC1lZGl0b3ItaWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xNSAxNUgzdjJoMTJ2LTJ6bTAtOEgzdjJoMTJWN3pNMyAxM2gxOHYtMkgzdjJ6bTAgOGgxOHYtMkgzdjJ6TTMgM3YyaDE4VjNIM3oiLz4KPC9zdmc+Cg==);
  --jp-icon-toc: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik03LDVIMjFWN0g3VjVNNywxM1YxMUgyMVYxM0g3TTQsNC41QTEuNSwxLjUgMCAwLDEgNS41LDZBMS41LDEuNSAwIDAsMSA0LDcuNUExLjUsMS41IDAgMCwxIDIuNSw2QTEuNSwxLjUgMCAwLDEgNCw0LjVNNCwxMC41QTEuNSwxLjUgMCAwLDEgNS41LDEyQTEuNSwxLjUgMCAwLDEgNCwxMy41QTEuNSwxLjUgMCAwLDEgMi41LDEyQTEuNSwxLjUgMCAwLDEgNCwxMC41TTcsMTlWMTdIMjFWMTlIN000LDE2LjVBMS41LDEuNSAwIDAsMSA1LjUsMThBMS41LDEuNSAwIDAsMSA0LDE5LjVBMS41LDEuNSAwIDAsMSAyLjUsMThBMS41LDEuNSAwIDAsMSA0LDE2LjVaIiAvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-tree-view: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik0yMiAxMVYzaC03djNIOVYzSDJ2OGg3VjhoMnYxMGg0djNoN3YtOGgtN3YzaC0yVjhoMnYzeiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-trusted: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI1Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIgMykiIGQ9Ik0xLjg2MDk0IDExLjQ0MDlDMC44MjY0NDggOC43NzAyNyAwLjg2Mzc3OSA2LjA1NzY0IDEuMjQ5MDcgNC4xOTkzMkMyLjQ4MjA2IDMuOTMzNDcgNC4wODA2OCAzLjQwMzQ3IDUuNjAxMDIgMi44NDQ5QzcuMjM1NDkgMi4yNDQ0IDguODU2NjYgMS41ODE1IDkuOTg3NiAxLjA5NTM5QzExLjA1OTcgMS41ODM0MSAxMi42MDk0IDIuMjQ0NCAxNC4yMTggMi44NDMzOUMxNS43NTAzIDMuNDEzOTQgMTcuMzk5NSAzLjk1MjU4IDE4Ljc1MzkgNC4yMTM4NUMxOS4xMzY0IDYuMDcxNzcgMTkuMTcwOSA4Ljc3NzIyIDE4LjEzOSAxMS40NDA5QzE3LjAzMDMgMTQuMzAzMiAxNC42NjY4IDE3LjE4NDQgOS45OTk5OSAxOC45MzU0QzUuMzMzMiAxNy4xODQ0IDIuOTY5NjggMTQuMzAzMiAxLjg2MDk0IDExLjQ0MDlaIi8+CiAgICA8cGF0aCBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiMzMzMzMzMiIHN0cm9rZT0iIzMzMzMzMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOCA5Ljg2NzE5KSIgZD0iTTIuODYwMTUgNC44NjUzNUwwLjcyNjU0OSAyLjk5OTU5TDAgMy42MzA0NUwyLjg2MDE1IDYuMTMxNTdMOCAwLjYzMDg3Mkw3LjI3ODU3IDBMMi44NjAxNSA0Ljg2NTM1WiIvPgo8L3N2Zz4K);
  --jp-icon-undo: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjUgOGMtMi42NSAwLTUuMDUuOTktNi45IDIuNkwyIDd2OWg5bC0zLjYyLTMuNjJjMS4zOS0xLjE2IDMuMTYtMS44OCA1LjEyLTEuODggMy41NCAwIDYuNTUgMi4zMSA3LjYgNS41bDIuMzctLjc4QzIxLjA4IDExLjAzIDE3LjE1IDggMTIuNSA4eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-user: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE2IDdhNCA0IDAgMTEtOCAwIDQgNCAwIDAxOCAwek0xMiAxNGE3IDcgMCAwMC03IDdoMTRhNyA3IDAgMDAtNy03eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-users: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDM2IDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogPGcgY2xhc3M9ImpwLWljb24zIiB0cmFuc2Zvcm09Im1hdHJpeCgxLjczMjcgMCAwIDEuNzMyNyAtMy42MjgyIC4wOTk1NzcpIiBmaWxsPSIjNjE2MTYxIj4KICA8cGF0aCB0cmFuc2Zvcm09Im1hdHJpeCgxLjUsMCwwLDEuNSwwLC02KSIgZD0ibTEyLjE4NiA3LjUwOThjLTEuMDUzNSAwLTEuOTc1NyAwLjU2NjUtMi40Nzg1IDEuNDEwMiAwLjc1MDYxIDAuMzEyNzcgMS4zOTc0IDAuODI2NDggMS44NzMgMS40NzI3aDMuNDg2M2MwLTEuNTkyLTEuMjg4OS0yLjg4MjgtMi44ODA5LTIuODgyOHoiLz4KICA8cGF0aCBkPSJtMjAuNDY1IDIuMzg5NWEyLjE4ODUgMi4xODg1IDAgMCAxLTIuMTg4NCAyLjE4ODUgMi4xODg1IDIuMTg4NSAwIDAgMS0yLjE4ODUtMi4xODg1IDIuMTg4NSAyLjE4ODUgMCAwIDEgMi4xODg1LTIuMTg4NSAyLjE4ODUgMi4xODg1IDAgMCAxIDIuMTg4NCAyLjE4ODV6Ii8+CiAgPHBhdGggdHJhbnNmb3JtPSJtYXRyaXgoMS41LDAsMCwxLjUsMCwtNikiIGQ9Im0zLjU4OTggOC40MjE5Yy0xLjExMjYgMC0yLjAxMzcgMC45MDExMS0yLjAxMzcgMi4wMTM3aDIuODE0NWMwLjI2Nzk3LTAuMzczMDkgMC41OTA3LTAuNzA0MzUgMC45NTg5OC0wLjk3ODUyLTAuMzQ0MzMtMC42MTY4OC0xLjAwMzEtMS4wMzUyLTEuNzU5OC0xLjAzNTJ6Ii8+CiAgPHBhdGggZD0ibTYuOTE1NCA0LjYyM2ExLjUyOTQgMS41Mjk0IDAgMCAxLTEuNTI5NCAxLjUyOTQgMS41Mjk0IDEuNTI5NCAwIDAgMS0xLjUyOTQtMS41Mjk0IDEuNTI5NCAxLjUyOTQgMCAwIDEgMS41Mjk0LTEuNTI5NCAxLjUyOTQgMS41Mjk0IDAgMCAxIDEuNTI5NCAxLjUyOTR6Ii8+CiAgPHBhdGggZD0ibTYuMTM1IDEzLjUzNWMwLTMuMjM5MiAyLjYyNTktNS44NjUgNS44NjUtNS44NjUgMy4yMzkyIDAgNS44NjUgMi42MjU5IDUuODY1IDUuODY1eiIvPgogIDxjaXJjbGUgY3g9IjEyIiBjeT0iMy43Njg1IiByPSIyLjk2ODUiLz4KIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-vega: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbjEganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMjEyMTIxIj4KICAgIDxwYXRoIGQ9Ik0xMC42IDUuNGwyLjItMy4ySDIuMnY3LjNsNC02LjZ6Ii8+CiAgICA8cGF0aCBkPSJNMTUuOCAyLjJsLTQuNCA2LjZMNyA2LjNsLTQuOCA4djUuNWgxNy42VjIuMmgtNHptLTcgMTUuNEg1LjV2LTQuNGgzLjN2NC40em00LjQgMEg5LjhWOS44aDMuNHY3Ljh6bTQuNCAwaC0zLjRWNi41aDMuNHYxMS4xeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-word: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KIDxnIGNsYXNzPSJqcC1pY29uMiIgZmlsbD0iIzQxNDE0MSI+CiAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiA8L2c+CiA8ZyBjbGFzcz0ianAtaWNvbi1hY2NlbnQyIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSguNDMgLjA0MDEpIiBmaWxsPSIjZmZmIj4KICA8cGF0aCBkPSJtNC4xNCA4Ljc2cTAuMDY4Mi0xLjg5IDIuNDItMS44OSAxLjE2IDAgMS42OCAwLjQyIDAuNTY3IDAuNDEgMC41NjcgMS4xNnYzLjQ3cTAgMC40NjIgMC41MTQgMC40NjIgMC4xMDMgMCAwLjItMC4wMjMxdjAuNzE0cS0wLjM5OSAwLjEwMy0wLjY1MSAwLjEwMy0wLjQ1MiAwLTAuNjkzLTAuMjItMC4yMzEtMC4yLTAuMjg0LTAuNjYyLTAuOTU2IDAuODcyLTIgMC44NzItMC45MDMgMC0xLjQ3LTAuNDcyLTAuNTI1LTAuNDcyLTAuNTI1LTEuMjYgMC0wLjI2MiAwLjA0NTItMC40NzIgMC4wNTY3LTAuMjIgMC4xMTYtMC4zNzggMC4wNjgyLTAuMTY4IDAuMjMxLTAuMzA0IDAuMTU4LTAuMTQ3IDAuMjYyLTAuMjQyIDAuMTE2LTAuMDkxNCAwLjM2OC0wLjE2OCAwLjI2Mi0wLjA5MTQgMC4zOTktMC4xMjYgMC4xMzYtMC4wNDUyIDAuNDcyLTAuMTAzIDAuMzM2LTAuMDU3OCAwLjUwNC0wLjA3OTggMC4xNTgtMC4wMjMxIDAuNTY3LTAuMDc5OCAwLjU1Ni0wLjA2ODIgMC43NzctMC4yMjEgMC4yMi0wLjE1MiAwLjIyLTAuNDQxdi0wLjI1MnEwLTAuNDMtMC4zNTctMC42NjItMC4zMzYtMC4yMzEtMC45NzYtMC4yMzEtMC42NjIgMC0wLjk5OCAwLjI2Mi0wLjMzNiAwLjI1Mi0wLjM5OSAwLjc5OHptMS44OSAzLjY4cTAuNzg4IDAgMS4yNi0wLjQxIDAuNTA0LTAuNDIgMC41MDQtMC45MDN2LTEuMDVxLTAuMjg0IDAuMTM2LTAuODYxIDAuMjMxLTAuNTY3IDAuMDkxNC0wLjk4NyAwLjE1OC0wLjQyIDAuMDY4Mi0wLjc2NiAwLjMyNi0wLjMzNiAwLjI1Mi0wLjMzNiAwLjcwNHQwLjMwNCAwLjcwNCAwLjg2MSAwLjI1MnoiIHN0cm9rZS13aWR0aD0iMS4wNSIvPgogIDxwYXRoIGQ9Im0xMCA0LjU2aDAuOTQ1djMuMTVxMC42NTEtMC45NzYgMS44OS0wLjk3NiAxLjE2IDAgMS44OSAwLjg0IDAuNjgyIDAuODQgMC42ODIgMi4zMSAwIDEuNDctMC43MDQgMi40Mi0wLjcwNCAwLjg4Mi0xLjg5IDAuODgyLTEuMjYgMC0xLjg5LTEuMDJ2MC43NjZoLTAuODV6bTIuNjIgMy4wNHEtMC43NDYgMC0xLjE2IDAuNjQtMC40NTIgMC42My0wLjQ1MiAxLjY4IDAgMS4wNSAwLjQ1MiAxLjY4dDEuMTYgMC42M3EwLjc3NyAwIDEuMjYtMC42MyAwLjQ5NC0wLjY0IDAuNDk0LTEuNjggMC0xLjA1LTAuNDcyLTEuNjgtMC40NjItMC42NC0xLjI2LTAuNjR6IiBzdHJva2Utd2lkdGg9IjEuMDUiLz4KICA8cGF0aCBkPSJtMi43MyAxNS44IDEzLjYgMC4wMDgxYzAuMDA2OSAwIDAtMi42IDAtMi42IDAtMC4wMDc4LTEuMTUgMC0xLjE1IDAtMC4wMDY5IDAtMC4wMDgzIDEuNS0wLjAwODMgMS41LTJlLTMgLTAuMDAxNC0xMS4zLTAuMDAxNC0xMS4zLTAuMDAxNGwtMC4wMDU5Mi0xLjVjMC0wLjAwNzgtMS4xNyAwLjAwMTMtMS4xNyAwLjAwMTN6IiBzdHJva2Utd2lkdGg9Ii45NzUiLz4KIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-yaml: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1jb250cmFzdDIganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjRDgxQjYwIj4KICAgIDxwYXRoIGQ9Ik03LjIgMTguNnYtNS40TDMgNS42aDMuM2wxLjQgMy4xYy4zLjkuNiAxLjYgMSAyLjUuMy0uOC42LTEuNiAxLTIuNWwxLjQtMy4xaDMuNGwtNC40IDcuNnY1LjVsLTIuOS0uMXoiLz4KICAgIDxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE3LjYiIGN5PSIxNi41IiByPSIyLjEiLz4KICAgIDxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE3LjYiIGN5PSIxMSIgcj0iMi4xIi8+CiAgPC9nPgo8L3N2Zz4K);
}

/* Icon CSS class declarations */

.jp-AddAboveIcon {
  background-image: var(--jp-icon-add-above);
}

.jp-AddBelowIcon {
  background-image: var(--jp-icon-add-below);
}

.jp-AddIcon {
  background-image: var(--jp-icon-add);
}

.jp-BellIcon {
  background-image: var(--jp-icon-bell);
}

.jp-BugDotIcon {
  background-image: var(--jp-icon-bug-dot);
}

.jp-BugIcon {
  background-image: var(--jp-icon-bug);
}

.jp-BuildIcon {
  background-image: var(--jp-icon-build);
}

.jp-CaretDownEmptyIcon {
  background-image: var(--jp-icon-caret-down-empty);
}

.jp-CaretDownEmptyThinIcon {
  background-image: var(--jp-icon-caret-down-empty-thin);
}

.jp-CaretDownIcon {
  background-image: var(--jp-icon-caret-down);
}

.jp-CaretLeftIcon {
  background-image: var(--jp-icon-caret-left);
}

.jp-CaretRightIcon {
  background-image: var(--jp-icon-caret-right);
}

.jp-CaretUpEmptyThinIcon {
  background-image: var(--jp-icon-caret-up-empty-thin);
}

.jp-CaretUpIcon {
  background-image: var(--jp-icon-caret-up);
}

.jp-CaseSensitiveIcon {
  background-image: var(--jp-icon-case-sensitive);
}

.jp-CheckIcon {
  background-image: var(--jp-icon-check);
}

.jp-CircleEmptyIcon {
  background-image: var(--jp-icon-circle-empty);
}

.jp-CircleIcon {
  background-image: var(--jp-icon-circle);
}

.jp-ClearIcon {
  background-image: var(--jp-icon-clear);
}

.jp-CloseIcon {
  background-image: var(--jp-icon-close);
}

.jp-CodeCheckIcon {
  background-image: var(--jp-icon-code-check);
}

.jp-CodeIcon {
  background-image: var(--jp-icon-code);
}

.jp-CollapseAllIcon {
  background-image: var(--jp-icon-collapse-all);
}

.jp-ConsoleIcon {
  background-image: var(--jp-icon-console);
}

.jp-CopyIcon {
  background-image: var(--jp-icon-copy);
}

.jp-CopyrightIcon {
  background-image: var(--jp-icon-copyright);
}

.jp-CutIcon {
  background-image: var(--jp-icon-cut);
}

.jp-DeleteIcon {
  background-image: var(--jp-icon-delete);
}

.jp-DownloadIcon {
  background-image: var(--jp-icon-download);
}

.jp-DuplicateIcon {
  background-image: var(--jp-icon-duplicate);
}

.jp-EditIcon {
  background-image: var(--jp-icon-edit);
}

.jp-EllipsesIcon {
  background-image: var(--jp-icon-ellipses);
}

.jp-ErrorIcon {
  background-image: var(--jp-icon-error);
}

.jp-ExpandAllIcon {
  background-image: var(--jp-icon-expand-all);
}

.jp-ExtensionIcon {
  background-image: var(--jp-icon-extension);
}

.jp-FastForwardIcon {
  background-image: var(--jp-icon-fast-forward);
}

.jp-FileIcon {
  background-image: var(--jp-icon-file);
}

.jp-FileUploadIcon {
  background-image: var(--jp-icon-file-upload);
}

.jp-FilterDotIcon {
  background-image: var(--jp-icon-filter-dot);
}

.jp-FilterIcon {
  background-image: var(--jp-icon-filter);
}

.jp-FilterListIcon {
  background-image: var(--jp-icon-filter-list);
}

.jp-FolderFavoriteIcon {
  background-image: var(--jp-icon-folder-favorite);
}

.jp-FolderIcon {
  background-image: var(--jp-icon-folder);
}

.jp-HomeIcon {
  background-image: var(--jp-icon-home);
}

.jp-Html5Icon {
  background-image: var(--jp-icon-html5);
}

.jp-ImageIcon {
  background-image: var(--jp-icon-image);
}

.jp-InfoIcon {
  background-image: var(--jp-icon-info);
}

.jp-InspectorIcon {
  background-image: var(--jp-icon-inspector);
}

.jp-JsonIcon {
  background-image: var(--jp-icon-json);
}

.jp-JuliaIcon {
  background-image: var(--jp-icon-julia);
}

.jp-JupyterFaviconIcon {
  background-image: var(--jp-icon-jupyter-favicon);
}

.jp-JupyterIcon {
  background-image: var(--jp-icon-jupyter);
}

.jp-JupyterlabWordmarkIcon {
  background-image: var(--jp-icon-jupyterlab-wordmark);
}

.jp-KernelIcon {
  background-image: var(--jp-icon-kernel);
}

.jp-KeyboardIcon {
  background-image: var(--jp-icon-keyboard);
}

.jp-LaunchIcon {
  background-image: var(--jp-icon-launch);
}

.jp-LauncherIcon {
  background-image: var(--jp-icon-launcher);
}

.jp-LineFormIcon {
  background-image: var(--jp-icon-line-form);
}

.jp-LinkIcon {
  background-image: var(--jp-icon-link);
}

.jp-ListIcon {
  background-image: var(--jp-icon-list);
}

.jp-MarkdownIcon {
  background-image: var(--jp-icon-markdown);
}

.jp-MoveDownIcon {
  background-image: var(--jp-icon-move-down);
}

.jp-MoveUpIcon {
  background-image: var(--jp-icon-move-up);
}

.jp-NewFolderIcon {
  background-image: var(--jp-icon-new-folder);
}

.jp-NotTrustedIcon {
  background-image: var(--jp-icon-not-trusted);
}

.jp-NotebookIcon {
  background-image: var(--jp-icon-notebook);
}

.jp-NumberingIcon {
  background-image: var(--jp-icon-numbering);
}

.jp-OfflineBoltIcon {
  background-image: var(--jp-icon-offline-bolt);
}

.jp-PaletteIcon {
  background-image: var(--jp-icon-palette);
}

.jp-PasteIcon {
  background-image: var(--jp-icon-paste);
}

.jp-PdfIcon {
  background-image: var(--jp-icon-pdf);
}

.jp-PythonIcon {
  background-image: var(--jp-icon-python);
}

.jp-RKernelIcon {
  background-image: var(--jp-icon-r-kernel);
}

.jp-ReactIcon {
  background-image: var(--jp-icon-react);
}

.jp-RedoIcon {
  background-image: var(--jp-icon-redo);
}

.jp-RefreshIcon {
  background-image: var(--jp-icon-refresh);
}

.jp-RegexIcon {
  background-image: var(--jp-icon-regex);
}

.jp-RunIcon {
  background-image: var(--jp-icon-run);
}

.jp-RunningIcon {
  background-image: var(--jp-icon-running);
}

.jp-SaveIcon {
  background-image: var(--jp-icon-save);
}

.jp-SearchIcon {
  background-image: var(--jp-icon-search);
}

.jp-SettingsIcon {
  background-image: var(--jp-icon-settings);
}

.jp-ShareIcon {
  background-image: var(--jp-icon-share);
}

.jp-SpreadsheetIcon {
  background-image: var(--jp-icon-spreadsheet);
}

.jp-StopIcon {
  background-image: var(--jp-icon-stop);
}

.jp-TabIcon {
  background-image: var(--jp-icon-tab);
}

.jp-TableRowsIcon {
  background-image: var(--jp-icon-table-rows);
}

.jp-TagIcon {
  background-image: var(--jp-icon-tag);
}

.jp-TerminalIcon {
  background-image: var(--jp-icon-terminal);
}

.jp-TextEditorIcon {
  background-image: var(--jp-icon-text-editor);
}

.jp-TocIcon {
  background-image: var(--jp-icon-toc);
}

.jp-TreeViewIcon {
  background-image: var(--jp-icon-tree-view);
}

.jp-TrustedIcon {
  background-image: var(--jp-icon-trusted);
}

.jp-UndoIcon {
  background-image: var(--jp-icon-undo);
}

.jp-UserIcon {
  background-image: var(--jp-icon-user);
}

.jp-UsersIcon {
  background-image: var(--jp-icon-users);
}

.jp-VegaIcon {
  background-image: var(--jp-icon-vega);
}

.jp-WordIcon {
  background-image: var(--jp-icon-word);
}

.jp-YamlIcon {
  background-image: var(--jp-icon-yaml);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * (DEPRECATED) Support for consuming icons as CSS background images
 */

.jp-Icon,
.jp-MaterialIcon {
  background-position: center;
  background-repeat: no-repeat;
  background-size: 16px;
  min-width: 16px;
  min-height: 16px;
}

.jp-Icon-cover {
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
}

/**
 * (DEPRECATED) Support for specific CSS icon sizes
 */

.jp-Icon-16 {
  background-size: 16px;
  min-width: 16px;
  min-height: 16px;
}

.jp-Icon-18 {
  background-size: 18px;
  min-width: 18px;
  min-height: 18px;
}

.jp-Icon-20 {
  background-size: 20px;
  min-width: 20px;
  min-height: 20px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.lm-TabBar .lm-TabBar-addButton {
  align-items: center;
  display: flex;
  padding: 4px;
  padding-bottom: 5px;
  margin-right: 1px;
  background-color: var(--jp-layout-color2);
}

.lm-TabBar .lm-TabBar-addButton:hover {
  background-color: var(--jp-layout-color1);
}

.lm-DockPanel-tabBar .lm-TabBar-tab {
  width: var(--jp-private-horizontal-tab-width);
}

.lm-DockPanel-tabBar .lm-TabBar-content {
  flex: unset;
}

.lm-DockPanel-tabBar[data-orientation='horizontal'] {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * Support for icons as inline SVG HTMLElements
 */

/* recolor the primary elements of an icon */
.jp-icon0[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon1[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon2[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon3[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon4[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon0[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon1[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon2[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon3[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon4[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/* recolor the accent elements of an icon */
.jp-icon-accent0[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-accent1[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-accent2[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-accent3[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-accent4[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-accent0[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-accent1[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-accent2[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-accent3[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-accent4[stroke] {
  stroke: var(--jp-layout-color4);
}

/* set the color of an icon to transparent */
.jp-icon-none[fill] {
  fill: none;
}

.jp-icon-none[stroke] {
  stroke: none;
}

/* brand icon colors. Same for light and dark */
.jp-icon-brand0[fill] {
  fill: var(--jp-brand-color0);
}

.jp-icon-brand1[fill] {
  fill: var(--jp-brand-color1);
}

.jp-icon-brand2[fill] {
  fill: var(--jp-brand-color2);
}

.jp-icon-brand3[fill] {
  fill: var(--jp-brand-color3);
}

.jp-icon-brand4[fill] {
  fill: var(--jp-brand-color4);
}

.jp-icon-brand0[stroke] {
  stroke: var(--jp-brand-color0);
}

.jp-icon-brand1[stroke] {
  stroke: var(--jp-brand-color1);
}

.jp-icon-brand2[stroke] {
  stroke: var(--jp-brand-color2);
}

.jp-icon-brand3[stroke] {
  stroke: var(--jp-brand-color3);
}

.jp-icon-brand4[stroke] {
  stroke: var(--jp-brand-color4);
}

/* warn icon colors. Same for light and dark */
.jp-icon-warn0[fill] {
  fill: var(--jp-warn-color0);
}

.jp-icon-warn1[fill] {
  fill: var(--jp-warn-color1);
}

.jp-icon-warn2[fill] {
  fill: var(--jp-warn-color2);
}

.jp-icon-warn3[fill] {
  fill: var(--jp-warn-color3);
}

.jp-icon-warn0[stroke] {
  stroke: var(--jp-warn-color0);
}

.jp-icon-warn1[stroke] {
  stroke: var(--jp-warn-color1);
}

.jp-icon-warn2[stroke] {
  stroke: var(--jp-warn-color2);
}

.jp-icon-warn3[stroke] {
  stroke: var(--jp-warn-color3);
}

/* icon colors that contrast well with each other and most backgrounds */
.jp-icon-contrast0[fill] {
  fill: var(--jp-icon-contrast-color0);
}

.jp-icon-contrast1[fill] {
  fill: var(--jp-icon-contrast-color1);
}

.jp-icon-contrast2[fill] {
  fill: var(--jp-icon-contrast-color2);
}

.jp-icon-contrast3[fill] {
  fill: var(--jp-icon-contrast-color3);
}

.jp-icon-contrast0[stroke] {
  stroke: var(--jp-icon-contrast-color0);
}

.jp-icon-contrast1[stroke] {
  stroke: var(--jp-icon-contrast-color1);
}

.jp-icon-contrast2[stroke] {
  stroke: var(--jp-icon-contrast-color2);
}

.jp-icon-contrast3[stroke] {
  stroke: var(--jp-icon-contrast-color3);
}

.jp-icon-dot[fill] {
  fill: var(--jp-warn-color0);
}

.jp-jupyter-icon-color[fill] {
  fill: var(--jp-jupyter-icon-color, var(--jp-warn-color0));
}

.jp-notebook-icon-color[fill] {
  fill: var(--jp-notebook-icon-color, var(--jp-warn-color0));
}

.jp-json-icon-color[fill] {
  fill: var(--jp-json-icon-color, var(--jp-warn-color1));
}

.jp-console-icon-color[fill] {
  fill: var(--jp-console-icon-color, white);
}

.jp-console-icon-background-color[fill] {
  fill: var(--jp-console-icon-background-color, var(--jp-brand-color1));
}

.jp-terminal-icon-color[fill] {
  fill: var(--jp-terminal-icon-color, var(--jp-layout-color2));
}

.jp-terminal-icon-background-color[fill] {
  fill: var(
    --jp-terminal-icon-background-color,
    var(--jp-inverse-layout-color2)
  );
}

.jp-text-editor-icon-color[fill] {
  fill: var(--jp-text-editor-icon-color, var(--jp-inverse-layout-color3));
}

.jp-inspector-icon-color[fill] {
  fill: var(--jp-inspector-icon-color, var(--jp-inverse-layout-color3));
}

/* CSS for icons in selected filebrowser listing items */
.jp-DirListing-item.jp-mod-selected .jp-icon-selectable[fill] {
  fill: #fff;
}

.jp-DirListing-item.jp-mod-selected .jp-icon-selectable-inverse[fill] {
  fill: var(--jp-brand-color1);
}

/* stylelint-disable selector-max-class, selector-max-compound-selectors */

/**
* TODO: come up with non css-hack solution for showing the busy icon on top
*  of the close icon
* CSS for complex behavior of close icon of tabs in the main area tabbar
*/
.lm-DockPanel-tabBar
  .lm-TabBar-tab.lm-mod-closable.jp-mod-dirty
  > .lm-TabBar-tabCloseIcon
  > :not(:hover)
  > .jp-icon3[fill] {
  fill: none;
}

.lm-DockPanel-tabBar
  .lm-TabBar-tab.lm-mod-closable.jp-mod-dirty
  > .lm-TabBar-tabCloseIcon
  > :not(:hover)
  > .jp-icon-busy[fill] {
  fill: var(--jp-inverse-layout-color3);
}

/* stylelint-enable selector-max-class, selector-max-compound-selectors */

/* CSS for icons in status bar */
#jp-main-statusbar .jp-mod-selected .jp-icon-selectable[fill] {
  fill: #fff;
}

#jp-main-statusbar .jp-mod-selected .jp-icon-selectable-inverse[fill] {
  fill: var(--jp-brand-color1);
}

/* special handling for splash icon CSS. While the theme CSS reloads during
   splash, the splash icon can loose theming. To prevent that, we set a
   default for its color variable */
:root {
  --jp-warn-color0: var(--md-orange-700);
}

/* not sure what to do with this one, used in filebrowser listing */
.jp-DragIcon {
  margin-right: 4px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * Support for alt colors for icons as inline SVG HTMLElements
 */

/* alt recolor the primary elements of an icon */
.jp-icon-alt .jp-icon0[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-alt .jp-icon1[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-alt .jp-icon2[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-alt .jp-icon3[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-alt .jp-icon4[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-alt .jp-icon0[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-alt .jp-icon1[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-alt .jp-icon2[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-alt .jp-icon3[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-alt .jp-icon4[stroke] {
  stroke: var(--jp-layout-color4);
}

/* alt recolor the accent elements of an icon */
.jp-icon-alt .jp-icon-accent0[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-alt .jp-icon-accent1[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-alt .jp-icon-accent2[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-alt .jp-icon-accent3[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-alt .jp-icon-accent4[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-alt .jp-icon-accent0[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-alt .jp-icon-accent1[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-alt .jp-icon-accent2[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-alt .jp-icon-accent3[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-alt .jp-icon-accent4[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-icon-hoverShow:not(:hover) .jp-icon-hoverShow-content {
  display: none !important;
}

/**
 * Support for hover colors for icons as inline SVG HTMLElements
 */

/**
 * regular colors
 */

/* recolor the primary elements of an icon */
.jp-icon-hover :hover .jp-icon0-hover[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-hover :hover .jp-icon1-hover[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-hover :hover .jp-icon2-hover[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-hover :hover .jp-icon3-hover[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-hover :hover .jp-icon4-hover[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-hover :hover .jp-icon0-hover[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-hover :hover .jp-icon1-hover[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-hover :hover .jp-icon2-hover[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-hover :hover .jp-icon3-hover[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-hover :hover .jp-icon4-hover[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/* recolor the accent elements of an icon */
.jp-icon-hover :hover .jp-icon-accent0-hover[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-hover :hover .jp-icon-accent1-hover[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-hover :hover .jp-icon-accent2-hover[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-hover :hover .jp-icon-accent3-hover[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-hover :hover .jp-icon-accent4-hover[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-hover :hover .jp-icon-accent0-hover[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-hover :hover .jp-icon-accent1-hover[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-hover :hover .jp-icon-accent2-hover[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-hover :hover .jp-icon-accent3-hover[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-hover :hover .jp-icon-accent4-hover[stroke] {
  stroke: var(--jp-layout-color4);
}

/* set the color of an icon to transparent */
.jp-icon-hover :hover .jp-icon-none-hover[fill] {
  fill: none;
}

.jp-icon-hover :hover .jp-icon-none-hover[stroke] {
  stroke: none;
}

/**
 * inverse colors
 */

/* inverse recolor the primary elements of an icon */
.jp-icon-hover.jp-icon-alt :hover .jp-icon0-hover[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon1-hover[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon2-hover[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon3-hover[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon4-hover[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon0-hover[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon1-hover[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon2-hover[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon3-hover[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon4-hover[stroke] {
  stroke: var(--jp-layout-color4);
}

/* inverse recolor the accent elements of an icon */
.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent0-hover[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent1-hover[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent2-hover[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent3-hover[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent4-hover[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent0-hover[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent1-hover[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent2-hover[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent3-hover[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent4-hover[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-IFrame {
  width: 100%;
  height: 100%;
}

.jp-IFrame > iframe {
  border: none;
}

/*
When drag events occur, `lm-mod-override-cursor` is added to the body.
Because iframes steal all cursor events, the following two rules are necessary
to suppress pointer events while resize drags are occurring. There may be a
better solution to this problem.
*/
body.lm-mod-override-cursor .jp-IFrame {
  position: relative;
}

body.lm-mod-override-cursor .jp-IFrame::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-HoverBox {
  position: fixed;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-FormGroup-content fieldset {
  border: none;
  padding: 0;
  min-width: 0;
  width: 100%;
}

/* stylelint-disable selector-max-type */

.jp-FormGroup-content fieldset .jp-inputFieldWrapper input,
.jp-FormGroup-content fieldset .jp-inputFieldWrapper select,
.jp-FormGroup-content fieldset .jp-inputFieldWrapper textarea {
  font-size: var(--jp-content-font-size2);
  border-color: var(--jp-input-border-color);
  border-style: solid;
  border-radius: var(--jp-border-radius);
  border-width: 1px;
  padding: 6px 8px;
  background: none;
  color: var(--jp-ui-font-color0);
  height: inherit;
}

.jp-FormGroup-content fieldset input[type='checkbox'] {
  position: relative;
  top: 2px;
  margin-left: 0;
}

.jp-FormGroup-content button.jp-mod-styled {
  cursor: pointer;
}

.jp-FormGroup-content .checkbox label {
  cursor: pointer;
  font-size: var(--jp-content-font-size1);
}

.jp-FormGroup-content .jp-root > fieldset > legend {
  display: none;
}

.jp-FormGroup-content .jp-root > fieldset > p {
  display: none;
}

/** copy of `input.jp-mod-styled:focus` style */
.jp-FormGroup-content fieldset input:focus,
.jp-FormGroup-content fieldset select:focus {
  -moz-outline-radius: unset;
  outline: var(--jp-border-width) solid var(--md-blue-500);
  outline-offset: -1px;
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-FormGroup-content fieldset input:hover:not(:focus),
.jp-FormGroup-content fieldset select:hover:not(:focus) {
  background-color: var(--jp-border-color2);
}

/* stylelint-enable selector-max-type */

.jp-FormGroup-content .checkbox .field-description {
  /* Disable default description field for checkbox:
   because other widgets do not have description fields,
   we add descriptions to each widget on the field level.
  */
  display: none;
}

.jp-FormGroup-content #root__description {
  display: none;
}

.jp-FormGroup-content .jp-modifiedIndicator {
  width: 5px;
  background-color: var(--jp-brand-color2);
  margin-top: 0;
  margin-left: calc(var(--jp-private-settingeditor-modifier-indent) * -1);
  flex-shrink: 0;
}

.jp-FormGroup-content .jp-modifiedIndicator.jp-errorIndicator {
  background-color: var(--jp-error-color0);
  margin-right: 0.5em;
}

/* RJSF ARRAY style */

.jp-arrayFieldWrapper legend {
  font-size: var(--jp-content-font-size2);
  color: var(--jp-ui-font-color0);
  flex-basis: 100%;
  padding: 4px 0;
  font-weight: var(--jp-content-heading-font-weight);
  border-bottom: 1px solid var(--jp-border-color2);
}

.jp-arrayFieldWrapper .field-description {
  padding: 4px 0;
  white-space: pre-wrap;
}

.jp-arrayFieldWrapper .array-item {
  width: 100%;
  border: 1px solid var(--jp-border-color2);
  border-radius: 4px;
  margin: 4px;
}

.jp-ArrayOperations {
  display: flex;
  margin-left: 8px;
}

.jp-ArrayOperationsButton {
  margin: 2px;
}

.jp-ArrayOperationsButton .jp-icon3[fill] {
  fill: var(--jp-ui-font-color0);
}

button.jp-ArrayOperationsButton.jp-mod-styled:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

/* RJSF form validation error */

.jp-FormGroup-content .validationErrors {
  color: var(--jp-error-color0);
}

/* Hide panel level error as duplicated the field level error */
.jp-FormGroup-content .panel.errors {
  display: none;
}

/* RJSF normal content (settings-editor) */

.jp-FormGroup-contentNormal {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

.jp-FormGroup-contentNormal .jp-FormGroup-contentItem {
  margin-left: 7px;
  color: var(--jp-ui-font-color0);
}

.jp-FormGroup-contentNormal .jp-FormGroup-description {
  flex-basis: 100%;
  padding: 4px 7px;
}

.jp-FormGroup-contentNormal .jp-FormGroup-default {
  flex-basis: 100%;
  padding: 4px 7px;
}

.jp-FormGroup-contentNormal .jp-FormGroup-fieldLabel {
  font-size: var(--jp-content-font-size1);
  font-weight: normal;
  min-width: 120px;
}

.jp-FormGroup-contentNormal fieldset:not(:first-child) {
  margin-left: 7px;
}

.jp-FormGroup-contentNormal .field-array-of-string .array-item {
  /* Display `jp-ArrayOperations` buttons side-by-side with content except
    for small screens where flex-wrap will place them one below the other.
  */
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

.jp-FormGroup-contentNormal .jp-objectFieldWrapper .form-group {
  padding: 2px 8px 2px var(--jp-private-settingeditor-modifier-indent);
  margin-top: 2px;
}

/* RJSF compact content (metadata-form) */

.jp-FormGroup-content.jp-FormGroup-contentCompact {
  width: 100%;
}

.jp-FormGroup-contentCompact .form-group {
  display: flex;
  padding: 0.5em 0.2em 0.5em 0;
}

.jp-FormGroup-contentCompact
  .jp-FormGroup-compactTitle
  .jp-FormGroup-description {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color2);
}

.jp-FormGroup-contentCompact .jp-FormGroup-fieldLabel {
  padding-bottom: 0.3em;
}

.jp-FormGroup-contentCompact .jp-inputFieldWrapper .form-control {
  width: 100%;
  box-sizing: border-box;
}

.jp-FormGroup-contentCompact .jp-arrayFieldWrapper .jp-FormGroup-compactTitle {
  padding-bottom: 7px;
}

.jp-FormGroup-contentCompact
  .jp-objectFieldWrapper
  .jp-objectFieldWrapper
  .form-group {
  padding: 2px 8px 2px var(--jp-private-settingeditor-modifier-indent);
  margin-top: 2px;
}

.jp-FormGroup-contentCompact ul.error-detail {
  margin-block-start: 0.5em;
  margin-block-end: 0.5em;
  padding-inline-start: 1em;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-SidePanel {
  display: flex;
  flex-direction: column;
  min-width: var(--jp-sidebar-min-width);
  overflow-y: auto;
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);
  font-size: var(--jp-ui-font-size1);
}

.jp-SidePanel-header {
  flex: 0 0 auto;
  display: flex;
  border-bottom: var(--jp-border-width) solid var(--jp-border-color2);
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  letter-spacing: 1px;
  margin: 0;
  padding: 2px;
  text-transform: uppercase;
}

.jp-SidePanel-toolbar {
  flex: 0 0 auto;
}

.jp-SidePanel-content {
  flex: 1 1 auto;
}

.jp-SidePanel-toolbar,
.jp-AccordionPanel-toolbar {
  height: var(--jp-private-toolbar-height);
}

.jp-SidePanel-toolbar.jp-Toolbar-micro {
  display: none;
}

.lm-AccordionPanel .jp-AccordionPanel-title {
  box-sizing: border-box;
  line-height: 25px;
  margin: 0;
  display: flex;
  align-items: center;
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  font-size: var(--jp-ui-font-size0);
}

.jp-AccordionPanel-title {
  cursor: pointer;
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  text-transform: uppercase;
}

.lm-AccordionPanel[data-orientation='horizontal'] > .jp-AccordionPanel-title {
  /* Title is rotated for horizontal accordion panel using CSS */
  display: block;
  transform-origin: top left;
  transform: rotate(-90deg) translate(-100%);
}

.jp-AccordionPanel-title .lm-AccordionPanel-titleLabel {
  user-select: none;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}

.jp-AccordionPanel-title .lm-AccordionPanel-titleCollapser {
  transform: rotate(-90deg);
  margin: auto 0;
  height: 16px;
}

.jp-AccordionPanel-title.lm-mod-expanded .lm-AccordionPanel-titleCollapser {
  transform: rotate(0deg);
}

.lm-AccordionPanel .jp-AccordionPanel-toolbar {
  background: none;
  box-shadow: none;
  border: none;
  margin-left: auto;
}

.lm-AccordionPanel .lm-SplitPanel-handle:hover {
  background: var(--jp-layout-color3);
}

.jp-text-truncated {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Spinner {
  position: absolute;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: var(--jp-layout-color0);
  outline: none;
}

.jp-SpinnerContent {
  font-size: 10px;
  margin: 50px auto;
  text-indent: -9999em;
  width: 3em;
  height: 3em;
  border-radius: 50%;
  background: var(--jp-brand-color3);
  background: linear-gradient(
    to right,
    #f37626 10%,
    rgba(255, 255, 255, 0) 42%
  );
  position: relative;
  animation: load3 1s infinite linear, fadeIn 1s;
}

.jp-SpinnerContent::before {
  width: 50%;
  height: 50%;
  background: #f37626;
  border-radius: 100% 0 0;
  position: absolute;
  top: 0;
  left: 0;
  content: '';
}

.jp-SpinnerContent::after {
  background: var(--jp-layout-color0);
  width: 75%;
  height: 75%;
  border-radius: 50%;
  content: '';
  margin: auto;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}

@keyframes fadeIn {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@keyframes load3 {
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

button.jp-mod-styled {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  border: none;
  box-sizing: border-box;
  text-align: center;
  line-height: 32px;
  height: 32px;
  padding: 0 12px;
  letter-spacing: 0.8px;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

input.jp-mod-styled {
  background: var(--jp-input-background);
  height: 28px;
  box-sizing: border-box;
  border: var(--jp-border-width) solid var(--jp-border-color1);
  padding-left: 7px;
  padding-right: 7px;
  font-size: var(--jp-ui-font-size2);
  color: var(--jp-ui-font-color0);
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

input[type='checkbox'].jp-mod-styled {
  appearance: checkbox;
  -webkit-appearance: checkbox;
  -moz-appearance: checkbox;
  height: auto;
}

input.jp-mod-styled:focus {
  border: var(--jp-border-width) solid var(--md-blue-500);
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-select-wrapper {
  display: flex;
  position: relative;
  flex-direction: column;
  padding: 1px;
  background-color: var(--jp-layout-color1);
  box-sizing: border-box;
  margin-bottom: 12px;
}

.jp-select-wrapper:not(.multiple) {
  height: 28px;
}

.jp-select-wrapper.jp-mod-focused select.jp-mod-styled {
  border: var(--jp-border-width) solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
  background-color: var(--jp-input-active-background);
}

select.jp-mod-styled:hover {
  cursor: pointer;
  color: var(--jp-ui-font-color0);
  background-color: var(--jp-input-hover-background);
  box-shadow: inset 0 0 1px rgba(0, 0, 0, 0.5);
}

select.jp-mod-styled {
  flex: 1 1 auto;
  width: 100%;
  font-size: var(--jp-ui-font-size2);
  background: var(--jp-input-background);
  color: var(--jp-ui-font-color0);
  padding: 0 25px 0 8px;
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  border-radius: 0;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

select.jp-mod-styled:not([multiple]) {
  height: 32px;
}

select.jp-mod-styled[multiple] {
  max-height: 200px;
  overflow-y: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-switch {
  display: flex;
  align-items: center;
  padding-left: 4px;
  padding-right: 4px;
  font-size: var(--jp-ui-font-size1);
  background-color: transparent;
  color: var(--jp-ui-font-color1);
  border: none;
  height: 20px;
}

.jp-switch:hover {
  background-color: var(--jp-layout-color2);
}

.jp-switch-label {
  margin-right: 5px;
  font-family: var(--jp-ui-font-family);
}

.jp-switch-track {
  cursor: pointer;
  background-color: var(--jp-switch-color, var(--jp-border-color1));
  -webkit-transition: 0.4s;
  transition: 0.4s;
  border-radius: 34px;
  height: 16px;
  width: 35px;
  position: relative;
}

.jp-switch-track::before {
  content: '';
  position: absolute;
  height: 10px;
  width: 10px;
  margin: 3px;
  left: 0;
  background-color: var(--jp-ui-inverse-font-color1);
  -webkit-transition: 0.4s;
  transition: 0.4s;
  border-radius: 50%;
}

.jp-switch[aria-checked='true'] .jp-switch-track {
  background-color: var(--jp-switch-true-position-color, var(--jp-warn-color0));
}

.jp-switch[aria-checked='true'] .jp-switch-track::before {
  /* track width (35) - margins (3 + 3) - thumb width (10) */
  left: 19px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

:root {
  --jp-private-toolbar-height: calc(
    28px + var(--jp-border-width)
  ); /* leave 28px for content */
}

.jp-Toolbar {
  color: var(--jp-ui-font-color1);
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  background: var(--jp-toolbar-background);
  min-height: var(--jp-toolbar-micro-height);
  padding: 2px;
  z-index: 8;
  overflow-x: hidden;
}

/* Toolbar items */

.jp-Toolbar > .jp-Toolbar-item.jp-Toolbar-spacer {
  flex-grow: 1;
  flex-shrink: 1;
}

.jp-Toolbar-item.jp-Toolbar-kernelStatus {
  display: inline-block;
  width: 32px;
  background-repeat: no-repeat;
  background-position: center;
  background-size: 16px;
}

.jp-Toolbar > .jp-Toolbar-item {
  flex: 0 0 auto;
  display: flex;
  padding-left: 1px;
  padding-right: 1px;
  font-size: var(--jp-ui-font-size1);
  line-height: var(--jp-private-toolbar-height);
  height: 100%;
}

/* Toolbar buttons */

/* This is the div we use to wrap the react component into a Widget */
div.jp-ToolbarButton {
  color: transparent;
  border: none;
  box-sizing: border-box;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 0;
  margin: 0;
}

button.jp-ToolbarButtonComponent {
  background: var(--jp-layout-color1);
  border: none;
  box-sizing: border-box;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 0 6px;
  margin: 0;
  height: 24px;
  border-radius: var(--jp-border-radius);
  display: flex;
  align-items: center;
  text-align: center;
  font-size: 14px;
  min-width: unset;
  min-height: unset;
}

button.jp-ToolbarButtonComponent:disabled {
  opacity: 0.4;
}

button.jp-ToolbarButtonComponent > span {
  padding: 0;
  flex: 0 0 auto;
}

button.jp-ToolbarButtonComponent .jp-ToolbarButtonComponent-label {
  font-size: var(--jp-ui-font-size1);
  line-height: 100%;
  padding-left: 2px;
  color: var(--jp-ui-font-color1);
  font-family: var(--jp-ui-font-family);
}

#jp-main-dock-panel[data-mode='single-document']
  .jp-MainAreaWidget
  > .jp-Toolbar.jp-Toolbar-micro {
  padding: 0;
  min-height: 0;
}

#jp-main-dock-panel[data-mode='single-document']
  .jp-MainAreaWidget
  > .jp-Toolbar {
  border: none;
  box-shadow: none;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-WindowedPanel-outer {
  position: relative;
  overflow-y: auto;
}

.jp-WindowedPanel-inner {
  position: relative;
}

.jp-WindowedPanel-window {
  position: absolute;
  left: 0;
  right: 0;
  overflow: visible;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* Sibling imports */

body {
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
}

/* Disable native link decoration styles everywhere outside of dialog boxes */
a {
  text-decoration: unset;
  color: unset;
}

a:hover {
  text-decoration: unset;
  color: unset;
}

/* Accessibility for links inside dialog box text */
.jp-Dialog-content a {
  text-decoration: revert;
  color: var(--jp-content-link-color);
}

.jp-Dialog-content a:hover {
  text-decoration: revert;
}

/* Styles for ui-components */
.jp-Button {
  color: var(--jp-ui-font-color2);
  border-radius: var(--jp-border-radius);
  padding: 0 12px;
  font-size: var(--jp-ui-font-size1);

  /* Copy from blueprint 3 */
  display: inline-flex;
  flex-direction: row;
  border: none;
  cursor: pointer;
  align-items: center;
  justify-content: center;
  text-align: left;
  vertical-align: middle;
  min-height: 30px;
  min-width: 30px;
}

.jp-Button:disabled {
  cursor: not-allowed;
}

.jp-Button:empty {
  padding: 0 !important;
}

.jp-Button.jp-mod-small {
  min-height: 24px;
  min-width: 24px;
  font-size: 12px;
  padding: 0 7px;
}

/* Use our own theme for hover styles */
.jp-Button.jp-mod-minimal:hover {
  background-color: var(--jp-layout-color2);
}

.jp-Button.jp-mod-minimal {
  background: none;
}

.jp-InputGroup {
  display: block;
  position: relative;
}

.jp-InputGroup input {
  box-sizing: border-box;
  border: none;
  border-radius: 0;
  background-color: transparent;
  color: var(--jp-ui-font-color0);
  box-shadow: inset 0 0 0 var(--jp-border-width) var(--jp-input-border-color);
  padding-bottom: 0;
  padding-top: 0;
  padding-left: 10px;
  padding-right: 28px;
  position: relative;
  width: 100%;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  font-size: 14px;
  font-weight: 400;
  height: 30px;
  line-height: 30px;
  outline: none;
  vertical-align: middle;
}

.jp-InputGroup input:focus {
  box-shadow: inset 0 0 0 var(--jp-border-width)
      var(--jp-input-active-box-shadow-color),
    inset 0 0 0 3px var(--jp-input-active-box-shadow-color);
}

.jp-InputGroup input:disabled {
  cursor: not-allowed;
  resize: block;
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color2);
}

.jp-InputGroup input:disabled ~ span {
  cursor: not-allowed;
  color: var(--jp-ui-font-color2);
}

.jp-InputGroup input::placeholder,
input::placeholder {
  color: var(--jp-ui-font-color2);
}

.jp-InputGroupAction {
  position: absolute;
  bottom: 1px;
  right: 0;
  padding: 6px;
}

.jp-HTMLSelect.jp-DefaultStyle select {
  background-color: initial;
  border: none;
  border-radius: 0;
  box-shadow: none;
  color: var(--jp-ui-font-color0);
  display: block;
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  height: 24px;
  line-height: 14px;
  padding: 0 25px 0 10px;
  text-align: left;
  -moz-appearance: none;
  -webkit-appearance: none;
}

.jp-HTMLSelect.jp-DefaultStyle select:disabled {
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color2);
  cursor: not-allowed;
  resize: block;
}

.jp-HTMLSelect.jp-DefaultStyle select:disabled ~ span {
  cursor: not-allowed;
}

/* Use our own theme for hover and option styles */
/* stylelint-disable-next-line selector-max-type */
.jp-HTMLSelect.jp-DefaultStyle select:hover,
.jp-HTMLSelect.jp-DefaultStyle select > option {
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color0);
}

select {
  box-sizing: border-box;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-StatusBar-Widget {
  display: flex;
  align-items: center;
  background: var(--jp-layout-color2);
  min-height: var(--jp-statusbar-height);
  justify-content: space-between;
  padding: 0 10px;
}

.jp-StatusBar-Left {
  display: flex;
  align-items: center;
  flex-direction: row;
}

.jp-StatusBar-Middle {
  display: flex;
  align-items: center;
}

.jp-StatusBar-Right {
  display: flex;
  align-items: center;
  flex-direction: row-reverse;
}

.jp-StatusBar-Item {
  max-height: var(--jp-statusbar-height);
  margin: 0 2px;
  height: var(--jp-statusbar-height);
  white-space: nowrap;
  text-overflow: ellipsis;
  color: var(--jp-ui-font-color1);
  padding: 0 6px;
}

.jp-mod-highlighted:hover {
  background-color: var(--jp-layout-color3);
}

.jp-mod-clicked {
  background-color: var(--jp-brand-color1);
}

.jp-mod-clicked:hover {
  background-color: var(--jp-brand-color0);
}

.jp-mod-clicked .jp-StatusBar-TextItem {
  color: var(--jp-ui-inverse-font-color1);
}

.jp-StatusBar-HoverItem {
  box-shadow: '0px 4px 4px rgba(0, 0, 0, 0.25)';
}

.jp-StatusBar-TextItem {
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  line-height: 24px;
  color: var(--jp-ui-font-color1);
}

.jp-StatusBar-GroupItem {
  display: flex;
  align-items: center;
  flex-direction: row;
}

.jp-Statusbar-ProgressCircle svg {
  display: block;
  margin: 0 auto;
  width: 16px;
  height: 24px;
  align-self: normal;
}

.jp-Statusbar-ProgressCircle path {
  fill: var(--jp-inverse-layout-color3);
}

.jp-Statusbar-ProgressBar-progress-bar {
  height: 10px;
  width: 100px;
  border: solid 0.25px var(--jp-brand-color2);
  border-radius: 3px;
  overflow: hidden;
  align-self: center;
}

.jp-Statusbar-ProgressBar-progress-bar > div {
  background-color: var(--jp-brand-color2);
  background-image: linear-gradient(
    -45deg,
    rgba(255, 255, 255, 0.2) 25%,
    transparent 25%,
    transparent 50%,
    rgba(255, 255, 255, 0.2) 50%,
    rgba(255, 255, 255, 0.2) 75%,
    transparent 75%,
    transparent
  );
  background-size: 40px 40px;
  float: left;
  width: 0%;
  height: 100%;
  font-size: 12px;
  line-height: 14px;
  color: #fff;
  text-align: center;
  animation: jp-Statusbar-ExecutionTime-progress-bar 2s linear infinite;
}

.jp-Statusbar-ProgressBar-progress-bar p {
  color: var(--jp-ui-font-color1);
  font-family: var(--jp-ui-font-family);
  font-size: var(--jp-ui-font-size1);
  line-height: 10px;
  width: 100px;
}

@keyframes jp-Statusbar-ExecutionTime-progress-bar {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 40px 40px;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-commandpalette-search-height: 28px;
}

/*-----------------------------------------------------------------------------
| Overall styles
|----------------------------------------------------------------------------*/

.lm-CommandPalette {
  padding-bottom: 0;
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);

  /* This is needed so that all font sizing of children done in ems is
   * relative to this base size */
  font-size: var(--jp-ui-font-size1);
}

/*-----------------------------------------------------------------------------
| Modal variant
|----------------------------------------------------------------------------*/

.jp-ModalCommandPalette {
  position: absolute;
  z-index: 10000;
  top: 38px;
  left: 30%;
  margin: 0;
  padding: 4px;
  width: 40%;
  box-shadow: var(--jp-elevation-z4);
  border-radius: 4px;
  background: var(--jp-layout-color0);
}

.jp-ModalCommandPalette .lm-CommandPalette {
  max-height: 40vh;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-close-icon::after {
  display: none;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-CommandPalette-header {
  display: none;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-CommandPalette-item {
  margin-left: 4px;
  margin-right: 4px;
}

.jp-ModalCommandPalette
  .lm-CommandPalette
  .lm-CommandPalette-item.lm-mod-disabled {
  display: none;
}

/*-----------------------------------------------------------------------------
| Search
|----------------------------------------------------------------------------*/

.lm-CommandPalette-search {
  padding: 4px;
  background-color: var(--jp-layout-color1);
  z-index: 2;
}

.lm-CommandPalette-wrapper {
  overflow: overlay;
  padding: 0 9px;
  background-color: var(--jp-input-active-background);
  height: 30px;
  box-shadow: inset 0 0 0 var(--jp-border-width) var(--jp-input-border-color);
}

.lm-CommandPalette.lm-mod-focused .lm-CommandPalette-wrapper {
  box-shadow: inset 0 0 0 1px var(--jp-input-active-box-shadow-color),
    inset 0 0 0 3px var(--jp-input-active-box-shadow-color);
}

.jp-SearchIconGroup {
  color: white;
  background-color: var(--jp-brand-color1);
  position: absolute;
  top: 4px;
  right: 4px;
  padding: 5px 5px 1px;
}

.jp-SearchIconGroup svg {
  height: 20px;
  width: 20px;
}

.jp-SearchIconGroup .jp-icon3[fill] {
  fill: var(--jp-layout-color0);
}

.lm-CommandPalette-input {
  background: transparent;
  width: calc(100% - 18px);
  float: left;
  border: none;
  outline: none;
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  line-height: var(--jp-private-commandpalette-search-height);
}

.lm-CommandPalette-input::-webkit-input-placeholder,
.lm-CommandPalette-input::-moz-placeholder,
.lm-CommandPalette-input:-ms-input-placeholder {
  color: var(--jp-ui-font-color2);
  font-size: var(--jp-ui-font-size1);
}

/*-----------------------------------------------------------------------------
| Results
|----------------------------------------------------------------------------*/

.lm-CommandPalette-header:first-child {
  margin-top: 0;
}

.lm-CommandPalette-header {
  border-bottom: solid var(--jp-border-width) var(--jp-border-color2);
  color: var(--jp-ui-font-color1);
  cursor: pointer;
  display: flex;
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  letter-spacing: 1px;
  margin-top: 8px;
  padding: 8px 0 8px 12px;
  text-transform: uppercase;
}

.lm-CommandPalette-header.lm-mod-active {
  background: var(--jp-layout-color2);
}

.lm-CommandPalette-header > mark {
  background-color: transparent;
  font-weight: bold;
  color: var(--jp-ui-font-color1);
}

.lm-CommandPalette-item {
  padding: 4px 12px 4px 4px;
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  font-weight: 400;
  display: flex;
}

.lm-CommandPalette-item.lm-mod-disabled {
  color: var(--jp-ui-font-color2);
}

.lm-CommandPalette-item.lm-mod-active {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.lm-CommandPalette-item.lm-mod-active .lm-CommandPalette-itemLabel > mark {
  color: var(--jp-ui-inverse-font-color0);
}

.lm-CommandPalette-item.lm-mod-active .jp-icon-selectable[fill] {
  fill: var(--jp-layout-color0);
}

.lm-CommandPalette-item.lm-mod-active:hover:not(.lm-mod-disabled) {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.lm-CommandPalette-item:hover:not(.lm-mod-active):not(.lm-mod-disabled) {
  background: var(--jp-layout-color2);
}

.lm-CommandPalette-itemContent {
  overflow: hidden;
}

.lm-CommandPalette-itemLabel > mark {
  color: var(--jp-ui-font-color0);
  background-color: transparent;
  font-weight: bold;
}

.lm-CommandPalette-item.lm-mod-disabled mark {
  color: var(--jp-ui-font-color2);
}

.lm-CommandPalette-item .lm-CommandPalette-itemIcon {
  margin: 0 4px 0 0;
  position: relative;
  width: 16px;
  top: 2px;
  flex: 0 0 auto;
}

.lm-CommandPalette-item.lm-mod-disabled .lm-CommandPalette-itemIcon {
  opacity: 0.6;
}

.lm-CommandPalette-item .lm-CommandPalette-itemShortcut {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemCaption {
  display: none;
}

.lm-CommandPalette-content {
  background-color: var(--jp-layout-color1);
}

.lm-CommandPalette-content:empty::after {
  content: 'No results';
  margin: auto;
  margin-top: 20px;
  width: 100px;
  display: block;
  font-size: var(--jp-ui-font-size2);
  font-family: var(--jp-ui-font-family);
  font-weight: lighter;
}

.lm-CommandPalette-emptyMessage {
  text-align: center;
  margin-top: 24px;
  line-height: 1.32;
  padding: 0 8px;
  color: var(--jp-content-font-color3);
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Dialog {
  position: absolute;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  top: 0;
  left: 0;
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: var(--jp-dialog-background);
}

.jp-Dialog-content {
  display: flex;
  flex-direction: column;
  margin-left: auto;
  margin-right: auto;
  background: var(--jp-layout-color1);
  padding: 24px 24px 12px;
  min-width: 300px;
  min-height: 150px;
  max-width: 1000px;
  max-height: 500px;
  box-sizing: border-box;
  box-shadow: var(--jp-elevation-z20);
  word-wrap: break-word;
  border-radius: var(--jp-border-radius);

  /* This is needed so that all font sizing of children done in ems is
   * relative to this base size */
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color1);
  resize: both;
}

.jp-Dialog-content.jp-Dialog-content-small {
  max-width: 500px;
}

.jp-Dialog-button {
  overflow: visible;
}

button.jp-Dialog-button:focus {
  outline: 1px solid var(--jp-brand-color1);
  outline-offset: 4px;
  -moz-outline-radius: 0;
}

button.jp-Dialog-button:focus::-moz-focus-inner {
  border: 0;
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-accept:focus,
button.jp-Dialog-button.jp-mod-styled.jp-mod-warn:focus,
button.jp-Dialog-button.jp-mod-styled.jp-mod-reject:focus {
  outline-offset: 4px;
  -moz-outline-radius: 0;
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-accept:focus {
  outline: 1px solid var(--jp-accept-color-normal, var(--jp-brand-color1));
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-warn:focus {
  outline: 1px solid var(--jp-warn-color-normal, var(--jp-error-color1));
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-reject:focus {
  outline: 1px solid var(--jp-reject-color-normal, var(--md-grey-600));
}

button.jp-Dialog-close-button {
  padding: 0;
  height: 100%;
  min-width: unset;
  min-height: unset;
}

.jp-Dialog-header {
  display: flex;
  justify-content: space-between;
  flex: 0 0 auto;
  padding-bottom: 12px;
  font-size: var(--jp-ui-font-size3);
  font-weight: 400;
  color: var(--jp-ui-font-color1);
}

.jp-Dialog-body {
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  font-size: var(--jp-ui-font-size1);
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  overflow: auto;
}

.jp-Dialog-footer {
  display: flex;
  flex-direction: row;
  justify-content: flex-end;
  align-items: center;
  flex: 0 0 auto;
  margin-left: -12px;
  margin-right: -12px;
  padding: 12px;
}

.jp-Dialog-checkbox {
  padding-right: 5px;
}

.jp-Dialog-checkbox > input:focus-visible {
  outline: 1px solid var(--jp-input-active-border-color);
  outline-offset: 1px;
}

.jp-Dialog-spacer {
  flex: 1 1 auto;
}

.jp-Dialog-title {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.jp-Dialog-body > .jp-select-wrapper {
  width: 100%;
}

.jp-Dialog-body > button {
  padding: 0 16px;
}

.jp-Dialog-body > label {
  line-height: 1.4;
  color: var(--jp-ui-font-color0);
}

.jp-Dialog-button.jp-mod-styled:not(:last-child) {
  margin-right: 12px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-Input-Boolean-Dialog {
  flex-direction: row-reverse;
  align-items: end;
  width: 100%;
}

.jp-Input-Boolean-Dialog > label {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-MainAreaWidget > :focus {
  outline: none;
}

.jp-MainAreaWidget .jp-MainAreaWidget-error {
  padding: 6px;
}

.jp-MainAreaWidget .jp-MainAreaWidget-error > pre {
  width: auto;
  padding: 10px;
  background: var(--jp-error-color3);
  border: var(--jp-border-width) solid var(--jp-error-color1);
  border-radius: var(--jp-border-radius);
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  white-space: pre-wrap;
  word-wrap: break-word;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/**
 * google-material-color v1.2.6
 * https://github.com/danlevan/google-material-color
 */
:root {
  --md-red-50: #ffebee;
  --md-red-100: #ffcdd2;
  --md-red-200: #ef9a9a;
  --md-red-300: #e57373;
  --md-red-400: #ef5350;
  --md-red-500: #f44336;
  --md-red-600: #e53935;
  --md-red-700: #d32f2f;
  --md-red-800: #c62828;
  --md-red-900: #b71c1c;
  --md-red-A100: #ff8a80;
  --md-red-A200: #ff5252;
  --md-red-A400: #ff1744;
  --md-red-A700: #d50000;
  --md-pink-50: #fce4ec;
  --md-pink-100: #f8bbd0;
  --md-pink-200: #f48fb1;
  --md-pink-300: #f06292;
  --md-pink-400: #ec407a;
  --md-pink-500: #e91e63;
  --md-pink-600: #d81b60;
  --md-pink-700: #c2185b;
  --md-pink-800: #ad1457;
  --md-pink-900: #880e4f;
  --md-pink-A100: #ff80ab;
  --md-pink-A200: #ff4081;
  --md-pink-A400: #f50057;
  --md-pink-A700: #c51162;
  --md-purple-50: #f3e5f5;
  --md-purple-100: #e1bee7;
  --md-purple-200: #ce93d8;
  --md-purple-300: #ba68c8;
  --md-purple-400: #ab47bc;
  --md-purple-500: #9c27b0;
  --md-purple-600: #8e24aa;
  --md-purple-700: #7b1fa2;
  --md-purple-800: #6a1b9a;
  --md-purple-900: #4a148c;
  --md-purple-A100: #ea80fc;
  --md-purple-A200: #e040fb;
  --md-purple-A400: #d500f9;
  --md-purple-A700: #a0f;
  --md-deep-purple-50: #ede7f6;
  --md-deep-purple-100: #d1c4e9;
  --md-deep-purple-200: #b39ddb;
  --md-deep-purple-300: #9575cd;
  --md-deep-purple-400: #7e57c2;
  --md-deep-purple-500: #673ab7;
  --md-deep-purple-600: #5e35b1;
  --md-deep-purple-700: #512da8;
  --md-deep-purple-800: #4527a0;
  --md-deep-purple-900: #311b92;
  --md-deep-purple-A100: #b388ff;
  --md-deep-purple-A200: #7c4dff;
  --md-deep-purple-A400: #651fff;
  --md-deep-purple-A700: #6200ea;
  --md-indigo-50: #e8eaf6;
  --md-indigo-100: #c5cae9;
  --md-indigo-200: #9fa8da;
  --md-indigo-300: #7986cb;
  --md-indigo-400: #5c6bc0;
  --md-indigo-500: #3f51b5;
  --md-indigo-600: #3949ab;
  --md-indigo-700: #303f9f;
  --md-indigo-800: #283593;
  --md-indigo-900: #1a237e;
  --md-indigo-A100: #8c9eff;
  --md-indigo-A200: #536dfe;
  --md-indigo-A400: #3d5afe;
  --md-indigo-A700: #304ffe;
  --md-blue-50: #e3f2fd;
  --md-blue-100: #bbdefb;
  --md-blue-200: #90caf9;
  --md-blue-300: #64b5f6;
  --md-blue-400: #42a5f5;
  --md-blue-500: #2196f3;
  --md-blue-600: #1e88e5;
  --md-blue-700: #1976d2;
  --md-blue-800: #1565c0;
  --md-blue-900: #0d47a1;
  --md-blue-A100: #82b1ff;
  --md-blue-A200: #448aff;
  --md-blue-A400: #2979ff;
  --md-blue-A700: #2962ff;
  --md-light-blue-50: #e1f5fe;
  --md-light-blue-100: #b3e5fc;
  --md-light-blue-200: #81d4fa;
  --md-light-blue-300: #4fc3f7;
  --md-light-blue-400: #29b6f6;
  --md-light-blue-500: #03a9f4;
  --md-light-blue-600: #039be5;
  --md-light-blue-700: #0288d1;
  --md-light-blue-800: #0277bd;
  --md-light-blue-900: #01579b;
  --md-light-blue-A100: #80d8ff;
  --md-light-blue-A200: #40c4ff;
  --md-light-blue-A400: #00b0ff;
  --md-light-blue-A700: #0091ea;
  --md-cyan-50: #e0f7fa;
  --md-cyan-100: #b2ebf2;
  --md-cyan-200: #80deea;
  --md-cyan-300: #4dd0e1;
  --md-cyan-400: #26c6da;
  --md-cyan-500: #00bcd4;
  --md-cyan-600: #00acc1;
  --md-cyan-700: #0097a7;
  --md-cyan-800: #00838f;
  --md-cyan-900: #006064;
  --md-cyan-A100: #84ffff;
  --md-cyan-A200: #18ffff;
  --md-cyan-A400: #00e5ff;
  --md-cyan-A700: #00b8d4;
  --md-teal-50: #e0f2f1;
  --md-teal-100: #b2dfdb;
  --md-teal-200: #80cbc4;
  --md-teal-300: #4db6ac;
  --md-teal-400: #26a69a;
  --md-teal-500: #009688;
  --md-teal-600: #00897b;
  --md-teal-700: #00796b;
  --md-teal-800: #00695c;
  --md-teal-900: #004d40;
  --md-teal-A100: #a7ffeb;
  --md-teal-A200: #64ffda;
  --md-teal-A400: #1de9b6;
  --md-teal-A700: #00bfa5;
  --md-green-50: #e8f5e9;
  --md-green-100: #c8e6c9;
  --md-green-200: #a5d6a7;
  --md-green-300: #81c784;
  --md-green-400: #66bb6a;
  --md-green-500: #4caf50;
  --md-green-600: #43a047;
  --md-green-700: #388e3c;
  --md-green-800: #2e7d32;
  --md-green-900: #1b5e20;
  --md-green-A100: #b9f6ca;
  --md-green-A200: #69f0ae;
  --md-green-A400: #00e676;
  --md-green-A700: #00c853;
  --md-light-green-50: #f1f8e9;
  --md-light-green-100: #dcedc8;
  --md-light-green-200: #c5e1a5;
  --md-light-green-300: #aed581;
  --md-light-green-400: #9ccc65;
  --md-light-green-500: #8bc34a;
  --md-light-green-600: #7cb342;
  --md-light-green-700: #689f38;
  --md-light-green-800: #558b2f;
  --md-light-green-900: #33691e;
  --md-light-green-A100: #ccff90;
  --md-light-green-A200: #b2ff59;
  --md-light-green-A400: #76ff03;
  --md-light-green-A700: #64dd17;
  --md-lime-50: #f9fbe7;
  --md-lime-100: #f0f4c3;
  --md-lime-200: #e6ee9c;
  --md-lime-300: #dce775;
  --md-lime-400: #d4e157;
  --md-lime-500: #cddc39;
  --md-lime-600: #c0ca33;
  --md-lime-700: #afb42b;
  --md-lime-800: #9e9d24;
  --md-lime-900: #827717;
  --md-lime-A100: #f4ff81;
  --md-lime-A200: #eeff41;
  --md-lime-A400: #c6ff00;
  --md-lime-A700: #aeea00;
  --md-yellow-50: #fffde7;
  --md-yellow-100: #fff9c4;
  --md-yellow-200: #fff59d;
  --md-yellow-300: #fff176;
  --md-yellow-400: #ffee58;
  --md-yellow-500: #ffeb3b;
  --md-yellow-600: #fdd835;
  --md-yellow-700: #fbc02d;
  --md-yellow-800: #f9a825;
  --md-yellow-900: #f57f17;
  --md-yellow-A100: #ffff8d;
  --md-yellow-A200: #ff0;
  --md-yellow-A400: #ffea00;
  --md-yellow-A700: #ffd600;
  --md-amber-50: #fff8e1;
  --md-amber-100: #ffecb3;
  --md-amber-200: #ffe082;
  --md-amber-300: #ffd54f;
  --md-amber-400: #ffca28;
  --md-amber-500: #ffc107;
  --md-amber-600: #ffb300;
  --md-amber-700: #ffa000;
  --md-amber-800: #ff8f00;
  --md-amber-900: #ff6f00;
  --md-amber-A100: #ffe57f;
  --md-amber-A200: #ffd740;
  --md-amber-A400: #ffc400;
  --md-amber-A700: #ffab00;
  --md-orange-50: #fff3e0;
  --md-orange-100: #ffe0b2;
  --md-orange-200: #ffcc80;
  --md-orange-300: #ffb74d;
  --md-orange-400: #ffa726;
  --md-orange-500: #ff9800;
  --md-orange-600: #fb8c00;
  --md-orange-700: #f57c00;
  --md-orange-800: #ef6c00;
  --md-orange-900: #e65100;
  --md-orange-A100: #ffd180;
  --md-orange-A200: #ffab40;
  --md-orange-A400: #ff9100;
  --md-orange-A700: #ff6d00;
  --md-deep-orange-50: #fbe9e7;
  --md-deep-orange-100: #ffccbc;
  --md-deep-orange-200: #ffab91;
  --md-deep-orange-300: #ff8a65;
  --md-deep-orange-400: #ff7043;
  --md-deep-orange-500: #ff5722;
  --md-deep-orange-600: #f4511e;
  --md-deep-orange-700: #e64a19;
  --md-deep-orange-800: #d84315;
  --md-deep-orange-900: #bf360c;
  --md-deep-orange-A100: #ff9e80;
  --md-deep-orange-A200: #ff6e40;
  --md-deep-orange-A400: #ff3d00;
  --md-deep-orange-A700: #dd2c00;
  --md-brown-50: #efebe9;
  --md-brown-100: #d7ccc8;
  --md-brown-200: #bcaaa4;
  --md-brown-300: #a1887f;
  --md-brown-400: #8d6e63;
  --md-brown-500: #795548;
  --md-brown-600: #6d4c41;
  --md-brown-700: #5d4037;
  --md-brown-800: #4e342e;
  --md-brown-900: #3e2723;
  --md-grey-50: #fafafa;
  --md-grey-100: #f5f5f5;
  --md-grey-200: #eee;
  --md-grey-300: #e0e0e0;
  --md-grey-400: #bdbdbd;
  --md-grey-500: #9e9e9e;
  --md-grey-600: #757575;
  --md-grey-700: #616161;
  --md-grey-800: #424242;
  --md-grey-900: #212121;
  --md-blue-grey-50: #eceff1;
  --md-blue-grey-100: #cfd8dc;
  --md-blue-grey-200: #b0bec5;
  --md-blue-grey-300: #90a4ae;
  --md-blue-grey-400: #78909c;
  --md-blue-grey-500: #607d8b;
  --md-blue-grey-600: #546e7a;
  --md-blue-grey-700: #455a64;
  --md-blue-grey-800: #37474f;
  --md-blue-grey-900: #263238;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| RenderedText
|----------------------------------------------------------------------------*/

:root {
  /* This is the padding value to fill the gaps between lines containing spans with background color. */
  --jp-private-code-span-padding: calc(
    (var(--jp-code-line-height) - 1) * var(--jp-code-font-size) / 2
  );
}

.jp-RenderedText {
  text-align: left;
  padding-left: var(--jp-code-padding);
  line-height: var(--jp-code-line-height);
  font-family: var(--jp-code-font-family);
}

.jp-RenderedText pre,
.jp-RenderedJavaScript pre,
.jp-RenderedHTMLCommon pre {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-code-font-size);
  border: none;
  margin: 0;
  padding: 0;
}

.jp-RenderedText pre a:link {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

.jp-RenderedText pre a:hover {
  text-decoration: underline;
  color: var(--jp-content-link-color);
}

.jp-RenderedText pre a:visited {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

/* console foregrounds and backgrounds */
.jp-RenderedText pre .ansi-black-fg {
  color: #3e424d;
}

.jp-RenderedText pre .ansi-red-fg {
  color: #e75c58;
}

.jp-RenderedText pre .ansi-green-fg {
  color: #00a250;
}

.jp-RenderedText pre .ansi-yellow-fg {
  color: #ddb62b;
}

.jp-RenderedText pre .ansi-blue-fg {
  color: #208ffb;
}

.jp-RenderedText pre .ansi-magenta-fg {
  color: #d160c4;
}

.jp-RenderedText pre .ansi-cyan-fg {
  color: #60c6c8;
}

.jp-RenderedText pre .ansi-white-fg {
  color: #c5c1b4;
}

.jp-RenderedText pre .ansi-black-bg {
  background-color: #3e424d;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-red-bg {
  background-color: #e75c58;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-green-bg {
  background-color: #00a250;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-yellow-bg {
  background-color: #ddb62b;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-blue-bg {
  background-color: #208ffb;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-magenta-bg {
  background-color: #d160c4;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-cyan-bg {
  background-color: #60c6c8;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-white-bg {
  background-color: #c5c1b4;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-black-intense-fg {
  color: #282c36;
}

.jp-RenderedText pre .ansi-red-intense-fg {
  color: #b22b31;
}

.jp-RenderedText pre .ansi-green-intense-fg {
  color: #007427;
}

.jp-RenderedText pre .ansi-yellow-intense-fg {
  color: #b27d12;
}

.jp-RenderedText pre .ansi-blue-intense-fg {
  color: #0065ca;
}

.jp-RenderedText pre .ansi-magenta-intense-fg {
  color: #a03196;
}

.jp-RenderedText pre .ansi-cyan-intense-fg {
  color: #258f8f;
}

.jp-RenderedText pre .ansi-white-intense-fg {
  color: #a1a6b2;
}

.jp-RenderedText pre .ansi-black-intense-bg {
  background-color: #282c36;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-red-intense-bg {
  background-color: #b22b31;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-green-intense-bg {
  background-color: #007427;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-yellow-intense-bg {
  background-color: #b27d12;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-blue-intense-bg {
  background-color: #0065ca;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-magenta-intense-bg {
  background-color: #a03196;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-cyan-intense-bg {
  background-color: #258f8f;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-white-intense-bg {
  background-color: #a1a6b2;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-default-inverse-fg {
  color: var(--jp-ui-inverse-font-color0);
}

.jp-RenderedText pre .ansi-default-inverse-bg {
  background-color: var(--jp-inverse-layout-color0);
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-bold {
  font-weight: bold;
}

.jp-RenderedText pre .ansi-underline {
  text-decoration: underline;
}

.jp-RenderedText[data-mime-type='application/vnd.jupyter.stderr'] {
  background: var(--jp-rendermime-error-background);
  padding-top: var(--jp-code-padding);
}

/*-----------------------------------------------------------------------------
| RenderedLatex
|----------------------------------------------------------------------------*/

.jp-RenderedLatex {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-content-font-size1);
  line-height: var(--jp-content-line-height);
}

/* Left-justify outputs.*/
.jp-OutputArea-output.jp-RenderedLatex {
  padding: var(--jp-code-padding);
  text-align: left;
}

/*-----------------------------------------------------------------------------
| RenderedHTML
|----------------------------------------------------------------------------*/

.jp-RenderedHTMLCommon {
  color: var(--jp-content-font-color1);
  font-family: var(--jp-content-font-family);
  font-size: var(--jp-content-font-size1);
  line-height: var(--jp-content-line-height);

  /* Give a bit more R padding on Markdown text to keep line lengths reasonable */
  padding-right: 20px;
}

.jp-RenderedHTMLCommon em {
  font-style: italic;
}

.jp-RenderedHTMLCommon strong {
  font-weight: bold;
}

.jp-RenderedHTMLCommon u {
  text-decoration: underline;
}

.jp-RenderedHTMLCommon a:link {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

.jp-RenderedHTMLCommon a:hover {
  text-decoration: underline;
  color: var(--jp-content-link-color);
}

.jp-RenderedHTMLCommon a:visited {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

/* Headings */

.jp-RenderedHTMLCommon h1,
.jp-RenderedHTMLCommon h2,
.jp-RenderedHTMLCommon h3,
.jp-RenderedHTMLCommon h4,
.jp-RenderedHTMLCommon h5,
.jp-RenderedHTMLCommon h6 {
  line-height: var(--jp-content-heading-line-height);
  font-weight: var(--jp-content-heading-font-weight);
  font-style: normal;
  margin: var(--jp-content-heading-margin-top) 0
    var(--jp-content-heading-margin-bottom) 0;
}

.jp-RenderedHTMLCommon h1:first-child,
.jp-RenderedHTMLCommon h2:first-child,
.jp-RenderedHTMLCommon h3:first-child,
.jp-RenderedHTMLCommon h4:first-child,
.jp-RenderedHTMLCommon h5:first-child,
.jp-RenderedHTMLCommon h6:first-child {
  margin-top: calc(0.5 * var(--jp-content-heading-margin-top));
}

.jp-RenderedHTMLCommon h1:last-child,
.jp-RenderedHTMLCommon h2:last-child,
.jp-RenderedHTMLCommon h3:last-child,
.jp-RenderedHTMLCommon h4:last-child,
.jp-RenderedHTMLCommon h5:last-child,
.jp-RenderedHTMLCommon h6:last-child {
  margin-bottom: calc(0.5 * var(--jp-content-heading-margin-bottom));
}

.jp-RenderedHTMLCommon h1 {
  font-size: var(--jp-content-font-size5);
}

.jp-RenderedHTMLCommon h2 {
  font-size: var(--jp-content-font-size4);
}

.jp-RenderedHTMLCommon h3 {
  font-size: var(--jp-content-font-size3);
}

.jp-RenderedHTMLCommon h4 {
  font-size: var(--jp-content-font-size2);
}

.jp-RenderedHTMLCommon h5 {
  font-size: var(--jp-content-font-size1);
}

.jp-RenderedHTMLCommon h6 {
  font-size: var(--jp-content-font-size0);
}

/* Lists */

/* stylelint-disable selector-max-type, selector-max-compound-selectors */

.jp-RenderedHTMLCommon ul:not(.list-inline),
.jp-RenderedHTMLCommon ol:not(.list-inline) {
  padding-left: 2em;
}

.jp-RenderedHTMLCommon ul {
  list-style: disc;
}

.jp-RenderedHTMLCommon ul ul {
  list-style: square;
}

.jp-RenderedHTMLCommon ul ul ul {
  list-style: circle;
}

.jp-RenderedHTMLCommon ol {
  list-style: decimal;
}

.jp-RenderedHTMLCommon ol ol {
  list-style: upper-alpha;
}

.jp-RenderedHTMLCommon ol ol ol {
  list-style: lower-alpha;
}

.jp-RenderedHTMLCommon ol ol ol ol {
  list-style: lower-roman;
}

.jp-RenderedHTMLCommon ol ol ol ol ol {
  list-style: decimal;
}

.jp-RenderedHTMLCommon ol,
.jp-RenderedHTMLCommon ul {
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon ul ul,
.jp-RenderedHTMLCommon ul ol,
.jp-RenderedHTMLCommon ol ul,
.jp-RenderedHTMLCommon ol ol {
  margin-bottom: 0;
}

/* stylelint-enable selector-max-type, selector-max-compound-selectors */

.jp-RenderedHTMLCommon hr {
  color: var(--jp-border-color2);
  background-color: var(--jp-border-color1);
  margin-top: 1em;
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon > pre {
  margin: 1.5em 2em;
}

.jp-RenderedHTMLCommon pre,
.jp-RenderedHTMLCommon code {
  border: 0;
  background-color: var(--jp-layout-color0);
  color: var(--jp-content-font-color1);
  font-family: var(--jp-code-font-family);
  font-size: inherit;
  line-height: var(--jp-code-line-height);
  padding: 0;
  white-space: pre-wrap;
}

.jp-RenderedHTMLCommon :not(pre) > code {
  background-color: var(--jp-layout-color2);
  padding: 1px 5px;
}

/* Tables */

.jp-RenderedHTMLCommon table {
  border-collapse: collapse;
  border-spacing: 0;
  border: none;
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  table-layout: fixed;
  margin-left: auto;
  margin-bottom: 1em;
  margin-right: auto;
}

.jp-RenderedHTMLCommon thead {
  border-bottom: var(--jp-border-width) solid var(--jp-border-color1);
  vertical-align: bottom;
}

.jp-RenderedHTMLCommon td,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon tr {
  vertical-align: middle;
  padding: 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}

.jp-RenderedMarkdown.jp-RenderedHTMLCommon td,
.jp-RenderedMarkdown.jp-RenderedHTMLCommon th {
  max-width: none;
}

:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon td,
:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon th,
:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon tr {
  text-align: right;
}

.jp-RenderedHTMLCommon th {
  font-weight: bold;
}

.jp-RenderedHTMLCommon tbody tr:nth-child(odd) {
  background: var(--jp-layout-color0);
}

.jp-RenderedHTMLCommon tbody tr:nth-child(even) {
  background: var(--jp-rendermime-table-row-background);
}

.jp-RenderedHTMLCommon tbody tr:hover {
  background: var(--jp-rendermime-table-row-hover-background);
}

.jp-RenderedHTMLCommon p {
  text-align: left;
  margin: 0;
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon img {
  -moz-force-broken-image-icon: 1;
}

/* Restrict to direct children as other images could be nested in other content. */
.jp-RenderedHTMLCommon > img {
  display: block;
  margin-left: 0;
  margin-right: 0;
  margin-bottom: 1em;
}

/* Change color behind transparent images if they need it... */
[data-jp-theme-light='false'] .jp-RenderedImage img.jp-needs-light-background {
  background-color: var(--jp-inverse-layout-color1);
}

[data-jp-theme-light='true'] .jp-RenderedImage img.jp-needs-dark-background {
  background-color: var(--jp-inverse-layout-color1);
}

.jp-RenderedHTMLCommon img,
.jp-RenderedImage img,
.jp-RenderedHTMLCommon svg,
.jp-RenderedSVG svg {
  max-width: 100%;
  height: auto;
}

.jp-RenderedHTMLCommon img.jp-mod-unconfined,
.jp-RenderedImage img.jp-mod-unconfined,
.jp-RenderedHTMLCommon svg.jp-mod-unconfined,
.jp-RenderedSVG svg.jp-mod-unconfined {
  max-width: none;
}

.jp-RenderedHTMLCommon .alert {
  padding: var(--jp-notebook-padding);
  border: var(--jp-border-width) solid transparent;
  border-radius: var(--jp-border-radius);
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon .alert-info {
  color: var(--jp-info-color0);
  background-color: var(--jp-info-color3);
  border-color: var(--jp-info-color2);
}

.jp-RenderedHTMLCommon .alert-info hr {
  border-color: var(--jp-info-color3);
}

.jp-RenderedHTMLCommon .alert-info > p:last-child,
.jp-RenderedHTMLCommon .alert-info > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-warning {
  color: var(--jp-warn-color0);
  background-color: var(--jp-warn-color3);
  border-color: var(--jp-warn-color2);
}

.jp-RenderedHTMLCommon .alert-warning hr {
  border-color: var(--jp-warn-color3);
}

.jp-RenderedHTMLCommon .alert-warning > p:last-child,
.jp-RenderedHTMLCommon .alert-warning > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-success {
  color: var(--jp-success-color0);
  background-color: var(--jp-success-color3);
  border-color: var(--jp-success-color2);
}

.jp-RenderedHTMLCommon .alert-success hr {
  border-color: var(--jp-success-color3);
}

.jp-RenderedHTMLCommon .alert-success > p:last-child,
.jp-RenderedHTMLCommon .alert-success > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-danger {
  color: var(--jp-error-color0);
  background-color: var(--jp-error-color3);
  border-color: var(--jp-error-color2);
}

.jp-RenderedHTMLCommon .alert-danger hr {
  border-color: var(--jp-error-color3);
}

.jp-RenderedHTMLCommon .alert-danger > p:last-child,
.jp-RenderedHTMLCommon .alert-danger > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon blockquote {
  margin: 1em 2em;
  padding: 0 1em;
  border-left: 5px solid var(--jp-border-color2);
}

a.jp-InternalAnchorLink {
  visibility: hidden;
  margin-left: 8px;
  color: var(--md-blue-800);
}

h1:hover .jp-InternalAnchorLink,
h2:hover .jp-InternalAnchorLink,
h3:hover .jp-InternalAnchorLink,
h4:hover .jp-InternalAnchorLink,
h5:hover .jp-InternalAnchorLink,
h6:hover .jp-InternalAnchorLink {
  visibility: visible;
}

.jp-RenderedHTMLCommon kbd {
  background-color: var(--jp-rendermime-table-row-background);
  border: 1px solid var(--jp-border-color0);
  border-bottom-color: var(--jp-border-color2);
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.25);
  display: inline-block;
  font-size: var(--jp-ui-font-size0);
  line-height: 1em;
  padding: 0.2em 0.5em;
}

/* Most direct children of .jp-RenderedHTMLCommon have a margin-bottom of 1.0.
 * At the bottom of cells this is a bit too much as there is also spacing
 * between cells. Going all the way to 0 gets too tight between markdown and
 * code cells.
 */
.jp-RenderedHTMLCommon > *:last-child {
  margin-bottom: 0.5em;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-cursor-backdrop {
  position: fixed;
  width: 200px;
  height: 200px;
  margin-top: -100px;
  margin-left: -100px;
  will-change: transform;
  z-index: 100;
}

.lm-mod-drag-image {
  will-change: transform;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-lineFormSearch {
  padding: 4px 12px;
  background-color: var(--jp-layout-color2);
  box-shadow: var(--jp-toolbar-box-shadow);
  z-index: 2;
  font-size: var(--jp-ui-font-size1);
}

.jp-lineFormCaption {
  font-size: var(--jp-ui-font-size0);
  line-height: var(--jp-ui-font-size1);
  margin-top: 4px;
  color: var(--jp-ui-font-color0);
}

.jp-baseLineForm {
  border: none;
  border-radius: 0;
  position: absolute;
  background-size: 16px;
  background-repeat: no-repeat;
  background-position: center;
  outline: none;
}

.jp-lineFormButtonContainer {
  top: 4px;
  right: 8px;
  height: 24px;
  padding: 0 12px;
  width: 12px;
}

.jp-lineFormButtonIcon {
  top: 0;
  right: 0;
  background-color: var(--jp-brand-color1);
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  padding: 4px 6px;
}

.jp-lineFormButton {
  top: 0;
  right: 0;
  background-color: transparent;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
}

.jp-lineFormWrapper {
  overflow: hidden;
  padding: 0 8px;
  border: 1px solid var(--jp-border-color0);
  background-color: var(--jp-input-active-background);
  height: 22px;
}

.jp-lineFormWrapperFocusWithin {
  border: var(--jp-border-width) solid var(--md-blue-500);
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-lineFormInput {
  background: transparent;
  width: 200px;
  height: 100%;
  border: none;
  outline: none;
  color: var(--jp-ui-font-color0);
  line-height: 28px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-JSONEditor {
  display: flex;
  flex-direction: column;
  width: 100%;
}

.jp-JSONEditor-host {
  flex: 1 1 auto;
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  border-radius: 0;
  background: var(--jp-layout-color0);
  min-height: 50px;
  padding: 1px;
}

.jp-JSONEditor.jp-mod-error .jp-JSONEditor-host {
  border-color: red;
  outline-color: red;
}

.jp-JSONEditor-header {
  display: flex;
  flex: 1 0 auto;
  padding: 0 0 0 12px;
}

.jp-JSONEditor-header label {
  flex: 0 0 auto;
}

.jp-JSONEditor-commitButton {
  height: 16px;
  width: 16px;
  background-size: 18px;
  background-repeat: no-repeat;
  background-position: center;
}

.jp-JSONEditor-host.jp-mod-focused {
  background-color: var(--jp-input-active-background);
  border: 1px solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
}

.jp-Editor.jp-mod-dropTarget {
  border: var(--jp-border-width) solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
.jp-DocumentSearch-input {
  border: none;
  outline: none;
  color: var(--jp-ui-font-color0);
  font-size: var(--jp-ui-font-size1);
  background-color: var(--jp-layout-color0);
  font-family: var(--jp-ui-font-family);
  padding: 2px 1px;
  resize: none;
}

.jp-DocumentSearch-overlay {
  position: absolute;
  background-color: var(--jp-toolbar-background);
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  border-left: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  top: 0;
  right: 0;
  z-index: 7;
  min-width: 405px;
  padding: 2px;
  font-size: var(--jp-ui-font-size1);

  --jp-private-document-search-button-height: 20px;
}

.jp-DocumentSearch-overlay button {
  background-color: var(--jp-toolbar-background);
  outline: 0;
}

.jp-DocumentSearch-overlay button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-overlay button:active {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-overlay-row {
  display: flex;
  align-items: center;
  margin-bottom: 2px;
}

.jp-DocumentSearch-button-content {
  display: inline-block;
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-button-content svg {
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-input-wrapper {
  border: var(--jp-border-width) solid var(--jp-border-color0);
  display: flex;
  background-color: var(--jp-layout-color0);
  margin: 2px;
}

.jp-DocumentSearch-input-wrapper:focus-within {
  border-color: var(--jp-cell-editor-active-border-color);
}

.jp-DocumentSearch-toggle-wrapper,
.jp-DocumentSearch-button-wrapper {
  all: initial;
  overflow: hidden;
  display: inline-block;
  border: none;
  box-sizing: border-box;
}

.jp-DocumentSearch-toggle-wrapper {
  width: 14px;
  height: 14px;
}

.jp-DocumentSearch-button-wrapper {
  width: var(--jp-private-document-search-button-height);
  height: var(--jp-private-document-search-button-height);
}

.jp-DocumentSearch-toggle-wrapper:focus,
.jp-DocumentSearch-button-wrapper:focus {
  outline: var(--jp-border-width) solid
    var(--jp-cell-editor-active-border-color);
  outline-offset: -1px;
}

.jp-DocumentSearch-toggle-wrapper,
.jp-DocumentSearch-button-wrapper,
.jp-DocumentSearch-button-content:focus {
  outline: none;
}

.jp-DocumentSearch-toggle-placeholder {
  width: 5px;
}

.jp-DocumentSearch-input-button::before {
  display: block;
  padding-top: 100%;
}

.jp-DocumentSearch-input-button-off {
  opacity: var(--jp-search-toggle-off-opacity);
}

.jp-DocumentSearch-input-button-off:hover {
  opacity: var(--jp-search-toggle-hover-opacity);
}

.jp-DocumentSearch-input-button-on {
  opacity: var(--jp-search-toggle-on-opacity);
}

.jp-DocumentSearch-index-counter {
  padding-left: 10px;
  padding-right: 10px;
  user-select: none;
  min-width: 35px;
  display: inline-block;
}

.jp-DocumentSearch-up-down-wrapper {
  display: inline-block;
  padding-right: 2px;
  margin-left: auto;
  white-space: nowrap;
}

.jp-DocumentSearch-spacer {
  margin-left: auto;
}

.jp-DocumentSearch-up-down-wrapper button {
  outline: 0;
  border: none;
  width: var(--jp-private-document-search-button-height);
  height: var(--jp-private-document-search-button-height);
  vertical-align: middle;
  margin: 1px 5px 2px;
}

.jp-DocumentSearch-up-down-button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-up-down-button:active {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-filter-button {
  border-radius: var(--jp-border-radius);
}

.jp-DocumentSearch-filter-button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-filter-button-enabled {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-filter-button-enabled:hover {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-search-options {
  padding: 0 8px;
  margin-left: 3px;
  width: 100%;
  display: grid;
  justify-content: start;
  grid-template-columns: 1fr 1fr;
  align-items: center;
  justify-items: stretch;
}

.jp-DocumentSearch-search-filter-disabled {
  color: var(--jp-ui-font-color2);
}

.jp-DocumentSearch-search-filter {
  display: flex;
  align-items: center;
  user-select: none;
}

.jp-DocumentSearch-regex-error {
  color: var(--jp-error-color0);
}

.jp-DocumentSearch-replace-button-wrapper {
  overflow: hidden;
  display: inline-block;
  box-sizing: border-box;
  border: var(--jp-border-width) solid var(--jp-border-color0);
  margin: auto 2px;
  padding: 1px 4px;
  height: calc(var(--jp-private-document-search-button-height) + 2px);
}

.jp-DocumentSearch-replace-button-wrapper:focus {
  border: var(--jp-border-width) solid var(--jp-cell-editor-active-border-color);
}

.jp-DocumentSearch-replace-button {
  display: inline-block;
  text-align: center;
  cursor: pointer;
  box-sizing: border-box;
  color: var(--jp-ui-font-color1);

  /* height - 2 * (padding of wrapper) */
  line-height: calc(var(--jp-private-document-search-button-height) - 2px);
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-replace-button:focus {
  outline: none;
}

.jp-DocumentSearch-replace-wrapper-class {
  margin-left: 14px;
  display: flex;
}

.jp-DocumentSearch-replace-toggle {
  border: none;
  background-color: var(--jp-toolbar-background);
  border-radius: var(--jp-border-radius);
}

.jp-DocumentSearch-replace-toggle:hover {
  background-color: var(--jp-layout-color2);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.cm-editor {
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  font-family: var(--jp-code-font-family);
  border: 0;
  border-radius: 0;
  height: auto;

  /* Changed to auto to autogrow */
}

.cm-editor pre {
  padding: 0 var(--jp-code-padding);
}

.jp-CodeMirrorEditor[data-type='inline'] .cm-dialog {
  background-color: var(--jp-layout-color0);
  color: var(--jp-content-font-color1);
}

.jp-CodeMirrorEditor {
  cursor: text;
}

/* When zoomed out 67% and 33% on a screen of 1440 width x 900 height */
@media screen and (min-width: 2138px) and (max-width: 4319px) {
  .jp-CodeMirrorEditor[data-type='inline'] .cm-cursor {
    border-left: var(--jp-code-cursor-width1) solid
      var(--jp-editor-cursor-color);
  }
}

/* When zoomed out less than 33% */
@media screen and (min-width: 4320px) {
  .jp-CodeMirrorEditor[data-type='inline'] .cm-cursor {
    border-left: var(--jp-code-cursor-width2) solid
      var(--jp-editor-cursor-color);
  }
}

.cm-editor.jp-mod-readOnly .cm-cursor {
  display: none;
}

.jp-CollaboratorCursor {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: none;
  border-bottom: 3px solid;
  background-clip: content-box;
  margin-left: -5px;
  margin-right: -5px;
}

.cm-searching,
.cm-searching span {
  /* `.cm-searching span`: we need to override syntax highlighting */
  background-color: var(--jp-search-unselected-match-background-color);
  color: var(--jp-search-unselected-match-color);
}

.cm-searching::selection,
.cm-searching span::selection {
  background-color: var(--jp-search-unselected-match-background-color);
  color: var(--jp-search-unselected-match-color);
}

.jp-current-match > .cm-searching,
.jp-current-match > .cm-searching span,
.cm-searching > .jp-current-match,
.cm-searching > .jp-current-match span {
  background-color: var(--jp-search-selected-match-background-color);
  color: var(--jp-search-selected-match-color);
}

.jp-current-match > .cm-searching::selection,
.cm-searching > .jp-current-match::selection,
.jp-current-match > .cm-searching span::selection {
  background-color: var(--jp-search-selected-match-background-color);
  color: var(--jp-search-selected-match-color);
}

.cm-trailingspace {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAsElEQVQIHQGlAFr/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7+r3zKmT0/+pk9P/7+r3zAAAAAAAAAAABAAAAAAAAAAA6OPzM+/q9wAAAAAA6OPzMwAAAAAAAAAAAgAAAAAAAAAAGR8NiRQaCgAZIA0AGR8NiQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQyoYJ/SY80UAAAAASUVORK5CYII=);
  background-position: center left;
  background-repeat: repeat-x;
}

.jp-CollaboratorCursor-hover {
  position: absolute;
  z-index: 1;
  transform: translateX(-50%);
  color: white;
  border-radius: 3px;
  padding-left: 4px;
  padding-right: 4px;
  padding-top: 1px;
  padding-bottom: 1px;
  text-align: center;
  font-size: var(--jp-ui-font-size1);
  white-space: nowrap;
}

.jp-CodeMirror-ruler {
  border-left: 1px dashed var(--jp-border-color2);
}

/* Styles for shared cursors (remote cursor locations and selected ranges) */
.jp-CodeMirrorEditor .cm-ySelectionCaret {
  position: relative;
  border-left: 1px solid black;
  margin-left: -1px;
  margin-right: -1px;
  box-sizing: border-box;
}

.jp-CodeMirrorEditor .cm-ySelectionCaret > .cm-ySelectionInfo {
  white-space: nowrap;
  position: absolute;
  top: -1.15em;
  padding-bottom: 0.05em;
  left: -1px;
  font-size: 0.95em;
  font-family: var(--jp-ui-font-family);
  font-weight: bold;
  line-height: normal;
  user-select: none;
  color: white;
  padding-left: 2px;
  padding-right: 2px;
  z-index: 101;
  transition: opacity 0.3s ease-in-out;
}

.jp-CodeMirrorEditor .cm-ySelectionInfo {
  transition-delay: 0.7s;
  opacity: 0;
}

.jp-CodeMirrorEditor .cm-ySelectionCaret:hover > .cm-ySelectionInfo {
  opacity: 1;
  transition-delay: 0s;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-MimeDocument {
  outline: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-filebrowser-button-height: 28px;
  --jp-private-filebrowser-button-width: 48px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-FileBrowser .jp-SidePanel-content {
  display: flex;
  flex-direction: column;
}

.jp-FileBrowser-toolbar.jp-Toolbar {
  flex-wrap: wrap;
  row-gap: 12px;
  border-bottom: none;
  height: auto;
  margin: 8px 12px 0;
  box-shadow: none;
  padding: 0;
  justify-content: flex-start;
}

.jp-FileBrowser-Panel {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
}

.jp-BreadCrumbs {
  flex: 0 0 auto;
  margin: 8px 12px;
}

.jp-BreadCrumbs-item {
  margin: 0 2px;
  padding: 0 2px;
  border-radius: var(--jp-border-radius);
  cursor: pointer;
}

.jp-BreadCrumbs-item:hover {
  background-color: var(--jp-layout-color2);
}

.jp-BreadCrumbs-item:first-child {
  margin-left: 0;
}

.jp-BreadCrumbs-item.jp-mod-dropTarget {
  background-color: var(--jp-brand-color2);
  opacity: 0.7;
}

/*-----------------------------------------------------------------------------
| Buttons
|----------------------------------------------------------------------------*/

.jp-FileBrowser-toolbar > .jp-Toolbar-item {
  flex: 0 0 auto;
  padding-left: 0;
  padding-right: 2px;
  align-items: center;
  height: unset;
}

.jp-FileBrowser-toolbar > .jp-Toolbar-item .jp-ToolbarButtonComponent {
  width: 40px;
}

/*-----------------------------------------------------------------------------
| Other styles
|----------------------------------------------------------------------------*/

.jp-FileDialog.jp-mod-conflict input {
  color: var(--jp-error-color1);
}

.jp-FileDialog .jp-new-name-title {
  margin-top: 12px;
}

.jp-LastModified-hidden {
  display: none;
}

.jp-FileSize-hidden {
  display: none;
}

.jp-FileBrowser .lm-AccordionPanel > h3:first-child {
  display: none;
}

/*-----------------------------------------------------------------------------
| DirListing
|----------------------------------------------------------------------------*/

.jp-DirListing {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  outline: 0;
}

.jp-DirListing-header {
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
  align-items: center;
  overflow: hidden;
  border-top: var(--jp-border-width) solid var(--jp-border-color2);
  border-bottom: var(--jp-border-width) solid var(--jp-border-color1);
  box-shadow: var(--jp-toolbar-box-shadow);
  z-index: 2;
}

.jp-DirListing-headerItem {
  padding: 4px 12px 2px;
  font-weight: 500;
}

.jp-DirListing-headerItem:hover {
  background: var(--jp-layout-color2);
}

.jp-DirListing-headerItem.jp-id-name {
  flex: 1 0 84px;
}

.jp-DirListing-headerItem.jp-id-modified {
  flex: 0 0 112px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
}

.jp-DirListing-headerItem.jp-id-filesize {
  flex: 0 0 75px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
}

.jp-id-narrow {
  display: none;
  flex: 0 0 5px;
  padding: 4px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
  color: var(--jp-border-color2);
}

.jp-DirListing-narrow .jp-id-narrow {
  display: block;
}

.jp-DirListing-narrow .jp-id-modified,
.jp-DirListing-narrow .jp-DirListing-itemModified {
  display: none;
}

.jp-DirListing-headerItem.jp-mod-selected {
  font-weight: 600;
}

/* increase specificity to override bundled default */
.jp-DirListing-content {
  flex: 1 1 auto;
  margin: 0;
  padding: 0;
  list-style-type: none;
  overflow: auto;
  background-color: var(--jp-layout-color1);
}

.jp-DirListing-content mark {
  color: var(--jp-ui-font-color0);
  background-color: transparent;
  font-weight: bold;
}

.jp-DirListing-content .jp-DirListing-item.jp-mod-selected mark {
  color: var(--jp-ui-inverse-font-color0);
}

/* Style the directory listing content when a user drops a file to upload */
.jp-DirListing.jp-mod-native-drop .jp-DirListing-content {
  outline: 5px dashed rgba(128, 128, 128, 0.5);
  outline-offset: -10px;
  cursor: copy;
}

.jp-DirListing-item {
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 4px 12px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-DirListing-checkboxWrapper {
  /* Increases hit area of checkbox. */
  padding: 4px;
}

.jp-DirListing-header
  .jp-DirListing-checkboxWrapper
  + .jp-DirListing-headerItem {
  padding-left: 4px;
}

.jp-DirListing-content .jp-DirListing-checkboxWrapper {
  position: relative;
  left: -4px;
  margin: -4px 0 -4px -8px;
}

.jp-DirListing-checkboxWrapper.jp-mod-visible {
  visibility: visible;
}

/* For devices that support hovering, hide checkboxes until hovered, selected...
*/
@media (hover: hover) {
  .jp-DirListing-checkboxWrapper {
    visibility: hidden;
  }

  .jp-DirListing-item:hover .jp-DirListing-checkboxWrapper,
  .jp-DirListing-item.jp-mod-selected .jp-DirListing-checkboxWrapper {
    visibility: visible;
  }
}

.jp-DirListing-item[data-is-dot] {
  opacity: 75%;
}

.jp-DirListing-item.jp-mod-selected {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.jp-DirListing-item.jp-mod-dropTarget {
  background: var(--jp-brand-color3);
}

.jp-DirListing-item:hover:not(.jp-mod-selected) {
  background: var(--jp-layout-color2);
}

.jp-DirListing-itemIcon {
  flex: 0 0 20px;
  margin-right: 4px;
}

.jp-DirListing-itemText {
  flex: 1 0 64px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  user-select: none;
}

.jp-DirListing-itemText:focus {
  outline-width: 2px;
  outline-color: var(--jp-inverse-layout-color1);
  outline-style: solid;
  outline-offset: 1px;
}

.jp-DirListing-item.jp-mod-selected .jp-DirListing-itemText:focus {
  outline-color: var(--jp-layout-color1);
}

.jp-DirListing-itemModified {
  flex: 0 0 125px;
  text-align: right;
}

.jp-DirListing-itemFileSize {
  flex: 0 0 90px;
  text-align: right;
}

.jp-DirListing-editor {
  flex: 1 0 64px;
  outline: none;
  border: none;
  color: var(--jp-ui-font-color1);
  background-color: var(--jp-layout-color1);
}

.jp-DirListing-item.jp-mod-running .jp-DirListing-itemIcon::before {
  color: var(--jp-success-color1);
  content: '\25CF';
  font-size: 8px;
  position: absolute;
  left: -8px;
}

.jp-DirListing-item.jp-mod-running.jp-mod-selected
  .jp-DirListing-itemIcon::before {
  color: var(--jp-ui-inverse-font-color1);
}

.jp-DirListing-item.lm-mod-drag-image,
.jp-DirListing-item.jp-mod-selected.lm-mod-drag-image {
  font-size: var(--jp-ui-font-size1);
  padding-left: 4px;
  margin-left: 4px;
  width: 160px;
  background-color: var(--jp-ui-inverse-font-color2);
  box-shadow: var(--jp-elevation-z2);
  border-radius: 0;
  color: var(--jp-ui-font-color1);
  transform: translateX(-40%) translateY(-58%);
}

.jp-Document {
  min-width: 120px;
  min-height: 120px;
  outline: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Main OutputArea
| OutputArea has a list of Outputs
|----------------------------------------------------------------------------*/

.jp-OutputArea {
  overflow-y: auto;
}

.jp-OutputArea-child {
  display: table;
  table-layout: fixed;
  width: 100%;
  overflow: hidden;
}

.jp-OutputPrompt {
  width: var(--jp-cell-prompt-width);
  color: var(--jp-cell-outprompt-font-color);
  font-family: var(--jp-cell-prompt-font-family);
  padding: var(--jp-code-padding);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;
  opacity: var(--jp-cell-prompt-opacity);

  /* Right align prompt text, don't wrap to handle large prompt numbers */
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  /* Disable text selection */
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-OutputArea-prompt {
  display: table-cell;
  vertical-align: top;
}

.jp-OutputArea-output {
  display: table-cell;
  width: 100%;
  height: auto;
  overflow: auto;
  user-select: text;
  -moz-user-select: text;
  -webkit-user-select: text;
  -ms-user-select: text;
}

.jp-OutputArea .jp-RenderedText {
  padding-left: 1ch;
}

/**
 * Prompt overlay.
 */

.jp-OutputArea-promptOverlay {
  position: absolute;
  top: 0;
  width: var(--jp-cell-prompt-width);
  height: 100%;
  opacity: 0.5;
}

.jp-OutputArea-promptOverlay:hover {
  background: var(--jp-layout-color2);
  box-shadow: inset 0 0 1px var(--jp-inverse-layout-color0);
  cursor: zoom-out;
}

.jp-mod-outputsScrolled .jp-OutputArea-promptOverlay:hover {
  cursor: zoom-in;
}

/**
 * Isolated output.
 */
.jp-OutputArea-output.jp-mod-isolated {
  width: 100%;
  display: block;
}

/*
When drag events occur, `lm-mod-override-cursor` is added to the body.
Because iframes steal all cursor events, the following two rules are necessary
to suppress pointer events while resize drags are occurring. There may be a
better solution to this problem.
*/
body.lm-mod-override-cursor .jp-OutputArea-output.jp-mod-isolated {
  position: relative;
}

body.lm-mod-override-cursor .jp-OutputArea-output.jp-mod-isolated::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
}

/* pre */

.jp-OutputArea-output pre {
  border: none;
  margin: 0;
  padding: 0;
  overflow-x: auto;
  overflow-y: auto;
  word-break: break-all;
  word-wrap: break-word;
  white-space: pre-wrap;
}

/* tables */

.jp-OutputArea-output.jp-RenderedHTMLCommon table {
  margin-left: 0;
  margin-right: 0;
}

/* description lists */

.jp-OutputArea-output dl,
.jp-OutputArea-output dt,
.jp-OutputArea-output dd {
  display: block;
}

.jp-OutputArea-output dl {
  width: 100%;
  overflow: hidden;
  padding: 0;
  margin: 0;
}

.jp-OutputArea-output dt {
  font-weight: bold;
  float: left;
  width: 20%;
  padding: 0;
  margin: 0;
}

.jp-OutputArea-output dd {
  float: left;
  width: 80%;
  padding: 0;
  margin: 0;
}

.jp-TrimmedOutputs pre {
  background: var(--jp-layout-color3);
  font-size: calc(var(--jp-code-font-size) * 1.4);
  text-align: center;
  text-transform: uppercase;
}

/* Hide the gutter in case of
 *  - nested output areas (e.g. in the case of output widgets)
 *  - mirrored output areas
 */
.jp-OutputArea .jp-OutputArea .jp-OutputArea-prompt {
  display: none;
}

/* Hide empty lines in the output area, for instance due to cleared widgets */
.jp-OutputArea-prompt:empty {
  padding: 0;
  border: 0;
}

/*-----------------------------------------------------------------------------
| executeResult is added to any Output-result for the display of the object
| returned by a cell
|----------------------------------------------------------------------------*/

.jp-OutputArea-output.jp-OutputArea-executeResult {
  margin-left: 0;
  width: 100%;
}

/* Text output with the Out[] prompt needs a top padding to match the
 * alignment of the Out[] prompt itself.
 */
.jp-OutputArea-executeResult .jp-RenderedText.jp-OutputArea-output {
  padding-top: var(--jp-code-padding);
  border-top: var(--jp-border-width) solid transparent;
}

/*-----------------------------------------------------------------------------
| The Stdin output
|----------------------------------------------------------------------------*/

.jp-Stdin-prompt {
  color: var(--jp-content-font-color0);
  padding-right: var(--jp-code-padding);
  vertical-align: baseline;
  flex: 0 0 auto;
}

.jp-Stdin-input {
  font-family: var(--jp-code-font-family);
  font-size: inherit;
  color: inherit;
  background-color: inherit;
  width: 42%;
  min-width: 200px;

  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;

  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0 0.25em;
  margin: 0 0.25em;
  flex: 0 0 70%;
}

.jp-Stdin-input::placeholder {
  opacity: 0;
}

.jp-Stdin-input:focus {
  box-shadow: none;
}

.jp-Stdin-input:focus::placeholder {
  opacity: 1;
}

/*-----------------------------------------------------------------------------
| Output Area View
|----------------------------------------------------------------------------*/

.jp-LinkedOutputView .jp-OutputArea {
  height: 100%;
  display: block;
}

.jp-LinkedOutputView .jp-OutputArea-output:only-child {
  height: 100%;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

@media print {
  .jp-OutputArea-child {
    break-inside: avoid-page;
  }
}

/*-----------------------------------------------------------------------------
| Mobile
|----------------------------------------------------------------------------*/
@media only screen and (max-width: 760px) {
  .jp-OutputPrompt {
    display: table-row;
    text-align: left;
  }

  .jp-OutputArea-child .jp-OutputArea-output {
    display: table-row;
    margin-left: var(--jp-notebook-padding);
  }
}

/* Trimmed outputs warning */
.jp-TrimmedOutputs > a {
  margin: 10px;
  text-decoration: none;
  cursor: pointer;
}

.jp-TrimmedOutputs > a:hover {
  text-decoration: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Table of Contents
|----------------------------------------------------------------------------*/

:root {
  --jp-private-toc-active-width: 4px;
}

.jp-TableOfContents {
  display: flex;
  flex-direction: column;
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  height: 100%;
}

.jp-TableOfContents-placeholder {
  text-align: center;
}

.jp-TableOfContents-placeholderContent {
  color: var(--jp-content-font-color2);
  padding: 8px;
}

.jp-TableOfContents-placeholderContent > h3 {
  margin-bottom: var(--jp-content-heading-margin-bottom);
}

.jp-TableOfContents .jp-SidePanel-content {
  overflow-y: auto;
}

.jp-TableOfContents-tree {
  margin: 4px;
}

.jp-TableOfContents ol {
  list-style-type: none;
}

/* stylelint-disable-next-line selector-max-type */
.jp-TableOfContents li > ol {
  /* Align left border with triangle icon center */
  padding-left: 11px;
}

.jp-TableOfContents-content {
  /* left margin for the active heading indicator */
  margin: 0 0 0 var(--jp-private-toc-active-width);
  padding: 0;
  background-color: var(--jp-layout-color1);
}

.jp-tocItem {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-tocItem-heading {
  display: flex;
  cursor: pointer;
}

.jp-tocItem-heading:hover {
  background-color: var(--jp-layout-color2);
}

.jp-tocItem-content {
  display: block;
  padding: 4px 0;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow-x: hidden;
}

.jp-tocItem-collapser {
  height: 20px;
  margin: 2px 2px 0;
  padding: 0;
  background: none;
  border: none;
  cursor: pointer;
}

.jp-tocItem-collapser:hover {
  background-color: var(--jp-layout-color3);
}

/* Active heading indicator */

.jp-tocItem-heading::before {
  content: ' ';
  background: transparent;
  width: var(--jp-private-toc-active-width);
  height: 24px;
  position: absolute;
  left: 0;
  border-radius: var(--jp-border-radius);
}

.jp-tocItem-heading.jp-tocItem-active::before {
  background-color: var(--jp-brand-color1);
}

.jp-tocItem-heading:hover.jp-tocItem-active::before {
  background: var(--jp-brand-color0);
  opacity: 1;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Collapser {
  flex: 0 0 var(--jp-cell-collapser-width);
  padding: 0;
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
  border-radius: var(--jp-border-radius);
  opacity: 1;
}

.jp-Collapser-child {
  display: block;
  width: 100%;
  box-sizing: border-box;

  /* height: 100% doesn't work because the height of its parent is computed from content */
  position: absolute;
  top: 0;
  bottom: 0;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

/*
Hiding collapsers in print mode.

Note: input and output wrappers have "display: block" propery in print mode.
*/

@media print {
  .jp-Collapser {
    display: none;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Header/Footer
|----------------------------------------------------------------------------*/

/* Hidden by zero height by default */
.jp-CellHeader,
.jp-CellFooter {
  height: 0;
  width: 100%;
  padding: 0;
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Input
|----------------------------------------------------------------------------*/

/* All input areas */
.jp-InputArea {
  display: table;
  table-layout: fixed;
  width: 100%;
  overflow: hidden;
}

.jp-InputArea-editor {
  display: table-cell;
  overflow: hidden;
  vertical-align: top;

  /* This is the non-active, default styling */
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  border-radius: 0;
  background: var(--jp-cell-editor-background);
}

.jp-InputPrompt {
  display: table-cell;
  vertical-align: top;
  width: var(--jp-cell-prompt-width);
  color: var(--jp-cell-inprompt-font-color);
  font-family: var(--jp-cell-prompt-font-family);
  padding: var(--jp-code-padding);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  opacity: var(--jp-cell-prompt-opacity);
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;

  /* Right align prompt text, don't wrap to handle large prompt numbers */
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  /* Disable text selection */
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/*-----------------------------------------------------------------------------
| Mobile
|----------------------------------------------------------------------------*/
@media only screen and (max-width: 760px) {
  .jp-InputArea-editor {
    display: table-row;
    margin-left: var(--jp-notebook-padding);
  }

  .jp-InputPrompt {
    display: table-row;
    text-align: left;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Placeholder
|----------------------------------------------------------------------------*/

.jp-Placeholder {
  display: table;
  table-layout: fixed;
  width: 100%;
}

.jp-Placeholder-prompt {
  display: table-cell;
  box-sizing: border-box;
}

.jp-Placeholder-content {
  display: table-cell;
  padding: 4px 6px;
  border: 1px solid transparent;
  border-radius: 0;
  background: none;
  box-sizing: border-box;
  cursor: pointer;
}

.jp-Placeholder-contentContainer {
  display: flex;
}

.jp-Placeholder-content:hover,
.jp-InputPlaceholder > .jp-Placeholder-content:hover {
  border-color: var(--jp-layout-color3);
}

.jp-Placeholder-content .jp-MoreHorizIcon {
  width: 32px;
  height: 16px;
  border: 1px solid transparent;
  border-radius: var(--jp-border-radius);
}

.jp-Placeholder-content .jp-MoreHorizIcon:hover {
  border: 1px solid var(--jp-border-color1);
  box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.25);
  background-color: var(--jp-layout-color0);
}

.jp-PlaceholderText {
  white-space: nowrap;
  overflow-x: hidden;
  color: var(--jp-inverse-layout-color3);
  font-family: var(--jp-code-font-family);
}

.jp-InputPlaceholder > .jp-Placeholder-content {
  border-color: var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Private CSS variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-cell-scrolling-output-offset: 5px;
}

/*-----------------------------------------------------------------------------
| Cell
|----------------------------------------------------------------------------*/

.jp-Cell {
  padding: var(--jp-cell-padding);
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Common input/output
|----------------------------------------------------------------------------*/

.jp-Cell-inputWrapper,
.jp-Cell-outputWrapper {
  display: flex;
  flex-direction: row;
  padding: 0;
  margin: 0;

  /* Added to reveal the box-shadow on the input and output collapsers. */
  overflow: visible;
}

/* Only input/output areas inside cells */
.jp-Cell-inputArea,
.jp-Cell-outputArea {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Collapser
|----------------------------------------------------------------------------*/

/* Make the output collapser disappear when there is not output, but do so
 * in a manner that leaves it in the layout and preserves its width.
 */
.jp-Cell.jp-mod-noOutputs .jp-Cell-outputCollapser {
  border: none !important;
  background: transparent !important;
}

.jp-Cell:not(.jp-mod-noOutputs) .jp-Cell-outputCollapser {
  min-height: var(--jp-cell-collapser-min-height);
}

/*-----------------------------------------------------------------------------
| Output
|----------------------------------------------------------------------------*/

/* Put a space between input and output when there IS output */
.jp-Cell:not(.jp-mod-noOutputs) .jp-Cell-outputWrapper {
  margin-top: 5px;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea {
  overflow-y: auto;
  max-height: 24em;
  margin-left: var(--jp-private-cell-scrolling-output-offset);
  resize: vertical;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea[style*='height'] {
  max-height: unset;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea::after {
  content: ' ';
  box-shadow: inset 0 0 6px 2px rgb(0 0 0 / 30%);
  width: 100%;
  height: 100%;
  position: sticky;
  bottom: 0;
  top: 0;
  margin-top: -50%;
  float: left;
  display: block;
  pointer-events: none;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-child {
  padding-top: 6px;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-prompt {
  width: calc(
    var(--jp-cell-prompt-width) - var(--jp-private-cell-scrolling-output-offset)
  );
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-promptOverlay {
  left: calc(-1 * var(--jp-private-cell-scrolling-output-offset));
}

/*-----------------------------------------------------------------------------
| CodeCell
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| MarkdownCell
|----------------------------------------------------------------------------*/

.jp-MarkdownOutput {
  display: table-cell;
  width: 100%;
  margin-top: 0;
  margin-bottom: 0;
  padding-left: var(--jp-code-padding);
}

.jp-MarkdownOutput.jp-RenderedHTMLCommon {
  overflow: auto;
}

/* collapseHeadingButton (show always if hiddenCellsButton is _not_ shown) */
.jp-collapseHeadingButton {
  display: flex;
  min-height: var(--jp-cell-collapser-min-height);
  font-size: var(--jp-code-font-size);
  position: absolute;
  background-color: transparent;
  background-size: 25px;
  background-repeat: no-repeat;
  background-position-x: center;
  background-position-y: top;
  background-image: var(--jp-icon-caret-down);
  right: 0;
  top: 0;
  bottom: 0;
}

.jp-collapseHeadingButton.jp-mod-collapsed {
  background-image: var(--jp-icon-caret-right);
}

/*
 set the container font size to match that of content
 so that the nested collapse buttons have the right size
*/
.jp-MarkdownCell .jp-InputPrompt {
  font-size: var(--jp-content-font-size1);
}

/*
  Align collapseHeadingButton with cell top header
  The font sizes are identical to the ones in packages/rendermime/style/base.css
*/
.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='1'] {
  font-size: var(--jp-content-font-size5);
  background-position-y: calc(0.3 * var(--jp-content-font-size5));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='2'] {
  font-size: var(--jp-content-font-size4);
  background-position-y: calc(0.3 * var(--jp-content-font-size4));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='3'] {
  font-size: var(--jp-content-font-size3);
  background-position-y: calc(0.3 * var(--jp-content-font-size3));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='4'] {
  font-size: var(--jp-content-font-size2);
  background-position-y: calc(0.3 * var(--jp-content-font-size2));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='5'] {
  font-size: var(--jp-content-font-size1);
  background-position-y: top;
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='6'] {
  font-size: var(--jp-content-font-size0);
  background-position-y: top;
}

/* collapseHeadingButton (show only on (hover,active) if hiddenCellsButton is shown) */
.jp-Notebook.jp-mod-showHiddenCellsButton .jp-collapseHeadingButton {
  display: none;
}

.jp-Notebook.jp-mod-showHiddenCellsButton
  :is(.jp-MarkdownCell:hover, .jp-mod-active)
  .jp-collapseHeadingButton {
  display: flex;
}

/* showHiddenCellsButton (only show if jp-mod-showHiddenCellsButton is set, which
is a consequence of the showHiddenCellsButton option in Notebook Settings)*/
.jp-Notebook.jp-mod-showHiddenCellsButton .jp-showHiddenCellsButton {
  margin-left: calc(var(--jp-cell-prompt-width) + 2 * var(--jp-code-padding));
  margin-top: var(--jp-code-padding);
  border: 1px solid var(--jp-border-color2);
  background-color: var(--jp-border-color3) !important;
  color: var(--jp-content-font-color0) !important;
  display: flex;
}

.jp-Notebook.jp-mod-showHiddenCellsButton .jp-showHiddenCellsButton:hover {
  background-color: var(--jp-border-color2) !important;
}

.jp-showHiddenCellsButton {
  display: none;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

/*
Using block instead of flex to allow the use of the break-inside CSS property for
cell outputs.
*/

@media print {
  .jp-Cell-inputWrapper,
  .jp-Cell-outputWrapper {
    display: block;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-notebook-toolbar-padding: 2px 5px 2px 2px;
}

/*-----------------------------------------------------------------------------

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-NotebookPanel-toolbar {
  padding: var(--jp-notebook-toolbar-padding);

  /* disable paint containment from lumino 2.0 default strict CSS containment */
  contain: style size !important;
}

.jp-Toolbar-item.jp-Notebook-toolbarCellType .jp-select-wrapper.jp-mod-focused {
  border: none;
  box-shadow: none;
}

.jp-Notebook-toolbarCellTypeDropdown select {
  height: 24px;
  font-size: var(--jp-ui-font-size1);
  line-height: 14px;
  border-radius: 0;
  display: block;
}

.jp-Notebook-toolbarCellTypeDropdown span {
  top: 5px !important;
}

.jp-Toolbar-responsive-popup {
  position: absolute;
  height: fit-content;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: flex-end;
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  background: var(--jp-toolbar-background);
  min-height: var(--jp-toolbar-micro-height);
  padding: var(--jp-notebook-toolbar-padding);
  z-index: 1;
  right: 0;
  top: 0;
}

.jp-Toolbar > .jp-Toolbar-responsive-opener {
  margin-left: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-Notebook-ExecutionIndicator {
  position: relative;
  display: inline-block;
  height: 100%;
  z-index: 9997;
}

.jp-Notebook-ExecutionIndicator-tooltip {
  visibility: hidden;
  height: auto;
  width: max-content;
  width: -moz-max-content;
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color1);
  text-align: justify;
  border-radius: 6px;
  padding: 0 5px;
  position: fixed;
  display: table;
}

.jp-Notebook-ExecutionIndicator-tooltip.up {
  transform: translateX(-50%) translateY(-100%) translateY(-32px);
}

.jp-Notebook-ExecutionIndicator-tooltip.down {
  transform: translateX(calc(-100% + 16px)) translateY(5px);
}

.jp-Notebook-ExecutionIndicator-tooltip.hidden {
  display: none;
}

.jp-Notebook-ExecutionIndicator:hover .jp-Notebook-ExecutionIndicator-tooltip {
  visibility: visible;
}

.jp-Notebook-ExecutionIndicator span {
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  color: var(--jp-ui-font-color1);
  line-height: 24px;
  display: block;
}

.jp-Notebook-ExecutionIndicator-progress-bar {
  display: flex;
  justify-content: center;
  height: 100%;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*
 * Execution indicator
 */
.jp-tocItem-content::after {
  content: '';

  /* Must be identical to form a circle */
  width: 12px;
  height: 12px;
  background: none;
  border: none;
  position: absolute;
  right: 0;
}

.jp-tocItem-content[data-running='0']::after {
  border-radius: 50%;
  border: var(--jp-border-width) solid var(--jp-inverse-layout-color3);
  background: none;
}

.jp-tocItem-content[data-running='1']::after {
  border-radius: 50%;
  border: var(--jp-border-width) solid var(--jp-inverse-layout-color3);
  background-color: var(--jp-inverse-layout-color3);
}

.jp-tocItem-content[data-running='0'],
.jp-tocItem-content[data-running='1'] {
  margin-right: 12px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-Notebook-footer {
  height: 27px;
  margin-left: calc(
    var(--jp-cell-prompt-width) + var(--jp-cell-collapser-width) +
      var(--jp-cell-padding)
  );
  width: calc(
    100% -
      (
        var(--jp-cell-prompt-width) + var(--jp-cell-collapser-width) +
          var(--jp-cell-padding) + var(--jp-cell-padding)
      )
  );
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  color: var(--jp-ui-font-color3);
  margin-top: 6px;
  background: none;
  cursor: pointer;
}

.jp-Notebook-footer:focus {
  border-color: var(--jp-cell-editor-active-border-color);
}

/* For devices that support hovering, hide footer until hover */
@media (hover: hover) {
  .jp-Notebook-footer {
    opacity: 0;
  }

  .jp-Notebook-footer:focus,
  .jp-Notebook-footer:hover {
    opacity: 1;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Imports
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| CSS variables
|----------------------------------------------------------------------------*/

:root {
  --jp-side-by-side-output-size: 1fr;
  --jp-side-by-side-resized-cell: var(--jp-side-by-side-output-size);
  --jp-private-notebook-dragImage-width: 304px;
  --jp-private-notebook-dragImage-height: 36px;
  --jp-private-notebook-selected-color: var(--md-blue-400);
  --jp-private-notebook-active-color: var(--md-green-400);
}

/*-----------------------------------------------------------------------------
| Notebook
|----------------------------------------------------------------------------*/

/* stylelint-disable selector-max-class */

.jp-NotebookPanel {
  display: block;
  height: 100%;
}

.jp-NotebookPanel.jp-Document {
  min-width: 240px;
  min-height: 120px;
}

.jp-Notebook {
  padding: var(--jp-notebook-padding);
  outline: none;
  overflow: auto;
  background: var(--jp-layout-color0);
}

.jp-Notebook.jp-mod-scrollPastEnd::after {
  display: block;
  content: '';
  min-height: var(--jp-notebook-scroll-padding);
}

.jp-MainAreaWidget-ContainStrict .jp-Notebook * {
  contain: strict;
}

.jp-Notebook .jp-Cell {
  overflow: visible;
}

.jp-Notebook .jp-Cell .jp-InputPrompt {
  cursor: move;
}

/*-----------------------------------------------------------------------------
| Notebook state related styling
|
| The notebook and cells each have states, here are the possibilities:
|
| - Notebook
|   - Command
|   - Edit
| - Cell
|   - None
|   - Active (only one can be active)
|   - Selected (the cells actions are applied to)
|   - Multiselected (when multiple selected, the cursor)
|   - No outputs
|----------------------------------------------------------------------------*/

/* Command or edit modes */

.jp-Notebook .jp-Cell:not(.jp-mod-active) .jp-InputPrompt {
  opacity: var(--jp-cell-prompt-not-active-opacity);
  color: var(--jp-cell-prompt-not-active-font-color);
}

.jp-Notebook .jp-Cell:not(.jp-mod-active) .jp-OutputPrompt {
  opacity: var(--jp-cell-prompt-not-active-opacity);
  color: var(--jp-cell-prompt-not-active-font-color);
}

/* cell is active */
.jp-Notebook .jp-Cell.jp-mod-active .jp-Collapser {
  background: var(--jp-brand-color1);
}

/* cell is dirty */
.jp-Notebook .jp-Cell.jp-mod-dirty .jp-InputPrompt {
  color: var(--jp-warn-color1);
}

.jp-Notebook .jp-Cell.jp-mod-dirty .jp-InputPrompt::before {
  color: var(--jp-warn-color1);
  content: '•';
}

.jp-Notebook .jp-Cell.jp-mod-active.jp-mod-dirty .jp-Collapser {
  background: var(--jp-warn-color1);
}

/* collapser is hovered */
.jp-Notebook .jp-Cell .jp-Collapser:hover {
  box-shadow: var(--jp-elevation-z2);
  background: var(--jp-brand-color1);
  opacity: var(--jp-cell-collapser-not-active-hover-opacity);
}

/* cell is active and collapser is hovered */
.jp-Notebook .jp-Cell.jp-mod-active .jp-Collapser:hover {
  background: var(--jp-brand-color0);
  opacity: 1;
}

/* Command mode */

.jp-Notebook.jp-mod-commandMode .jp-Cell.jp-mod-selected {
  background: var(--jp-notebook-multiselected-color);
}

.jp-Notebook.jp-mod-commandMode
  .jp-Cell.jp-mod-active.jp-mod-selected:not(.jp-mod-multiSelected) {
  background: transparent;
}

/* Edit mode */

.jp-Notebook.jp-mod-editMode .jp-Cell.jp-mod-active .jp-InputArea-editor {
  border: var(--jp-border-width) solid var(--jp-cell-editor-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
  background-color: var(--jp-cell-editor-active-background);
}

/*-----------------------------------------------------------------------------
| Notebook drag and drop
|----------------------------------------------------------------------------*/

.jp-Notebook-cell.jp-mod-dropSource {
  opacity: 0.5;
}

.jp-Notebook-cell.jp-mod-dropTarget,
.jp-Notebook.jp-mod-commandMode
  .jp-Notebook-cell.jp-mod-active.jp-mod-selected.jp-mod-dropTarget {
  border-top-color: var(--jp-private-notebook-selected-color);
  border-top-style: solid;
  border-top-width: 2px;
}

.jp-dragImage {
  display: block;
  flex-direction: row;
  width: var(--jp-private-notebook-dragImage-width);
  height: var(--jp-private-notebook-dragImage-height);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background);
  overflow: visible;
}

.jp-dragImage-singlePrompt {
  box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.12);
}

.jp-dragImage .jp-dragImage-content {
  flex: 1 1 auto;
  z-index: 2;
  font-size: var(--jp-code-font-size);
  font-family: var(--jp-code-font-family);
  line-height: var(--jp-code-line-height);
  padding: var(--jp-code-padding);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background-color);
  color: var(--jp-content-font-color3);
  text-align: left;
  margin: 4px 4px 4px 0;
}

.jp-dragImage .jp-dragImage-prompt {
  flex: 0 0 auto;
  min-width: 36px;
  color: var(--jp-cell-inprompt-font-color);
  padding: var(--jp-code-padding);
  padding-left: 12px;
  font-family: var(--jp-cell-prompt-font-family);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  line-height: 1.9;
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;
}

.jp-dragImage-multipleBack {
  z-index: -1;
  position: absolute;
  height: 32px;
  width: 300px;
  top: 8px;
  left: 8px;
  background: var(--jp-layout-color2);
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.12);
}

/*-----------------------------------------------------------------------------
| Cell toolbar
|----------------------------------------------------------------------------*/

.jp-NotebookTools {
  display: block;
  min-width: var(--jp-sidebar-min-width);
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);

  /* This is needed so that all font sizing of children done in ems is
    * relative to this base size */
  font-size: var(--jp-ui-font-size1);
  overflow: auto;
}

.jp-ActiveCellTool {
  padding: 12px 0;
  display: flex;
}

.jp-ActiveCellTool-Content {
  flex: 1 1 auto;
}

.jp-ActiveCellTool .jp-ActiveCellTool-CellContent {
  background: var(--jp-cell-editor-background);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  border-radius: 0;
  min-height: 29px;
}

.jp-ActiveCellTool .jp-InputPrompt {
  min-width: calc(var(--jp-cell-prompt-width) * 0.75);
}

.jp-ActiveCellTool-CellContent > pre {
  padding: 5px 4px;
  margin: 0;
  white-space: normal;
}

.jp-MetadataEditorTool {
  flex-direction: column;
  padding: 12px 0;
}

.jp-RankedPanel > :not(:first-child) {
  margin-top: 12px;
}

.jp-KeySelector select.jp-mod-styled {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  border: var(--jp-border-width) solid var(--jp-border-color1);
}

.jp-KeySelector label,
.jp-MetadataEditorTool label,
.jp-NumberSetter label {
  line-height: 1.4;
}

.jp-NotebookTools .jp-select-wrapper {
  margin-top: 4px;
  margin-bottom: 0;
}

.jp-NumberSetter input {
  width: 100%;
  margin-top: 4px;
}

.jp-NotebookTools .jp-Collapse {
  margin-top: 16px;
}

/*-----------------------------------------------------------------------------
| Presentation Mode (.jp-mod-presentationMode)
|----------------------------------------------------------------------------*/

.jp-mod-presentationMode .jp-Notebook {
  --jp-content-font-size1: var(--jp-content-presentation-font-size1);
  --jp-code-font-size: var(--jp-code-presentation-font-size);
}

.jp-mod-presentationMode .jp-Notebook .jp-Cell .jp-InputPrompt,
.jp-mod-presentationMode .jp-Notebook .jp-Cell .jp-OutputPrompt {
  flex: 0 0 110px;
}

/*-----------------------------------------------------------------------------
| Side-by-side Mode (.jp-mod-sideBySide)
|----------------------------------------------------------------------------*/
.jp-mod-sideBySide.jp-Notebook .jp-Notebook-cell {
  margin-top: 3em;
  margin-bottom: 3em;
  margin-left: 5%;
  margin-right: 5%;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell {
  display: grid;
  grid-template-columns: minmax(0, 1fr) min-content minmax(
      0,
      var(--jp-side-by-side-output-size)
    );
  grid-template-rows: auto minmax(0, 1fr) auto;
  grid-template-areas:
    'header header header'
    'input handle output'
    'footer footer footer';
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell.jp-mod-resizedCell {
  grid-template-columns: minmax(0, 1fr) min-content minmax(
      0,
      var(--jp-side-by-side-resized-cell)
    );
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellHeader {
  grid-area: header;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-Cell-inputWrapper {
  grid-area: input;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-Cell-outputWrapper {
  /* overwrite the default margin (no vertical separation needed in side by side move */
  margin-top: 0;
  grid-area: output;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellFooter {
  grid-area: footer;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellResizeHandle {
  grid-area: handle;
  user-select: none;
  display: block;
  height: 100%;
  cursor: ew-resize;
  padding: 0 var(--jp-cell-padding);
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellResizeHandle::after {
  content: '';
  display: block;
  background: var(--jp-border-color2);
  height: 100%;
  width: 5px;
}

.jp-mod-sideBySide.jp-Notebook
  .jp-CodeCell.jp-mod-resizedCell
  .jp-CellResizeHandle::after {
  background: var(--jp-border-color0);
}

.jp-CellResizeHandle {
  display: none;
}

/*-----------------------------------------------------------------------------
| Placeholder
|----------------------------------------------------------------------------*/

.jp-Cell-Placeholder {
  padding-left: 55px;
}

.jp-Cell-Placeholder-wrapper {
  background: #fff;
  border: 1px solid;
  border-color: #e5e6e9 #dfe0e4 #d0d1d5;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  margin: 10px 15px;
}

.jp-Cell-Placeholder-wrapper-inner {
  padding: 15px;
  position: relative;
}

.jp-Cell-Placeholder-wrapper-body {
  background-repeat: repeat;
  background-size: 50% auto;
}

.jp-Cell-Placeholder-wrapper-body div {
  background: #f6f7f8;
  background-image: -webkit-linear-gradient(
    left,
    #f6f7f8 0%,
    #edeef1 20%,
    #f6f7f8 40%,
    #f6f7f8 100%
  );
  background-repeat: no-repeat;
  background-size: 800px 104px;
  height: 104px;
  position: absolute;
  right: 15px;
  left: 15px;
  top: 15px;
}

div.jp-Cell-Placeholder-h1 {
  top: 20px;
  height: 20px;
  left: 15px;
  width: 150px;
}

div.jp-Cell-Placeholder-h2 {
  left: 15px;
  top: 50px;
  height: 10px;
  width: 100px;
}

div.jp-Cell-Placeholder-content-1,
div.jp-Cell-Placeholder-content-2,
div.jp-Cell-Placeholder-content-3 {
  left: 15px;
  right: 15px;
  height: 10px;
}

div.jp-Cell-Placeholder-content-1 {
  top: 100px;
}

div.jp-Cell-Placeholder-content-2 {
  top: 120px;
}

div.jp-Cell-Placeholder-content-3 {
  top: 140px;
}

</style>
<style type="text/css">
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*
The following CSS variables define the main, public API for styling JupyterLab.
These variables should be used by all plugins wherever possible. In other
words, plugins should not define custom colors, sizes, etc unless absolutely
necessary. This enables users to change the visual theme of JupyterLab
by changing these variables.

Many variables appear in an ordered sequence (0,1,2,3). These sequences
are designed to work well together, so for example, `--jp-border-color1` should
be used with `--jp-layout-color1`. The numbers have the following meanings:

* 0: super-primary, reserved for special emphasis
* 1: primary, most important under normal situations
* 2: secondary, next most important under normal situations
* 3: tertiary, next most important under normal situations

Throughout JupyterLab, we are mostly following principles from Google's
Material Design when selecting colors. We are not, however, following
all of MD as it is not optimized for dense, information rich UIs.
*/

:root {
  /* Elevation
   *
   * We style box-shadows using Material Design's idea of elevation. These particular numbers are taken from here:
   *
   * https://github.com/material-components/material-components-web
   * https://material-components-web.appspot.com/elevation.html
   */

  --jp-shadow-base-lightness: 0;
  --jp-shadow-umbra-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.2
  );
  --jp-shadow-penumbra-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.14
  );
  --jp-shadow-ambient-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.12
  );
  --jp-elevation-z0: none;
  --jp-elevation-z1: 0 2px 1px -1px var(--jp-shadow-umbra-color),
    0 1px 1px 0 var(--jp-shadow-penumbra-color),
    0 1px 3px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z2: 0 3px 1px -2px var(--jp-shadow-umbra-color),
    0 2px 2px 0 var(--jp-shadow-penumbra-color),
    0 1px 5px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z4: 0 2px 4px -1px var(--jp-shadow-umbra-color),
    0 4px 5px 0 var(--jp-shadow-penumbra-color),
    0 1px 10px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z6: 0 3px 5px -1px var(--jp-shadow-umbra-color),
    0 6px 10px 0 var(--jp-shadow-penumbra-color),
    0 1px 18px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z8: 0 5px 5px -3px var(--jp-shadow-umbra-color),
    0 8px 10px 1px var(--jp-shadow-penumbra-color),
    0 3px 14px 2px var(--jp-shadow-ambient-color);
  --jp-elevation-z12: 0 7px 8px -4px var(--jp-shadow-umbra-color),
    0 12px 17px 2px var(--jp-shadow-penumbra-color),
    0 5px 22px 4px var(--jp-shadow-ambient-color);
  --jp-elevation-z16: 0 8px 10px -5px var(--jp-shadow-umbra-color),
    0 16px 24px 2px var(--jp-shadow-penumbra-color),
    0 6px 30px 5px var(--jp-shadow-ambient-color);
  --jp-elevation-z20: 0 10px 13px -6px var(--jp-shadow-umbra-color),
    0 20px 31px 3px var(--jp-shadow-penumbra-color),
    0 8px 38px 7px var(--jp-shadow-ambient-color);
  --jp-elevation-z24: 0 11px 15px -7px var(--jp-shadow-umbra-color),
    0 24px 38px 3px var(--jp-shadow-penumbra-color),
    0 9px 46px 8px var(--jp-shadow-ambient-color);

  /* Borders
   *
   * The following variables, specify the visual styling of borders in JupyterLab.
   */

  --jp-border-width: 1px;
  --jp-border-color0: var(--md-grey-400);
  --jp-border-color1: var(--md-grey-400);
  --jp-border-color2: var(--md-grey-300);
  --jp-border-color3: var(--md-grey-200);
  --jp-inverse-border-color: var(--md-grey-600);
  --jp-border-radius: 2px;

  /* UI Fonts
   *
   * The UI font CSS variables are used for the typography all of the JupyterLab
   * user interface elements that are not directly user generated content.
   *
   * The font sizing here is done assuming that the body font size of --jp-ui-font-size1
   * is applied to a parent element. When children elements, such as headings, are sized
   * in em all things will be computed relative to that body size.
   */

  --jp-ui-font-scale-factor: 1.2;
  --jp-ui-font-size0: 0.83333em;
  --jp-ui-font-size1: 13px; /* Base font size */
  --jp-ui-font-size2: 1.2em;
  --jp-ui-font-size3: 1.44em;
  --jp-ui-font-family: system-ui, -apple-system, blinkmacsystemfont, 'Segoe UI',
    helvetica, arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',
    'Segoe UI Symbol';

  /*
   * Use these font colors against the corresponding main layout colors.
   * In a light theme, these go from dark to light.
   */

  /* Defaults use Material Design specification */
  --jp-ui-font-color0: rgba(0, 0, 0, 1);
  --jp-ui-font-color1: rgba(0, 0, 0, 0.87);
  --jp-ui-font-color2: rgba(0, 0, 0, 0.54);
  --jp-ui-font-color3: rgba(0, 0, 0, 0.38);

  /*
   * Use these against the brand/accent/warn/error colors.
   * These will typically go from light to darker, in both a dark and light theme.
   */

  --jp-ui-inverse-font-color0: rgba(255, 255, 255, 1);
  --jp-ui-inverse-font-color1: rgba(255, 255, 255, 1);
  --jp-ui-inverse-font-color2: rgba(255, 255, 255, 0.7);
  --jp-ui-inverse-font-color3: rgba(255, 255, 255, 0.5);

  /* Content Fonts
   *
   * Content font variables are used for typography of user generated content.
   *
   * The font sizing here is done assuming that the body font size of --jp-content-font-size1
   * is applied to a parent element. When children elements, such as headings, are sized
   * in em all things will be computed relative to that body size.
   */

  --jp-content-line-height: 1.6;
  --jp-content-font-scale-factor: 1.2;
  --jp-content-font-size0: 0.83333em;
  --jp-content-font-size1: 14px; /* Base font size */
  --jp-content-font-size2: 1.2em;
  --jp-content-font-size3: 1.44em;
  --jp-content-font-size4: 1.728em;
  --jp-content-font-size5: 2.0736em;

  /* This gives a magnification of about 125% in presentation mode over normal. */
  --jp-content-presentation-font-size1: 17px;
  --jp-content-heading-line-height: 1;
  --jp-content-heading-margin-top: 1.2em;
  --jp-content-heading-margin-bottom: 0.8em;
  --jp-content-heading-font-weight: 500;

  /* Defaults use Material Design specification */
  --jp-content-font-color0: rgba(0, 0, 0, 1);
  --jp-content-font-color1: rgba(0, 0, 0, 0.87);
  --jp-content-font-color2: rgba(0, 0, 0, 0.54);
  --jp-content-font-color3: rgba(0, 0, 0, 0.38);
  --jp-content-link-color: var(--md-blue-900);
  --jp-content-font-family: system-ui, -apple-system, blinkmacsystemfont,
    'Segoe UI', helvetica, arial, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol';

  /*
   * Code Fonts
   *
   * Code font variables are used for typography of code and other monospaces content.
   */

  --jp-code-font-size: 13px;
  --jp-code-line-height: 1.3077; /* 17px for 13px base */
  --jp-code-padding: 5px; /* 5px for 13px base, codemirror highlighting needs integer px value */
  --jp-code-font-family-default: menlo, consolas, 'DejaVu Sans Mono', monospace;
  --jp-code-font-family: var(--jp-code-font-family-default);

  /* This gives a magnification of about 125% in presentation mode over normal. */
  --jp-code-presentation-font-size: 16px;

  /* may need to tweak cursor width if you change font size */
  --jp-code-cursor-width0: 1.4px;
  --jp-code-cursor-width1: 2px;
  --jp-code-cursor-width2: 4px;

  /* Layout
   *
   * The following are the main layout colors use in JupyterLab. In a light
   * theme these would go from light to dark.
   */

  --jp-layout-color0: white;
  --jp-layout-color1: white;
  --jp-layout-color2: var(--md-grey-200);
  --jp-layout-color3: var(--md-grey-400);
  --jp-layout-color4: var(--md-grey-600);

  /* Inverse Layout
   *
   * The following are the inverse layout colors use in JupyterLab. In a light
   * theme these would go from dark to light.
   */

  --jp-inverse-layout-color0: #111;
  --jp-inverse-layout-color1: var(--md-grey-900);
  --jp-inverse-layout-color2: var(--md-grey-800);
  --jp-inverse-layout-color3: var(--md-grey-700);
  --jp-inverse-layout-color4: var(--md-grey-600);

  /* Brand/accent */

  --jp-brand-color0: var(--md-blue-900);
  --jp-brand-color1: var(--md-blue-700);
  --jp-brand-color2: var(--md-blue-300);
  --jp-brand-color3: var(--md-blue-100);
  --jp-brand-color4: var(--md-blue-50);
  --jp-accent-color0: var(--md-green-900);
  --jp-accent-color1: var(--md-green-700);
  --jp-accent-color2: var(--md-green-300);
  --jp-accent-color3: var(--md-green-100);

  /* State colors (warn, error, success, info) */

  --jp-warn-color0: var(--md-orange-900);
  --jp-warn-color1: var(--md-orange-700);
  --jp-warn-color2: var(--md-orange-300);
  --jp-warn-color3: var(--md-orange-100);
  --jp-error-color0: var(--md-red-900);
  --jp-error-color1: var(--md-red-700);
  --jp-error-color2: var(--md-red-300);
  --jp-error-color3: var(--md-red-100);
  --jp-success-color0: var(--md-green-900);
  --jp-success-color1: var(--md-green-700);
  --jp-success-color2: var(--md-green-300);
  --jp-success-color3: var(--md-green-100);
  --jp-info-color0: var(--md-cyan-900);
  --jp-info-color1: var(--md-cyan-700);
  --jp-info-color2: var(--md-cyan-300);
  --jp-info-color3: var(--md-cyan-100);

  /* Cell specific styles */

  --jp-cell-padding: 5px;
  --jp-cell-collapser-width: 8px;
  --jp-cell-collapser-min-height: 20px;
  --jp-cell-collapser-not-active-hover-opacity: 0.6;
  --jp-cell-editor-background: var(--md-grey-100);
  --jp-cell-editor-border-color: var(--md-grey-300);
  --jp-cell-editor-box-shadow: inset 0 0 2px var(--md-blue-300);
  --jp-cell-editor-active-background: var(--jp-layout-color0);
  --jp-cell-editor-active-border-color: var(--jp-brand-color1);
  --jp-cell-prompt-width: 64px;
  --jp-cell-prompt-font-family: var(--jp-code-font-family-default);
  --jp-cell-prompt-letter-spacing: 0;
  --jp-cell-prompt-opacity: 1;
  --jp-cell-prompt-not-active-opacity: 0.5;
  --jp-cell-prompt-not-active-font-color: var(--md-grey-700);

  /* A custom blend of MD grey and blue 600
   * See https://meyerweb.com/eric/tools/color-blend/#546E7A:1E88E5:5:hex */
  --jp-cell-inprompt-font-color: #307fc1;

  /* A custom blend of MD grey and orange 600
   * https://meyerweb.com/eric/tools/color-blend/#546E7A:F4511E:5:hex */
  --jp-cell-outprompt-font-color: #bf5b3d;

  /* Notebook specific styles */

  --jp-notebook-padding: 10px;
  --jp-notebook-select-background: var(--jp-layout-color1);
  --jp-notebook-multiselected-color: var(--md-blue-50);

  /* The scroll padding is calculated to fill enough space at the bottom of the
  notebook to show one single-line cell (with appropriate padding) at the top
  when the notebook is scrolled all the way to the bottom. We also subtract one
  pixel so that no scrollbar appears if we have just one single-line cell in the
  notebook. This padding is to enable a 'scroll past end' feature in a notebook.
  */
  --jp-notebook-scroll-padding: calc(
    100% - var(--jp-code-font-size) * var(--jp-code-line-height) -
      var(--jp-code-padding) - var(--jp-cell-padding) - 1px
  );

  /* Rendermime styles */

  --jp-rendermime-error-background: #fdd;
  --jp-rendermime-table-row-background: var(--md-grey-100);
  --jp-rendermime-table-row-hover-background: var(--md-light-blue-50);

  /* Dialog specific styles */

  --jp-dialog-background: rgba(0, 0, 0, 0.25);

  /* Console specific styles */

  --jp-console-padding: 10px;

  /* Toolbar specific styles */

  --jp-toolbar-border-color: var(--jp-border-color1);
  --jp-toolbar-micro-height: 8px;
  --jp-toolbar-background: var(--jp-layout-color1);
  --jp-toolbar-box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.24);
  --jp-toolbar-header-margin: 4px 4px 0 4px;
  --jp-toolbar-active-background: var(--md-grey-300);

  /* Statusbar specific styles */

  --jp-statusbar-height: 24px;

  /* Input field styles */

  --jp-input-box-shadow: inset 0 0 2px var(--md-blue-300);
  --jp-input-active-background: var(--jp-layout-color1);
  --jp-input-hover-background: var(--jp-layout-color1);
  --jp-input-background: var(--md-grey-100);
  --jp-input-border-color: var(--jp-inverse-border-color);
  --jp-input-active-border-color: var(--jp-brand-color1);
  --jp-input-active-box-shadow-color: rgba(19, 124, 189, 0.3);

  /* General editor styles */

  --jp-editor-selected-background: #d9d9d9;
  --jp-editor-selected-focused-background: #d7d4f0;
  --jp-editor-cursor-color: var(--jp-ui-font-color0);

  /* Code mirror specific styles */

  --jp-mirror-editor-keyword-color: #008000;
  --jp-mirror-editor-atom-color: #88f;
  --jp-mirror-editor-number-color: #080;
  --jp-mirror-editor-def-color: #00f;
  --jp-mirror-editor-variable-color: var(--md-grey-900);
  --jp-mirror-editor-variable-2-color: rgb(0, 54, 109);
  --jp-mirror-editor-variable-3-color: #085;
  --jp-mirror-editor-punctuation-color: #05a;
  --jp-mirror-editor-property-color: #05a;
  --jp-mirror-editor-operator-color: #a2f;
  --jp-mirror-editor-comment-color: #408080;
  --jp-mirror-editor-string-color: #ba2121;
  --jp-mirror-editor-string-2-color: #708;
  --jp-mirror-editor-meta-color: #a2f;
  --jp-mirror-editor-qualifier-color: #555;
  --jp-mirror-editor-builtin-color: #008000;
  --jp-mirror-editor-bracket-color: #997;
  --jp-mirror-editor-tag-color: #170;
  --jp-mirror-editor-attribute-color: #00c;
  --jp-mirror-editor-header-color: blue;
  --jp-mirror-editor-quote-color: #090;
  --jp-mirror-editor-link-color: #00c;
  --jp-mirror-editor-error-color: #f00;
  --jp-mirror-editor-hr-color: #999;

  /*
    RTC user specific colors.
    These colors are used for the cursor, username in the editor,
    and the icon of the user.
  */

  --jp-collaborator-color1: #ffad8e;
  --jp-collaborator-color2: #dac83d;
  --jp-collaborator-color3: #72dd76;
  --jp-collaborator-color4: #00e4d0;
  --jp-collaborator-color5: #45d4ff;
  --jp-collaborator-color6: #e2b1ff;
  --jp-collaborator-color7: #ff9de6;

  /* Vega extension styles */

  --jp-vega-background: white;

  /* Sidebar-related styles */

  --jp-sidebar-min-width: 250px;

  /* Search-related styles */

  --jp-search-toggle-off-opacity: 0.5;
  --jp-search-toggle-hover-opacity: 0.8;
  --jp-search-toggle-on-opacity: 1;
  --jp-search-selected-match-background-color: rgb(245, 200, 0);
  --jp-search-selected-match-color: black;
  --jp-search-unselected-match-background-color: var(
    --jp-inverse-layout-color0
  );
  --jp-search-unselected-match-color: var(--jp-ui-inverse-font-color0);

  /* Icon colors that work well with light or dark backgrounds */
  --jp-icon-contrast-color0: var(--md-purple-600);
  --jp-icon-contrast-color1: var(--md-green-600);
  --jp-icon-contrast-color2: var(--md-pink-600);
  --jp-icon-contrast-color3: var(--md-blue-600);

  /* Button colors */
  --jp-accept-color-normal: var(--md-blue-700);
  --jp-accept-color-hover: var(--md-blue-800);
  --jp-accept-color-active: var(--md-blue-900);
  --jp-warn-color-normal: var(--md-red-700);
  --jp-warn-color-hover: var(--md-red-800);
  --jp-warn-color-active: var(--md-red-900);
  --jp-reject-color-normal: var(--md-grey-600);
  --jp-reject-color-hover: var(--md-grey-700);
  --jp-reject-color-active: var(--md-grey-800);

  /* File or activity icons and switch semantic variables */
  --jp-jupyter-icon-color: #f37626;
  --jp-notebook-icon-color: #f37626;
  --jp-json-icon-color: var(--md-orange-700);
  --jp-console-icon-background-color: var(--md-blue-700);
  --jp-console-icon-color: white;
  --jp-terminal-icon-background-color: var(--md-grey-800);
  --jp-terminal-icon-color: var(--md-grey-200);
  --jp-text-editor-icon-color: var(--md-grey-700);
  --jp-inspector-icon-color: var(--md-grey-700);
  --jp-switch-color: var(--md-grey-400);
  --jp-switch-true-position-color: var(--md-orange-900);
}
</style>
<style type="text/css">
/* Force rendering true colors when outputing to pdf */
* {
  -webkit-print-color-adjust: exact;
}

/* Misc */
a.anchor-link {
  display: none;
}

/* Input area styling */
.jp-InputArea {
  overflow: hidden;
}

.jp-InputArea-editor {
  overflow: hidden;
}

.cm-editor.cm-s-jupyter .highlight pre {
/* weird, but --jp-code-padding defined to be 5px but 4px horizontal padding is hardcoded for pre.cm-line */
  padding: var(--jp-code-padding) 4px;
  margin: 0;

  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  color: inherit;

}

.jp-OutputArea-output pre {
  line-height: inherit;
  font-family: inherit;
}

.jp-RenderedText pre {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-code-font-size);
}

/* Hiding the collapser by default */
.jp-Collapser {
  display: none;
}

@page {
    margin: 0.5in; /* Margin for each printed piece of paper */
}

@media print {
  .jp-Cell-inputWrapper,
  .jp-Cell-outputWrapper {
    display: block;
  }
}
</style>
<!-- Load mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML-full,Safe"> </script>
<!-- MathJax configuration -->
<script type="text/x-mathjax-config">
    init_mathjax = function() {
        if (window.MathJax) {
        // MathJax loaded
            MathJax.Hub.Config({
                TeX: {
                    equationNumbers: {
                    autoNumber: "AMS",
                    useLabelIds: true
                    }
                },
                tex2jax: {
                    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                    processEscapes: true,
                    processEnvironments: true
                },
                displayAlign: 'center',
                CommonHTML: {
                    linebreaks: {
                    automatic: true
                    }
                }
            });

            MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
        }
    }
    init_mathjax();
    </script>
<!-- End of mathjax configuration --><script type="module">
  document.addEventListener("DOMContentLoaded", async () => {
    const diagrams = document.querySelectorAll(".jp-Mermaid > pre.mermaid");
    // do not load mermaidjs if not needed
    if (!diagrams.length) {
      return;
    }
    const mermaid = (await import("https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.esm.min.mjs")).default;
    const parser = new DOMParser();

    mermaid.initialize({
      maxTextSize: 100000,
      maxEdges: 100000,
      startOnLoad: false,
      fontFamily: window
        .getComputedStyle(document.body)
        .getPropertyValue("--jp-ui-font-family"),
      theme: document.querySelector("body[data-jp-theme-light='true']")
        ? "default"
        : "dark",
    });

    let _nextMermaidId = 0;

    function makeMermaidImage(svg) {
      const img = document.createElement("img");
      const doc = parser.parseFromString(svg, "image/svg+xml");
      const svgEl = doc.querySelector("svg");
      const { maxWidth } = svgEl?.style || {};
      const firstTitle = doc.querySelector("title");
      const firstDesc = doc.querySelector("desc");

      img.setAttribute("src", `data:image/svg+xml,${encodeURIComponent(svg)}`);
      if (maxWidth) {
        img.width = parseInt(maxWidth);
      }
      if (firstTitle) {
        img.setAttribute("alt", firstTitle.textContent);
      }
      if (firstDesc) {
        const caption = document.createElement("figcaption");
        caption.className = "sr-only";
        caption.textContent = firstDesc.textContent;
        return [img, caption];
      }
      return [img];
    }

    async function makeMermaidError(text) {
      let errorMessage = "";
      try {
        await mermaid.parse(text);
      } catch (err) {
        errorMessage = `${err}`;
      }

      const result = document.createElement("details");
      result.className = 'jp-RenderedMermaid-Details';
      const summary = document.createElement("summary");
      summary.className = 'jp-RenderedMermaid-Summary';
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.innerText = text;
      pre.appendChild(code);
      summary.appendChild(pre);
      result.appendChild(summary);

      const warning = document.createElement("pre");
      warning.innerText = errorMessage;
      result.appendChild(warning);
      return [result];
    }

    async function renderOneMarmaid(src) {
      const id = `jp-mermaid-${_nextMermaidId++}`;
      const parent = src.parentNode;
      let raw = src.textContent.trim();
      const el = document.createElement("div");
      el.style.visibility = "hidden";
      document.body.appendChild(el);
      let results = null;
      let output = null;
      try {
        let { svg } = await mermaid.render(id, raw, el);
        svg = cleanMermaidSvg(svg);
        results = makeMermaidImage(svg);
        output = document.createElement("figure");
        results.map(output.appendChild, output);
      } catch (err) {
        parent.classList.add("jp-mod-warning");
        results = await makeMermaidError(raw);
        output = results[0];
      } finally {
        el.remove();
      }
      parent.classList.add("jp-RenderedMermaid");
      parent.appendChild(output);
    }


    /**
     * Post-process to ensure mermaid diagrams contain only valid SVG and XHTML.
     */
    function cleanMermaidSvg(svg) {
      return svg.replace(RE_VOID_ELEMENT, replaceVoidElement);
    }


    /**
     * A regular expression for all void elements, which may include attributes and
     * a slash.
     *
     * @see https://developer.mozilla.org/en-US/docs/Glossary/Void_element
     *
     * Of these, only `<br>` is generated by Mermaid in place of `\n`,
     * but _any_ "malformed" tag will break the SVG rendering entirely.
     */
    const RE_VOID_ELEMENT =
      /<\s*(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)\s*([^>]*?)\s*>/gi;

    /**
     * Ensure a void element is closed with a slash, preserving any attributes.
     */
    function replaceVoidElement(match, tag, rest) {
      rest = rest.trim();
      if (!rest.endsWith('/')) {
        rest = `${rest} /`;
      }
      return `<${tag} ${rest}>`;
    }

    void Promise.all([...diagrams].map(renderOneMarmaid));
  });
</script>
<style>
  .jp-Mermaid:not(.jp-RenderedMermaid) {
    display: none;
  }

  .jp-RenderedMermaid {
    overflow: auto;
    display: flex;
  }

  .jp-RenderedMermaid.jp-mod-warning {
    width: auto;
    padding: 0.5em;
    margin-top: 0.5em;
    border: var(--jp-border-width) solid var(--jp-warn-color2);
    border-radius: var(--jp-border-radius);
    color: var(--jp-ui-font-color1);
    font-size: var(--jp-ui-font-size1);
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .jp-RenderedMermaid figure {
    margin: 0;
    overflow: auto;
    max-width: 100%;
  }

  .jp-RenderedMermaid img {
    max-width: 100%;
  }

  .jp-RenderedMermaid-Details > pre {
    margin-top: 1em;
  }

  .jp-RenderedMermaid-Summary {
    color: var(--jp-warn-color2);
  }

  .jp-RenderedMermaid:not(.jp-mod-warning) pre {
    display: none;
  }

  .jp-RenderedMermaid-Summary > pre {
    display: inline-block;
    white-space: normal;
  }
</style>
<!-- End of mermaid configuration --></head>
<body class="jp-Notebook" data-jp-theme-light="true" data-jp-theme-name="JupyterLab Light">
<main>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=5d8b9021">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h1 id="Configs">Configs<a class="anchor-link" href="#Configs">¶</a></h1>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell jp-mod-noOutputs" id="cell-id=35f3af74">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">RESULTS_DIR</span><span class="o">=</span><span class="s2">"Results/CodeBERT_Original_CVE_Fixes_5050_no_errors_opt_lora_batch_16"</span>
</pre></div>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=e3f92c0e">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">wandb</span>

<span class="n">wandb</span><span class="o">.</span><span class="n">login</span><span class="p">()</span>
<span class="o">%</span><span class="k">env</span> WANDB_LOG_MODEL=true
<span class="o">%</span><span class="k">env</span> WANDB_NOTEBOOK_NAME=DiverseVul_CodeBERT
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>Failed to detect the name of this notebook, you can set it manually with the WANDB_NOTEBOOK_NAME environment variable to enable code saving.
<span class="ansi-blue-intense-fg ansi-bold">wandb</span>: Currently logged in as: <span class="ansi-yellow-fg">1180939</span>. Use <span class="ansi-bold">`wandb login --relogin`</span> to force relogin
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>env: WANDB_LOG_MODEL=true
env: WANDB_NOTEBOOK_NAME=DiverseVul_CodeBERT
</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=99811f76">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h1 id="Load-Dataset">Load Dataset<a class="anchor-link" href="#Load-Dataset">¶</a></h1>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=7916f206">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">datasets</span> <span class="kn">import</span> <span class="n">load_from_disk</span><span class="p">,</span> <span class="n">Dataset</span>

<span class="k">def</span> <span class="nf">load_dataset</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">""" Load dataset. """</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">load_from_disk</span><span class="p">(</span><span class="s2">"../datasets/cve_fixes_original_balanced_5050.hf/"</span><span class="p">)</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dataset</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>c:\Users\tiago\anaconda3\envs\LLMs_DiverseVul_ENV\Lib\site-packages\tqdm\auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html
  from .autonotebook import tqdm as notebook_tqdm
</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=4bf41149">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">dataset</span> <span class="o">=</span> <span class="n">load_dataset</span><span class="p">()</span>
<span class="n">dataset</span><span class="p">[</span><span class="s2">"validation"</span><span class="p">][</span><span class="s2">"text"</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child jp-OutputArea-executeResult">
<div class="jp-OutputPrompt jp-OutputArea-prompt">Out[ ]:</div>
<div class="jp-RenderedText jp-OutputArea-output jp-OutputArea-executeResult" data-mime-type="text/plain" tabindex="0">
<pre>['level_cost(unsigned int n)\n{\n    static const double log_1_1 = 0.09531017980432493;\n\n\t/* Adding 0.1 protects against the case where n==1 */\n\treturn ceil(log(n + 0.1)/log_1_1);\n}',
 "struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n\t\t\t\t     unsigned long data_len, int noblock,\n\t\t\t\t     int *errcode)\n{\n\tstruct sk_buff *skb;\n\tgfp_t gfp_mask;\n\tlong timeo;\n\tint err;\n\n\tgfp_mask = sk-&gt;sk_allocation;\n\tif (gfp_mask &amp; __GFP_WAIT)\n\t\tgfp_mask |= __GFP_REPEAT;\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\twhile (1) {\n\t\terr = sock_error(sk);\n\t\tif (err != 0)\n\t\t\tgoto failure;\n\n\t\terr = -EPIPE;\n\t\tif (sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN)\n\t\t\tgoto failure;\n\n\t\tif (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &lt; sk-&gt;sk_sndbuf) {\n\t\t\tskb = alloc_skb(header_len, gfp_mask);\n\t\t\tif (skb) {\n\t\t\t\tint npages;\n\t\t\t\tint i;\n\n\t\t\t\t/* No pages, we're done... */\n\t\t\t\tif (!data_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tnpages = (data_len + (PAGE_SIZE - 1)) &gt;&gt; PAGE_SHIFT;\n\t\t\t\tskb-&gt;truesize += data_len;\n\t\t\t\tskb_shinfo(skb)-&gt;nr_frags = npages;\n\t\t\t\tfor (i = 0; i &lt; npages; i++) {\n\t\t\t\t\tstruct page *page;\n\n\t\t\t\t\tpage = alloc_pages(sk-&gt;sk_allocation, 0);\n\t\t\t\t\tif (!page) {\n\t\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\t\t\tskb_shinfo(skb)-&gt;nr_frags = i;\n\t\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t\t}\n\n\t\t\t\t\t__skb_fill_page_desc(skb, i,\n\t\t\t\t\t\t\tpage, 0,\n\t\t\t\t\t\t\t(data_len &gt;= PAGE_SIZE ?\n\t\t\t\t\t\t\t PAGE_SIZE :\n\t\t\t\t\t\t\t data_len));\n\t\t\t\t\tdata_len -= PAGE_SIZE;\n\t\t\t\t}\n\n\t\t\t\t/* Full success... */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto failure;\n\t\t}\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);\n\t\tset_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto failure;\n\t\tif (signal_pending(current))\n\t\t\tgoto interrupted;\n\t\ttimeo = sock_wait_for_wmem(sk, timeo);\n\t}\n\n\tskb_set_owner_w(skb, sk);\n\treturn skb;\n\ninterrupted:\n\terr = sock_intr_errno(timeo);\nfailure:\n\t*errcode = err;\n\treturn NULL;\n}",
 'void initializeUpstreamTlsContextConfig(\n    const ClientSslTransportOptions&amp; options,\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext&amp; tls_context) {\n  std::string yaml_plain = R"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: "{{ test_rundir }}/test/config/integration/certs/cacert.pem"\n)EOF";\n  if (options.client_ecdsa_cert_) {\n    yaml_plain += R"EOF(\n    tls_certificates:\n      certificate_chain:\n        filename: "{{ test_rundir }}/test/config/integration/certs/client_ecdsacert.pem"\n      private_key:\n        filename: "{{ test_rundir }}/test/config/integration/certs/client_ecdsakey.pem"\n)EOF";\n  } else if (options.use_expired_spiffe_cert_) {\n    yaml_plain += R"EOF(\n    tls_certificates:\n      certificate_chain:\n        filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/expired_spiffe_san_cert.pem"\n      private_key:\n        filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/expired_spiffe_san_key.pem"\n)EOF";\n  } else {\n    yaml_plain += R"EOF(\n    tls_certificates:\n      certificate_chain:\n        filename: "{{ test_rundir }}/test/config/integration/certs/clientcert.pem"\n      private_key:\n        filename: "{{ test_rundir }}/test/config/integration/certs/clientkey.pem"\n)EOF";\n  }\n\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml_plain), tls_context);\n  auto* common_context = tls_context.mutable_common_tls_context();\n\n  if (options.alpn_) {\n    common_context-&gt;add_alpn_protocols(Http::Utility::AlpnNames::get().Http2);\n    common_context-&gt;add_alpn_protocols(Http::Utility::AlpnNames::get().Http11);\n    common_context-&gt;add_alpn_protocols(Http::Utility::AlpnNames::get().Http3);\n  }\n  if (!options.san_.empty()) {\n    envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher* matcher =\n        common_context-&gt;mutable_validation_context()-&gt;add_match_typed_subject_alt_names();\n    matcher-&gt;mutable_matcher()-&gt;set_exact(options.san_);\n    matcher-&gt;set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS);\n    matcher = common_context-&gt;mutable_validation_context()-&gt;add_match_typed_subject_alt_names();\n    matcher-&gt;mutable_matcher()-&gt;set_exact(options.san_);\n    matcher-&gt;set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI);\n    matcher = common_context-&gt;mutable_validation_context()-&gt;add_match_typed_subject_alt_names();\n    matcher-&gt;mutable_matcher()-&gt;set_exact(options.san_);\n    matcher-&gt;set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL);\n    matcher = common_context-&gt;mutable_validation_context()-&gt;add_match_typed_subject_alt_names();\n    matcher-&gt;mutable_matcher()-&gt;set_exact(options.san_);\n    matcher-&gt;set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS);\n  }\n  for (const std::string&amp; cipher_suite : options.cipher_suites_) {\n    common_context-&gt;mutable_tls_params()-&gt;add_cipher_suites(cipher_suite);\n  }\n  if (!options.sni_.empty()) {\n    tls_context.set_sni(options.sni_);\n  }\n\n  common_context-&gt;mutable_tls_params()-&gt;set_tls_minimum_protocol_version(options.tls_version_);\n  common_context-&gt;mutable_tls_params()-&gt;set_tls_maximum_protocol_version(options.tls_version_);\n}',
 'static av_cold int vqa_decode_init(AVCodecContext *avctx)\n{\n    VqaContext *s = avctx-&gt;priv_data;\n    int i, j, codebook_index, ret;\n\n    s-&gt;avctx = avctx;\n    avctx-&gt;pix_fmt = AV_PIX_FMT_PAL8;\n\n    /* make sure the extradata made it */\n    if (s-&gt;avctx-&gt;extradata_size != VQA_HEADER_SIZE) {\n        av_log(s-&gt;avctx, AV_LOG_ERROR, "expected extradata size of %d\\n", VQA_HEADER_SIZE);\n        return AVERROR(EINVAL);\n    }\n\n    /* load up the VQA parameters from the header */\n    s-&gt;vqa_version = s-&gt;avctx-&gt;extradata[0];\n    switch (s-&gt;vqa_version) {\n    case 1:\n    case 2:\n        break;\n    case 3:\n        avpriv_report_missing_feature(avctx, "VQA Version %d", s-&gt;vqa_version);\n        return AVERROR_PATCHWELCOME;\n    default:\n        avpriv_request_sample(avctx, "VQA Version %i", s-&gt;vqa_version);\n        return AVERROR_PATCHWELCOME;\n    }\n    s-&gt;width = AV_RL16(&amp;s-&gt;avctx-&gt;extradata[6]);\n    s-&gt;height = AV_RL16(&amp;s-&gt;avctx-&gt;extradata[8]);\n    if ((ret = ff_set_dimensions(avctx, s-&gt;width, s-&gt;height)) &lt; 0) {\n        s-&gt;width= s-&gt;height= 0;\n        return ret;\n    }\n    s-&gt;vector_width = s-&gt;avctx-&gt;extradata[10];\n    s-&gt;vector_height = s-&gt;avctx-&gt;extradata[11];\n    s-&gt;partial_count = s-&gt;partial_countdown = s-&gt;avctx-&gt;extradata[13];\n\n    /* the vector dimensions have to meet very stringent requirements */\n    if ((s-&gt;vector_width != 4) ||\n        ((s-&gt;vector_height != 2) &amp;&amp; (s-&gt;vector_height != 4))) {\n        /* return without further initialization */\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s-&gt;width % s-&gt;vector_width || s-&gt;height % s-&gt;vector_height) {\n        av_log(avctx, AV_LOG_ERROR, "Image size not multiple of block size\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* allocate codebooks */\n    s-&gt;codebook_size = MAX_CODEBOOK_SIZE;\n    s-&gt;codebook = av_malloc(s-&gt;codebook_size);\n    if (!s-&gt;codebook)\n        goto fail;\n    s-&gt;next_codebook_buffer = av_malloc(s-&gt;codebook_size);\n    if (!s-&gt;next_codebook_buffer)\n        goto fail;\n\n    /* allocate decode buffer */\n    s-&gt;decode_buffer_size = (s-&gt;width / s-&gt;vector_width) *\n        (s-&gt;height / s-&gt;vector_height) * 2;\n    s-&gt;decode_buffer = av_mallocz(s-&gt;decode_buffer_size);\n    if (!s-&gt;decode_buffer)\n        goto fail;\n\n    /* initialize the solid-color vectors */\n    if (s-&gt;vector_height == 4) {\n        codebook_index = 0xFF00 * 16;\n        for (i = 0; i &lt; 256; i++)\n            for (j = 0; j &lt; 16; j++)\n                s-&gt;codebook[codebook_index++] = i;\n    } else {\n        codebook_index = 0xF00 * 8;\n        for (i = 0; i &lt; 256; i++)\n            for (j = 0; j &lt; 8; j++)\n                s-&gt;codebook[codebook_index++] = i;\n    }\n    s-&gt;next_codebook_buffer_index = 0;\n\n    return 0;\nfail:\n    av_freep(&amp;s-&gt;codebook);\n    av_freep(&amp;s-&gt;next_codebook_buffer);\n    av_freep(&amp;s-&gt;decode_buffer);\n    return AVERROR(ENOMEM);\n}',
 'int pure_strcmp(const char * const s1, const char * const s2)\n{\n    const size_t s1_len = strlen(s1);\n    const size_t s2_len = strlen(s2);\n    const size_t len = (s1_len &lt; s2_len) ? s1_len : s2_len;\n\n    return pure_memcmp(s1, s2, len + 1);\n}',
 'TfLiteStatus Subgraph::AddNodeWithParameters(\n    const std::vector&lt;int&gt;&amp; inputs, const std::vector&lt;int&gt;&amp; outputs,\n    const std::vector&lt;int&gt;&amp; intermediates, const char* init_data,\n    size_t init_data_size, void* builtin_data,\n    const TfLiteRegistration* registration, int* node_index) {\n  std::unique_ptr&lt;void, decltype(free)*&gt; builtin_data_deleter(builtin_data,\n                                                              free);\n  if (state_ == kStateInvokableAndImmutable) {\n    ReportError("AddNodeWithParameters is disallowed when graph is immutable.");\n    return kTfLiteError;\n  }\n  state_ = kStateUninvokable;\n\n  TF_LITE_ENSURE_OK(&amp;context_, CheckTensorIndices("node inputs", inputs.data(),\n                                                  inputs.size()));\n  TF_LITE_ENSURE_OK(\n      &amp;context_,\n      CheckTensorIndices("node outputs", outputs.data(), outputs.size()));\n\n  // For builtin ops, inputs and outputs must not overlap. Custom ops must do\n  // this check by themselves if they don\'t support overlapping tensors. This\n  // distinction is to allow custom ops to just forward a tensor, reusing it as\n  // both input and output.\n  if (builtin_data != nullptr) {\n    TF_LITE_ENSURE_OK(&amp;context_, CheckInputAndOutputForOverlap(\n                                     inputs.data(), inputs.size(),\n                                     outputs.data(), outputs.size()));\n  }\n\n  int new_node_index = nodes_and_registration_.size();\n  if (node_index) *node_index = new_node_index;\n  nodes_and_registration_.resize(nodes_and_registration_.size() + 1);\n  auto&amp; node_and_reg = nodes_and_registration_.back();\n  TfLiteNode&amp; node = node_and_reg.first;\n  if (node.inputs) TfLiteIntArrayFree(node.inputs);\n  if (node.outputs) TfLiteIntArrayFree(node.outputs);\n  if (node.intermediates) TfLiteIntArrayFree(node.intermediates);\n  if (node.temporaries) TfLiteIntArrayFree(node.temporaries);\n\n  // NOTE, here we are not using move semantics yet, since our internal\n  // representation isn\'t std::vector, but in the future we would like to avoid\n  // copies, so we want the interface to take r-value references now.\n  node.inputs = ConvertVectorToTfLiteIntArray(inputs);\n  node.outputs = ConvertVectorToTfLiteIntArray(outputs);\n  node.intermediates = ConvertVectorToTfLiteIntArray(intermediates);\n  node.temporaries = TfLiteIntArrayCreate(0);\n  if (init_data) {\n    node.user_data = OpInit(*registration, init_data, init_data_size);\n  } else {\n    node.user_data = OpInit(\n        *registration, static_cast&lt;const char*&gt;(builtin_data_deleter.get()), 0);\n  }\n\n  node.builtin_data = builtin_data_deleter.release();\n  // TODO(ycling): Filling `custom_initial_data` and `custom_initial_data_size`\n  // properly for nodes generated by ReplaceNodeSubsetsWithDelegateKernels.\n\n  if (registration-&gt;builtin_code == BuiltinOperator_CUSTOM) {\n    // When it\'s a CUSTOM op, the `custom_options` field in the Flatbuffer\n    // `Operator` table is passed in.\n    node.custom_initial_data = init_data;\n    node.custom_initial_data_size = init_data_size;\n  } else {\n    node.custom_initial_data = nullptr;\n    node.custom_initial_data_size = 0;\n  }\n\n  node.delegate = nullptr;\n  // Copying of registration is required to support unresolved custom ops.\n  node_and_reg.second = *registration;\n  execution_plan_.push_back(new_node_index);\n  return kTfLiteOk;\n}',
 'int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info,\n                       const char * name, int rep_quick, my_bool no_copy_stat)\n{\n  int got_error;\n  uint i,key, total_key_length, istep;\n  ulong rec_length;\n  ha_rows start_records;\n  my_off_t new_header_length,del;\n  File new_file;\n  MI_SORT_PARAM *sort_param=0;\n  MYISAM_SHARE *share=info-&gt;s;\n  ulong   *rec_per_key_part;\n  HA_KEYSEG *keyseg;\n  char llbuff[22];\n  IO_CACHE new_data_cache; /* For non-quick repair. */\n  IO_CACHE_SHARE io_share;\n  SORT_INFO sort_info;\n  ulonglong UNINIT_VAR(key_map);\n  pthread_attr_t thr_attr;\n  ulong max_pack_reclength;\n  int error;\n  DBUG_ENTER("mi_repair_parallel");\n\n  start_records=info-&gt;state-&gt;records;\n  got_error=1;\n  new_file= -1;\n  new_header_length=(param-&gt;testflag &amp; T_UNPACK) ? 0 :\n    share-&gt;pack.header_length;\n  if (!(param-&gt;testflag &amp; T_SILENT))\n  {\n    printf("- parallel recovering (with sort) MyISAM-table \'%s\'\\n",name);\n    printf("Data records: %s\\n", llstr(start_records,llbuff));\n  }\n  param-&gt;testflag|=T_REP; /* for easy checking */\n\n  if (info-&gt;s-&gt;options &amp; (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD))\n    param-&gt;testflag|=T_CALC_CHECKSUM;\n\n  /*\n    Quick repair (not touching data file, rebuilding indexes):\n    {\n      Read  cache is (MI_CHECK *param)-&gt;read_cache using info-&gt;dfile.\n    }\n\n    Non-quick repair (rebuilding data file and indexes):\n    {\n      Master thread:\n\n        Read  cache is (MI_CHECK *param)-&gt;read_cache using info-&gt;dfile.\n        Write cache is (MI_INFO   *info)-&gt;rec_cache  using new_file.\n\n      Slave threads:\n\n        Read  cache is new_data_cache synced to master rec_cache.\n\n      The final assignment of the filedescriptor for rec_cache is done\n      after the cache creation.\n\n      Don\'t check file size on new_data_cache, as the resulting file size\n      is not known yet.\n\n      As rec_cache and new_data_cache are synced, write_buffer_length is\n      used for the read cache \'new_data_cache\'. Both start at the same\n      position \'new_header_length\'.\n    }\n  */\n  DBUG_PRINT("info", ("is quick repair: %d", rep_quick));\n  bzero((char*)&amp;sort_info,sizeof(sort_info));\n  /* Initialize pthread structures before goto err. */\n  mysql_mutex_init(mi_key_mutex_MI_SORT_INFO_mutex,\n                   &amp;sort_info.mutex, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(mi_key_cond_MI_SORT_INFO_cond, &amp;sort_info.cond, 0);\n  mysql_mutex_init(mi_key_mutex_MI_CHECK_print_msg,\n                   &amp;param-&gt;print_msg_mutex, MY_MUTEX_INIT_FAST);\n  param-&gt;need_print_msg_lock= 1;\n\n  if (!(sort_info.key_block=\n\talloc_key_blocks(param, (uint) param-&gt;sort_key_blocks,\n\t\t\t share-&gt;base.max_key_block_length)) ||\n      init_io_cache(&amp;param-&gt;read_cache, info-&gt;dfile,\n                    (uint) param-&gt;read_buffer_length,\n                    READ_CACHE, share-&gt;pack.header_length, 1, MYF(MY_WME)) ||\n      (!rep_quick &amp;&amp;\n       (init_io_cache(&amp;info-&gt;rec_cache, info-&gt;dfile,\n                      (uint) param-&gt;write_buffer_length,\n                      WRITE_CACHE, new_header_length, 1,\n                      MYF(MY_WME | MY_WAIT_IF_FULL) &amp; param-&gt;myf_rw) ||\n        init_io_cache(&amp;new_data_cache, -1,\n                      (uint) param-&gt;write_buffer_length,\n                      READ_CACHE, new_header_length, 1,\n                      MYF(MY_WME | MY_DONT_CHECK_FILESIZE)))))\n    goto err;\n  sort_info.key_block_end=sort_info.key_block+param-&gt;sort_key_blocks;\n  info-&gt;opt_flag|=WRITE_CACHE_USED;\n  info-&gt;rec_cache.file=info-&gt;dfile;         /* for sort_delete_record */\n\n  if (!rep_quick)\n  {\n    /* Get real path for data file */\n    if ((new_file= mysql_file_create(mi_key_file_datatmp,\n                                     fn_format(param-&gt;temp_filename,\n                                               share-&gt;data_file_name, "",\n                                               DATA_TMP_EXT, 2+4),\n                                     0, param-&gt;tmpfile_createflag,\n                                     MYF(0))) &lt; 0)\n    {\n      mi_check_print_error(param,"Can\'t create new tempfile: \'%s\'",\n\t\t\t   param-&gt;temp_filename);\n      goto err;\n    }\n    if (new_header_length &amp;&amp;\n        filecopy(param, new_file,info-&gt;dfile,0L,new_header_length,\n\t\t "datafile-header"))\n      goto err;\n    if (param-&gt;testflag &amp; T_UNPACK)\n    {\n      share-&gt;options&amp;= ~HA_OPTION_COMPRESS_RECORD;\n      mi_int2store(share-&gt;state.header.options,share-&gt;options);\n    }\n    share-&gt;state.dellink= HA_OFFSET_ERROR;\n    info-&gt;rec_cache.file=new_file;\n  }\n\n  info-&gt;update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);\n\n  /* Optionally drop indexes and optionally modify the key_map. */\n  mi_drop_all_indexes(param, info, FALSE);\n  key_map= share-&gt;state.key_map;\n  if (param-&gt;testflag &amp; T_CREATE_MISSING_KEYS)\n  {\n    /* Invert the copied key_map to recreate all disabled indexes. */\n    key_map= ~key_map;\n  }\n\n  sort_info.info=info;\n  sort_info.param = param;\n\n  set_data_file_type(&amp;sort_info, share);\n  sort_info.dupp=0;\n  sort_info.buff=0;\n  param-&gt;read_cache.end_of_file=sort_info.filelength=\n    mysql_file_seek(param-&gt;read_cache.file, 0L, MY_SEEK_END, MYF(0));\n\n  if (share-&gt;data_file_type == DYNAMIC_RECORD)\n    rec_length=max(share-&gt;base.min_pack_length+1,share-&gt;base.min_block_length);\n  else if (share-&gt;data_file_type == COMPRESSED_RECORD)\n    rec_length=share-&gt;base.min_block_length;\n  else\n    rec_length=share-&gt;base.pack_reclength;\n  /*\n    +1 below is required hack for parallel repair mode.\n    The info-&gt;state-&gt;records value, that is compared later\n    to sort_info.max_records and cannot exceed it, is\n    increased in sort_key_write. In mi_repair_by_sort, sort_key_write\n    is called after sort_key_read, where the comparison is performed,\n    but in parallel mode master thread can call sort_key_write\n    before some other repair thread calls sort_key_read.\n    Furthermore I\'m not even sure +1 would be enough.\n    May be sort_info.max_records shold be always set to max value in\n    parallel mode.\n  */\n  sort_info.max_records=\n    ((param-&gt;testflag &amp; T_CREATE_MISSING_KEYS) ? info-&gt;state-&gt;records + 1:\n     (ha_rows) (sort_info.filelength/rec_length+1));\n\n  del=info-&gt;state-&gt;del;\n  param-&gt;glob_crc=0;\n  /* for compressed tables */\n  max_pack_reclength= share-&gt;base.pack_reclength;\n  if (share-&gt;options &amp; HA_OPTION_COMPRESS_RECORD)\n    set_if_bigger(max_pack_reclength, share-&gt;max_pack_length);\n  if (!(sort_param=(MI_SORT_PARAM *)\n        my_malloc((uint) share-&gt;base.keys *\n\t\t  (sizeof(MI_SORT_PARAM) + max_pack_reclength),\n\t\t  MYF(MY_ZEROFILL))))\n  {\n    mi_check_print_error(param,"Not enough memory for key!");\n    goto err;\n  }\n  total_key_length=0;\n  rec_per_key_part= param-&gt;rec_per_key_part;\n  info-&gt;state-&gt;records=info-&gt;state-&gt;del=share-&gt;state.split=0;\n  info-&gt;state-&gt;empty=0;\n\n  for (i=key=0, istep=1 ; key &lt; share-&gt;base.keys ;\n       rec_per_key_part+=sort_param[i].keyinfo-&gt;keysegs, i+=istep, key++)\n  {\n    sort_param[i].key=key;\n    sort_param[i].keyinfo=share-&gt;keyinfo+key;\n    sort_param[i].seg=sort_param[i].keyinfo-&gt;seg;\n    /*\n      Skip this index if it is marked disabled in the copied\n      (and possibly inverted) key_map.\n    */\n    if (! mi_is_key_active(key_map, key))\n    {\n      /* Remember old statistics for key */\n      memcpy((char*) rec_per_key_part,\n\t     (char*) (share-&gt;state.rec_per_key_part+\n\t\t      (uint) (rec_per_key_part - param-&gt;rec_per_key_part)),\n\t     sort_param[i].keyinfo-&gt;keysegs*sizeof(*rec_per_key_part));\n      istep=0;\n      continue;\n    }\n    istep=1;\n    if ((!(param-&gt;testflag &amp; T_SILENT)))\n      printf ("- Fixing index %d\\n",key+1);\n    if (sort_param[i].keyinfo-&gt;flag &amp; HA_FULLTEXT)\n    {\n      sort_param[i].key_read=sort_ft_key_read;\n      sort_param[i].key_write=sort_ft_key_write;\n    }\n    else\n    {\n      sort_param[i].key_read=sort_key_read;\n      sort_param[i].key_write=sort_key_write;\n    }\n    sort_param[i].key_cmp=sort_key_cmp;\n    sort_param[i].lock_in_memory=lock_memory;\n    sort_param[i].tmpdir=param-&gt;tmpdir;\n    sort_param[i].sort_info=&amp;sort_info;\n    sort_param[i].master=0;\n    sort_param[i].fix_datafile=0;\n    sort_param[i].calc_checksum= 0;\n\n    sort_param[i].filepos=new_header_length;\n    sort_param[i].max_pos=sort_param[i].pos=share-&gt;pack.header_length;\n\n    sort_param[i].record= (((uchar *)(sort_param+share-&gt;base.keys))+\n\t\t\t   (max_pack_reclength * i));\n    if (!mi_alloc_rec_buff(info, -1, &amp;sort_param[i].rec_buff))\n    {\n      mi_check_print_error(param,"Not enough memory!");\n      goto err;\n    }\n\n    sort_param[i].key_length=share-&gt;rec_reflength;\n    for (keyseg=sort_param[i].seg; keyseg-&gt;type != HA_KEYTYPE_END;\n\t keyseg++)\n    {\n      sort_param[i].key_length+=keyseg-&gt;length;\n      if (keyseg-&gt;flag &amp; HA_SPACE_PACK)\n        sort_param[i].key_length+=get_pack_length(keyseg-&gt;length);\n      if (keyseg-&gt;flag &amp; (HA_BLOB_PART | HA_VAR_LENGTH_PART))\n        sort_param[i].key_length+=2 + test(keyseg-&gt;length &gt;= 127);\n      if (keyseg-&gt;flag &amp; HA_NULL_PART)\n        sort_param[i].key_length++;\n    }\n    total_key_length+=sort_param[i].key_length;\n\n    if (sort_param[i].keyinfo-&gt;flag &amp; HA_FULLTEXT)\n    {\n      uint ft_max_word_len_for_sort=FT_MAX_WORD_LEN_FOR_SORT*\n                                    sort_param[i].keyinfo-&gt;seg-&gt;charset-&gt;mbmaxlen;\n      sort_param[i].key_length+=ft_max_word_len_for_sort-HA_FT_MAXBYTELEN;\n      init_alloc_root(&amp;sort_param[i].wordroot, FTPARSER_MEMROOT_ALLOC_SIZE, 0);\n    }\n  }\n  sort_info.total_keys=i;\n  sort_param[0].master= 1;\n  sort_param[0].fix_datafile= (my_bool)(! rep_quick);\n  sort_param[0].calc_checksum= test(param-&gt;testflag &amp; T_CALC_CHECKSUM);\n\n  if (!ftparser_alloc_param(info))\n    goto err;\n\n  sort_info.got_error=0;\n  mysql_mutex_lock(&amp;sort_info.mutex);\n\n  /*\n    Initialize the I/O cache share for use with the read caches and, in\n    case of non-quick repair, the write cache. When all threads join on\n    the cache lock, the writer copies the write cache contents to the\n    read caches.\n  */\n  if (i &gt; 1)\n  {\n    if (rep_quick)\n      init_io_cache_share(&amp;param-&gt;read_cache, &amp;io_share, NULL, i);\n    else\n      init_io_cache_share(&amp;new_data_cache, &amp;io_share, &amp;info-&gt;rec_cache, i);\n  }\n  else\n    io_share.total_threads= 0; /* share not used */\n\n  (void) pthread_attr_init(&amp;thr_attr);\n  (void) pthread_attr_setdetachstate(&amp;thr_attr,PTHREAD_CREATE_DETACHED);\n\n  for (i=0 ; i &lt; sort_info.total_keys ; i++)\n  {\n    /*\n      Copy the properly initialized IO_CACHE structure so that every\n      thread has its own copy. In quick mode param-&gt;read_cache is shared\n      for use by all threads. In non-quick mode all threads but the\n      first copy the shared new_data_cache, which is synchronized to the\n      write cache of the first thread. The first thread copies\n      param-&gt;read_cache, which is not shared.\n    */\n    sort_param[i].read_cache= ((rep_quick || !i) ? param-&gt;read_cache :\n                               new_data_cache);\n    DBUG_PRINT("io_cache_share", ("thread: %u  read_cache: 0x%lx",\n                                  i, (long) &amp;sort_param[i].read_cache));\n\n    /*\n      two approaches: the same amount of memory for each thread\n      or the memory for the same number of keys for each thread...\n      In the second one all the threads will fill their sort_buffers\n      (and call write_keys) at the same time, putting more stress on i/o.\n    */\n    sort_param[i].sortbuff_size=\n#ifndef USING_SECOND_APPROACH\n      param-&gt;sort_buffer_length/sort_info.total_keys;\n#else\n      param-&gt;sort_buffer_length*sort_param[i].key_length/total_key_length;\n#endif\n    if ((error= mysql_thread_create(mi_key_thread_find_all_keys,\n                                    &amp;sort_param[i].thr, &amp;thr_attr,\n                                    thr_find_all_keys,\n                                    (void *) (sort_param+i))))\n    {\n      mi_check_print_error(param,"Cannot start a repair thread (errno= %d)",\n                           error);\n      /* Cleanup: Detach from the share. Avoid others to be blocked. */\n      if (io_share.total_threads)\n        remove_io_thread(&amp;sort_param[i].read_cache);\n      DBUG_PRINT("error", ("Cannot start a repair thread"));\n      sort_info.got_error=1;\n    }\n    else\n      sort_info.threads_running++;\n  }\n  (void) pthread_attr_destroy(&amp;thr_attr);\n\n  /* waiting for all threads to finish */\n  while (sort_info.threads_running)\n    mysql_cond_wait(&amp;sort_info.cond, &amp;sort_info.mutex);\n  mysql_mutex_unlock(&amp;sort_info.mutex);\n\n  if ((got_error= thr_write_keys(sort_param)))\n  {\n    param-&gt;retry_repair=1;\n    goto err;\n  }\n  got_error=1;\t\t\t\t/* Assume the following may go wrong */\n\n  if (sort_param[0].fix_datafile)\n  {\n    /*\n      Append some nuls to the end of a memory mapped file. Destroy the\n      write cache. The master thread did already detach from the share\n      by remove_io_thread() in sort.c:thr_find_all_keys().\n    */\n    if (write_data_suffix(&amp;sort_info,1) || end_io_cache(&amp;info-&gt;rec_cache))\n      goto err;\n    if (param-&gt;testflag &amp; T_SAFE_REPAIR)\n    {\n      /* Don\'t repair if we loosed more than one row */\n      if (info-&gt;state-&gt;records+1 &lt; start_records)\n      {\n        info-&gt;state-&gt;records=start_records;\n        goto err;\n      }\n    }\n    share-&gt;state.state.data_file_length= info-&gt;state-&gt;data_file_length=\n      sort_param-&gt;filepos;\n    /* Only whole records */\n    share-&gt;state.version=(ulong) time((time_t*) 0);\n\n    /*\n      Exchange the data file descriptor of the table, so that we use the\n      new file from now on.\n     */\n    mysql_file_close(info-&gt;dfile, MYF(0));\n    info-&gt;dfile=new_file;\n\n    share-&gt;data_file_type=sort_info.new_data_file_type;\n    share-&gt;pack.header_length=(ulong) new_header_length;\n  }\n  else\n    info-&gt;state-&gt;data_file_length=sort_param-&gt;max_pos;\n\n  if (rep_quick &amp;&amp; del+sort_info.dupp != info-&gt;state-&gt;del)\n  {\n    mi_check_print_error(param,"Couldn\'t fix table with quick recovery: Found wrong number of deleted records");\n    mi_check_print_error(param,"Run recovery again without -q");\n    param-&gt;retry_repair=1;\n    param-&gt;testflag|=T_RETRY_WITHOUT_QUICK;\n    goto err;\n  }\n\n  if (rep_quick &amp; T_FORCE_UNIQUENESS)\n  {\n    my_off_t skr=info-&gt;state-&gt;data_file_length+\n      (share-&gt;options &amp; HA_OPTION_COMPRESS_RECORD ?\n       MEMMAP_EXTRA_MARGIN : 0);\n#ifdef USE_RELOC\n    if (share-&gt;data_file_type == STATIC_RECORD &amp;&amp;\n\tskr &lt; share-&gt;base.reloc*share-&gt;base.min_pack_length)\n      skr=share-&gt;base.reloc*share-&gt;base.min_pack_length;\n#endif\n    if (skr != sort_info.filelength)\n      if (mysql_file_chsize(info-&gt;dfile, skr, 0, MYF(0)))\n\tmi_check_print_warning(param,\n\t\t\t       "Can\'t change size of datafile,  error: %d",\n\t\t\t       my_errno);\n  }\n  if (param-&gt;testflag &amp; T_CALC_CHECKSUM)\n    info-&gt;state-&gt;checksum=param-&gt;glob_crc;\n\n  if (mysql_file_chsize(share-&gt;kfile, info-&gt;state-&gt;key_file_length, 0, MYF(0)))\n    mi_check_print_warning(param,\n\t\t\t   "Can\'t change size of indexfile, error: %d", my_errno);\n\n  if (!(param-&gt;testflag &amp; T_SILENT))\n  {\n    if (start_records != info-&gt;state-&gt;records)\n      printf("Data records: %s\\n", llstr(info-&gt;state-&gt;records,llbuff));\n    if (sort_info.dupp)\n      mi_check_print_warning(param,\n\t\t\t     "%s records have been removed",\n\t\t\t     llstr(sort_info.dupp,llbuff));\n  }\n  got_error=0;\n\n  if (&amp;share-&gt;state.state != info-&gt;state)\n    memcpy(&amp;share-&gt;state.state, info-&gt;state, sizeof(*info-&gt;state));\n\nerr:\n  got_error|= flush_blocks(param, share-&gt;key_cache, share-&gt;kfile);\n  /*\n    Destroy the write cache. The master thread did already detach from\n    the share by remove_io_thread() or it was not yet started (if the\n    error happend before creating the thread).\n  */\n  (void) end_io_cache(&amp;info-&gt;rec_cache);\n  /*\n    Destroy the new data cache in case of non-quick repair. All slave\n    threads did either detach from the share by remove_io_thread()\n    already or they were not yet started (if the error happend before\n    creating the threads).\n  */\n  if (!rep_quick)\n    (void) end_io_cache(&amp;new_data_cache);\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file &gt;= 0)\n    {\n      myf flags= 0;\n      if (param-&gt;testflag &amp; T_BACKUP_DATA)\n        flags |= MY_REDEL_MAKE_BACKUP;\n      if (no_copy_stat)\n        flags |= MY_REDEL_NO_COPY_STAT;\n      mysql_file_close(new_file, MYF(0));\n      info-&gt;dfile=new_file= -1;\n      if (change_to_newfile(share-&gt;data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    flags) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)\n  {\n    if (! param-&gt;error_printed)\n      mi_check_print_error(param,"%d when fixing table",my_errno);\n    if (new_file &gt;= 0)\n    {\n      (void) mysql_file_close(new_file, MYF(0));\n      (void) mysql_file_delete(mi_key_file_datatmp,\n                               param-&gt;temp_filename, MYF(MY_WME));\n      if (info-&gt;dfile == new_file) /* Retry with key cache */\n        if (unlikely(mi_open_datafile(info, share, name, -1)))\n          param-&gt;retry_repair= 0; /* Safety */\n    }\n    mi_mark_crashed_on_repair(info);\n  }\n  else if (key_map == share-&gt;state.key_map)\n    share-&gt;state.changed&amp;= ~STATE_NOT_OPTIMIZED_KEYS;\n  share-&gt;state.changed|=STATE_NOT_SORTED_PAGES;\n\n  mysql_cond_destroy(&amp;sort_info.cond);\n  mysql_mutex_destroy(&amp;sort_info.mutex);\n  mysql_mutex_destroy(&amp;param-&gt;print_msg_mutex);\n  param-&gt;need_print_msg_lock= 0;\n\n  my_free(sort_info.ft_buf);\n  my_free(sort_info.key_block);\n  my_free(sort_param);\n  my_free(sort_info.buff);\n  (void) end_io_cache(&amp;param-&gt;read_cache);\n  info-&gt;opt_flag&amp;= ~(READ_CACHE_USED | WRITE_CACHE_USED);\n  if (!got_error &amp;&amp; (param-&gt;testflag &amp; T_UNPACK))\n  {\n    share-&gt;state.header.options[0]&amp;= (uchar) ~HA_OPTION_COMPRESS_RECORD;\n    share-&gt;pack.header_length=0;\n  }\n  DBUG_RETURN(got_error);\n}',
 '  void Compute(OpKernelContext* context) override {\n    const Tensor&amp; indices = context-&gt;input(0);\n    const Tensor&amp; values = context-&gt;input(1);\n    const Tensor&amp; shape = context-&gt;input(2);\n    const Tensor&amp; weights = context-&gt;input(3);\n    bool use_weights = weights.NumElements() &gt; 0;\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    "Input indices must be a 2-dimensional tensor. Got: ",\n                    indices.shape().DebugString()));\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              "Weights and values must have the same shape. Weight shape: ",\n              weights.shape().DebugString(),\n              "; values shape: ", values.shape().DebugString()));\n    }\n\n    OP_REQUIRES(context, shape.NumElements() != 0,\n                errors::InvalidArgument(\n                    "The shape argument requires at least one element."));\n\n    bool is_1d = shape.NumElements() == 1;\n    int num_batches = is_1d ? 1 : shape.flat&lt;int64&gt;()(0);\n    int num_values = values.NumElements();\n\n    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    "Number of values must match first dimension of indices.",\n                    "Got ", num_values,\n                    " values, indices shape: ", indices.shape().DebugString()));\n\n    const auto indices_values = indices.matrix&lt;int64&gt;();\n    const auto values_values = values.flat&lt;T&gt;();\n    const auto weight_values = weights.flat&lt;W&gt;();\n\n    auto per_batch_counts = BatchedMap&lt;W&gt;(num_batches);\n\n    T max_value = 0;\n\n    for (int idx = 0; idx &lt; num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      if (batch &gt;= num_batches) {\n        OP_REQUIRES(context, batch &lt; num_batches,\n                    errors::InvalidArgument(\n                        "Indices value along the first dimension must be ",\n                        "lower than the first index of the shape.", "Got ",\n                        batch, " as batch and ", num_batches,\n                        " as the first dimension of the shape."));\n      }\n      const auto&amp; value = values_values(idx);\n      if (value &gt;= 0 &amp;&amp; (maxlength_ &lt;= 0 || value &lt; maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value &gt; max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse&lt;W&gt;(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }',
 'TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &amp;output));\n  TfLiteTensor* hits;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &amp;hits));\n  const TfLiteTensor* lookup;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &amp;lookup));\n  const TfLiteTensor* key;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &amp;key));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &amp;value));\n\n  const int num_rows = SizeOfDimension(value, 0);\n  TF_LITE_ENSURE(context, num_rows != 0);\n  const int row_bytes = value-&gt;bytes / num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n\n  for (int i = 0; i &lt; SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&amp;(lookup-&gt;data.i32[i]), key-&gt;data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast&lt;char*&gt;(pointer) - (key-&gt;data.raw)) /\n            sizeof(int32_t);\n    }\n\n    if (idx &gt;= num_rows || idx &lt; 0) {\n      if (output-&gt;type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output-&gt;data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits-&gt;data.uint8[i] = 0;\n    } else {\n      if (output-&gt;type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output-&gt;data.raw + i * row_bytes,\n               value-&gt;data.raw + idx * row_bytes, row_bytes);\n      }\n      hits-&gt;data.uint8[i] = 1;\n    }\n  }\n  if (output-&gt;type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n\n  return kTfLiteOk;\n}',
 'static s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)\n{\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, "forbidden_zero_bit");\n\t\tgf_bs_read_int_log(bs, 2, "nal_ref_idc");\n\t\tgf_bs_read_int_log(bs, 5, "nal_unit_type");\n\t}\n\tpps_id = gf_bs_read_ue_log(bs, "pps_id");\n\tif (pps_id &gt;= 255) {\n\t\treturn -1;\n\t}\n\tpps = &amp;avc-&gt;pps[pps_id];\n\tpps-&gt;id = pps_id;\n\n\tif (!pps-&gt;status) pps-&gt;status = 1;\n\tpps-&gt;sps_id = gf_bs_read_ue_log(bs, "sps_id");\n\tif (pps-&gt;sps_id &gt;= 32) {\n\t\tpps-&gt;sps_id = 0;\n\t\treturn -1;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice referring to the pps*/\n\tif (!avc-&gt;sps[pps-&gt;sps_id].state &amp;&amp; !avc-&gt;sps[pps-&gt;sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\treturn -1;\n\t}\n\tavc-&gt;pps_active_idx = pps-&gt;id; /*set active sps*/\n\tavc-&gt;sps_active_idx = pps-&gt;sps_id; /*set active sps*/\n\tpps-&gt;entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, "entropy_coding_mode_flag");\n\tpps-&gt;pic_order_present = gf_bs_read_int_log(bs, 1, "pic_order_present");\n\tpps-&gt;slice_group_count = gf_bs_read_ue_log(bs, "slice_group_count_minus1") + 1;\n\tif (pps-&gt;slice_group_count &gt; 1) {\n\t\tu32 iGroup;\n\t\tpps-&gt;mb_slice_group_map_type = gf_bs_read_ue_log(bs, "mb_slice_group_map_type");\n\t\tif (pps-&gt;mb_slice_group_map_type == 0) {\n\t\t\tfor (iGroup = 0; iGroup &lt;= pps-&gt;slice_group_count - 1; iGroup++)\n\t\t\t\tgf_bs_read_ue_log_idx(bs, "run_length_minus1", iGroup);\n\t\t}\n\t\telse if (pps-&gt;mb_slice_group_map_type == 2) {\n\t\t\tfor (iGroup = 0; iGroup &lt; pps-&gt;slice_group_count - 1; iGroup++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, "top_left", iGroup);\n\t\t\t\tgf_bs_read_ue_log_idx(bs, "bottom_right", iGroup);\n\t\t\t}\n\t\t}\n\t\telse if (pps-&gt;mb_slice_group_map_type == 3 || pps-&gt;mb_slice_group_map_type == 4 || pps-&gt;mb_slice_group_map_type == 5) {\n\t\t\tgf_bs_read_int_log(bs, 1, "slice_group_change_direction_flag");\n\t\t\tgf_bs_read_ue_log(bs, "slice_group_change_rate_minus1");\n\t\t}\n\t\telse if (pps-&gt;mb_slice_group_map_type == 6) {\n\t\t\tu32 i;\n\t\t\tpps-&gt;pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, "pic_size_in_map_units_minus1");\n\t\t\tfor (i = 0; i &lt;= pps-&gt;pic_size_in_map_units_minus1; i++) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, (u32)ceil(log(pps-&gt;slice_group_count) / log(2)), "slice_group_id", i);\n\t\t\t}\n\t\t}\n\t}\n\tpps-&gt;num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, "num_ref_idx_l0_default_active_minus1");\n\tpps-&gt;num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, "num_ref_idx_l1_default_active_minus1");\n\n\t/*\n\tif ((pps-&gt;ref_count[0] &gt; 32) || (pps-&gt;ref_count[1] &gt; 32)) goto exit;\n\t*/\n\n\tpps-&gt;weighted_pred_flag = gf_bs_read_int_log(bs, 1, "weighted_pred_flag");\n\tgf_bs_read_int_log(bs, 2, "weighted_bipred_idc");\n\tgf_bs_read_se_log(bs, "init_qp_minus26");\n\tgf_bs_read_se_log(bs, "init_qs_minus26");\n\tgf_bs_read_se_log(bs, "chroma_qp_index_offset");\n\tpps-&gt;deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, "deblocking_filter_control_present_flag");\n\tgf_bs_read_int_log(bs, 1, "constrained_intra_pred");\n\tpps-&gt;redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, "redundant_pic_cnt_present");\n\n\treturn pps_id;\n}',
 'static int __vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct kvm *kvm = vcpu-&gt;kvm;\n\n\tvcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);\n\tr = vapic_enter(vcpu);\n\tif (r) {\n\t\tsrcu_read_unlock(&amp;kvm-&gt;srcu, vcpu-&gt;srcu_idx);\n\t\treturn r;\n\t}\n\n\tr = 1;\n\twhile (r &gt; 0) {\n\t\tif (vcpu-&gt;arch.mp_state == KVM_MP_STATE_RUNNABLE &amp;&amp;\n\t\t    !vcpu-&gt;arch.apf.halted)\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\telse {\n\t\t\tsrcu_read_unlock(&amp;kvm-&gt;srcu, vcpu-&gt;srcu_idx);\n\t\t\tkvm_vcpu_block(vcpu);\n\t\t\tvcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);\n\t\t\tif (kvm_check_request(KVM_REQ_UNHALT, vcpu)) {\n\t\t\t\tkvm_apic_accept_events(vcpu);\n\t\t\t\tswitch(vcpu-&gt;arch.mp_state) {\n\t\t\t\tcase KVM_MP_STATE_HALTED:\n\t\t\t\t\tvcpu-&gt;arch.pv.pv_unhalted = false;\n\t\t\t\t\tvcpu-&gt;arch.mp_state =\n\t\t\t\t\t\tKVM_MP_STATE_RUNNABLE;\n\t\t\t\tcase KVM_MP_STATE_RUNNABLE:\n\t\t\t\t\tvcpu-&gt;arch.apf.halted = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tr = -EINTR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (r &lt;= 0)\n\t\t\tbreak;\n\n\t\tclear_bit(KVM_REQ_PENDING_TIMER, &amp;vcpu-&gt;requests);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\n\t\tif (dm_request_for_irq_injection(vcpu)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu-&gt;run-&gt;exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu-&gt;stat.request_irq_exits;\n\t\t}\n\n\t\tkvm_check_async_pf_completion(vcpu);\n\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu-&gt;run-&gt;exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu-&gt;stat.signal_exits;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tsrcu_read_unlock(&amp;kvm-&gt;srcu, vcpu-&gt;srcu_idx);\n\t\t\tkvm_resched(vcpu);\n\t\t\tvcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);\n\t\t}\n\t}\n\n\tsrcu_read_unlock(&amp;kvm-&gt;srcu, vcpu-&gt;srcu_idx);\n\n\tvapic_exit(vcpu);\n\n\treturn r;\n}',
 'snmp_mib_find_next(snmp_oid_t *oid)\n{\n  snmp_mib_resource_t *resource;\n\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource-&gt;next) {\n\n    if(snmp_mib_cmp_oid(&amp;resource-&gt;oid, oid) &gt; 0) {\n      return resource;\n    }\n  }\n\n  return NULL;\n}',
 'static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int intermed_channel,\n\tconst struct iw_csdescr *out_csdescr)\n{\n\tint i,j;\n\tint z;\n\tint k;\n\tint retval=0;\n\tiw_tmpsample tmpsamp;\n\tiw_tmpsample alphasamp = 0.0;\n\tiw_tmpsample *inpix_tofree = NULL; // Used if we need a separate temp buffer for input samples\n\tiw_tmpsample *outpix_tofree = NULL; // Used if we need a separate temp buffer for output samples\n\t// Do any of the output channels use error-diffusion dithering?\n\tint using_errdiffdither = 0;\n\tint output_channel;\n\tint is_alpha_channel;\n\tint bkgd_has_transparency;\n\tdouble tmpbkgdalpha=0.0;\n\tint alt_bkgd = 0; // Nonzero if we should use bkgd2 for this sample\n\tstruct iw_resize_settings *rs = NULL;\n\tint ditherfamily, dithersubtype;\n\tstruct iw_channelinfo_intermed *int_ci;\n\tstruct iw_channelinfo_out *out_ci;\n\n\tiw_tmpsample *in_pix = NULL;\n\tiw_tmpsample *out_pix = NULL;\n\tint num_in_pix;\n\tint num_out_pix;\n\n\tnum_in_pix = ctx-&gt;intermed_canvas_width;\n\tnum_out_pix = ctx-&gt;img2.width;\n\n\tint_ci = &amp;ctx-&gt;intermed_ci[intermed_channel];\n\toutput_channel = int_ci-&gt;corresponding_output_channel;\n\tout_ci = &amp;ctx-&gt;img2_ci[output_channel];\n\tis_alpha_channel = (int_ci-&gt;channeltype==IW_CHANNELTYPE_ALPHA);\n\tbkgd_has_transparency = iw_bkgd_has_transparency(ctx);\n\n\tinpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));\n\tin_pix = inpix_tofree;\n\n\t// We need an output buffer.\n\toutpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample));\n\tif(!outpix_tofree) goto done;\n\tout_pix = outpix_tofree;\n\n\t// Decide if the \'nearest color table\' optimization can be used\n\tif(ctx-&gt;nearest_color_table &amp;&amp; !is_alpha_channel &amp;&amp;\n\t   out_ci-&gt;ditherfamily==IW_DITHERFAMILY_NONE &amp;&amp;\n\t   out_ci-&gt;color_count==0)\n\t{\n\t\tout_ci-&gt;use_nearest_color_table = 1;\n\t}\n\telse {\n\t\tout_ci-&gt;use_nearest_color_table = 0;\n\t}\n\n\t// Seed the PRNG, if necessary.\n\tditherfamily = out_ci-&gt;ditherfamily;\n\tdithersubtype = out_ci-&gt;dithersubtype;\n\tif(ditherfamily==IW_DITHERFAMILY_RANDOM) {\n\t\t// Decide what random seed to use. The alpha channel always has its own\n\t\t// seed. If using "r" (not "r2") dithering, every channel has its own seed.\n\t\tif(dithersubtype==IW_DITHERSUBTYPE_SAMEPATTERN &amp;&amp; out_ci-&gt;channeltype!=IW_CHANNELTYPE_ALPHA)\n\t\t{\n\t\t\tiwpvt_prng_set_random_seed(ctx-&gt;prng,ctx-&gt;random_seed);\n\t\t}\n\t\telse {\n\t\t\tiwpvt_prng_set_random_seed(ctx-&gt;prng,ctx-&gt;random_seed+out_ci-&gt;channeltype);\n\t\t}\n\t}\n\n\t// Initialize Floyd-Steinberg dithering.\n\tif(output_channel&gt;=0 &amp;&amp; out_ci-&gt;ditherfamily==IW_DITHERFAMILY_ERRDIFF) {\n\t\tusing_errdiffdither = 1;\n\t\tfor(i=0;i&lt;ctx-&gt;img2.width;i++) {\n\t\t\tfor(k=0;k&lt;IW_DITHER_MAXROWS;k++) {\n\t\t\t\tctx-&gt;dither_errors[k][i] = 0.0;\n\t\t\t}\n\t\t}\n\t}\n\n\trs=&amp;ctx-&gt;resize_settings[IW_DIMENSION_H];\n\n\t// If the resize context for this dimension already exists, we should be\n\t// able to reuse it. Otherwise, create a new one.\n\tif(!rs-&gt;rrctx) {\n\t\trs-&gt;rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci-&gt;channeltype,\n\t\t\tnum_in_pix, num_out_pix);\n\t\tif(!rs-&gt;rrctx) goto done;\n\t}\n\n\tfor(j=0;j&lt;ctx-&gt;intermed_canvas_height;j++) {\n\n\t\t// As needed, either copy the input pixels to a temp buffer (inpix, which\n\t\t// ctx-&gt;in_pix already points to), or point ctx-&gt;in_pix directly to the\n\t\t// intermediate data.\n\t\tif(is_alpha_channel) {\n\t\t\tfor(i=0;i&lt;num_in_pix;i++) {\n\t\t\t\tinpix_tofree[i] = ctx-&gt;intermediate_alpha32[((size_t)j)*ctx-&gt;intermed_canvas_width+i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(i=0;i&lt;num_in_pix;i++) {\n\t\t\t\tinpix_tofree[i] = ctx-&gt;intermediate32[((size_t)j)*ctx-&gt;intermed_canvas_width+i];\n\t\t\t}\n\t\t}\n\n\t\t// Resize ctx-&gt;in_pix to ctx-&gt;out_pix.\n\t\tiwpvt_resize_row_main(rs-&gt;rrctx,in_pix,out_pix);\n\n\t\tif(ctx-&gt;intclamp)\n\t\t\tclamp_output_samples(ctx,out_pix,num_out_pix);\n\n\t\t// If necessary, copy the resized samples to the final_alpha image\n\t\tif(is_alpha_channel &amp;&amp; outpix_tofree &amp;&amp; ctx-&gt;final_alpha32) {\n\t\t\tfor(i=0;i&lt;num_out_pix;i++) {\n\t\t\t\tctx-&gt;final_alpha32[((size_t)j)*ctx-&gt;img2.width+i] = (iw_float32)outpix_tofree[i];\n\t\t\t}\n\t\t}\n\n\t\t// Now convert the out_pix and put them in the final image.\n\n\t\tif(output_channel == -1) {\n\t\t\t// No corresponding output channel.\n\t\t\t// (Presumably because this is an alpha channel that\'s being\n\t\t\t// removed because we\'re applying a background.)\n\t\t\tgoto here;\n\t\t}\n\n\t\tfor(z=0;z&lt;ctx-&gt;img2.width;z++) {\n\t\t\t// For decent Floyd-Steinberg dithering, we need to process alternate\n\t\t\t// rows in reverse order.\n\t\t\tif(using_errdiffdither &amp;&amp; (j%2))\n\t\t\t\ti=ctx-&gt;img2.width-1-z;\n\t\t\telse\n\t\t\t\ti=z;\n\n\t\t\ttmpsamp = out_pix[i];\n\n\t\t\tif(ctx-&gt;bkgd_checkerboard) {\n\t\t\t\talt_bkgd = (((ctx-&gt;bkgd_check_origin[IW_DIMENSION_H]+i)/ctx-&gt;bkgd_check_size)%2) !=\n\t\t\t\t\t(((ctx-&gt;bkgd_check_origin[IW_DIMENSION_V]+j)/ctx-&gt;bkgd_check_size)%2);\n\t\t\t}\n\n\t\t\tif(bkgd_has_transparency) {\n\t\t\t\ttmpbkgdalpha = alt_bkgd ? ctx-&gt;bkgd2alpha : ctx-&gt;bkgd1alpha;\n\t\t\t}\n\n\t\t\tif(int_ci-&gt;need_unassoc_alpha_processing) {\n\t\t\t\t// Convert color samples back to unassociated alpha.\n\t\t\t\talphasamp = ctx-&gt;final_alpha32[((size_t)j)*ctx-&gt;img2.width + i];\n\n\t\t\t\tif(alphasamp!=0.0) {\n\t\t\t\t\ttmpsamp /= alphasamp;\n\t\t\t\t}\n\n\t\t\t\tif(ctx-&gt;apply_bkgd &amp;&amp; ctx-&gt;apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE) {\n\t\t\t\t\t// Apply a background color (or checkerboard pattern).\n\t\t\t\t\tdouble bkcolor;\n\t\t\t\t\tbkcolor = alt_bkgd ? out_ci-&gt;bkgd2_color_lin : out_ci-&gt;bkgd1_color_lin;\n\n\t\t\t\t\tif(bkgd_has_transparency) {\n\t\t\t\t\t\ttmpsamp = tmpsamp*alphasamp + bkcolor*tmpbkgdalpha*(1.0-alphasamp);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttmpsamp = tmpsamp*alphasamp + bkcolor*(1.0-alphasamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(is_alpha_channel &amp;&amp; bkgd_has_transparency) {\n\t\t\t\t// Composite the alpha of the foreground over the alpha of the background.\n\t\t\t\ttmpsamp = tmpsamp + tmpbkgdalpha*(1.0-tmpsamp);\n\t\t\t}\n\n\t\t\tif(ctx-&gt;img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)\n\t\t\t\tput_sample_convert_from_linear_flt(ctx,tmpsamp,i,j,output_channel,out_csdescr);\n\t\t\telse\n\t\t\t\tput_sample_convert_from_linear(ctx,tmpsamp,i,j,output_channel,out_csdescr);\n\n\t\t}\n\n\t\tif(using_errdiffdither) {\n\t\t\t// Move "next row" error data to "this row", and clear the "next row".\n\t\t\t// TODO: Obviously, it would be more efficient to just swap pointers\n\t\t\t// to the rows.\n\t\t\tfor(i=0;i&lt;ctx-&gt;img2.width;i++) {\n\t\t\t\t// Move data in all rows but the first row up one row.\n\t\t\t\tfor(k=0;k&lt;IW_DITHER_MAXROWS-1;k++) {\n\t\t\t\t\tctx-&gt;dither_errors[k][i] = ctx-&gt;dither_errors[k+1][i];\n\t\t\t\t}\n\t\t\t\t// Clear the last row.\n\t\t\t\tctx-&gt;dither_errors[IW_DITHER_MAXROWS-1][i] = 0.0;\n\t\t\t}\n\t\t}\n\nhere:\n\t\t;\n\t}\n\n\tretval=1;\n\ndone:\n\tif(rs &amp;&amp; rs-&gt;disable_rrctx_cache &amp;&amp; rs-&gt;rrctx) {\n\t\t// In some cases, the channels may need different resize contexts.\n\t\t// Delete the current context, so that it doesn\'t get reused.\n\t\tiwpvt_resize_rows_done(rs-&gt;rrctx);\n\t\trs-&gt;rrctx = NULL;\n\t}\n\tif(inpix_tofree) iw_free(ctx,inpix_tofree);\n\tif(outpix_tofree) iw_free(ctx,outpix_tofree);\n\n\treturn retval;\n}',
 'snmp_ber_encode_null(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  (*out_len)++;\n  *out-- = 0x00;\n  out = snmp_ber_encode_type(out, out_len, type);\n\n  return out;\n}',
 'compile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    char_u\t*line_to_free = NULL;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in "def_functions".\n    if (ufunc-&gt;uf_dfunc_idx &gt; 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc-&gt;uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc-&gt;df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc-&gt;df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc-&gt;df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&amp;dfunc-&gt;df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    ufunc-&gt;uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&amp;cctx.ctx_locals, sizeof(lvar_T), 10);\n    ga_init2(&amp;cctx.ctx_type_stack, sizeof(type_T *), 50);\n    ga_init2(&amp;cctx.ctx_imports, sizeof(imported_T), 10);\n    cctx.ctx_type_list = &amp;ufunc-&gt;uf_type_list;\n    ga_init2(&amp;cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &amp;cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc-&gt;uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don\'t use the flag from ":legacy" here.\n    cmdmod.cmod_flags &amp;= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (ufunc-&gt;uf_def_args.ga_len &gt; 0)\n    {\n\tint\tcount = ufunc-&gt;uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc-&gt;uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc-&gt;uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i &lt; count; ++i)\n\t{\n\t    garray_T\t*stack = &amp;cctx.ctx_type_stack;\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr-&gt;ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&amp;cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc-&gt;uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc-&gt;uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&amp;arg, &amp;cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = ((type_T **)stack-&gt;ga_data)[stack-&gt;ga_len - 1];\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc-&gt;uf_arg_types[arg_idx] == &amp;t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc-&gt;uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc-&gt;uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &amp;cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&amp;cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr-&gt;ga_data) + jump_instr_idx;\n\t    isn-&gt;isn_arg.jumparg.jump_where = instr-&gt;ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc-&gt;uf_args_visible = ufunc-&gt;uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL &amp;&amp; *line == \'|\')\n\t    // the line continues after a \'|\'\n\t    ++line;\n\telse if (line != NULL &amp;&amp; *skipwhite(line) != NUL\n\t\t&amp;&amp; !(*line == \'#\' &amp;&amp; (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_arg), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL &amp;&amp; vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&amp;cctx, FALSE);\n\t    if (cctx.ctx_lnum &gt;= ufunc-&gt;uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&amp;cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tvim_free(line_to_free);\n\t\tline_to_free = line;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &amp;line;\n\tea.cmd = skipwhite(line);\n\n\tif (*ea.cmd == \'#\')\n\t{\n\t    // "#" starts a comment\n\t    line = (char_u *)"";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE &amp;&amp; cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  &amp;&amp; cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&amp;cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&amp;cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG &amp;&amp; cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  &amp;&amp; cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&amp;cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case \'}\':\n\t\t{\n\t\t    // "}" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope-&gt;se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&amp;cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case \'{\':\n\t\t// "{" starts a block scope\n\t\t// "{\'a\': 1}-&gt;func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &amp;cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&amp;ea, &amp;errormsg, &amp;local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t{\n\t    if (errormsg != NULL)\n\t\tgoto erret;\n\t    // empty line or comment\n\t    line = (char_u *)"";\n\t    continue;\n\t}\n\tgenerate_cmdmods(&amp;cctx, &amp;local_cmdmod);\n\tundo_cmdmod(&amp;local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p &gt;= line; --p)\n\t{\n\t    if (*p == \':\')\n\t\tstarts_with_colon = TRUE;\n\t    if (p &lt; ea.cmd &amp;&amp; !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip ":call" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags &amp; CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&amp;ea.cmd, "call", 3))\n\t    {\n\t\tif (*ea.cmd == \'(\')\n\t\t    // not for "call()"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&amp;ea, &amp;line, &amp;cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * \'text\'-&gt;func() should not be confused with \'a mark\n\t * "++nr" and "--nr" are eval commands\n\t * in "$ENV-&gt;func()" the "$" is not a range\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != \'$\' || starts_with_colon)\n\t\t&amp;&amp; (starts_with_colon || !(*cmd == \'\\\'\'\n\t\t       || (cmd[0] == cmd[1] &amp;&amp; (*cmd == \'+\' || *cmd == \'-\')))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd &gt; cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   &amp;&amp; !(local_cmdmod.cmod_flags &amp; CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&amp;cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&amp;ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags &amp; CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &amp;cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\temsg(_(e_ambiguous_use_of_user_defined_command));\n\t    goto erret;\n\t}\n\n\t// When using ":legacy cmd" always use compile_exec().\n\tif (local_cmdmod.cmod_flags &amp; CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // ":legacy return expr" needs to be handled differently.\n\t    if (checkforcmd(&amp;start, "return", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd &amp;&amp; ea.cmdidx != CMD_SIZE)\n\t{\n\t    if (cctx.ctx_skip == SKIP_YES &amp;&amp; ea.cmdidx != CMD_eval)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else if (ea.cmdidx != CMD_eval)\n\t    {\n\t\t// CMD_var cannot happen, compile_assignment() above would be\n\t\t// used.  Most likely an assignment to a non-existing variable.\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&amp;&amp; ea.cmdidx != CMD_elseif\n\t\t&amp;&amp; ea.cmdidx != CMD_else\n\t\t&amp;&amp; ea.cmdidx != CMD_endif\n\t\t&amp;&amp; ea.cmdidx != CMD_endfor\n\t\t&amp;&amp; ea.cmdidx != CMD_endwhile\n\t\t&amp;&amp; ea.cmdidx != CMD_catch\n\t\t&amp;&amp; ea.cmdidx != CMD_finally\n\t\t&amp;&amp; ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    &amp;&amp; ea.cmdidx != CMD_write &amp;&amp; ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx &gt;= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt &amp; EX_BANG) &amp;&amp; *p == \'!\')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&amp;ea, &amp;cctx);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags &amp; CMOD_LEGACY, &amp;cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &amp;ea, ea.cmdidx, &amp;cctx);\n\t\t    if (line == p)\n\t\t\tline = NULL;\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &amp;ea, &amp;cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &amp;cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &amp;cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &amp;cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &amp;cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &amp;cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &amp;cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &amp;cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &amp;cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &amp;cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &amp;cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &amp;cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &amp;cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &amp;cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &amp;cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &amp;cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &amp;cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &amp;cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &amp;ea, &amp;cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)"";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &amp;ea, &amp;cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &amp;ea, &amp;cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &amp;ea, &amp;cctx);\n#else\n\t\t    ex_ni(&amp;ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&amp;ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don\'t check for a next command here.\n\t\t    line = (char_u *)"";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, \'\\n\') == NULL)\n\t\t\tline = compile_exec(line, &amp;ea, &amp;cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &amp;cctx);\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &amp;ea, &amp;cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&amp;cctx);\n\n\tif (cctx.ctx_type_stack.ga_len &lt; 0)\n\t{\n\t    iemsg("Type stack underflow");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope-&gt;se_type == IF_SCOPE)\n\t    emsg(_(e_endif));\n\telse if (cctx.ctx_scope-&gt;se_type == WHILE_SCOPE)\n\t    emsg(_(e_endwhile));\n\telse if (cctx.ctx_scope-&gt;se_type == FOR_SCOPE)\n\t    emsg(_(e_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc-&gt;uf_ret_type-&gt;tt_type == VAR_UNKNOWN)\n\t    ufunc-&gt;uf_ret_type = &amp;t_void;\n\telse if (ufunc-&gt;uf_ret_type-&gt;tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&amp;cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with ":silent!" and there was an error don\'t consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc-&gt;uf_dfunc_idx;\n\tdfunc-&gt;df_deleted = FALSE;\n\tdfunc-&gt;df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc-&gt;df_instr_prof = instr-&gt;ga_data;\n\t    dfunc-&gt;df_instr_prof_count = instr-&gt;ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc-&gt;df_instr_debug = instr-&gt;ga_data;\n\t    dfunc-&gt;df_instr_debug_count = instr-&gt;ga_len;\n\t}\n\telse\n\t{\n\t    dfunc-&gt;df_instr = instr-&gt;ga_data;\n\t    dfunc-&gt;df_instr_count = instr-&gt;ga_len;\n\t}\n\tdfunc-&gt;df_varcount = dfunc-&gt;df_var_names.ga_len;\n\tdfunc-&gt;df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc-&gt;uf_flags |= FC_CLOSURE;\n\tufunc-&gt;uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc-&gt;uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc-&gt;uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc-&gt;df_name);\n\tga_clear_strings(&amp;dfunc-&gt;df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc-&gt;df_deleted &amp;&amp; new_def_function\n\t\t\t    &amp;&amp; ufunc-&gt;uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc-&gt;uf_dfunc_idx = 0;\n\t}\n\tufunc-&gt;uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&amp;cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    vim_free(line_to_free);\n    free_imported(&amp;cctx);\n    free_locals(&amp;cctx);\n    ga_clear(&amp;cctx.ctx_type_stack);\n    return ret;\n}',
 "void VariableUnserializer::unserializeProp(ObjectData* obj,\n                                           const String&amp; key,\n                                           Class* ctx,\n                                           const String&amp; realKey,\n                                           int nProp) {\n\n  auto const cls = obj-&gt;getVMClass();\n  auto const lookup = cls-&gt;getDeclPropSlot(ctx, key.get());\n  auto const slot = lookup.slot;\n  tv_lval t;\n\n  if (slot == kInvalidSlot || !lookup.accessible) {\n    // Unserialize as a dynamic property. If this is the first, we need to\n    // pre-allocate space in the array to ensure the elements don't move during\n    // unserialization.\n    obj-&gt;reserveDynProps(nProp);\n    t = obj-&gt;makeDynProp(realKey.get());\n  } else {\n    // We'll check if this doesn't violate the type-hint once we're done\n    // unserializing all the props.\n    t = obj-&gt;getPropLval(ctx, key.get());\n  }\n\n  unserializePropertyValue(t, nProp);\n  if (!RuntimeOption::RepoAuthoritative) return;\n  if (!Repo::get().global().HardPrivatePropInference) return;\n\n  /*\n   * We assume for performance reasons in repo authoriative mode that\n   * we can see all the sets to private properties in a class.\n   *\n   * It's a hole in this if we don't check unserialization doesn't\n   * violate what we've seen, which we handle by throwing if the repo\n   * was built with this option.\n   */\n  if (UNLIKELY(slot == kInvalidSlot)) return;\n  auto const repoTy = cls-&gt;declPropRepoAuthType(slot);\n  if (LIKELY(tvMatchesRepoAuthType(*t, repoTy))) return;\n  if (t.type() == KindOfUninit &amp;&amp;\n      (cls-&gt;declProperties()[slot].attrs &amp; AttrLateInit)) {\n    return;\n  }\n  throwUnexpectedType(key, obj, *t);\n}",
 'ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)\n{\n    ssize_t                    n;\n    ngx_int_t                  rc;\n    ngx_str_t                  l;\n    ngx_mail_core_srv_conf_t  *cscf;\n\n    if (s-&gt;buffer-&gt;last &lt; s-&gt;buffer-&gt;end) {\n\n        n = c-&gt;recv(c, s-&gt;buffer-&gt;last, s-&gt;buffer-&gt;end - s-&gt;buffer-&gt;last);\n\n        if (n == NGX_ERROR || n == 0) {\n            ngx_mail_close_connection(c);\n            return NGX_ERROR;\n        }\n\n        if (n &gt; 0) {\n            s-&gt;buffer-&gt;last += n;\n        }\n\n        if (n == NGX_AGAIN) {\n            if (s-&gt;buffer-&gt;pos == s-&gt;buffer-&gt;last) {\n                return NGX_AGAIN;\n            }\n        }\n    }\n\n    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n\n    rc = cscf-&gt;protocol-&gt;parse_command(s);\n\n    if (rc == NGX_AGAIN) {\n\n        if (s-&gt;buffer-&gt;last &lt; s-&gt;buffer-&gt;end) {\n            return rc;\n        }\n\n        l.len = s-&gt;buffer-&gt;last - s-&gt;buffer-&gt;start;\n        l.data = s-&gt;buffer-&gt;start;\n\n        ngx_log_error(NGX_LOG_INFO, c-&gt;log, 0,\n                      "client sent too long command \\"%V\\"", &amp;l);\n\n        s-&gt;quit = 1;\n\n        return NGX_MAIL_PARSE_INVALID_COMMAND;\n    }\n\n    if (rc == NGX_MAIL_PARSE_INVALID_COMMAND) {\n\n        s-&gt;errors++;\n\n        if (s-&gt;errors &gt;= cscf-&gt;max_errors) {\n            ngx_log_error(NGX_LOG_INFO, c-&gt;log, 0,\n                          "client sent too many invalid commands");\n            s-&gt;quit = 1;\n        }\n\n        return rc;\n    }\n\n    if (rc == NGX_IMAP_NEXT) {\n        return rc;\n    }\n\n    if (rc == NGX_ERROR) {\n        ngx_mail_close_connection(c);\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}',
 'void jas_matrix_asr(jas_matrix_t *matrix, int n)\n{\n\tjas_matind_t i;\n\tjas_matind_t j;\n\tjas_seqent_t *rowstart;\n\tjas_matind_t rowstep;\n\tjas_seqent_t *data;\n\n\tassert(n &gt;= 0);\n\tif (jas_matrix_numrows(matrix) &gt; 0 &amp;&amp; jas_matrix_numcols(matrix) &gt; 0) {\n\t\tassert(matrix-&gt;rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix-&gt;numrows_, rowstart = matrix-&gt;rows_[0]; i &gt; 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix-&gt;numcols_, data = rowstart; j &gt; 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data &gt;&gt;= n;\n\t\t\t\t*data = jas_seqent_asr(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}',
 'static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  if (data != (unsigned char *) NULL) \\\n    data=(unsigned char *) RelinquishMagickMemory(data); \\\n  if (stream_info != (DCMStreamInfo *) NULL) \\\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    colors,\n    height,\n    length,\n    number_scenes,\n    quantum,\n    status,\n    width;\n\n  ssize_t\n    count,\n    scene;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info-&gt;signature == MagickCoreSignature);\n  if (image_info-&gt;debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",\n      image_info-&gt;filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception-&gt;signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image-&gt;depth=8UL;\n  image-&gt;endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  data=(unsigned char *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,"ImproperImageHeader");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,"DICM",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset &lt; 0)\n        ThrowDCMException(CorruptImageError,"ImproperImageHeader");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,"MONOCHROME1 ",MagickPathExtent);\n  info.polarity=MagickFalse;\n  info.scale=(Quantum *) NULL;\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.significant_bits=0;\n  info.rescale=MagickFalse;\n  info.rescale_intercept=0.0;\n  info.rescale_slope=1.0;\n  info.window_center=0.0;\n  info.window_width=0.0;\n  data=(unsigned char *) NULL;\n  element=0;\n  explicit_vr[2]=\'\\0\';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  number_scenes=1;\n  sequence=MagickFalse;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image-&gt;offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) &amp;&amp; (image-&gt;endian == MSBEndian))\n      {\n        group=(unsigned short) ((group &lt;&lt; 8) | ((group &gt;&gt; 8) &amp; 0xFF));\n        element=(unsigned short) ((element &lt;&lt; 8) | ((element &gt;&gt; 8) &amp; 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group &lt; 0xffff; i++)\n      if ((group == dicom_info[i].group) &amp;&amp; (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowDCMException(CorruptImageError,"ImproperImageHeader");\n    /*\n      Check for "explicitness", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) &amp;&amp; (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &amp;&amp;\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) &amp;&amp; (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) &amp;&amp; (strncmp(implicit_vr,"xs",2) == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,"!!",2) == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset &lt; 0)\n          ThrowDCMException(CorruptImageError,"ImproperImageHeader");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strncmp(explicit_vr,"OB",2) == 0) ||\n            (strncmp(explicit_vr,"UN",2) == 0) ||\n            (strncmp(explicit_vr,"OW",2) == 0) ||\n            (strncmp(explicit_vr,"SQ",2) == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=ReadBlobLSBSignedLong(image);\n        else\n          datum=ReadBlobSignedLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strncmp(implicit_vr,"SS",2) == 0) ||\n            (strncmp(implicit_vr,"US",2) == 0))\n          quantum=2;\n        else\n          if ((strncmp(implicit_vr,"UL",2) == 0) ||\n              (strncmp(implicit_vr,"SL",2) == 0) ||\n              (strncmp(implicit_vr,"FL",2) == 0))\n            quantum=4;\n          else\n            if (strncmp(implicit_vr,"FD",2) != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info-&gt;verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]=\'\\0\';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &amp;&amp;\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)",\n          (unsigned long) image-&gt;offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout," %s",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,": ");\n      }\n    if ((sequence == MagickFalse) &amp;&amp; (group == 0x7FE0) &amp;&amp; (element == 0x0010))\n      {\n        if (image_info-&gt;verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,"\\n");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) &amp;&amp; (quantum == 1))\n      datum=ReadBlobByte(image);\n    else\n      if ((length == 1) &amp;&amp; (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n      else\n        if ((length == 1) &amp;&amp; (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedLong(image);\n            else\n              datum=ReadBlobSignedLong(image);\n          }\n        else\n          if ((quantum != 0) &amp;&amp; (length != 0))\n            {\n              if (length &gt; GetBlobSize(image))\n                ThrowReaderException(CorruptImageError,\n                  "InsufficientImageDataInFile");\n              if (~length &gt;= 1)\n                data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info-&gt;verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,"count=%d quantum=%d "\n                      "length=%d group=%d\\n",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowDCMException(CorruptImageError,\n                     "InsufficientImageDataInFile");\n                }\n              data[length*quantum]=\'\\0\';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n\n    if ((unsigned int) ((group &lt;&lt; 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MagickPathExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) &amp;&amp; (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info-&gt;verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    "Corrupted image - trying explicit format\\n");\n                break;\n              }\n            *transfer_syntax=\'\\0\';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MagickPathExtent);\n            if (image_info-&gt;verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,"transfer_syntax=%s\\n",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,"1.2.840.10008.1.2",17) == 0)\n              {\n                int\n                  subtype,\n                  type;\n\n                type=1;\n                subtype=0;\n                if (strlen(transfer_syntax) &gt; 17)\n                  {\n                    count=(ssize_t) sscanf(transfer_syntax+17,".%d.%d",&amp;type,\n                      &amp;subtype);\n                    if (count &lt; 1)\n                      ThrowDCMException(CorruptImageError,\n                        "ImproperImageHeader");\n                  }\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image-&gt;endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image-&gt;endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype &gt;= 80) &amp;&amp; (subtype &lt;= 81))\n                      image-&gt;compression=JPEGCompression;\n                    else\n                      if ((subtype &gt;= 90) &amp;&amp; (subtype &lt;= 93))\n                        image-&gt;compression=JPEG2000Compression;\n                      else\n                        image-&gt;compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image-&gt;compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            info.samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n            /*\n              Photometric interpretation.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            for (i=0; i &lt; (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n              photometric[i]=(char) data[i];\n            photometric[i]=\'\\0\';\n            info.polarity=LocaleCompare(photometric,"MONOCHROME1 ") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image-&gt;interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n            /*\n              Number of frames.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            number_scenes=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            info.bits_allocated=(size_t) datum;\n            info.bytes_per_pixel=1;\n            if (datum &gt; 8)\n              info.bytes_per_pixel=2;\n            info.depth=info.bits_allocated;\n            if (info.depth &gt; 32)\n              ThrowDCMException(CorruptImageError,"ImproperImageHeader");\n            info.max_value=(1UL &lt;&lt; info.bits_allocated)-1;\n            image-&gt;depth=info.depth;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            info.significant_bits=(size_t) datum;\n            info.bytes_per_pixel=1;\n            if (info.significant_bits &gt; 8)\n              info.bytes_per_pixel=2;\n            info.depth=info.significant_bits;\n            if (info.depth &gt; 32)\n              ThrowDCMException(CorruptImageError,"ImproperImageHeader");\n            info.max_value=(1UL &lt;&lt; info.significant_bits)-1;\n            info.mask=(size_t) GetQuantumRange(info.significant_bits);\n            image-&gt;depth=info.depth;\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            info.signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              info.window_center=StringToDouble((char *) data, (char **) NULL);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              info.window_width=StringToDouble((char *) data, (char **) NULL);\n            break;\n          }\n          case 0x1052:\n          {\n            /*\n              Rescale intercept\n            */\n            if (data != (unsigned char *) NULL)\n              info.rescale_intercept=StringToDouble((char *) data,\n                (char **) NULL);\n            break;\n          }\n          case 0x1053:\n          {\n            /*\n              Rescale slope\n            */\n            if (data != (unsigned char *) NULL)\n              info.rescale_slope=StringToDouble((char *) data, (char **) NULL);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/info.bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");\n            for (i=0; i &lt; (ssize_t) colors; i++)\n              if (info.bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");\n            p=data;\n            for (i=0; i &lt; (ssize_t) colors; i++)\n            {\n              if (image-&gt;endian == MSBEndian)\n                index=(unsigned short) ((*p &lt;&lt; 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) &lt;&lt; 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");\n            p=data;\n            for (i=0; i &lt; (ssize_t) colors; i++)\n            {\n              if (image-&gt;endian == MSBEndian)\n                index=(unsigned short) ((*p &lt;&lt; 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) &lt;&lt; 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");\n            p=data;\n            for (i=0; i &lt; (ssize_t) colors; i++)\n            {\n              if (image-&gt;endian == MSBEndian)\n                index=(unsigned short) ((*p &lt;&lt; 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) &lt;&lt; 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &amp;&amp;\n                (strncmp((char *) data,"INVERSE",7) == 0))\n              info.polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &amp;&amp;\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString("dcm:");\n            (void) ConcatenateString(&amp;attribute,dicom_info[i].description);\n            for (i=0; i &lt; (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length &gt; 4))\n              {\n                (void) SubstituteString(&amp;attribute," ","");\n                (void) SetImageProperty(image,attribute,(char *) data,\n                  exception);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info-&gt;verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,"%d\\n",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i &lt; (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) &amp;&amp; (length &lt;= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j &gt;= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,"%d",datum);\n              }\n            else\n              for (i=0; i &lt; (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,"%c",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,"%c",\'.\');\n            (void) FormatLocaleFile(stdout,"\\n");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",\n          image-&gt;filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowDCMException(CorruptImageError,"ImproperImageHeader");\n  image-&gt;columns=(size_t) width;\n  image-&gt;rows=(size_t) height;\n  if (info.signed_data == 0xffff)\n    info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n  if ((image-&gt;compression == JPEGCompression) ||\n      (image-&gt;compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i &lt; (ssize_t) stream_info-&gt;remaining; i++)\n        (void) ReadBlobByte(image);\n      (void)((ReadBlobLSBShort(image) &lt;&lt; 16) | ReadBlobLSBShort(image));\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info-&gt;offset_count=length &gt;&gt; 2;\n      if (stream_info-&gt;offset_count != 0)\n        {\n          stream_info-&gt;offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info-&gt;offset_count,sizeof(*stream_info-&gt;offsets));\n          if (stream_info-&gt;offsets == (ssize_t *) NULL)\n            ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");\n          for (i=0; i &lt; (ssize_t) stream_info-&gt;offset_count; i++)\n            stream_info-&gt;offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i &lt; (ssize_t) stream_info-&gt;offset_count; i++)\n            stream_info-&gt;offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene &lt; (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MagickPathExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) &lt;&lt; 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowDCMException(CorruptImageError,"ImproperImageHeader");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,"wb");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              "UnableToCreateTemporaryFile",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                "UnexpectedEndOfFile",image-&gt;filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info-&gt;filename,MagickPathExtent,\n          "jpeg:%s",filename);\n        if (image-&gt;compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info-&gt;filename,MagickPathExtent,\n            "j2k:%s",filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property,exception),exception);\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&amp;images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(info.depth)+1);\n      info.scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*info.scale));\n      if (info.scale == (Quantum *) NULL)\n        ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");\n      range=GetQuantumRange(info.depth);\n      for (i=0; i &lt;= (ssize_t) GetQuantumRange(info.depth); i++)\n        info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n    }\n  if (image-&gt;compression == RLECompression)\n    {\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i &lt; (ssize_t) stream_info-&gt;remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) &lt;&lt; 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info-&gt;offset_count=length &gt;&gt; 2;\n      if (stream_info-&gt;offset_count != 0)\n        {\n          stream_info-&gt;offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info-&gt;offset_count,sizeof(*stream_info-&gt;offsets));\n          if (stream_info-&gt;offsets == (ssize_t *) NULL)\n            ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");\n          for (i=0; i &lt; (ssize_t) stream_info-&gt;offset_count; i++)\n            stream_info-&gt;offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image)+8;\n          for (i=0; i &lt; (ssize_t) stream_info-&gt;offset_count; i++)\n            stream_info-&gt;offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene &lt; (ssize_t) number_scenes; scene++)\n  {\n    if (image_info-&gt;ping != MagickFalse)\n      break;\n    image-&gt;columns=(size_t) width;\n    image-&gt;rows=(size_t) height;\n    image-&gt;depth=info.depth;\n    status=SetImageExtent(image,image-&gt;columns,image-&gt;rows,exception);\n    if (status == MagickFalse)\n      break;\n    image-&gt;colorspace=RGBColorspace;\n    if ((image-&gt;colormap == (PixelInfo *) NULL) &amp;&amp;\n        (info.samples_per_pixel == 1))\n      {\n        int\n          index;\n\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one &lt;&lt; info.depth;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");\n        if (redmap != (int *) NULL)\n          for (i=0; i &lt; (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((info.scale != (Quantum *) NULL) &amp;&amp;\n                (index &lt;= (int) info.max_value))\n              index=(int) info.scale[index];\n            image-&gt;colormap[i].red=(MagickRealType) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i &lt; (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((info.scale != (Quantum *) NULL) &amp;&amp;\n                (index &lt;= (int) info.max_value))\n              index=(int) info.scale[index];\n            image-&gt;colormap[i].green=(MagickRealType) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i &lt; (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((info.scale != (Quantum *) NULL) &amp;&amp;\n                (index &lt;= (int) info.max_value))\n              index=(int) info.scale[index];\n            image-&gt;colormap[i].blue=(MagickRealType) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i &lt; (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((info.scale != (Quantum *) NULL) &amp;&amp;\n                (index &lt;= (int) info.max_value))\n              index=(int) info.scale[index];\n            image-&gt;colormap[i].red=(MagickRealType) index;\n            image-&gt;colormap[i].green=(MagickRealType) index;\n            image-&gt;colormap[i].blue=(MagickRealType) index;\n          }\n      }\n    if (image-&gt;compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i &lt; (ssize_t) stream_info-&gt;remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) &lt;&lt; 16) | ReadBlobLSBShort(image);\n        stream_info-&gt;remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info-&gt;remaining &lt;= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowDCMException(CorruptImageError,"ImproperImageHeader");\n        stream_info-&gt;count=0;\n        stream_info-&gt;segment_count=ReadBlobLSBLong(image);\n        for (i=0; i &lt; 15; i++)\n          stream_info-&gt;segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n        stream_info-&gt;remaining-=64;\n        if (stream_info-&gt;segment_count &gt; 1)\n          {\n            info.bytes_per_pixel=1;\n            info.depth=8;\n            if (stream_info-&gt;offset_count &gt; 0)\n              (void) SeekBlob(image,(MagickOffsetType) stream_info-&gt;offsets[0]+\n                stream_info-&gt;segments[0],SEEK_SET);\n          }\n      }\n    if ((info.samples_per_pixel &gt; 1) &amp;&amp; (image-&gt;interlace == PlaneInterlace))\n      {\n        register ssize_t\n          x;\n\n        register Quantum\n          *q;\n\n        ssize_t\n          y;\n\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i &lt; (ssize_t) info.samples_per_pixel; i++)\n        {\n          for (y=0; y &lt; (ssize_t) image-&gt;rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image-&gt;columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x &lt; (ssize_t) image-&gt;columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                default:\n                  break;\n              }\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image-&gt;previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image-&gt;rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        option=GetImageOption(image_info,"dcm:display-range");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,"reset") == 0)\n              info.window_width=0;\n          }\n        option=GetImageOption(image_info,"dcm:window");\n        if (option != (char *) NULL)\n          {\n            GeometryInfo\n              geometry_info;\n\n            MagickStatusType\n              flags;\n\n            flags=ParseGeometry(option,&amp;geometry_info);\n            if (flags &amp; RhoValue)\n              info.window_center=geometry_info.rho;\n            if (flags &amp; SigmaValue)\n              info.window_width=geometry_info.sigma;\n            info.rescale=MagickTrue;\n          }\n        option=GetImageOption(image_info,"dcm:rescale");\n        if (option != (char *) NULL)\n          info.rescale=IsStringTrue(option);\n        if ((info.window_center != 0) &amp;&amp; (info.window_width == 0))\n          info.window_width=info.window_center;\n        status=ReadDCMPixels(image,&amp;info,stream_info,MagickTrue,exception);\n        if ((status != MagickFalse) &amp;&amp; (stream_info-&gt;segment_count &gt; 1))\n          {\n            if (stream_info-&gt;offset_count &gt; 0)\n              (void) SeekBlob(image,(MagickOffsetType) stream_info-&gt;offsets[0]+\n                stream_info-&gt;segments[1],SEEK_SET);\n            (void) ReadDCMPixels(image,&amp;info,stream_info,MagickFalse,exception);\n          }\n      }\n    if (SetImageGray(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",\n          image-&gt;filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info-&gt;number_scenes != 0)\n      if (image-&gt;scene &gt;= (image_info-&gt;scene+image_info-&gt;number_scenes-1))\n        break;\n    if (scene &lt; (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info-&gt;offsets != (ssize_t *) NULL)\n    stream_info-&gt;offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info-&gt;offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (info.scale != (Quantum *) NULL)\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}',
 'static ssize_t _consolefs_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || !iov || iovcnt &lt; 0 || iovcnt &gt; OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &amp;buf, &amp;buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_readv_ocall(&amp;ret, file-&gt;host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}',
 'static int closeVirtualHostDirective(MaState *state, cchar *key, cchar *value)\n{\n    HttpEndpoint    *endpoint;\n    char            *address, *ip, *addresses, *tok;\n    int             port;\n\n    if (state-&gt;enabled) { \n        if (state-&gt;endpoints &amp;&amp; *state-&gt;endpoints) {\n            addresses = state-&gt;endpoints;\n            while ((address = stok(addresses, " \\t,", &amp;tok)) != 0) {\n                addresses = 0;\n                mprParseSocketAddress(address, &amp;ip, &amp;port, NULL, -1);\n                if ((endpoint = httpLookupEndpoint(ip, port)) == 0) {\n                    mprLog("error appweb config", 0, "Cannot find listen directive for virtual host %s", address);\n                    return MPR_ERR_BAD_SYNTAX;\n                } else {\n                    httpAddHostToEndpoint(endpoint, state-&gt;host);\n                }\n            }\n        } else {\n            httpAddHostToEndpoints(state-&gt;host);\n        }\n    }\n    closeDirective(state, key, value);\n    return 0;\n}',
 "int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,\n\t\t\t    struct mem_access *ma, int expected,\n\t\t\t    unsigned long address)\n{\n\tu_int rm;\n\tint ret, index;\n\n\t/*\n\t * XXX: We can't handle mixed 16/32-bit instructions yet\n\t */\n\tif (instruction_size(instruction) != 2)\n\t\treturn -EINVAL;\n\n\tindex = (instruction&gt;&gt;8)&amp;15;\t/* 0x0F00 */\n\trm = regs-&gt;regs[index];\n\n\t/*\n\t * Log the unexpected fixups, and then pass them on to perf.\n\t *\n\t * We intentionally don't report the expected cases to perf as\n\t * otherwise the trapped I/O case will skew the results too much\n\t * to be useful.\n\t */\n\tif (!expected) {\n\t\tunaligned_fixups_notify(current, instruction, regs);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,\n\t\t\t      regs, address);\n\t}\n\n\tret = -EFAULT;\n\tswitch (instruction&amp;0xF000) {\n\tcase 0x0000:\n\t\tif (instruction==0x000B) {\n\t\t\t/* rts */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs-&gt;pc = regs-&gt;pr;\n\t\t}\n\t\telse if ((instruction&amp;0x00FF)==0x0023) {\n\t\t\t/* braf @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs-&gt;pc += rm + 4;\n\t\t}\n\t\telse if ((instruction&amp;0x00FF)==0x0003) {\n\t\t\t/* bsrf @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n\t\t\t\tregs-&gt;pr = regs-&gt;pc + 4;\n\t\t\t\tregs-&gt;pc += rm + 4;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* mov.[bwl] to/from memory via r0+rn */\n\t\t\tgoto simple;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1000: /* mov.l Rm,@(disp,Rn) */\n\t\tgoto simple;\n\n\tcase 0x2000: /* mov.[bwl] to memory, possibly with pre-decrement */\n\t\tgoto simple;\n\n\tcase 0x4000:\n\t\tif ((instruction&amp;0x00FF)==0x002B) {\n\t\t\t/* jmp @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs-&gt;pc = rm;\n\t\t}\n\t\telse if ((instruction&amp;0x00FF)==0x000B) {\n\t\t\t/* jsr @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n\t\t\t\tregs-&gt;pr = regs-&gt;pc + 4;\n\t\t\t\tregs-&gt;pc = rm;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* mov.[bwl] to/from memory via r0+rn */\n\t\t\tgoto simple;\n\t\t}\n\t\tbreak;\n\n\tcase 0x5000: /* mov.l @(disp,Rm),Rn */\n\t\tgoto simple;\n\n\tcase 0x6000: /* mov.[bwl] from memory, possibly with post-increment */\n\t\tgoto simple;\n\n\tcase 0x8000: /* bf lab, bf/s lab, bt lab, bt/s lab */\n\t\tswitch (instruction&amp;0x0F00) {\n\t\tcase 0x0100: /* mov.w R0,@(disp,Rm) */\n\t\t\tgoto simple;\n\t\tcase 0x0500: /* mov.w @(disp,Rm),R0 */\n\t\t\tgoto simple;\n\t\tcase 0x0B00: /* bf   lab - no delayslot*/\n\t\t\tbreak;\n\t\tcase 0x0F00: /* bf/s lab */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)\n\t\t\t\tif ((regs-&gt;sr &amp; 0x00000001) != 0)\n\t\t\t\t\tregs-&gt;pc += 4; /* next after slot */\n\t\t\t\telse\n#endif\n\t\t\t\t\tregs-&gt;pc += SH_PC_8BIT_OFFSET(instruction);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x0900: /* bt   lab - no delayslot */\n\t\t\tbreak;\n\t\tcase 0x0D00: /* bt/s lab */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)\n\t\t\t\tif ((regs-&gt;sr &amp; 0x00000001) == 0)\n\t\t\t\t\tregs-&gt;pc += 4; /* next after slot */\n\t\t\t\telse\n#endif\n\t\t\t\t\tregs-&gt;pc += SH_PC_8BIT_OFFSET(instruction);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0xA000: /* bra label */\n\t\tret = handle_delayslot(regs, instruction, ma);\n\t\tif (ret==0)\n\t\t\tregs-&gt;pc += SH_PC_12BIT_OFFSET(instruction);\n\t\tbreak;\n\n\tcase 0xB000: /* bsr label */\n\t\tret = handle_delayslot(regs, instruction, ma);\n\t\tif (ret==0) {\n\t\t\tregs-&gt;pr = regs-&gt;pc + 4;\n\t\t\tregs-&gt;pc += SH_PC_12BIT_OFFSET(instruction);\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n\n\t/* handle non-delay-slot instruction */\n simple:\n\tret = handle_unaligned_ins(instruction, regs, ma);\n\tif (ret==0)\n\t\tregs-&gt;pc += instruction_size(instruction);\n\treturn ret;\n}",
 'BinaryParameter::BinaryParameter(const char* name_, const char* desc_,\n\t\t\t\t const void* v, size_t l, ConfigurationObject co)\n: VoidParameter(name_, desc_, co), value(0), length(0), def_value((char*)v), def_length(l) {\n  if (l) {\n    value = new char[l];\n    length = l;\n    memcpy(value, v, l);\n  }\n}',
 "IPV6DefragInOrderSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p1, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n    reassembled = Defrag(NULL, NULL, p3, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    if (IPV6_GET_PLEN(reassembled) != 19)\n        goto end;\n\n    /* 40 bytes in we should find 8 bytes of A. */\n    for (i = 40; i &lt; 40 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 48; i &lt; 48 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 56; i &lt; 56 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}",
 'static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,\n\t\t       struct in6_addr *addr, uint32_t *ifindex)\n{\n\tstruct sockaddr_in6 sin6;\n\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n\tstruct iovec iovec;\n\tstruct msghdr msghdr;\n\tstruct cmsghdr *cmsghdr;\n\tssize_t len;\n\n\tiovec.iov_len = *buflen;\n\tiovec.iov_base = buf;\n\tmemset(&amp;msghdr, 0, sizeof(msghdr));\n\tmsghdr.msg_name = &amp;sin6;\n\tmsghdr.msg_namelen = sizeof(sin6);\n\tmsghdr.msg_iov = &amp;iovec;\n\tmsghdr.msg_iovlen = 1;\n\tmsghdr.msg_control = cbuf;\n\tmsghdr.msg_controllen = sizeof(cbuf);\n\n\tlen = recvmsg(sockfd, &amp;msghdr, flags);\n\tif (len == -1)\n\t\treturn -errno;\n\t*buflen = len;\n\n\t/* Set ifindex to scope_id now. But since scope_id gets not\n\t * set by kernel for linklocal addresses, use pktinfo to obtain that\n\t * value right after.\n\t */\n\t*ifindex = sin6.sin6_scope_id;\n        for (cmsghdr = CMSG_FIRSTHDR(&amp;msghdr); cmsghdr;\n\t     cmsghdr = CMSG_NXTHDR(&amp;msghdr, cmsghdr)) {\n\t\tif (cmsghdr-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;\n\t\t    cmsghdr-&gt;cmsg_type == IPV6_PKTINFO &amp;&amp;\n\t\t    cmsghdr-&gt;cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\tstruct in6_pktinfo *pktinfo;\n\n\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);\n\t\t\t*ifindex = pktinfo-&gt;ipi6_ifindex;\n\t\t}\n\t}\n\t*addr = sin6.sin6_addr;\n\n\treturn 0;\n}',
 'ubik_print(netdissect_options *ndo,\n           register const u_char *bp)\n{\n\tint ubik_op;\n\tint32_t temp;\n\n\t/*\n\t * Print out the afs call we\'re invoking.  The table used here was\n\t * gleaned from ubik/ubik_int.xg\n\t */\n\n\tubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n\n\tND_PRINT((ndo, " ubik call %s", tok2str(ubik_req, "op#%d", ubik_op)));\n\n\t/*\n\t * Decode some of the arguments to the Ubik calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (ubik_op) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, " syncsite %s", temp ? "yes" : "no"));\n\t\t\tND_PRINT((ndo, " votestart"));\n\t\t\tDATEOUT();\n\t\t\tND_PRINT((ndo, " dbversion"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, " tid"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 10003:\t\t/* Get sync site */\n\t\t\tND_PRINT((ndo, " site"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 20000:\t\t/* Begin */\n\t\tcase 20001:\t\t/* Commit */\n\t\tcase 20007:\t\t/* Abort */\n\t\tcase 20008:\t\t/* Release locks */\n\t\tcase 20010:\t\t/* Writev */\n\t\t\tND_PRINT((ndo, " tid"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20002:\t\t/* Lock */\n\t\t\tND_PRINT((ndo, " tid"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, " file"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, " pos"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, " length"));\n\t\t\tINTOUT();\n\t\t\tND_TCHECK_32BITS(bp);\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\ttok2str(ubik_lock_types, "type %d", temp);\n\t\t\tbreak;\n\t\tcase 20003:\t\t/* Write */\n\t\t\tND_PRINT((ndo, " tid"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, " file"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, " pos"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20005:\t\t/* Get file */\n\t\t\tND_PRINT((ndo, " file"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20006:\t\t/* Send file */\n\t\t\tND_PRINT((ndo, " file"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, " length"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, " dbversion"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20009:\t\t/* Truncate */\n\t\t\tND_PRINT((ndo, " tid"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, " file"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, " length"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20012:\t\t/* Set version */\n\t\t\tND_PRINT((ndo, " tid"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, " oldversion"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, " newversion"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, " [|ubik]"));\n}',
 'static int base64decode_block(unsigned char *target, const char *data, size_t data_size)\n{\n\tint w1,w2,w3,w4;\n\tint i;\n\tsize_t n;\n\n\tif (!data || (data_size &lt;= 0)) {\n\t\treturn 0;\n\t}\n\n\tn = 0;\n\ti = 0;\n\twhile (n &lt; data_size-3) {\n\t\tw1 = base64_table[(int)data[n]];\n\t\tw2 = base64_table[(int)data[n+1]];\n\t\tw3 = base64_table[(int)data[n+2]];\n\t\tw4 = base64_table[(int)data[n+3]];\n\n\t\tif (w2 &gt;= 0) {\n\t\t\ttarget[i++] = (char)((w1*4 + (w2 &gt;&gt; 4)) &amp; 255);\n\t\t}\n\t\tif (w3 &gt;= 0) {\n\t\t\ttarget[i++] = (char)((w2*16 + (w3 &gt;&gt; 2)) &amp; 255);\n\t\t}\n\t\tif (w4 &gt;= 0) {\n\t\t\ttarget[i++] = (char)((w3*64 + w4) &amp; 255);\n\t\t}\n\t\tn+=4;\n\t}\n\treturn i;\n}',
 'CodingReturnValue VP8ComponentDecoder::decode_chunk(UncompressedComponents * const colldata)\n{\n    mux_splicer.init(spin_workers_);\n    /* cmpc is a global variable with the component count */\n\n\n    /* construct 4x4 VP8 blocks to hold 8x8 JPEG blocks */\n    if ( thread_state_[0] == nullptr || thread_state_[0]-&gt;context_[0].isNil() ) {\n        /* first call */\n        BlockBasedImagePerChannel&lt;false&gt; framebuffer;\n        framebuffer.memset(0);\n        for (size_t i = 0; i &lt; framebuffer.size() &amp;&amp; int( i ) &lt; colldata-&gt;get_num_components(); ++i) {\n            framebuffer[i] = &amp;colldata-&gt;full_component_write((BlockType)i);\n        }\n        Sirikata::Array1d&lt;BlockBasedImagePerChannel&lt;false&gt;, MAX_NUM_THREADS&gt; all_framebuffers;\n        for (size_t i = 0; i &lt; all_framebuffers.size(); ++i) {\n            all_framebuffers[i] = framebuffer;\n        }\n        size_t num_threads_needed = initialize_decoder_state(colldata,\n                                                             all_framebuffers).size();\n\n\n        for (size_t i = 0;i &lt; num_threads_needed; ++i) {\n            map_logical_thread_to_physical_thread(i, i);\n        }\n        for (size_t i = 0;i &lt; num_threads_needed; ++i) {\n            initialize_thread_id(i, i, framebuffer);\n            if (!do_threading_) {\n                break;\n            }\n        }\n        if (num_threads_needed &gt; NUM_THREADS || num_threads_needed == 0) {\n            return CODING_ERROR;\n        }\n    }\n    if (do_threading_) {\n        for (unsigned int thread_id = 0; thread_id &lt; NUM_THREADS; ++thread_id) {\n            unsigned int cur_spin_worker = thread_id;\n            spin_workers_[cur_spin_worker].work\n                = std::bind(worker_thread,\n                            thread_state_[thread_id],\n                            thread_id,\n                            colldata,\n                            mux_splicer.thread_target,\n                            getWorker(cur_spin_worker),\n                            &amp;send_to_actual_thread_state);\n            spin_workers_[cur_spin_worker].activate_work();\n        }\n        flush();\n        for (unsigned int thread_id = 0; thread_id &lt; NUM_THREADS; ++thread_id) {\n            unsigned int cur_spin_worker = thread_id;\n            TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_STARTED] = TimingHarness::get_time_us();\n            spin_workers_[cur_spin_worker].main_wait_for_done();\n            TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_FINISHED] = TimingHarness::get_time_us();\n        }\n        // join on all threads\n    } else {\n        if (virtual_thread_id_ != -1) {\n            TimingHarness::timing[0][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();\n            CodingReturnValue ret = thread_state_[0]-&gt;vp8_decode_thread(0, colldata);\n            if (ret == CODING_PARTIAL) {\n                return ret;\n            }\n            TimingHarness::timing[0][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();\n        }\n        // wait for "threads"\n        virtual_thread_id_ += 1; // first time\'s a charm\n        for (unsigned int thread_id = virtual_thread_id_; thread_id &lt; NUM_THREADS; ++thread_id, ++virtual_thread_id_) {\n            BlockBasedImagePerChannel&lt;false&gt; framebuffer;\n            framebuffer.memset(0);\n            for (size_t i = 0; i &lt; framebuffer.size() &amp;&amp; int( i ) &lt; colldata-&gt;get_num_components(); ++i) {\n                framebuffer[i] = &amp;colldata-&gt;full_component_write((BlockType)i);\n            }\n\n            initialize_thread_id(thread_id, 0, framebuffer);\n            thread_state_[0]-&gt;bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &amp;mux_reader_, &amp;mux_splicer));\n            TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();\n            CodingReturnValue ret;\n            if ((ret = thread_state_[0]-&gt;vp8_decode_thread(0, colldata)) == CODING_PARTIAL) {\n                return ret;\n            }\n            TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();\n        }\n    }\n    TimingHarness::timing[0][TimingHarness::TS_JPEG_RECODE_STARTED] = TimingHarness::get_time_us();\n    for (int component = 0; component &lt; colldata-&gt;get_num_components(); ++component) {\n        colldata-&gt;worker_mark_cmp_finished((BlockType)component);\n    }\n    colldata-&gt;worker_update_coefficient_position_progress( 64 );\n    colldata-&gt;worker_update_bit_progress( 16 );\n    write_byte_bill(Billing::DELIMITERS, true, mux_reader_.getOverhead());\n    return CODING_DONE;\n}',
 "static int getnum (const char **fmt, int df) {\n  if (!isdigit(**fmt))  /* no number? */\n    return df;  /* return default value */\n  else {\n    int a = 0;\n    do {\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}",
 'static int p4_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tperf_sample_data_init(&amp;data, 0);\n\n\tcpuc = &amp;__get_cpu_var(cpu_hw_events);\n\n\tfor (idx = 0; idx &lt; x86_pmu.num_counters; idx++) {\n\t\tint overflow;\n\n\t\tif (!test_bit(idx, cpuc-&gt;active_mask)) {\n\t\t\t/* catch in-flight IRQs */\n\t\t\tif (__test_and_clear_bit(idx, cpuc-&gt;running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc-&gt;events[idx];\n\t\thwc = &amp;event-&gt;hw;\n\n\t\tWARN_ON_ONCE(hwc-&gt;idx != idx);\n\n\t\t/* it might be unflagged overflow */\n\t\toverflow = p4_pmu_clear_cccr_ovf(hwc);\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (!overflow &amp;&amp; (val &amp; (1ULL &lt;&lt; (x86_pmu.cntval_bits - 1))))\n\t\t\tcontinue;\n\n\t\thandled += overflow;\n\n\t\t/* event overflow for sure */\n\t\tdata.period = event-&gt;hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\t\tif (perf_event_overflow(event, &amp;data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\t/*\n\t * When dealing with the unmasking of the LVTPC on P4 perf hw, it has\n\t * been observed that the OVF bit flag has to be cleared first _before_\n\t * the LVTPC can be unmasked.\n\t *\n\t * The reason is the NMI line will continue to be asserted while the OVF\n\t * bit is set.  This causes a second NMI to generate if the LVTPC is\n\t * unmasked before the OVF bit is cleared, leading to unknown NMI\n\t * messages.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\treturn handled;\n}',
 'grub_disk_read (grub_disk_t disk, grub_disk_addr_t sector,\n\t\tgrub_off_t offset, grub_size_t size, void *buf)\n{\n  char *tmp_buf;\n  unsigned real_offset;\n\n  /* First of all, check if the region is within the disk.  */\n  if (grub_disk_adjust_range (disk, &amp;sector, &amp;offset, size) != GRUB_ERR_NONE)\n    {\n      grub_error_push ();\n      grub_dprintf ("disk", "Read out of range: sector 0x%llx (%s).\\n",\n\t\t    (unsigned long long) sector, grub_errmsg);\n      grub_error_pop ();\n      return grub_errno;\n    }\n\n  real_offset = offset;\n\n  /* Allocate a temporary buffer.  */\n  tmp_buf = grub_malloc (GRUB_DISK_SECTOR_SIZE &lt;&lt; GRUB_DISK_CACHE_BITS);\n  if (! tmp_buf)\n    return grub_errno;\n\n  /* Until SIZE is zero...  */\n  while (size)\n    {\n      char *data;\n      grub_disk_addr_t start_sector;\n      grub_size_t len;\n      grub_size_t pos;\n\n      /* For reading bulk data.  */\n      start_sector = sector &amp; ~(GRUB_DISK_CACHE_SIZE - 1);\n      pos = (sector - start_sector) &lt;&lt; GRUB_DISK_SECTOR_BITS;\n      len = ((GRUB_DISK_SECTOR_SIZE &lt;&lt; GRUB_DISK_CACHE_BITS)\n\t     - pos - real_offset);\n      if (len &gt; size)\n\tlen = size;\n\n      /* Fetch the cache.  */\n      data = grub_disk_cache_fetch (disk-&gt;dev-&gt;id, disk-&gt;id, start_sector);\n      if (data)\n\t{\n\t  /* Just copy it!  */\n\t  if (buf) {\n\t    if (pos + real_offset + len &gt;= size) {\n              // prevent read overflow\n              grub_errno = GRUB_ERR_BAD_FS;\n              return grub_errno;\n\t    }\n\t    grub_memcpy (buf, data + pos + real_offset, len);\n          }\n\t  grub_disk_cache_unlock (disk-&gt;dev-&gt;id, disk-&gt;id, start_sector);\n\t}\n      else\n\t{\n\t  /* Otherwise read data from the disk actually.  */\n\t  if (start_sector + GRUB_DISK_CACHE_SIZE &gt; disk-&gt;total_sectors\n\t      || (disk-&gt;dev-&gt;read) (disk, start_sector,\n\t\t\t\t    GRUB_DISK_CACHE_SIZE, tmp_buf)\n\t      != GRUB_ERR_NONE)\n\t    {\n\t      /* Uggh... Failed. Instead, just read necessary data.  */\n\t      unsigned num;\n\t      char *p;\n\n\t      grub_errno = GRUB_ERR_NONE;\n\n\t      num = ((size + real_offset + GRUB_DISK_SECTOR_SIZE - 1)\n\t\t     &gt;&gt; GRUB_DISK_SECTOR_BITS);\n\n\t      p = grub_realloc (tmp_buf, num &lt;&lt; GRUB_DISK_SECTOR_BITS);\n\t      if (!p)\n\t\tgoto finish;\n\n\t      tmp_buf = p;\n\n\t      if ((disk-&gt;dev-&gt;read) (disk, sector, num, tmp_buf))\n\t\t{\n\t\t  grub_error_push ();\n\t\t  grub_dprintf ("disk", "%s read failed\\n", disk-&gt;name);\n\t\t  grub_error_pop ();\n\t\t  goto finish;\n\t\t}\n\n\t      if (buf)\n\t\tgrub_memcpy (buf, tmp_buf + real_offset, size);\n\n\t      /* Call the read hook, if any.  */\n\t      if (disk-&gt;read_hook)\n\t\twhile (size)\n\t\t  {\n\t\t    grub_size_t to_read;\n\n\t\t    to_read = size;\n\t\t    if (real_offset + to_read &gt; GRUB_DISK_SECTOR_SIZE)\n\t\t      to_read = GRUB_DISK_SECTOR_SIZE - real_offset;\n\t\t    (disk-&gt;read_hook) (sector, real_offset,\n\t\t\t\t       to_read, disk-&gt;closure);\n\t\t    if (grub_errno != GRUB_ERR_NONE)\n\t\t      goto finish;\n\n\t\t    sector++;\n\t\t    size -= to_read;\n\t\t    real_offset = 0;\n\t\t  }\n\n\t      /* This must be the end.  */\n\t      goto finish;\n\t    }\n\n\t  /* Copy it and store it in the disk cache.  */\n\t  if (buf)\n\t    grub_memcpy (buf, tmp_buf + pos + real_offset, len);\n\t  grub_disk_cache_store (disk-&gt;dev-&gt;id, disk-&gt;id,\n\t\t\t\t start_sector, tmp_buf);\n\t}\n\n      /* Call the read hook, if any.  */\n      if (disk-&gt;read_hook)\n\t{\n\t  grub_disk_addr_t s = sector;\n\t  grub_size_t l = len;\n\n\t  while (l)\n\t    {\n\t      (disk-&gt;read_hook) (s, real_offset,\n\t\t\t\t ((l &gt; GRUB_DISK_SECTOR_SIZE)\n\t\t\t\t  ? GRUB_DISK_SECTOR_SIZE\n\t\t\t\t  : l), disk-&gt;closure);\n\n\t      if (l &lt; GRUB_DISK_SECTOR_SIZE - real_offset)\n\t\tbreak;\n\n\t      s++;\n\t      l -= GRUB_DISK_SECTOR_SIZE - real_offset;\n\t      real_offset = 0;\n\t    }\n\t}\n\n      sector = start_sector + GRUB_DISK_CACHE_SIZE;\n      if (buf)\n\tbuf = (char *) buf + len;\n      size -= len;\n      real_offset = 0;\n    }\n\n finish:\n\n  grub_free (tmp_buf);\n\n  return grub_errno;\n}',
 'static void dhcps_send_ack(struct pbuf *packet_buffer)\n{\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer-&gt;payload;\n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&amp;dhcp_message_repository-&gt;options[4],\n\t\t\t      \t\t\tDHCP_MESSAGE_TYPE_ACK));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t   &amp;dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}',
 'static void bt_tags_for_each(struct blk_mq_tags *tags,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_tag_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tif (!tags-&gt;rqs)\n\t\treturn;\n\tfor (i = 0; i &lt; bt-&gt;map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &amp;bt-&gt;map[i];\n\n\t\tfor (bit = find_first_bit(&amp;bm-&gt;word, bm-&gt;depth);\n\t\t     bit &lt; bm-&gt;depth;\n\t\t     bit = find_next_bit(&amp;bm-&gt;word, bm-&gt;depth, bit + 1)) {\n\t\t\trq = tags-&gt;rqs[off + bit];\n\t\t\tfn(rq, data, reserved);\n\t\t}\n\n\t\toff += (1 &lt;&lt; bt-&gt;bits_per_word);\n\t}\n}',
 'static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh-&gt;md;\n\tstruct state *const st = md-&gt;st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log("ikev2 parent inR1outI2: calculating g^{xy} sending I2"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       "%s: Request was disconnected from state",\n\t\t       __FUNCTION__);\n\t\tif (dh-&gt;md)\n\t\t\trelease_md(dh-&gt;md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st-&gt;st_suspended_md == dh-&gt;md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst-&gt;st_calculating = FALSE;\n\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\n\tif (dh-&gt;md != NULL) {\n\t\tcomplete_v2_state_transition(&amp;dh-&gt;md, e);\n\t\tif (dh-&gt;md)\n\t\t\trelease_md(dh-&gt;md);\n\t}\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}',
 '_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n{\n\tconst char *cert_domain, *domain, *next_dot;\n\n\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n\t\treturn 0;\n\n\t/* Wildcard match? */\n\tif (cert_hostname[0] == \'*\')\n\t{\n\t\t/*\n\t\t * Valid wildcards:\n\t\t * - "*.domain.tld"\n\t\t * - "*.sub.domain.tld"\n\t\t * - etc.\n\t\t * Reject "*.tld".\n\t\t * No attempt to prevent the use of eg. "*.co.uk".\n\t\t */\n\t\tcert_domain = &amp;cert_hostname[1];\n\t\t/* Disallow "*"  */\n\t\tif (cert_domain[0] == \'\\0\')\n\t\t\treturn -1;\n\t\t/* Disallow "*foo" */\n\t\tif (cert_domain[0] != \'.\')\n\t\t\treturn -1;\n\t\t/* Disallow "*.." */\n\t\tif (cert_domain[1] == \'.\')\n\t\t\treturn -1;\n\t\tnext_dot = strchr (&amp;cert_domain[1], \'.\');\n\t\t/* Disallow "*.bar" */\n\t\tif (next_dot == NULL)\n\t\t\treturn -1;\n\t\t/* Disallow "*.bar.." */\n\t\tif (next_dot[1] == \'.\')\n\t\t\treturn -1;\n\n\t\tdomain = strchr (hostname, \'.\');\n\n\t\t/* No wildcard match against a hostname with no domain part. */\n\t\tif (domain == NULL || strlen(domain) == 1)\n\t\t\treturn -1;\n\n\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}',
 'create_watching_parent (void)\n{\n  pid_t child;\n  sigset_t ourset;\n  struct sigaction oldact[3];\n  int status = 0;\n  int retval;\n\n  retval = pam_open_session (pamh, 0);\n  if (is_pam_failure(retval))\n    {\n      cleanup_pam (retval);\n      errx (EXIT_FAILURE, _("cannot open session: %s"),\n\t     pam_strerror (pamh, retval));\n    }\n  else\n    _pam_session_opened = 1;\n\n  memset(oldact, 0, sizeof(oldact));\n\n  child = fork ();\n  if (child == (pid_t) -1)\n    {\n      cleanup_pam (PAM_ABORT);\n      err (EXIT_FAILURE, _("cannot create child process"));\n    }\n\n  /* the child proceeds to run the shell */\n  if (child == 0)\n    return;\n\n  /* In the parent watch the child.  */\n\n  /* su without pam support does not have a helper that keeps\n     sitting on any directory so let\'s go to /.  */\n  if (chdir ("/") != 0)\n    warn (_("cannot change directory to %s"), "/");\n\n  sigfillset (&amp;ourset);\n  if (sigprocmask (SIG_BLOCK, &amp;ourset, NULL))\n    {\n      warn (_("cannot block signals"));\n      caught_signal = true;\n    }\n  if (!caught_signal)\n    {\n      struct sigaction action;\n      action.sa_handler = su_catch_sig;\n      sigemptyset (&amp;action.sa_mask);\n      action.sa_flags = 0;\n      sigemptyset (&amp;ourset);\n    if (!same_session)\n      {\n        if (sigaddset(&amp;ourset, SIGINT) || sigaddset(&amp;ourset, SIGQUIT))\n          {\n            warn (_("cannot set signal handler"));\n            caught_signal = true;\n          }\n      }\n    if (!caught_signal &amp;&amp; (sigaddset(&amp;ourset, SIGTERM)\n                    || sigaddset(&amp;ourset, SIGALRM)\n                    || sigaction(SIGTERM, &amp;action, &amp;oldact[0])\n                    || sigprocmask(SIG_UNBLOCK, &amp;ourset, NULL))) {\n\t  warn (_("cannot set signal handler"));\n\t  caught_signal = true;\n\t}\n    if (!caught_signal &amp;&amp; !same_session &amp;&amp; (sigaction(SIGINT, &amp;action, &amp;oldact[1])\n                                     || sigaction(SIGQUIT, &amp;action, &amp;oldact[2])))\n      {\n        warn (_("cannot set signal handler"));\n        caught_signal = true;\n      }\n    }\n  if (!caught_signal)\n    {\n      pid_t pid;\n      for (;;)\n\t{\n\t  pid = waitpid (child, &amp;status, WUNTRACED);\n\n\t  if (pid != (pid_t)-1 &amp;&amp; WIFSTOPPED (status))\n\t    {\n\t      kill (getpid (), SIGSTOP);\n\t      /* once we get here, we must have resumed */\n\t      kill (pid, SIGCONT);\n\t    }\n\t  else\n\t    break;\n\t}\n      if (pid != (pid_t)-1)\n        {\n          if (WIFSIGNALED (status))\n            {\n              fprintf (stderr, "%s%s\\n", strsignal (WTERMSIG (status)),\n                       WCOREDUMP (status) ? _(" (core dumped)") : "");\n              status = WTERMSIG (status) + 128;\n            }\n          else\n            status = WEXITSTATUS (status);\n        }\n      else if (caught_signal)\n        status = caught_signal + 128;\n      else\n        status = 1;\n    }\n  else\n    status = 1;\n\n  if (caught_signal)\n    {\n      fprintf (stderr, _("\\nSession terminated, killing shell..."));\n      kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n\n  if (caught_signal)\n    {\n      sleep (2);\n      kill (child, SIGKILL);\n      fprintf (stderr, _(" ...killed.\\n"));\n\n      /* Let\'s terminate itself with the received signal.\n       *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)\n       * terminal settings (kzak -- Jun 2013).\n       */\n      switch (caught_signal) {\n        case SIGTERM:\n          sigaction(SIGTERM, &amp;oldact[0], NULL);\n          break;\n        case SIGINT:\n          sigaction(SIGINT, &amp;oldact[1], NULL);\n          break;\n        case SIGQUIT:\n          sigaction(SIGQUIT, &amp;oldact[2], NULL);\n          break;\n        default:\n\t  /* just in case that signal stuff initialization failed and\n\t   * caught_signal = true */\n          caught_signal = SIGKILL;\n          break;\n      }\n      kill(getpid(), caught_signal);\n    }\n  exit (status);\n}',
 'static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm-&gt;pid  = get_pid(pid);\n\tscm-&gt;cred = cred ? get_cred(cred) : NULL;\n\tscm-&gt;creds.pid = pid_vnr(pid);\n\tscm-&gt;creds.uid = cred ? cred-&gt;uid : INVALID_UID;\n\tscm-&gt;creds.gid = cred ? cred-&gt;gid : INVALID_GID;\n}',
 'bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map&lt;string, std::vector&lt;PartialTensorShape&gt;&gt;*\n        shape_map,\n    const std::function&lt;bool(const Node*)&gt;&amp; consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map&lt;const Node*, std::vector&lt;Tensor&gt;&gt;*\n        shape_replacement_map) {\n  if (n-&gt;IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n-&gt;op_def().is_stateful()) {\n    return false;\n  }\n  if (consider &amp;&amp; !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    // We can skip the node if an output is known to be oversized.\n    auto shape_it = shape_map-&gt;find(n-&gt;name());\n    if (shape_it != shape_map-&gt;end()) {\n      for (int64_t i = 0; i &lt; shape_it-&gt;second.size(); ++i) {\n        const auto&amp; out_shape = shape_it-&gt;second[i];\n        if (out_shape.IsFullyDefined() &amp;&amp;\n            out_shape.num_elements() * DataTypeSize(n-&gt;output_type(i)) &gt;\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n-&gt;IsControlFlow() || n-&gt;IsSend() || n-&gt;IsRecv()) {\n    return false;\n  }\n  // TODO(yuanbyu): For now disable these session handle operations.\n  if (n-&gt;IsGetSessionHandle() || n-&gt;IsGetSessionTensor() ||\n      n-&gt;IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n-&gt;IsSource()) {\n    return false;\n  }\n  if (n-&gt;IsSink()) {\n    return false;\n  }\n  if (n-&gt;IsFakeParam()) {\n    return false;\n  }\n  // Since constant-folding runs on the CPU, do not attempt to constant-fold\n  // operators that have no CPU kernel. Also implies that we will not\n  // constant-fold functions.\n  // TODO(phawkins): allow constant-folding for functions; functions may\n  // be arbitrarily expensive to execute.\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n-&gt;def())) {\n    return false;\n  }\n  // Do not constant fold nodes which will be allocated by ScopedAllocator.\n  // This is because the constant-folding graph will not contain the\n  // `_ScopedAllocator` node, and that is necessary to be able to run a node\n  // that will use this allocator.\n  if (n-&gt;attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) &lt;&lt; "Skip node [" &lt;&lt; n-&gt;DebugString()\n            &lt;&lt; "] for constant folding due to scoped allocator";\n    return false;\n  }\n  return true;\n}',
 'void perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\n\tperf_sample_data_init(&amp;sample, bp-&gt;attr.bp_addr);\n\n\tif (!bp-&gt;hw.state &amp;&amp; !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, 1, &amp;sample, regs);\n}',
 'void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (!_gdImageJpegCtx(im, out, quality)) {\n\t\trv = gdDPExtractData(out, size);\n\t} else {\n\t\trv = NULL;\n\t}\n\tout-&gt;gd_free (out);\n\n\treturn rv;\n}',
 'static void *gp_worker_main(void *pvt)\n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n\n    while (!t-&gt;pool-&gt;shutdown) {\n\n        /* initialize debug client id to 0 until work is scheduled */\n        gp_debug_set_conn_id(0);\n\n        /* ======&gt; COND_MUTEX */\n        pthread_mutex_lock(&amp;t-&gt;cond_mutex);\n        while (t-&gt;query == NULL) {\n            /* wait for next query */\n            pthread_cond_wait(&amp;t-&gt;cond_wakeup, &amp;t-&gt;cond_mutex);\n            if (t-&gt;pool-&gt;shutdown) {\n                pthread_mutex_unlock(&amp;t-&gt;cond_mutex);\n                pthread_exit(NULL);\n            }\n        }\n\n        /* grab the query off the shared pointer */\n        q = t-&gt;query;\n        t-&gt;query = NULL;\n\n        /* &lt;====== COND_MUTEX */\n        pthread_mutex_unlock(&amp;t-&gt;cond_mutex);\n\n        /* set client id before hndling requests */\n        gp_debug_set_conn_id(gp_conn_get_cid(q-&gt;conn));\n\n        /* handle the client request */\n        GPDEBUGN(3, "[status] Handling query input: %p (%zu)\\n", q-&gt;buffer,\n                 q-&gt;buflen);\n        gp_handle_query(t-&gt;pool, q);\n        GPDEBUGN(3 ,"[status] Handling query output: %p (%zu)\\n", q-&gt;buffer,\n                 q-&gt;buflen);\n\n        /* now get lock on main queue, to play with the reply list */\n        /* ======&gt; POOL LOCK */\n        pthread_mutex_lock(&amp;t-&gt;pool-&gt;lock);\n\n        /* put back query so that dispatcher can send reply */\n        q-&gt;next = t-&gt;pool-&gt;reply_list;\n        t-&gt;pool-&gt;reply_list = q;\n\n        /* add us back to the free list but only if we are not\n         * shutting down */\n        if (!t-&gt;pool-&gt;shutdown) {\n            LIST_DEL(t-&gt;pool-&gt;busy_list, t);\n            LIST_ADD(t-&gt;pool-&gt;free_list, t);\n        }\n\n        /* &lt;====== POOL LOCK */\n        pthread_mutex_unlock(&amp;t-&gt;pool-&gt;lock);\n\n        /* and wake up dispatcher so it will handle it */\n        ret = write(t-&gt;pool-&gt;sig_pipe[1], &amp;dummy, 1);\n        if (ret == -1) {\n            GPERROR("Failed to signal dispatcher!");\n        }\n    }\n\n    pthread_exit(NULL);\n}',
 'obj2ast_stmt(PyObject* obj, stmt_ty* out, PyArena* arena)\n{\n    int isinstance;\n\n    PyObject *tmp = NULL;\n    int lineno;\n    int col_offset;\n\n    if (obj == Py_None) {\n        *out = NULL;\n        return 0;\n    }\n    if (_PyObject_HasAttrId(obj, &amp;PyId_lineno)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &amp;PyId_lineno);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_int(tmp, &amp;lineno, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, "required field \\"lineno\\" missing from stmt");\n        return 1;\n    }\n    if (_PyObject_HasAttrId(obj, &amp;PyId_col_offset)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &amp;PyId_col_offset);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_int(tmp, &amp;col_offset, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, "required field \\"col_offset\\" missing from stmt");\n        return 1;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)FunctionDef_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        identifier name;\n        arguments_ty args;\n        asdl_seq* body;\n        asdl_seq* decorator_list;\n        expr_ty returns;\n        string type_comment;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_name)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_name);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_identifier(tmp, &amp;name, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"name\\" missing from FunctionDef");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_args)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_args);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_arguments(tmp, &amp;args, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"args\\" missing from FunctionDef");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_body)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_body);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "FunctionDef field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "FunctionDef field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from FunctionDef");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_decorator_list)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_decorator_list);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "FunctionDef field \\"decorator_list\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            decorator_list = _Ta3_asdl_seq_new(len, arena);\n            if (decorator_list == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty value;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "FunctionDef field \\"decorator_list\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(decorator_list, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"decorator_list\\" missing from FunctionDef");\n            return 1;\n        }\n        if (exists_not_none(obj, &amp;PyId_returns)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_returns);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;returns, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            returns = NULL;\n        }\n        if (exists_not_none(obj, &amp;PyId_type_comment)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_type_comment);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            type_comment = NULL;\n        }\n        *out = FunctionDef(name, args, body, decorator_list, returns,\n                           type_comment, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)AsyncFunctionDef_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        identifier name;\n        arguments_ty args;\n        asdl_seq* body;\n        asdl_seq* decorator_list;\n        expr_ty returns;\n        string type_comment;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_name)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_name);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_identifier(tmp, &amp;name, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"name\\" missing from AsyncFunctionDef");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_args)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_args);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_arguments(tmp, &amp;args, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"args\\" missing from AsyncFunctionDef");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_body)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_body);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncFunctionDef field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncFunctionDef field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from AsyncFunctionDef");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_decorator_list)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_decorator_list);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncFunctionDef field \\"decorator_list\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            decorator_list = _Ta3_asdl_seq_new(len, arena);\n            if (decorator_list == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty value;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncFunctionDef field \\"decorator_list\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(decorator_list, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"decorator_list\\" missing from AsyncFunctionDef");\n            return 1;\n        }\n        if (exists_not_none(obj, &amp;PyId_returns)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_returns);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;returns, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            returns = NULL;\n        }\n        if (exists_not_none(obj, &amp;PyId_type_comment)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_type_comment);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            type_comment = NULL;\n        }\n        *out = AsyncFunctionDef(name, args, body, decorator_list, returns,\n                                type_comment, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)ClassDef_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        identifier name;\n        asdl_seq* bases;\n        asdl_seq* keywords;\n        asdl_seq* body;\n        asdl_seq* decorator_list;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_name)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_name);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_identifier(tmp, &amp;name, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"name\\" missing from ClassDef");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_bases)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_bases);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "ClassDef field \\"bases\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            bases = _Ta3_asdl_seq_new(len, arena);\n            if (bases == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty value;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \\"bases\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(bases, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"bases\\" missing from ClassDef");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_keywords)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_keywords);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "ClassDef field \\"keywords\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            keywords = _Ta3_asdl_seq_new(len, arena);\n            if (keywords == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                keyword_ty value;\n                res = obj2ast_keyword(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \\"keywords\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(keywords, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"keywords\\" missing from ClassDef");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_body)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_body);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "ClassDef field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from ClassDef");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_decorator_list)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_decorator_list);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "ClassDef field \\"decorator_list\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            decorator_list = _Ta3_asdl_seq_new(len, arena);\n            if (decorator_list == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty value;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \\"decorator_list\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(decorator_list, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"decorator_list\\" missing from ClassDef");\n            return 1;\n        }\n        *out = ClassDef(name, bases, keywords, body, decorator_list, lineno,\n                        col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Return_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty value;\n\n        if (exists_not_none(obj, &amp;PyId_value)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_value);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;value, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            value = NULL;\n        }\n        *out = Return(value, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Delete_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* targets;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_targets)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_targets);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Delete field \\"targets\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            targets = _Ta3_asdl_seq_new(len, arena);\n            if (targets == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty value;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Delete field \\"targets\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(targets, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"targets\\" missing from Delete");\n            return 1;\n        }\n        *out = Delete(targets, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Assign_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* targets;\n        expr_ty value;\n        string type_comment;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_targets)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_targets);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Assign field \\"targets\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            targets = _Ta3_asdl_seq_new(len, arena);\n            if (targets == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty value;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Assign field \\"targets\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(targets, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"targets\\" missing from Assign");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_value)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_value);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;value, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"value\\" missing from Assign");\n            return 1;\n        }\n        if (exists_not_none(obj, &amp;PyId_type_comment)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_type_comment);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            type_comment = NULL;\n        }\n        *out = Assign(targets, value, type_comment, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)AugAssign_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty target;\n        operator_ty op;\n        expr_ty value;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_target)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_target);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;target, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"target\\" missing from AugAssign");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_op)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_op);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_operator(tmp, &amp;op, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"op\\" missing from AugAssign");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_value)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_value);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;value, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"value\\" missing from AugAssign");\n            return 1;\n        }\n        *out = AugAssign(target, op, value, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)AnnAssign_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty target;\n        expr_ty annotation;\n        expr_ty value;\n        int simple;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_target)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_target);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;target, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"target\\" missing from AnnAssign");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_annotation)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_annotation);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;annotation, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"annotation\\" missing from AnnAssign");\n            return 1;\n        }\n        if (exists_not_none(obj, &amp;PyId_value)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_value);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;value, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            value = NULL;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_simple)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_simple);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_int(tmp, &amp;simple, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"simple\\" missing from AnnAssign");\n            return 1;\n        }\n        *out = AnnAssign(target, annotation, value, simple, lineno, col_offset,\n                         arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)For_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty target;\n        expr_ty iter;\n        asdl_seq* body;\n        asdl_seq* orelse;\n        string type_comment;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_target)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_target);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;target, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"target\\" missing from For");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_iter)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_iter);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;iter, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"iter\\" missing from For");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_body)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_body);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "For field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "For field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from For");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_orelse)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_orelse);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "For field \\"orelse\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            orelse = _Ta3_asdl_seq_new(len, arena);\n            if (orelse == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "For field \\"orelse\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(orelse, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"orelse\\" missing from For");\n            return 1;\n        }\n        if (exists_not_none(obj, &amp;PyId_type_comment)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_type_comment);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            type_comment = NULL;\n        }\n        *out = For(target, iter, body, orelse, type_comment, lineno,\n                   col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)AsyncFor_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty target;\n        expr_ty iter;\n        asdl_seq* body;\n        asdl_seq* orelse;\n        string type_comment;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_target)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_target);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;target, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"target\\" missing from AsyncFor");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_iter)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_iter);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;iter, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"iter\\" missing from AsyncFor");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_body)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_body);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncFor field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncFor field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from AsyncFor");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_orelse)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_orelse);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncFor field \\"orelse\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            orelse = _Ta3_asdl_seq_new(len, arena);\n            if (orelse == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncFor field \\"orelse\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(orelse, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"orelse\\" missing from AsyncFor");\n            return 1;\n        }\n        if (exists_not_none(obj, &amp;PyId_type_comment)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_type_comment);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            type_comment = NULL;\n        }\n        *out = AsyncFor(target, iter, body, orelse, type_comment, lineno,\n                        col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)While_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty test;\n        asdl_seq* body;\n        asdl_seq* orelse;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_test)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_test);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;test, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"test\\" missing from While");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_body)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_body);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "While field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "While field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from While");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_orelse)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_orelse);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "While field \\"orelse\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            orelse = _Ta3_asdl_seq_new(len, arena);\n            if (orelse == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "While field \\"orelse\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(orelse, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"orelse\\" missing from While");\n            return 1;\n        }\n        *out = While(test, body, orelse, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)If_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty test;\n        asdl_seq* body;\n        asdl_seq* orelse;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_test)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_test);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;test, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"test\\" missing from If");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_body)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_body);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "If field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "If field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from If");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_orelse)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_orelse);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "If field \\"orelse\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            orelse = _Ta3_asdl_seq_new(len, arena);\n            if (orelse == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "If field \\"orelse\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(orelse, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"orelse\\" missing from If");\n            return 1;\n        }\n        *out = If(test, body, orelse, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)With_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* items;\n        asdl_seq* body;\n        string type_comment;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_items)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_items);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "With field \\"items\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            items = _Ta3_asdl_seq_new(len, arena);\n            if (items == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                withitem_ty value;\n                res = obj2ast_withitem(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "With field \\"items\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(items, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"items\\" missing from With");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_body)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_body);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "With field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "With field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from With");\n            return 1;\n        }\n        if (exists_not_none(obj, &amp;PyId_type_comment)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_type_comment);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            type_comment = NULL;\n        }\n        *out = With(items, body, type_comment, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)AsyncWith_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* items;\n        asdl_seq* body;\n        string type_comment;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_items)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_items);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncWith field \\"items\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            items = _Ta3_asdl_seq_new(len, arena);\n            if (items == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                withitem_ty value;\n                res = obj2ast_withitem(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncWith field \\"items\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(items, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"items\\" missing from AsyncWith");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_body)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_body);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncWith field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncWith field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from AsyncWith");\n            return 1;\n        }\n        if (exists_not_none(obj, &amp;PyId_type_comment)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_type_comment);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            type_comment = NULL;\n        }\n        *out = AsyncWith(items, body, type_comment, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Raise_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty exc;\n        expr_ty cause;\n\n        if (exists_not_none(obj, &amp;PyId_exc)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_exc);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;exc, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            exc = NULL;\n        }\n        if (exists_not_none(obj, &amp;PyId_cause)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_cause);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;cause, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            cause = NULL;\n        }\n        *out = Raise(exc, cause, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Try_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* body;\n        asdl_seq* handlers;\n        asdl_seq* orelse;\n        asdl_seq* finalbody;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_body)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_body);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Try field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Try field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from Try");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_handlers)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_handlers);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Try field \\"handlers\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            handlers = _Ta3_asdl_seq_new(len, arena);\n            if (handlers == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                excepthandler_ty value;\n                res = obj2ast_excepthandler(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Try field \\"handlers\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(handlers, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"handlers\\" missing from Try");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_orelse)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_orelse);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Try field \\"orelse\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            orelse = _Ta3_asdl_seq_new(len, arena);\n            if (orelse == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Try field \\"orelse\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(orelse, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"orelse\\" missing from Try");\n            return 1;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_finalbody)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_finalbody);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Try field \\"finalbody\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            finalbody = _Ta3_asdl_seq_new(len, arena);\n            if (finalbody == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty value;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Try field \\"finalbody\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(finalbody, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"finalbody\\" missing from Try");\n            return 1;\n        }\n        *out = Try(body, handlers, orelse, finalbody, lineno, col_offset,\n                   arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Assert_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty test;\n        expr_ty msg;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_test)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_test);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;test, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"test\\" missing from Assert");\n            return 1;\n        }\n        if (exists_not_none(obj, &amp;PyId_msg)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_msg);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;msg, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            msg = NULL;\n        }\n        *out = Assert(test, msg, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Import_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* names;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_names)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_names);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Import field \\"names\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            names = _Ta3_asdl_seq_new(len, arena);\n            if (names == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                alias_ty value;\n                res = obj2ast_alias(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Import field \\"names\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(names, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"names\\" missing from Import");\n            return 1;\n        }\n        *out = Import(names, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)ImportFrom_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        identifier module;\n        asdl_seq* names;\n        int level;\n\n        if (exists_not_none(obj, &amp;PyId_module)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_module);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_identifier(tmp, &amp;module, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            module = NULL;\n        }\n        if (_PyObject_HasAttrId(obj, &amp;PyId_names)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_names);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "ImportFrom field \\"names\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            names = _Ta3_asdl_seq_new(len, arena);\n            if (names == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                alias_ty value;\n                res = obj2ast_alias(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "ImportFrom field \\"names\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(names, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"names\\" missing from ImportFrom");\n            return 1;\n        }\n        if (exists_not_none(obj, &amp;PyId_level)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_level);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_int(tmp, &amp;level, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            level = 0;\n        }\n        *out = ImportFrom(module, names, level, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Global_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* names;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_names)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_names);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Global field \\"names\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            names = _Ta3_asdl_seq_new(len, arena);\n            if (names == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                identifier value;\n                res = obj2ast_identifier(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Global field \\"names\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(names, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"names\\" missing from Global");\n            return 1;\n        }\n        *out = Global(names, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Nonlocal_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* names;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_names)) {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_names);\n            if (tmp == NULL) goto failed;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Nonlocal field \\"names\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            names = _Ta3_asdl_seq_new(len, arena);\n            if (names == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                identifier value;\n                res = obj2ast_identifier(PyList_GET_ITEM(tmp, i), &amp;value, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Nonlocal field \\"names\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(names, i, value);\n            }\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"names\\" missing from Nonlocal");\n            return 1;\n        }\n        *out = Nonlocal(names, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Expr_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty value;\n\n        if (_PyObject_HasAttrId(obj, &amp;PyId_value)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &amp;PyId_value);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_expr(tmp, &amp;value, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, "required field \\"value\\" missing from Expr");\n            return 1;\n        }\n        *out = Expr(value, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Pass_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n\n        *out = Pass(lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Break_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n\n        *out = Break(lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Continue_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n\n        *out = Continue(lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n\n    PyErr_Format(PyExc_TypeError, "expected some sort of stmt, but got %R", obj);\n    failed:\n    Py_XDECREF(tmp);\n    return 1;\n}',
 'static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &amp;ms-&gt;parms.qcd;\n\tint i;\n\tfprintf(out, "qntsty = %d; numguard = %d; numstepsizes = %d\\n",\n\t  (int) qcd-&gt;compparms.qntsty, qcd-&gt;compparms.numguard, qcd-&gt;compparms.numstepsizes);\n\tfor (i = 0; i &lt; qcd-&gt;compparms.numstepsizes; ++i) {\n\t\tfprintf(out, "expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd-&gt;compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd-&gt;compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}',
 'static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\n\tevtchn = info-&gt;evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tunmask_evtchn(evtchn);\n}',
 'bool DNP3_Base::ParseAppLayer(Endpoint* endp)\n\t{\n\tbool orig = (endp == &amp;orig_state);\n\tbinpac::DNP3::DNP3_Flow* flow = orig ? interp-&gt;upflow() : interp-&gt;downflow();\n\n\tu_char* data = endp-&gt;buffer + PSEUDO_TRANSPORT_INDEX; // The transport layer byte counts as app-layer it seems.\n\tint len = endp-&gt;pkt_length - 5;\n\n\t// DNP3 Packet :  DNP3 Pseudo Link Layer | DNP3 Pseudo Transport Layer | DNP3 Pseudo Application Layer\n\t// DNP3 Serial Transport Layer data is always 1 byte.\n\t// Get FIN FIR seq field in transport header.\n\t// FIR indicate whether the following DNP3 Serial Application Layer is first chunk of bytes or not.\n\t// FIN indicate whether the following DNP3 Serial Application Layer is last chunk of bytes or not.\n\n\tint is_first = (endp-&gt;tpflags &amp; 0x40) &gt;&gt; 6; // Initial chunk of data in this packet.\n\tint is_last = (endp-&gt;tpflags &amp; 0x80) &gt;&gt; 7; // Last chunk of data in this packet.\n\n\tint transport = PSEUDO_TRANSPORT_LEN;\n\n\tint i = 0;\n\twhile ( len &gt; 0 )\n\t\t{\n\t\tint n = min(len, 16);\n\n\t\t// Make sure chunk has a correct checksum.\n\t\tif ( ! CheckCRC(n, data, data + n, "app_chunk") )\n\t\t\treturn false;\n\n\t\tif ( data + n &gt;= endp-&gt;buffer + endp-&gt;buffer_len )\n\t\t\t{\n\t\t\treporter-&gt;AnalyzerError(analyzer,\n\t\t\t                        "dnp3 app layer parsing overflow %d - %d",\n\t\t\t                        endp-&gt;buffer_len, n);\n\t\t\treturn false;\n\t\t\t}\n\n\t\t// Pass on to BinPAC.\n\t\tflow-&gt;flow_buffer()-&gt;BufferData(data + transport, data + n);\n\t\ttransport = 0;\n\n\t\tdata += n + 2;\n\t\tlen -= n;\n\t\t}\n\n\tif ( is_first )\n\t\tendp-&gt;encountered_first_chunk = true;\n\n\tif ( ! is_first &amp;&amp; ! endp-&gt;encountered_first_chunk )\n\t\t{\n\t\t// We lost the first chunk.\n\t\tanalyzer-&gt;Weird("dnp3_first_application_layer_chunk_missing");\n\t\treturn false;\n\t\t}\n\n\tif ( is_last )\n\t\t{\n\t\tflow-&gt;flow_buffer()-&gt;FinishBuffer();\n\t\tflow-&gt;FlowEOF();\n\t\tClearEndpointState(orig);\n\t\t}\n\n\treturn true;\n\t}',
 'hb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set-&gt;symmetric_difference (*other);\n}',
 'njs_promise_perform_race_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_value_t                  arguments[2], next;\n    njs_promise_capability_t     *capability;\n    njs_promise_iterator_args_t  *pargs;\n\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&amp;njs_value_undefined);\n    }\n\n    pargs = (njs_promise_iterator_args_t *) args;\n\n    ret = njs_function_call(vm, pargs-&gt;function, pargs-&gt;constructor, value,\n                            1, &amp;next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    capability = pargs-&gt;capability;\n\n    arguments[0] = capability-&gt;resolve;\n    arguments[1] = capability-&gt;reject;\n\n    (void) njs_promise_invoke_then(vm, &amp;next, arguments, 2);\n\n    return NJS_OK;\n}',
 'static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tconst unsigned char *b = buf;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint c;\n\tssize_t retval = 0;\n\n\t/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */\n\tif (L_TOSTOP(tty) &amp;&amp; file-&gt;f_op-&gt;write != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&amp;tty-&gt;termios_rwsem);\n\n\t/* Write out any echoed characters that are still pending */\n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&amp;tty-&gt;write_wait, &amp;wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty-&gt;link &amp;&amp; !tty-&gt;link-&gt;count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr &gt; 0) {\n\t\t\t\tssize_t num = process_output_block(tty, b, nr);\n\t\t\t\tif (num &lt; 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *b;\n\t\t\t\tif (process_output(c, tty) &lt; 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n\t\t\tif (tty-&gt;ops-&gt;flush_chars)\n\t\t\t\ttty-&gt;ops-&gt;flush_chars(tty);\n\t\t} else {\n\t\t\tstruct n_tty_data *ldata = tty-&gt;disc_data;\n\n\t\t\twhile (nr &gt; 0) {\n\t\t\t\tmutex_lock(&amp;ldata-&gt;output_lock);\n\t\t\t\tc = tty-&gt;ops-&gt;write(tty, b, nr);\n\t\t\t\tmutex_unlock(&amp;ldata-&gt;output_lock);\n\t\t\t\tif (c &lt; 0) {\n\t\t\t\t\tretval = c;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t\tb += c;\n\t\t\t\tnr -= c;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (file-&gt;f_flags &amp; O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&amp;tty-&gt;termios_rwsem);\n\n\t\tschedule();\n\n\t\tdown_read(&amp;tty-&gt;termios_rwsem);\n\t}\nbreak_out:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&amp;tty-&gt;write_wait, &amp;wait);\n\tif (b - buf != nr &amp;&amp; tty-&gt;fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &amp;tty-&gt;flags);\n\tup_read(&amp;tty-&gt;termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}',
 'shared_ptr &lt;vector&lt;uint8_t&gt;&gt; check_and_set_SEK(const string &amp;SEK) {\n\n    vector&lt;char&gt; decr_key(BUF_LEN, 0);\n    vector&lt;char&gt; errMsg(BUF_LEN, 0);\n    int err_status = 0;\n\n    auto encrypted_SEK = make_shared &lt; vector &lt; uint8_t &gt;&gt; (BUF_LEN, 0);\n\n    uint32_t l = 0;\n\n    sgx_status_t status = trustedSetSEK_backup(eid, &amp;err_status, errMsg.data(), encrypted_SEK-&gt;data(), &amp;l,\n                                               SEK.c_str());\n\n    encrypted_SEK-&gt;resize(l);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n    validate_SEK();\n\n    return encrypted_SEK;\n}',
 'void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  // Already loaded, or invalid.\n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) &lt;&lt; "Reading meta data from file " &lt;&lt; fname &lt;&lt; "...";\n  Table* table;\n  Status s = open_function_(fname, &amp;table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss("Unable to open table file ", fname, ": ",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table-&gt;Get(kSavedTensorSlicesKey, &amp;value) &amp;&amp;\n        ParseProtoUnlimited(&amp;sts, value))) {\n    status_ = errors::Internal(\n        "Failed to find the saved tensor slices at the beginning of the "\n        "checkpoint file: ",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, "Checkpoint",\n                          "checkpoint");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta&amp; ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape(ssm.shape());\n    for (const TensorSliceProto&amp; tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &amp;tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}',
 'AsyncFor(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, int\n         lineno, int col_offset, int end_lineno, int end_col_offset, PyArena\n         *arena)\n{\n    stmt_ty p;\n    if (!target) {\n        PyErr_SetString(PyExc_ValueError,\n                        "field target is required for AsyncFor");\n        return NULL;\n    }\n    if (!iter) {\n        PyErr_SetString(PyExc_ValueError,\n                        "field iter is required for AsyncFor");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p-&gt;kind = AsyncFor_kind;\n    p-&gt;v.AsyncFor.target = target;\n    p-&gt;v.AsyncFor.iter = iter;\n    p-&gt;v.AsyncFor.body = body;\n    p-&gt;v.AsyncFor.orelse = orelse;\n    p-&gt;lineno = lineno;\n    p-&gt;col_offset = col_offset;\n    p-&gt;end_lineno = end_lineno;\n    p-&gt;end_col_offset = end_col_offset;\n    return p;\n}',
 'static const char* ConvertOneFloat(PyObject* v, T* out) {\n  if (PyErr_Occurred()) {\n    return nullptr;\n  }\n  if (TF_PREDICT_TRUE(PyFloat_Check(v))) {\n    const double as_double = PyFloat_AS_DOUBLE(v);\n    *out = static_cast&lt;T&gt;(as_double);\n    // Check for overflow\n    if (TF_PREDICT_FALSE(CheckForOverflow&lt;T&gt;(as_double, out))) {\n      return ErrorOutOfRangeDouble;\n    }\n    return nullptr;\n  }\n#if PY_MAJOR_VERSION &lt; 3\n  if (PyInt_Check(v)) {\n    *out = static_cast&lt;T&gt;(PyInt_AS_LONG(v));\n    return nullptr;\n  }\n#endif\n  if (PyLong_Check(v)) {\n    *out = static_cast&lt;T&gt;(PyLong_AsDouble(v));\n    if (PyErr_Occurred()) return ErrorOutOfRangeDouble;\n    return nullptr;\n  }\n  if (PyIsInstance(v, &amp;PyFloatingArrType_Type)) {  // NumPy float types\n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat&lt;T&gt;(as_float.get(), out);\n  }\n  if (PyIsInstance(v, &amp;PyIntegerArrType_Type)) {  // NumPy integers\n#if PY_MAJOR_VERSION &lt; 3\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat&lt;T&gt;(as_int.get(), out);\n  }\n  return ErrorMixedTypes;\n}',
 'static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb-&gt;len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &amp;_dh);\n\tif (dh == NULL) {\n\t\tmsg = "nf_ct_dccp: short packet ";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh-&gt;dccph_doff * 4 &lt; sizeof(struct dccp_hdr) ||\n\t    dh-&gt;dccph_doff * 4 &gt; dccp_len) {\n\t\tmsg = "nf_ct_dccp: truncated/malformed packet ";\n\t\tgoto out_invalid;\n\t}\n\n\tcscov = dccp_len;\n\tif (dh-&gt;dccph_cscov) {\n\t\tcscov = (dh-&gt;dccph_cscov - 1) * 4;\n\t\tif (cscov &gt; dccp_len) {\n\t\t\tmsg = "nf_ct_dccp: bad checksum coverage ";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\n\tif (net-&gt;ct.sysctl_checksum &amp;&amp; hooknum == NF_INET_PRE_ROUTING &amp;&amp;\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = "nf_ct_dccp: bad checksum ";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh-&gt;dccph_type &gt;= DCCP_PKT_INVALID) {\n\t\tmsg = "nf_ct_dccp: reserved packet type ";\n\t\tgoto out_invalid;\n\t}\n\n\treturn NF_ACCEPT;\n\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, "%s", msg);\n\treturn -NF_ACCEPT;\n}',
 'inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {\n  static char id[32];\n  bool selectedRow=(i&gt;=sel1.y &amp;&amp; i&lt;=sel2.y);\n  ImGui::TableNextRow(0,lineHeight);\n  ImGui::TableNextColumn();\n  float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();\n  // check if the row is visible\n  if (cursorPosY&lt;-lineHeight || cursorPosY&gt;ImGui::GetWindowSize().y) {\n    return;\n  }\n  // check if we are in range\n  if (ord&lt;0 || ord&gt;=e-&gt;song.ordersLen) {\n    return;\n  }\n  if (i&lt;0 || i&gt;=e-&gt;song.patLen) {\n    return;\n  }\n  bool isPushing=false;\n  ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];\n  ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];\n  ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];\n  if (e-&gt;song.hilightB&gt;0 &amp;&amp; !(i%e-&gt;song.hilightB)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];\n  } else if (e-&gt;song.hilightA&gt;0 &amp;&amp; !(i%e-&gt;song.hilightA)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];\n  }\n  // check overflow highlight\n  if (settings.overflowHighlight) {\n    if (edit &amp;&amp; cursor.y==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying &amp;&amp; oldRow==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e-&gt;song.hilightB&gt;0 &amp;&amp; !(i%e-&gt;song.hilightB)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e-&gt;song.hilightA&gt;0 &amp;&amp; !(i%e-&gt;song.hilightA)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    }\n  } else {\n    isPushing=true;\n    if (edit &amp;&amp; cursor.y==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying &amp;&amp; oldRow==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e-&gt;song.hilightB&gt;0 &amp;&amp; !(i%e-&gt;song.hilightB)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e-&gt;song.hilightA&gt;0 &amp;&amp; !(i%e-&gt;song.hilightA)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    } else {\n      isPushing=false;\n    }\n  }\n  // row number\n  if (settings.patRowsBase==1) {\n    ImGui::TextColored(rowIndexColor," %.2X ",i);\n  } else {\n    ImGui::TextColored(rowIndexColor,"%3d ",i);\n  }\n  // for each column\n  for (int j=0; j&lt;chans; j++) {\n    // check if channel is not hidden\n    if (!e-&gt;song.chanShow[j]) {\n      patChanX[j]=ImGui::GetCursorPosX();\n      continue;\n    }\n    int chanVolMax=e-&gt;getMaxVolumeChan(j);\n    if (chanVolMax&lt;1) chanVolMax=1;\n    const DivPattern* pat=patCache[j];\n    ImGui::TableNextColumn();\n    patChanX[j]=ImGui::GetCursorPosX();\n\n    // selection highlight flags\n    int sel1XSum=sel1.xCoarse*32+sel1.xFine;\n    int sel2XSum=sel2.xCoarse*32+sel2.xFine;\n    int j32=j*32;\n    bool selectedNote=selectedRow &amp;&amp; (j32&gt;=sel1XSum &amp;&amp; j32&lt;=sel2XSum);\n    bool selectedIns=selectedRow &amp;&amp; (j32+1&gt;=sel1XSum &amp;&amp; j32+1&lt;=sel2XSum);\n    bool selectedVol=selectedRow &amp;&amp; (j32+2&gt;=sel1XSum &amp;&amp; j32+2&lt;=sel2XSum);\n    bool cursorNote=(cursor.y==i &amp;&amp; cursor.xCoarse==j &amp;&amp; cursor.xFine==0);\n    bool cursorIns=(cursor.y==i &amp;&amp; cursor.xCoarse==j &amp;&amp; cursor.xFine==1);\n    bool cursorVol=(cursor.y==i &amp;&amp; cursor.xCoarse==j &amp;&amp; cursor.xFine==2);\n\n    // note\n    sprintf(id,"%s##PN_%d_%d",noteName(pat-&gt;data[i][0],pat-&gt;data[i][1]),i,j);\n    if (pat-&gt;data[i][0]==0 &amp;&amp; pat-&gt;data[i][1]==0) {\n      ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n    } else {\n      ImGui::PushStyleColor(ImGuiCol_Text,activeColor);\n    }\n    if (cursorNote) {\n      ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n      ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      demandX=ImGui::GetCursorPosX();\n      ImGui::PopStyleColor(3);\n    } else {\n      if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n      ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      if (selectedNote) ImGui::PopStyleColor();\n    }\n    if (ImGui::IsItemClicked()) {\n      startSelection(j,0,i);\n    }\n    if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n      updateSelection(j,0,i);\n    }\n    ImGui::PopStyleColor();\n\n    // the following is only visible when the channel is not collapsed\n    if (!e-&gt;song.chanCollapse[j]) {\n      // instrument\n      if (pat-&gt;data[i][2]==-1) {\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        sprintf(id,"..##PI_%d_%d",i,j);\n      } else {\n        if (pat-&gt;data[i][2]&lt;0 || pat-&gt;data[i][2]&gt;=e-&gt;song.insLen) {\n          ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);\n        } else {\n          DivInstrumentType t=e-&gt;song.ins[pat-&gt;data[i][2]]-&gt;type;\n          if (t!=DIV_INS_AMIGA &amp;&amp; t!=e-&gt;getPreferInsType(j)) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);\n          }\n        }\n        sprintf(id,"%.2X##PI_%d_%d",pat-&gt;data[i][2],i,j);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorIns) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedIns) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,1,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,1,i);\n      }\n      ImGui::PopStyleColor();\n\n      // volume\n      if (pat-&gt;data[i][3]==-1) {\n        sprintf(id,"..##PV_%d_%d",i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n      } else {\n        int volColor=(pat-&gt;data[i][3]*127)/chanVolMax;\n        if (volColor&gt;127) volColor=127;\n        if (volColor&lt;0) volColor=0;\n        sprintf(id,"%.2X##PV_%d_%d",pat-&gt;data[i][3],i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorVol) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedVol) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,2,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,2,i);\n      }\n      ImGui::PopStyleColor();\n\n      // effects\n      for (int k=0; k&lt;e-&gt;song.pat[j].effectRows; k++) {\n        int index=4+(k&lt;&lt;1);\n        bool selectedEffect=selectedRow &amp;&amp; (j32+index-1&gt;=sel1XSum &amp;&amp; j32+index-1&lt;=sel2XSum);\n        bool selectedEffectVal=selectedRow &amp;&amp; (j32+index&gt;=sel1XSum &amp;&amp; j32+index&lt;=sel2XSum);\n        bool cursorEffect=(cursor.y==i &amp;&amp; cursor.xCoarse==j &amp;&amp; cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i &amp;&amp; cursor.xCoarse==j &amp;&amp; cursor.xFine==index);\n        \n        // effect\n        if (pat-&gt;data[i][index]==-1) {\n          sprintf(id,"..##PE%d_%d_%d",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          if (pat-&gt;data[i][index]&gt;0xff) {\n            sprintf(id,"??##PE%d_%d_%d",k,i,j);\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            const unsigned char data=pat-&gt;data[i][index];\n            sprintf(id,"%.2X##PE%d_%d_%d",data,k,i,j);\n            if (data&lt;0x10) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);\n            } else if (data&lt;0x20) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data&lt;0x30) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n            } else if (data&lt;0x48) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data&lt;0x90) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data&lt;0xa0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n            } else if (data&lt;0xc0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data&lt;0xd0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n            } else if (data&lt;0xe0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);\n            }\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffect) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index-1,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index-1,i);\n        }\n\n        // effect value\n        if (pat-&gt;data[i][index+1]==-1) {\n          sprintf(id,"..##PF%d_%d_%d",k,i,j);\n        } else {\n          sprintf(id,"%.2X##PF%d_%d_%d",pat-&gt;data[i][index+1],k,i,j);\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffectVal) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffectVal) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index,i);\n        }\n        ImGui::PopStyleColor();\n      }\n    }\n  }\n  if (isPushing) {\n    ImGui::PopStyleColor();\n  }\n  ImGui::TableNextColumn();\n  patChanX[chans]=ImGui::GetCursorPosX();\n}',
 'vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\n\tif (!vq || !vq-&gt;used)\n\t\treturn;\n\n\t/*\n\t * Interrupt generation: if we\'re using EVENT_IDX,\n\t * interrupt if we\'ve crossed the event threshold.\n\t * Otherwise interrupt is generated if we added "used" entries,\n\t * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.\n\t *\n\t * In any case, though, if NOTIFY_ON_EMPTY is set and the\n\t * entire avail was processed, we need to interrupt always.\n\t */\n\n\tatomic_thread_fence();\n\n\tbase = vq-&gt;base;\n\told_idx = vq-&gt;save_used;\n\tvq-&gt;save_used = new_idx = vq-&gt;used-&gt;idx;\n\tif (used_all_avail &amp;&amp;\n\t    (base-&gt;negotiated_caps &amp; (1 &lt;&lt; VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base-&gt;negotiated_caps &amp; (1 &lt;&lt; VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\t/*\n\t\t * This calculation is per docs and the kernel\n\t\t * (see src/sys/dev/virtio/virtio_ring.h).\n\t\t */\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) &lt;\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &amp;&amp;\n\t\t    !(vq-&gt;avail-&gt;flags &amp; VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}',
 'TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteType output_type = GetOutput(context, node, kOutputTensor)-&gt;type;\n\n  switch (output_type) {  // Already know in/outtypes are same.\n    case kTfLiteFloat32:\n      EvalUnquantized&lt;float&gt;(context, node);\n      break;\n    case kTfLiteInt32:\n      EvalUnquantized&lt;int32_t&gt;(context, node);\n      break;\n    case kTfLiteUInt8:\n      EvalQuantizedUInt8(context, node);\n      break;\n    case kTfLiteInt8:\n      EvalUnquantized&lt;int8_t&gt;(context, node);\n      break;\n    case kTfLiteInt64:\n      EvalUnquantized&lt;int64_t&gt;(context, node);\n      break;\n\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, "Op Concatenation does not currently support Type \'%s\'.",\n          TfLiteTypeGetName(output_type));\n      return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}',
 "get_function_line(\n\texarg_T\t\t*eap,\n\tchar_u\t\t**line_to_free,\n\tint\t\tindent,\n\tgetline_opt_T\tgetline_options)\n{\n    char_u *theline;\n\n    if (eap-&gt;getline == NULL)\n\ttheline = getcmdline(':', 0L, indent, 0);\n    else\n\ttheline = eap-&gt;getline(':', eap-&gt;cookie, indent, getline_options);\n    if (theline != NULL)\n    {\n\tif (*eap-&gt;cmdlinep == *line_to_free)\n\t    *eap-&gt;cmdlinep = theline;\n\tvim_free(*line_to_free);\n\t*line_to_free = theline;\n    }\n\n    return theline;\n}",
 'static void rekey_seq_generator(struct work_struct *work)\n{\n\tstruct keydata *keyptr = &amp;ip_keydata[1 ^ (ip_cnt &amp; 1)];\n\n\tget_random_bytes(keyptr-&gt;secret, sizeof(keyptr-&gt;secret));\n\tkeyptr-&gt;count = (ip_cnt &amp; COUNT_MASK) &lt;&lt; HASH_BITS;\n\tsmp_wmb();\n\tip_cnt++;\n\tschedule_delayed_work(&amp;rekey_work,\n\t\t\t      round_jiffies_relative(REKEY_INTERVAL));\n}',
 'static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card-&gt;ctx, SC_LOG_DEBUG_NORMAL);\n        if (card-&gt;serialnr.len)   {\n                *serial = card-&gt;serialnr;\n                SC_FUNC_RETURN(card-&gt;ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv-&gt;cac_id_len) {\n\t\tserial-&gt;len = MIN(priv-&gt;cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial-&gt;value, priv-&gt;cac_id, priv-&gt;cac_id_len);\n\t\tSC_FUNC_RETURN(card-&gt;ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card-&gt;ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}',
 'static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path *path,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags)\n{\n\text4_fsblk_t newblock;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex, newex, orig_ex;\n\tstruct ext4_extent *ex2 = NULL;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\n\text_debug("ext4_split_extents_at: inode %lu, logical"\n\t\t"block %llu\\n", inode-&gt;i_ino, (unsigned long long)split);\n\n\text4_ext_show_leaf(inode, path);\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex-&gt;ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tnewblock = split - ee_block + ext4_ext_pblock(ex);\n\n\tBUG_ON(split &lt; ee_block || split &gt;= (ee_block + ee_len));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\n\tif (split == ee_block) {\n\t\t/*\n\t\t * case b: block @split is the block that the extent begins with\n\t\t * then we just change the state of the extent, and splitting\n\t\t * is not needed.\n\t\t */\n\t\tif (split_flag &amp; EXT4_EXT_MARK_UNINIT2)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\telse\n\t\t\text4_ext_mark_initialized(ex);\n\n\t\tif (!(flags &amp; EXT4_GET_BLOCKS_PRE_IO))\n\t\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + path-&gt;p_depth);\n\t\tgoto out;\n\t}\n\n\t/* case a */\n\tmemcpy(&amp;orig_ex, ex, sizeof(orig_ex));\n\tex-&gt;ee_len = cpu_to_le16(split - ee_block);\n\tif (split_flag &amp; EXT4_EXT_MARK_UNINIT1)\n\t\text4_ext_mark_uninitialized(ex);\n\n\t/*\n\t * path may lead to new leaf, not to original leaf any more\n\t * after ext4_ext_insert_extent() returns,\n\t */\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\tif (err)\n\t\tgoto fix_extent_len;\n\n\tex2 = &amp;newex;\n\tex2-&gt;ee_block = cpu_to_le32(split);\n\tex2-&gt;ee_len   = cpu_to_le16(ee_len - (split - ee_block));\n\text4_ext_store_pblock(ex2, newblock);\n\tif (split_flag &amp; EXT4_EXT_MARK_UNINIT2)\n\t\text4_ext_mark_uninitialized(ex2);\n\n\terr = ext4_ext_insert_extent(handle, inode, path, &amp;newex, flags);\n\tif (err == -ENOSPC &amp;&amp; (EXT4_EXT_MAY_ZEROOUT &amp; split_flag)) {\n\t\terr = ext4_ext_zeroout(inode, &amp;orig_ex);\n\t\tif (err)\n\t\t\tgoto fix_extent_len;\n\t\t/* update the extent length and mark as initialized */\n\t\tex-&gt;ee_len = cpu_to_le16(ee_len);\n\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\t\terr = ext4_ext_dirty(handle, inode, path + path-&gt;p_depth);\n\t\tgoto out;\n\t} else if (err)\n\t\tgoto fix_extent_len;\n\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n\nfix_extent_len:\n\tex-&gt;ee_len = orig_ex.ee_len;\n\text4_ext_dirty(handle, inode, path + depth);\n\treturn err;\n}',
 'bool zx_confirmZxLiquidTx(uint32_t data_total, const EthereumSignTx *msg) {\n    (void)data_total;\n    const TokenType *token;\n    char constr1[40], constr2[40], *arStr = "";\n    uint8_t *tokenAddress, *deadlineBytes;\n    bignum256 tokenAmount, tokenMinAmount, ethMinAmount;\n    uint64_t deadline;\n\n    if (isAddLiquidityEthCall(msg)) {\n        arStr = "uniswap add liquidity";\n    } else if (isRemoveLiquidityEthCall(msg)) {\n        arStr = "uniswap remove liquidity";\n    } else {\n        return false;\n    }\n\n    tokenAddress = (uint8_t *)(msg-&gt;data_initial_chunk.bytes + 4 + 32 - 20);\n    token = tokenByChainAddress(msg-&gt;chain_id, tokenAddress);\n    bn_from_bytes(msg-&gt;data_initial_chunk.bytes + 4 + 32, 32, &amp;tokenAmount);\n    bn_from_bytes(msg-&gt;data_initial_chunk.bytes + 4 + 2*32, 32, &amp;tokenMinAmount);\n    bn_from_bytes(msg-&gt;data_initial_chunk.bytes + 4 + 3*32, 32, &amp;ethMinAmount);\n    deadlineBytes = (uint8_t *)(msg-&gt;data_initial_chunk.bytes + 4 + 6*32 - 8);\n    deadline = ((uint64_t)deadlineBytes[0] &lt;&lt; 8*7) |\n               ((uint64_t)deadlineBytes[1] &lt;&lt; 8*6) |\n               ((uint64_t)deadlineBytes[2] &lt;&lt; 8*5) |\n               ((uint64_t)deadlineBytes[3] &lt;&lt; 8*4) |\n               ((uint64_t)deadlineBytes[4] &lt;&lt; 8*3) |\n               ((uint64_t)deadlineBytes[5] &lt;&lt; 8*2) |\n               ((uint64_t)deadlineBytes[6] &lt;&lt; 8*1) |\n               ((uint64_t)deadlineBytes[7]);\n        \n    char tokbuf[32];\n    ethereumFormatAmount(&amp;tokenAmount, token, msg-&gt;chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr1, 32, "%s", tokbuf);\n    ethereumFormatAmount(&amp;tokenMinAmount, token, msg-&gt;chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr2, 32, "%s", tokbuf);\n    confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,\n                 "%s\\nMinimum %s", constr1, constr2);\n    if (!confirmFromAccountMatch(msg, arStr)) {\n        return false;\n    }\n    \n    ethereumFormatAmount(&amp;ethMinAmount, NULL, msg-&gt;chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr1, 32, "%s", tokbuf);\n    confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,\n                 "Minimum %s", constr1);\n\n    snprintf(constr1, 32, "%lld", deadline);\n    confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,\n                 "Deadline %s", ctime((const time_t *)&amp;deadline));\n    \n    return true;\n}',
 'static double ipow( double n, int exp )\n{\n\tdouble r;\n\n\tif ( exp &lt; 0 )\n\t\treturn 1.0 / ipow( n, -exp );\n\tr = 1;\n\twhile ( exp &gt; 0 ) {\n\t\tif ( exp &amp; 1 )\n\t\t\tr *= n;\n\t\texp &gt;&gt;= 1;\n\t\tn *= n;\n\t}\n\treturn r;\n}',
 "  void combine_list(String &amp; res, const StringList &amp; in)\n  {\n    res.clear();\n    StringListEnumeration els = in.elements_obj();\n    const char * s = 0;\n    while ( (s = els.next()) != 0) \n    {\n      for (; *s; ++s) {\n        if (*s == ':')\n          res.append('\\\\');\n        res.append(*s);\n      }\n      res.append(':');\n    }\n    if (res.back() == ':') res.pop_back();\n  }",
 'int firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x&gt;&gt;=1;\n                ++position;\n        }\n        return position;\n}',
 'int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    if( profile == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    *flags = 0;\n\n    if( cn != NULL )\n    {\n        name = &amp;crt-&gt;subject;\n        cn_len = strlen( cn );\n\n        if( crt-&gt;ext_types &amp; MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &amp;crt-&gt;subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur-&gt;buf.len == cn_len &amp;&amp;\n                    x509_memcasecmp( cn, cur-&gt;buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur-&gt;buf.len &gt; 2 &amp;&amp;\n                    memcmp( cur-&gt;buf.p, "*.", 2 ) == 0 &amp;&amp;\n                    x509_check_wildcard( cn, &amp;cur-&gt;buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur-&gt;next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &amp;name-&gt;oid ) == 0 )\n                {\n                    if( name-&gt;val.len == cn_len &amp;&amp;\n                        x509_memcasecmp( name-&gt;val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name-&gt;val.len &gt; 2 &amp;&amp;\n                        memcmp( name-&gt;val.p, "*.", 2 ) == 0 &amp;&amp;\n                        x509_check_wildcard( cn, &amp;name-&gt;val ) == 0 )\n                        break;\n                }\n\n                name = name-&gt;next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &amp;crt-&gt;pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &amp;crt-&gt;pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent-&gt;next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt-&gt;next; parent != NULL; parent = parent-&gt;next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}',
 'spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}',
 'mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0) return NULL;\n  while ((cl-&gt;tt == MRB_TT_SCLASS) || (cl-&gt;tt == MRB_TT_ICLASS)) {\n    cl = cl-&gt;super;\n    if (cl == 0) return NULL;\n  }\n  return cl;\n}',
 'TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node,\n                                  TfLiteConvParams* params, OpData* data,\n                                  const TfLiteTensor* input,\n                                  const TfLiteTensor* filter,\n                                  const TfLiteTensor* bias,\n                                  TfLiteTensor* im2col, TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params-&gt;activation, &amp;output_activation_min,\n                           &amp;output_activation_max);\n\n  const int batch_size = SizeOfDimension(input, 0);\n  TF_LITE_ENSURE(context, batch_size != 0);\n  const int input_size = NumElements(input) / batch_size;\n  TfLiteTensor* quantized_input_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data-&gt;input_quantized_index,\n                                     &amp;quantized_input_tensor));\n  int8_t* quantized_input_ptr_batch =\n      GetTensorData&lt;int8_t&gt;(quantized_input_tensor);\n  TfLiteTensor* scaling_factors_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data-&gt;scaling_factors_index,\n                                     &amp;scaling_factors_tensor));\n  float* scaling_factors_ptr = GetTensorData&lt;float&gt;(scaling_factors_tensor);\n  TfLiteTensor* input_offset_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data-&gt;input_offset_index,\n                                     &amp;input_offset_tensor));\n  int32_t* input_offset_ptr = GetTensorData&lt;int32_t&gt;(input_offset_tensor);\n\n  for (int b = 0; b &lt; batch_size; ++b) {\n    const int offset = b * input_size;\n    tensor_utils::AsymmetricQuantizeFloats(\n        GetTensorData&lt;float&gt;(input) + offset, input_size,\n        quantized_input_ptr_batch + offset, &amp;scaling_factors_ptr[b],\n        &amp;input_offset_ptr[b]);\n  }\n\n  int8_t* im2col_ptr = nullptr;\n  int8_t* filter_ptr = nullptr;\n  if (im2col != nullptr) {\n    im2col_ptr = im2col-&gt;data.int8;\n  }\n  filter_ptr = filter-&gt;data.int8;\n  const auto* affine_quantization =\n      reinterpret_cast&lt;TfLiteAffineQuantization*&gt;(filter-&gt;quantization.params);\n\n  KernelType effective_kernel_type = kernel_type;\n  // We have to fallback to reference execution path when im2col is needed but\n  // disabled because to-be-allocated temporary im2col tensor is too large.\n  // See b/178743262 for the detailed motivation.\n  if (data-&gt;im2col_oversized) {\n    effective_kernel_type = kReference;\n  }\n\n  ConvParams op_params;\n  op_params.padding_type = PaddingType::kSame;\n  op_params.padding_values.width = data-&gt;padding.width;\n  op_params.padding_values.height = data-&gt;padding.height;\n  op_params.dilation_width_factor = params-&gt;dilation_width_factor;\n  op_params.dilation_height_factor = params-&gt;dilation_height_factor;\n  op_params.stride_width = params-&gt;stride_width;\n  op_params.stride_height = params-&gt;stride_height;\n  op_params.float_activation_min = output_activation_min;\n  op_params.float_activation_max = output_activation_max;\n  switch (effective_kernel_type) {\n    case kReference:\n      reference_ops::HybridConvPerChannel(\n          op_params, scaling_factors_ptr, GetTensorShape(input),\n          quantized_input_ptr_batch, GetTensorShape(filter), filter_ptr,\n          GetTensorShape(bias), GetTensorData&lt;float&gt;(bias),\n          GetTensorShape(output), GetTensorData&lt;float&gt;(output),\n          GetTensorShape(im2col), im2col_ptr, affine_quantization-&gt;scale-&gt;data,\n          input_offset_ptr);\n      break;\n    case kGenericOptimized:\n    case kMultithreadOptimized:\n    case kCblasOptimized: {\n      TfLiteTensor* row_sums;\n      TF_LITE_ENSURE_OK(\n          context,\n          GetTemporarySafe(context, node, data-&gt;row_sums_index, &amp;row_sums));\n      TfLiteTensor* scratch;\n      TF_LITE_ENSURE_OK(\n          context,\n          GetTemporarySafe(context, node, data-&gt;accum_scratch_index, &amp;scratch));\n      optimized_ops::HybridConvPerChannel(\n          op_params, scaling_factors_ptr, GetTensorShape(input),\n          quantized_input_ptr_batch, GetTensorShape(filter), filter_ptr,\n          GetTensorShape(bias), GetTensorData&lt;float&gt;(bias),\n          GetTensorShape(output), GetTensorData&lt;float&gt;(output),\n          GetTensorShape(im2col), im2col_ptr, affine_quantization-&gt;scale-&gt;data,\n          input_offset_ptr, GetTensorShape(scratch),\n          GetTensorData&lt;int32&gt;(scratch), GetTensorData&lt;int32_t&gt;(row_sums),\n          &amp;data-&gt;compute_hybrid_row_sums,\n          CpuBackendContext::GetFromContext(context));\n      data-&gt;compute_hybrid_row_sums = false;\n      break;\n    }\n  }\n\n  return kTfLiteOk;\n}',
 'static int pcd_detect(void)\n{\n\tchar id[18];\n\tint k, unit;\n\tstruct pcd_unit *cd;\n\n\tprintk("%s: %s version %s, major %d, nice %d\\n",\n\t       name, name, PCD_VERSION, major, nice);\n\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err("failed to register %s driver\\n", name);\n\t\treturn -1;\n\t}\n\n\tk = 0;\n\tif (pcd_drive_count == 0) { /* nothing spec\'d - so autoprobe for 1 */\n\t\tcd = pcd;\n\t\tif (pi_init(cd-&gt;pi, 1, -1, -1, -1, -1, -1, pcd_buffer,\n\t\t\t    PI_PCD, verbose, cd-&gt;name)) {\n\t\t\tif (!pcd_probe(cd, -1, id) &amp;&amp; cd-&gt;disk) {\n\t\t\t\tcd-&gt;present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd-&gt;pi);\n\t\t}\n\t} else {\n\t\tfor (unit = 0, cd = pcd; unit &lt; PCD_UNITS; unit++, cd++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (!pi_init(cd-&gt;pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t     conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t     pcd_buffer, PI_PCD, verbose, cd-&gt;name)) \n\t\t\t\tcontinue;\n\t\t\tif (!pcd_probe(cd, conf[D_SLV], id) &amp;&amp; cd-&gt;disk) {\n\t\t\t\tcd-&gt;present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd-&gt;pi);\n\t\t}\n\t}\n\tif (k)\n\t\treturn 0;\n\n\tprintk("%s: No CD-ROM drive found\\n", name);\n\tfor (unit = 0, cd = pcd; unit &lt; PCD_UNITS; unit++, cd++) {\n\t\tif (!cd-&gt;disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(cd-&gt;disk-&gt;queue);\n\t\tcd-&gt;disk-&gt;queue = NULL;\n\t\tblk_mq_free_tag_set(&amp;cd-&gt;tag_set);\n\t\tput_disk(cd-&gt;disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}',
 'void AverageEvalQuantizedInt8(TfLiteContext* context, TfLiteNode* node,\n                              TfLitePoolParams* params, OpData* data,\n                              const TfLiteTensor* input, TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n\n  (void)CalculateActivationRangeQuantized(context, params-&gt;activation, output,\n                                          &amp;activation_min, &amp;activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                        \\\n  tflite::PoolParams op_params;                                           \\\n  op_params.stride_height = params-&gt;stride_height;                        \\\n  op_params.stride_width = params-&gt;stride_width;                          \\\n  op_params.filter_height = params-&gt;filter_height;                        \\\n  op_params.filter_width = params-&gt;filter_width;                          \\\n  op_params.padding_values.height = data-&gt;padding.height;                 \\\n  op_params.padding_values.width = data-&gt;padding.width;                   \\\n  op_params.quantized_activation_min = activation_min;                    \\\n  op_params.quantized_activation_max = activation_max;                    \\\n  type::AveragePool(op_params, GetTensorShape(input),                     \\\n                    GetTensorData&lt;int8_t&gt;(input), GetTensorShape(output), \\\n                    GetTensorData&lt;int8_t&gt;(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_integer_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_integer_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}',
 "int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,\n\t\t\t    struct mem_access *ma, int expected,\n\t\t\t    unsigned long address)\n{\n\tu_int rm;\n\tint ret, index;\n\n\t/*\n\t * XXX: We can't handle mixed 16/32-bit instructions yet\n\t */\n\tif (instruction_size(instruction) != 2)\n\t\treturn -EINVAL;\n\n\tindex = (instruction&gt;&gt;8)&amp;15;\t/* 0x0F00 */\n\trm = regs-&gt;regs[index];\n\n\t/*\n\t * Log the unexpected fixups, and then pass them on to perf.\n\t *\n\t * We intentionally don't report the expected cases to perf as\n\t * otherwise the trapped I/O case will skew the results too much\n\t * to be useful.\n\t */\n\tif (!expected) {\n\t\tunaligned_fixups_notify(current, instruction, regs);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,\n\t\t\t      regs, address);\n\t}\n\n\tret = -EFAULT;\n\tswitch (instruction&amp;0xF000) {\n\tcase 0x0000:\n\t\tif (instruction==0x000B) {\n\t\t\t/* rts */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs-&gt;pc = regs-&gt;pr;\n\t\t}\n\t\telse if ((instruction&amp;0x00FF)==0x0023) {\n\t\t\t/* braf @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs-&gt;pc += rm + 4;\n\t\t}\n\t\telse if ((instruction&amp;0x00FF)==0x0003) {\n\t\t\t/* bsrf @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n\t\t\t\tregs-&gt;pr = regs-&gt;pc + 4;\n\t\t\t\tregs-&gt;pc += rm + 4;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* mov.[bwl] to/from memory via r0+rn */\n\t\t\tgoto simple;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1000: /* mov.l Rm,@(disp,Rn) */\n\t\tgoto simple;\n\n\tcase 0x2000: /* mov.[bwl] to memory, possibly with pre-decrement */\n\t\tgoto simple;\n\n\tcase 0x4000:\n\t\tif ((instruction&amp;0x00FF)==0x002B) {\n\t\t\t/* jmp @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs-&gt;pc = rm;\n\t\t}\n\t\telse if ((instruction&amp;0x00FF)==0x000B) {\n\t\t\t/* jsr @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n\t\t\t\tregs-&gt;pr = regs-&gt;pc + 4;\n\t\t\t\tregs-&gt;pc = rm;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* mov.[bwl] to/from memory via r0+rn */\n\t\t\tgoto simple;\n\t\t}\n\t\tbreak;\n\n\tcase 0x5000: /* mov.l @(disp,Rm),Rn */\n\t\tgoto simple;\n\n\tcase 0x6000: /* mov.[bwl] from memory, possibly with post-increment */\n\t\tgoto simple;\n\n\tcase 0x8000: /* bf lab, bf/s lab, bt lab, bt/s lab */\n\t\tswitch (instruction&amp;0x0F00) {\n\t\tcase 0x0100: /* mov.w R0,@(disp,Rm) */\n\t\t\tgoto simple;\n\t\tcase 0x0500: /* mov.w @(disp,Rm),R0 */\n\t\t\tgoto simple;\n\t\tcase 0x0B00: /* bf   lab - no delayslot*/\n\t\t\tbreak;\n\t\tcase 0x0F00: /* bf/s lab */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)\n\t\t\t\tif ((regs-&gt;sr &amp; 0x00000001) != 0)\n\t\t\t\t\tregs-&gt;pc += 4; /* next after slot */\n\t\t\t\telse\n#endif\n\t\t\t\t\tregs-&gt;pc += SH_PC_8BIT_OFFSET(instruction);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x0900: /* bt   lab - no delayslot */\n\t\t\tbreak;\n\t\tcase 0x0D00: /* bt/s lab */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)\n\t\t\t\tif ((regs-&gt;sr &amp; 0x00000001) == 0)\n\t\t\t\t\tregs-&gt;pc += 4; /* next after slot */\n\t\t\t\telse\n#endif\n\t\t\t\t\tregs-&gt;pc += SH_PC_8BIT_OFFSET(instruction);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0xA000: /* bra label */\n\t\tret = handle_delayslot(regs, instruction, ma);\n\t\tif (ret==0)\n\t\t\tregs-&gt;pc += SH_PC_12BIT_OFFSET(instruction);\n\t\tbreak;\n\n\tcase 0xB000: /* bsr label */\n\t\tret = handle_delayslot(regs, instruction, ma);\n\t\tif (ret==0) {\n\t\t\tregs-&gt;pr = regs-&gt;pc + 4;\n\t\t\tregs-&gt;pc += SH_PC_12BIT_OFFSET(instruction);\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n\n\t/* handle non-delay-slot instruction */\n simple:\n\tret = handle_unaligned_ins(instruction, regs, ma);\n\tif (ret==0)\n\t\tregs-&gt;pc += instruction_size(instruction);\n\treturn ret;\n}",
 'static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print("%s", "INDX structure not initialized\\n");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx-&gt;entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number &gt;= indx-&gt;total_entries_count) {\n        debug_print("Entry number beyond array: %zu\\n", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* save original record maxlen */\n    const size_t buf_maxlen = buf-&gt;maxlen;\n    if (buf-&gt;offset + entry_length &gt;= buf_maxlen) {\n        debug_print("Entry length too long: %zu\\n", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf-&gt;maxlen = buf-&gt;offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length &gt; entry_length) {\n        debug_print("Label length too long: %zu\\n", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX];\n    /* FIXME: what is ORDT1 for? */\n    if (ordt-&gt;ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx-&gt;ligt_entries_count);\n    }\n    indx-&gt;entries[entry_number].label = malloc(label_length + 1);\n    if (indx-&gt;entries[entry_number].label == NULL) {\n        debug_print("Memory allocation failed (%zu bytes)\\n", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx-&gt;entries[entry_number].label, text, label_length + 1);\n    //debug_print("tag label[%zu]: %s\\n", entry_number, indx-&gt;entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf-&gt;data + buf-&gt;offset;\n    mobi_buffer_seek(buf, (int) tagx-&gt;control_byte_count);\n    indx-&gt;entries[entry_number].tags_count = 0;\n    indx-&gt;entries[entry_number].tags = NULL;\n    if (tagx-&gt;tags_count &gt; 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx-&gt;tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print("Memory allocation failed (%zu bytes)\\n", tagx-&gt;tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i &lt; tagx-&gt;tags_count) {\n            if (tagx-&gt;tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] &amp; tagx-&gt;tags[i].bitmask;\n            if (value != 0) {\n                /* FIXME: is it safe to use MOBI_NOTSET? */\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                /* all bits of masked value are set */\n                if (value == tagx-&gt;tags[i].bitmask) {\n                    /* more than 1 bit set */\n                    if (mobi_bitcount(tagx-&gt;tags[i].bitmask) &gt; 1) {\n                        /* read value bytes from entry */\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &amp;len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx-&gt;tags[i].bitmask;\n                    while ((mask &amp; 1) == 0) {\n                        mask &gt;&gt;= 1;\n                        value &gt;&gt;= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx-&gt;tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx-&gt;tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx-&gt;entries[entry_number].tags = malloc(tagx-&gt;tags_count * sizeof(MOBIIndexTag));\n        if (indx-&gt;entries[entry_number].tags == NULL) {\n            debug_print("Memory allocation failed (%zu bytes)\\n", tagx-&gt;tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i &lt; ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            /* FIXME: is it safe to use MOBI_NOTSET? */\n            /* value count is set */\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- &amp;&amp; tagvalues_count &lt; INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &amp;len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            /* value count is not set */\n            } else {\n                /* read value_bytes bytes */\n                len = 0;\n                while (len &lt; ptagx[i].value_bytes &amp;&amp; tagvalues_count &lt; INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &amp;len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx-&gt;entries[entry_number].tags[i].tagvalues);\n                indx-&gt;entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx-&gt;entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print("Memory allocation failed (%zu bytes)\\n", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx-&gt;entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx-&gt;entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx-&gt;entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx-&gt;entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx-&gt;entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    /* restore buffer maxlen */\n    buf-&gt;maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}',
 'static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len&lt;4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, "ICC profile segment, selector=%d, data len=%d", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d-&gt;iccprofile_file);\n\t\td-&gt;iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td-&gt;iccprofile_file = dbuf_create_output_file(c, "icc", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\n\t\tif(!d-&gt;iccprofile_file) {\n\t\t\tde_warn(c, "Bad ICC profile segment");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c-&gt;infile, pos+4, data_len, d-&gt;iccprofile_file);\n\t}\n}',
 'pci_lintr_route(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct intxinfo *ii;\n\n\tif (dev-&gt;lintr.pin == 0)\n\t\treturn;\n\n\tbi = pci_businfo[dev-&gt;bus];\n\tassert(bi != NULL);\n\tii = &amp;bi-&gt;slotinfo[dev-&gt;slot].si_intpins[dev-&gt;lintr.pin - 1];\n\n\t/*\n\t * Attempt to allocate an I/O APIC pin for this intpin if one\n\t * is not yet assigned.\n\t */\n\tif (ii-&gt;ii_ioapic_irq == 0)\n\t\tii-&gt;ii_ioapic_irq = ioapic_pci_alloc_irq(dev);\n\tassert(ii-&gt;ii_ioapic_irq &gt; 0);\n\n\t/*\n\t * Attempt to allocate a PIRQ pin for this intpin if one is\n\t * not yet assigned.\n\t */\n\tif (ii-&gt;ii_pirq_pin == 0)\n\t\tii-&gt;ii_pirq_pin = pirq_alloc_pin(dev);\n\tassert(ii-&gt;ii_pirq_pin &gt; 0);\n\n\tdev-&gt;lintr.ioapic_irq = ii-&gt;ii_ioapic_irq;\n\tdev-&gt;lintr.pirq_pin = ii-&gt;ii_pirq_pin;\n\tpci_set_cfgdata8(dev, PCIR_INTLINE, pirq_irq(ii-&gt;ii_pirq_pin));\n}',
 'acc_ctx_new(OM_uint32 *minor_status,\n\t    gss_buffer_t buf,\n\t    gss_ctx_id_t *ctx,\n\t    spnego_gss_cred_id_t spcred,\n\t    gss_buffer_t *mechToken,\n\t    gss_buffer_t *mechListMIC,\n\t    OM_uint32 *negState,\n\t    send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret, req_flags;\n\tgss_OID_set supported_mechSet, mechTypes;\n\tgss_buffer_desc der_mechTypes;\n\tgss_OID mech_wanted;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\t*mechToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = mechTypes = GSS_C_NO_OID_SET;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\tret = get_negTokenInit(minor_status, buf, &amp;der_mechTypes,\n\t\t\t       &amp;mechTypes, &amp;req_flags,\n\t\t\t       mechToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE) {\n\t\tgoto cleanup;\n\t}\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &amp;supported_mechSet);\n\tif (ret != GSS_S_COMPLETE) {\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * Select the best match between the list of mechs\n\t * that the initiator requested and the list that\n\t * the acceptor will support.\n\t */\n\tmech_wanted = negotiate_mech(supported_mechSet, mechTypes, negState);\n\tif (*negState == REJECT) {\n\t\tret = GSS_S_BAD_MECH;\n\t\tgoto cleanup;\n\t}\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tif (sc != NULL) {\n\t\tgss_release_buffer(&amp;tmpmin, &amp;sc-&gt;DER_mechTypes);\n\t\tassert(mech_wanted != GSS_C_NO_OID);\n\t} else\n\t\tsc = create_spnego_ctx(0);\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\tsc-&gt;mech_set = mechTypes;\n\tmechTypes = GSS_C_NO_OID_SET;\n\tsc-&gt;internal_mech = mech_wanted;\n\tsc-&gt;DER_mechTypes = der_mechTypes;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\n\tif (*negState == REQUEST_MIC)\n\t\tsc-&gt;mic_reqd = 1;\n\n\t*return_token = INIT_TOKEN_SEND;\n\tsc-&gt;firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\tgss_release_oid_set(&amp;tmpmin, &amp;mechTypes);\n\tgss_release_oid_set(&amp;tmpmin, &amp;supported_mechSet);\n\tif (der_mechTypes.length != 0)\n\t\tgss_release_buffer(&amp;tmpmin, &amp;der_mechTypes);\n\n\treturn ret;\n}',
 'iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n{\n    iakerb_ctx_id_t ctx;\n    krb5_error_code code;\n\n    *pctx = NULL;\n\n    ctx = k5alloc(sizeof(*ctx), &amp;code);\n    if (ctx == NULL)\n        goto cleanup;\n    ctx-&gt;defcred = GSS_C_NO_CREDENTIAL;\n    ctx-&gt;magic = KG_IAKERB_CONTEXT;\n    ctx-&gt;state = IAKERB_AS_REQ;\n    ctx-&gt;count = 0;\n\n    code = krb5_gss_init_context(&amp;ctx-&gt;k5c);\n    if (code != 0)\n        goto cleanup;\n\n    *pctx = ctx;\n\ncleanup:\n    if (code != 0)\n        iakerb_release_context(ctx);\n\n    return code;\n}',
 'ikev2_t_print(netdissect_options *ndo, int tcount,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep)\n{\n\tconst struct ikev2_t *p;\n\tstruct ikev2_t t;\n\tuint16_t  t_id;\n\tconst u_char *cp;\n\tconst char *idstr;\n\tconst struct attrmap *map;\n\tsize_t nmap;\n\tconst u_char *ep2;\n\n\tp = (const struct ikev2_t *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&amp;t, ext, sizeof(t));\n\tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_T), t.h.critical);\n\n\tt_id = ntohs(t.t_id);\n\n\tmap = NULL;\n\tnmap = 0;\n\n\tswitch (t.t_type) {\n\tcase IV2_T_ENCR:\n\t\tidstr = STR_OR_ID(t_id, esp_p_map);\n\t\tmap = encr_t_map;\n\t\tnmap = sizeof(encr_t_map)/sizeof(encr_t_map[0]);\n\t\tbreak;\n\n\tcase IV2_T_PRF:\n\t\tidstr = STR_OR_ID(t_id, prf_p_map);\n\t\tbreak;\n\n\tcase IV2_T_INTEG:\n\t\tidstr = STR_OR_ID(t_id, integ_p_map);\n\t\tbreak;\n\n\tcase IV2_T_DH:\n\t\tidstr = STR_OR_ID(t_id, dh_p_map);\n\t\tbreak;\n\n\tcase IV2_T_ESN:\n\t\tidstr = STR_OR_ID(t_id, esn_p_map);\n\t\tbreak;\n\n\tdefault:\n\t\tidstr = NULL;\n\t\tbreak;\n\t}\n\n\tif (idstr)\n\t\tND_PRINT((ndo," #%u type=%s id=%s ", tcount,\n\t\t\t  STR_OR_ID(t.t_type, ikev2_t_type_map),\n\t\t\t  idstr));\n\telse\n\t\tND_PRINT((ndo," #%u type=%s id=%u ", tcount,\n\t\t\t  STR_OR_ID(t.t_type, ikev2_t_type_map),\n\t\t\t  t.t_id));\n\tcp = (const u_char *)(p + 1);\n\tep2 = (const u_char *)p + item_len;\n\twhile (cp &lt; ep &amp;&amp; cp &lt; ep2) {\n\t\tif (map &amp;&amp; nmap) {\n\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n\t\t} else\n\t\t\tcp = ikev1_attr_print(ndo, cp, ep2);\n\t\tif (cp == NULL)\n\t\t\tgoto trunc;\n\t}\n\tif (ep &lt; ep2)\n\t\tND_PRINT((ndo,"..."));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_T)));\n\treturn NULL;\n}',
 'void TestSocketLineReader::initTestCase()\n{\n    m_server = new Server(this);\n\n    QVERIFY2(m_server-&gt;listen(QHostAddress::LocalHost, 8694), "Failed to create local tcp server");\n\n    m_timer.setInterval(4000);//For second is more enough to send some data via local socket\n    m_timer.setSingleShot(true);\n    connect(&amp;m_timer, &amp;QTimer::timeout, &amp;m_loop, &amp;QEventLoop::quit);\n\n    m_conn = new QSslSocket(this);\n    m_conn-&gt;connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &amp;QAbstractSocket::connected, &amp;m_loop, &amp;QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n\n    QVERIFY2(m_conn-&gt;isOpen(), "Could not connect to local tcp server");\n}',
 'static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr &gt;&gt; 12) &amp; 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs-&gt;uregs[reg] = current_thread_info()-&gt;tp_value[0];\n\tregs-&gt;ARM_pc += 4;\n\treturn 0;\n}',
 'void SMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n\n  if (len &lt; 4)\n    throw Exception("Invalid extended clipboard message");\n  if (len &gt; maxCutText) {\n    vlog.error("Extended clipboard message too long (%d bytes) - ignoring", len);\n    is-&gt;skip(len);\n    return;\n  }\n\n  flags = is-&gt;readU32();\n  action = flags &amp; clipboardActionMask;\n\n  if (action &amp; clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n\n    num = 0;\n    for (i = 0;i &lt; 16;i++) {\n      if (flags &amp; (1 &lt;&lt; i))\n        num++;\n    }\n\n    if (len &lt; (rdr::S32)(4 + 4*num))\n      throw Exception("Invalid extended clipboard message");\n\n    num = 0;\n    for (i = 0;i &lt; 16;i++) {\n      if (flags &amp; (1 &lt;&lt; i))\n        lengths[num++] = is-&gt;readU32();\n    }\n\n    handler-&gt;handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n\n    zis.setUnderlying(is, len - 4);\n\n    num = 0;\n    for (i = 0;i &lt; 16;i++) {\n      if (!(flags &amp; 1 &lt;&lt; i))\n        continue;\n\n      lengths[num] = zis.readU32();\n      if (lengths[num] &gt; (size_t)maxCutText) {\n        vlog.error("Extended clipboard data too long (%d bytes) - ignoring",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &amp;= ~(1 &lt;&lt; i);\n        continue;\n      }\n\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n\n    zis.removeUnderlying();\n\n    handler-&gt;handleClipboardProvide(flags, lengths, buffers);\n\n    num = 0;\n    for (i = 0;i &lt; 16;i++) {\n      if (!(flags &amp; 1 &lt;&lt; i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler-&gt;handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler-&gt;handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler-&gt;handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception("Invalid extended clipboard action");\n    }\n  }\n}',
 'static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\n\tif (var-&gt;ptr &gt;= var-&gt;end) {\n\t\treturn 0;\n\t}\n\n\tvsep = memchr(var-&gt;ptr, \'&amp;\', var-&gt;end - var-&gt;ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var-&gt;end;\n\t\t}\n\t}\n\n\tksep = memchr(var-&gt;ptr, \'=\', vsep - var-&gt;ptr);\n\tif (ksep) {\n\t\t*ksep = \'\\0\';\n\t\t/* "foo=bar&amp;" or "foo=&amp;" */\n\t\tklen = ksep - var-&gt;ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = "";\n\t\t/* "foo&amp;" */\n\t\tklen = vsep - var-&gt;ptr;\n\t\tvlen = 0;\n\t}\n\n\tphp_url_decode(var-&gt;ptr, klen);\n\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\n\tif (sapi_module.input_filter(PARSE_POST, var-&gt;ptr, &amp;val, vlen, &amp;new_vlen)) {\n\t\tphp_register_variable_safe(var-&gt;ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\n\tvar-&gt;ptr = vsep + (vsep != var-&gt;end);\n\treturn 1;\n}',
 'size_t ZlibOutStream::length()\n{\n  return offset + ptr - start;\n}',
 'bool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;\n\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast&lt;unsigned char*&gt;( pEncryptedDataAndTag ), &amp;pcbEncryptedDataAndTag_longlong,\n\t\tstatic_cast&lt;const unsigned char*&gt;( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast&lt;const unsigned char*&gt;(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast&lt;const unsigned char*&gt;( pIV ),\n\t\tstatic_cast&lt;const crypto_aead_aes256gcm_state*&gt;( m_ctx )\n\t);\n\n    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;\n\n    return true;\n}',
 'static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size &lt;= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != \'\\0\') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = \'\\0\';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&amp;args, " ");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, "current") == 0) {\n\t\tif (strcmp(command, "changehat") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, "permhat") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, "changeprofile") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, "permprofile") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, "permipc") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&amp;sa, NONE);\n\t\t\tsa.aad.op = OP_SETPROCATTR;\n\t\t\tsa.aad.info = name;\n\t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED,\n\t\t\t\t\t__aa_current_profile(), GFP_KERNEL,\n\t\t\t\t\t&amp;sa, NULL);\n\t\t}\n\t} else if (strcmp(name, "exec") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\t/* only support the "current" and "exec" process attributes */\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}',
 'int mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, ".");\n\n\tmemset(&amp;user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i&lt;(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, "-c") || !strcmp(arg, "-cfg")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, "-mem-track") || !strcmp(arg, "-mem-track-stack")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, "-mem-track-stack") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, "WARNING - GPAC not compiled with Memory Tracker - ignoring \\"%s\\"\\n", arg);\n#endif\n\t\t} else if (!strcmp(arg, "-gui")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, "-guid")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, "-h") || !strcmp(arg, "-help")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, "Error: Configuration File not found\\n");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, "General", "Logs") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, "General", "Logs") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, "General", "ForceGUI");\n\t\tif (str &amp;&amp; !strcmp(str, "yes")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i&lt;(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, "-rti")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-rtix")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, "-size")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], "%dx%d", &amp;forced_width, &amp;forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-quiet")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, "-strict-error")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, "-log-file") || !strcmp(arg, "-lf")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], "wt");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-logs") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-log-clock") || !strcmp(arg, "-lc")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, "-log-utc") || !strcmp(arg, "-lu")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, "-thread")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, "-no-thread")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, "-no-cthread") || !strcmp(arg, "-no-compositor-thread")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, "-no-audio")) no_audio = 1;\n\t\telse if (!strcmp(arg, "-no-regulation")) no_regulation = 1;\n\t\telse if (!strcmp(arg, "-fs")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, "-opt")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-conf")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, "-ifce")) {\n\t\t\tgf_cfg_set_key(cfg_file, "Network", "DefaultMCastInterface", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, "-help")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, "-noprog")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, "-no-save") || !stricmp(arg, "--no-save") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, "-ntp-shift")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, "-run-for")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, "-out")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, "-fps")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-avi") || !strcmp(arg, "-sha")) {\n\t\t\tdump_mode &amp;= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, "-sha")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2&lt;(u32)argc)) &amp;&amp; get_time_list(argv[i+1], times, &amp;nb_times)) {\n\t\t\t\tif (!strcmp(arg, "-avi") &amp;&amp; (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, "Only one time arg found for -avi - check usage\\n");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, "-rgbds")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, "-rgbd")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, "-depth")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, "-bmp")) {\n\t\t\tdump_mode &amp;= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2&lt;(u32)argc)) &amp;&amp; get_time_list(argv[i+1], times, &amp;nb_times)) i++;\n\t\t} else if (!strcmp(arg, "-png")) {\n\t\t\tdump_mode &amp;= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2&lt;(u32)argc)) &amp;&amp; get_time_list(argv[i+1], times, &amp;nb_times)) i++;\n\t\t} else if (!strcmp(arg, "-raw")) {\n\t\t\tdump_mode &amp;= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2&lt;(u32)argc)) &amp;&amp; get_time_list(argv[i+1], times, &amp;nb_times)) i++;\n\t\t} else if (!stricmp(arg, "-scale")) {\n\t\t\tsscanf(argv[i+1], "%f", &amp;scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, "-c") || !strcmp(arg, "-cfg")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != \'-\') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, "Several input URLs provided (\\"%s\\", \\"%s\\"). Check your command-line.\\n", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, "-loop")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, "-bench")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, "-vbench")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, "-sbench")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, "-no-addon")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, "-pause")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, "-play-from")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, "-speed")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed &lt;= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, "-no-wnd")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, "-no-back")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, "-align")) {\n\t\t\t\tif (argv[i+1][0]==\'m\') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]==\'b\') align_mode = 2;\n\t\t\t\talign_mode &lt;&lt;= 8;\n\t\t\t\tif (argv[i+1][1]==\'m\') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]==\'r\') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, "-fill")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, "-show")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, "-uncache")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, "-exit")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, "-views")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, "-mosaic")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, "-com")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, "-service")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, "GPAC Config updated\\n");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, "General", "CacheDirectory");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, "GPAC Cache dir %s flattened\\n", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode &amp;&amp; !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, "General", "StartupFile");\n\t\ttest = url_arg ? gf_fopen(url_arg, "rt") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, "Missing argument for dump\\n");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode &amp;&amp; !url_arg &amp;&amp; (gf_cfg_get_key(cfg_file, "General", "StartupFile") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, "General", "ModulesDirectory");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg &amp;&amp; simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\t//only override default log callback when needed\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &amp;rti, 0))\n\t\t\tfprintf(stderr, "System info: %d MB RAM - %d cores\\n", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, "Audio", "DriverName", "Raw Audio Output");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, "Error: no modules found - exiting\\n");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, "Modules Found : %d \\n", i);\n\n\tstr = gf_cfg_get_key(cfg_file, "General", "GPACVersion");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, "PluginsCache");\n\t\tgf_cfg_set_key(cfg_file, "General", "GPACVersion", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags &amp; (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\t//in dump mode we don\'t want to rely on system clock but on the number of samples being consumed\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, "Audio", "DriverName", "Raw Audio Output");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, "Video", "DriverName", "Raw Video Output");\n\t\t\tgf_cfg_set_key(user.config, "RAWVideo", "RawOutput", "null");\n\t\t\tgf_cfg_set_key(user.config, "Compositor", "OpenGLMode", "disable");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, "Video", "DisableVSync", "yes");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, "%d", forced_width);\n\t\tgf_cfg_set_key(user.config, "Compositor", "DefaultWidth", forced_width ? dim : NULL);\n\t\tsprintf(dim, "%d", forced_height);\n\t\tgf_cfg_set_key(user.config, "Compositor", "DefaultHeight", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, "Loading GPAC Terminal\\n");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&amp;user);\n\tif (!term) {\n\t\tfprintf(stderr, "\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, "Terminal Loaded in %d ms\\n", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n//\t\tgf_term_set_option(term, GF_OPT_VISIBLE, 0);\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, "Video", "DriverName");\n\t\tif (!bench_mode &amp;&amp; !strcmp(str, "Raw Video Output")) fprintf(stderr, "WARNING: using raw output video (memory only) - no display used\\n");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, "Audio", "DriverName");\n\t\tif (!str || !strcmp(str, "No Audio Output Available")) fprintf(stderr, "WARNING: no audio output available - make sure no other program is locking the sound card\\n");\n\n\t\tstr = gf_cfg_get_key(cfg_file, "General", "NoMIMETypeFetch");\n\t\tno_mime_check = (str &amp;&amp; !stricmp(str, "yes")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, "HTTPProxy", "Enabled");\n\tif (str &amp;&amp; !strcmp(str, "yes")) {\n\t\tstr = gf_cfg_get_key(cfg_file, "HTTPProxy", "Name");\n\t\tif (str) fprintf(stderr, "HTTP Proxy %s enabled\\n", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, "General", "RTIRefreshPeriod");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, "General", "RTIRefreshPeriod", "200");\n\t\t}\n\t\tUpdateRTInfo("At GPAC load time\\n");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode &amp;&amp; url_arg) {\n\t\tchar *ext;\n\n\t\tif (strlen(url_arg) &gt;= sizeof(the_url)) {\n\t\t\tfprintf(stderr, "Input url %s is too long, truncating to %d chars.\\n", url_arg, (int)(sizeof(the_url) - 1));\n\t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t}\n\t\telse {\n\t\t\tstrcpy(the_url, url_arg);\n\t\t}\n\t\text = strrchr(the_url, \'.\');\n\t\tif (ext &amp;&amp; (!stricmp(ext, ".m3u") || !stricmp(ext, ".pls"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, "Opening Playlist %s\\n", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp("http:", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term-&gt;downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &amp;e);\n\t\t\t\tif (sess) {\n\t\t\t\t\te = gf_dm_sess_process(sess);\n\t\t\t\t\tif (!e) {\n\t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);\n\t\t\t\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, "rt");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, "Failed to open playlist %s: %s\\n", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, "Hit \'h\' for help\\n\\n");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, "Opening URL %s\\n", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, "[Status: Paused]\\n");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, "Hit \'h\' for help\\n\\n");\n\t\tstr = gf_cfg_get_key(cfg_file, "General", "StartupFile");\n\t\tif (str) {\n\t\t\tstrncpy(the_url, "MP4Client "GPAC_FULL_VERSION , sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, "views://%s", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, "mosaic://%s", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don\'t want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, "General", "StartupFile") : the_url);\n\t\t\t}\n\t\t\tif (restart &amp;&amp; gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = \'\\n\';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command &amp;&amp; is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i&lt;(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], "-com")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id &amp;&amp; is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit &amp;&amp; eos_seen &amp;&amp; gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        &amp;&amp; ( (gf_term_get_elapsed_time_in_ms(term)&gt;simulation_time_in_ms) || (!url_arg &amp;&amp; gf_sys_clock()&gt;simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase \'q\':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&amp;evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &amp;evt);\n\t\t}\n//\t\t\tRun = 0;\n\t\tbreak;\n\t\tcase \'X\':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase \'Q\':\n\t\t\tbreak;\n\t\tcase \'o\':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, "Enter the absolute URL\\n");\n\t\t\tif (1 &gt; scanf("%s", the_url)) {\n\t\t\t\tfprintf(stderr, "Cannot read absolute URL, aborting\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase \'O\':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, "Enter the absolute URL to the playlist\\n");\n\t\t\tif (1 &gt; scanf("%s", the_url)) {\n\t\t\t\tfprintf(stderr, "Cannot read the absolute URL, aborting.\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, "rt");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 &gt;\tfscanf(playlist, "%s", the_url)) {\n\t\t\t\t\tfprintf(stderr, "Cannot read any URL from playlist, aborting.\\n");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, "Opening URL %s\\n", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'\\n\':\n\t\tcase \'N\':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, "%s", the_url);\n\t\t\t\tif ((res == EOF) &amp;&amp; loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, "%s", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, "No more items - exiting\\n");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == \'#\') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, "Opening URL %s\\n", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'P\':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 &gt; scanf("%u", &amp;count)) {\n\t\t\t\t\tfprintf(stderr, "Cannot read number, aborting.\\n");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, "%s", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, "Failed to read line, aborting\\n");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, "Opening URL %s\\n", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'r\':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase \'D\':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase \'p\':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, "[Status: %s]\\n", is_pause ? "Playing" : "Paused");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'s\':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, "Step time: ");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, "\\n");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase \'z\':\n\t\tcase \'T\':\n\t\t\tif (!CanSeek || (Duration&lt;=2000)) {\n\t\t\t\tfprintf(stderr, "scene not seekable\\n");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, "Duration: ");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c==\'z\') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, " (current %.2f %%)\\nEnter Seek percentage:\\n", res);\n\t\t\t\t\tif (scanf("%d", &amp;seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo &gt; 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, " - Current Time: ");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, "\\nEnter seek time (Format: s, m:s or h:m:s):\\n");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r &amp;&amp; (r&lt;=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase \'t\':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, "Current Time: ");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, " - Duration: ");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, "\\n");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase \'w\':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase \'v\':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, "Root");\n\t\t\tbreak;\n\t\tcase \'i\':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, "Enter OD ID (0 for main OD): ");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf("%ud", &amp;ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf("%s", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'j\':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, "Enter OD number (0 for main OD): ");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 &gt; scanf("%ud", &amp;num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'b\':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase \'m\':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase \'l\':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase \'n\':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase \'x\':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase \'d\':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, "Enter Inline OD ID if any or 0 : ");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 &gt;  scanf("%ud", &amp;odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i&lt;count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &amp;info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od-&gt;objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, "Enter file radical name (+\\\'.x\\\' for XML dumping) - \\"std\\" for stderr: ");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 &gt; scanf("%s", radname));\n\t\t\t\tsExt = strrchr(radname, \'.\');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, ".x")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, "std", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, "Dump done (%s)\\n", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase \'c\':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase \'3\':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, "Using %s for 2D drawing\\n", use_3d ? "OpenGL" : "2D rasterizer");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase \'k\':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, "Turning stress mode %s\\n", opt ? "on" : "off");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase \'4\':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase \'5\':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase \'6\':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase \'7\':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase \'C\':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, "Streaming Cache is running - please stop it first\\n");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, "Streaming Cache Enabled\\n");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, "Streaming Cache Disabled\\n");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, "Streaming Cache Running\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'S\':\n\t\tcase \'A\':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c==\'S\') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, "Streaming Cache stopped\\n");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, "Streaming Cache not running\\n");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'R\':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase \'F\':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase \'u\':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, "Enter command to send:\\n");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 &gt; scanf("%[^\\t\\n]", szCom)) {\n\t\t\t\tfprintf(stderr, "Cannot read command to send, aborting.\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, "Processing command failed: %s\\n", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase \'e\':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, "Enter JavaScript code to evaluate:\\n");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 &gt; scanf("%[^\\t\\n]", jsCode)) {\n\t\t\t\tfprintf(stderr, "Cannot read code to evaluate, aborting.\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, "application/ecmascript", jsCode);\n\t\t\tif (e) fprintf(stderr, "Processing JS code failed: %s\\n", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase \'L\':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, "Enter new log level (current tools %s):\\n", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf("%s", szLog) &lt; 1) {\n\t\t\t\tfprintf(stderr, "Cannot read new log level, aborting.\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase \'g\':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &amp;rti, 0);\n\t\t\tfprintf(stderr, "GPAC allocated memory "LLD"\\n", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase \'M\':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, "Enter new video cache memory in kBytes (current %ud):\\n", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 &gt; scanf("%ud", &amp;size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase \'H\':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, "Enter new http bitrate in bps (0 for none) - current limit: %d\\n", http_bitrate);\n\t\t\t} while (1 &gt; scanf("%ud", &amp;http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase \'E\':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase \'B\':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase \'Y\':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, "Enter option to set (Section:Name=Value):\\n");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 &gt; scanf("%[^\\t\\n]", szOpt)) {\n\t\t\t\tfprintf(stderr, "Cannot read option\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase \'Z\':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views&gt;1) {\n\t\t\t\tfprintf(stderr, "Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf("%d", &amp;offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, "view%d_dump.png", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &amp;fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, "gpac_video_dump_"LLU".png", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &amp;fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, "Error dumping screen buffer %s\\n", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &amp;dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, "Error encoding PNG %s\\n", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, "wb");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, "Error writing file %s\\n", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, "Dump to %s\\n", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &amp;fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, "Done: %s\\n", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase \'G\':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, "Enter 0-based index of object to select or service ID:\\n");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 &gt; scanf("%[^\\t\\n]", szOpt)) {\n\t\t\t\tfprintf(stderr, "Cannot read OD ID\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, "Cannot find service %d - trying with object index\\n", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, "Cannot find object at index %d\\n", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase \'h\':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo("Disconnected\\n");\n\n\tfprintf(stderr, "Deleting terminal... ");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, "done (in %d ms) - ran for %d ms\\n", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, "GPAC cleanup ...\\n");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track &amp;&amp; (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}',
 'void gps_tracker( void )\n{\n\tssize_t unused;\n    int gpsd_sock;\n    char line[256], *temp;\n    struct sockaddr_in gpsd_addr;\n    int ret, is_json, pos;\n    fd_set read_fd;\n    struct timeval timeout;\n\n    /* attempt to connect to localhost, port 2947 */\n\n    pos = 0;\n    gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 );\n\n    if( gpsd_sock &lt; 0 ) {\n        return;\n    }\n\n    gpsd_addr.sin_family      = AF_INET;\n    gpsd_addr.sin_port        = htons( 2947 );\n    gpsd_addr.sin_addr.s_addr = inet_addr( "127.0.0.1" );\n\n    if( connect( gpsd_sock, (struct sockaddr *) &amp;gpsd_addr,\n                 sizeof( gpsd_addr ) ) &lt; 0 ) {\n        return;\n    }\n\n    // Check if it\'s GPSd &lt; 2.92 or the new one\n    // 2.92+ immediately send stuff\n    // &lt; 2.92 requires to send PVTAD command\n    FD_ZERO(&amp;read_fd);\n    FD_SET(gpsd_sock, &amp;read_fd);\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n    is_json = select(gpsd_sock + 1, &amp;read_fd, NULL, NULL, &amp;timeout);\n    if (is_json) {\n    \t/*\n\t\t\t{"class":"VERSION","release":"2.95","rev":"2010-11-16T21:12:35","proto_major":3,"proto_minor":3}\n\t\t\t?WATCH={"json":true};\n\t\t\t{"class":"DEVICES","devices":[]}\n    \t */\n\n\n    \t// Get the crap and ignore it: {"class":"VERSION","release":"2.95","rev":"2010-11-16T21:12:35","proto_major":3,"proto_minor":3}\n    \tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) &lt;= 0 )\n    \t\treturn;\n\n    \tis_json = (line[0] == \'{\');\n    \tif (is_json) {\n\t\t\t// Send ?WATCH={"json":true};\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tstrcpy(line, "?WATCH={\\"json\\":true};\\n");\n\t\t\tif( send( gpsd_sock, line, 22, 0 ) != 22 )\n\t\t\t\treturn;\n\n\t\t\t// Check that we have devices\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) &lt;= 0 )\n\t\t\t\treturn;\n\n\t\t\t// Stop processing if there is no device\n\t\t\tif (strncmp(line, "{\\"class\\":\\"DEVICES\\",\\"devices\\":[]}", 32) == 0) {\n\t\t\t\tclose(gpsd_sock);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpos = strlen(line);\n\t\t\t}\n    \t}\n    }\n\n    /* loop reading the GPS coordinates */\n\n    while( G.do_exit == 0 )\n    {\n        usleep( 500000 );\n        memset( G.gps_loc, 0, sizeof( float ) * 5 );\n\n        /* read position, speed, heading, altitude */\n        if (is_json) {\n        \t// Format definition: http://catb.org/gpsd/gpsd_json.html\n\n        \tif (pos == sizeof( line )) {\n        \t\tmemset(line, 0, sizeof(line));\n        \t\tpos = 0;\n        \t}\n\n        \t// New version, JSON\n        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) &lt;= 0 )\n        \t\treturn;\n\n        \t// search for TPV class: {"class":"TPV"\n        \ttemp = strstr(line, "{\\"class\\":\\"TPV\\"");\n        \tif (temp == NULL) {\n        \t\tcontinue;\n        \t}\n\n        \t// Make sure the data we have is complete\n        \tif (strchr(temp, \'}\') == NULL) {\n        \t\t// Move the data at the beginning of the buffer;\n        \t\tpos = strlen(temp);\n        \t\tif (temp != line) {\n        \t\t\tmemmove(line, temp, pos);\n        \t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n        \t\t}\n        \t}\n\n\t\t\t// Example line: {"class":"TPV","tag":"MID2","device":"/dev/ttyUSB0","time":1350957517.000,"ept":0.005,"lat":46.878936576,"lon":-115.832602964,"alt":1968.382,"track":0.0000,"speed":0.000,"climb":0.000,"mode":3}\n\n        \t// Latitude\n        \ttemp = strstr(temp, "\\"lat\\":");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, "%f", &amp;G.gps_loc[0]);\n\n\t\t\t// Longitude\n\t\t\ttemp = strstr(temp, "\\"lon\\":");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, "%f", &amp;G.gps_loc[1]);\n\n\t\t\t// Altitude\n\t\t\ttemp = strstr(temp, "\\"alt\\":");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, "%f", &amp;G.gps_loc[4]);\n\n\t\t\t// Speed\n\t\t\ttemp = strstr(temp, "\\"speed\\":");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, "%f", &amp;G.gps_loc[2]);\n\n\t\t\t// No more heading\n\n\t\t\t// Get the next TPV class\n\t\t\ttemp = strstr(temp, "{\\"class\\":\\"TPV\\"");\n\t\t\tif (temp == NULL) {\n\t\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\t\tpos = 0;\n\t\t\t} else {\n\t\t\t\tpos = strlen(temp);\n\t\t\t\tmemmove(line, temp, pos);\n\t\t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n\t\t\t}\n\n        } else {\n        \tmemset( line, 0, sizeof( line ) );\n\n\t\t\tsnprintf( line,  sizeof( line ) - 1, "PVTAD\\r\\n" );\n\t\t\tif( send( gpsd_sock, line, 7, 0 ) != 7 )\n\t\t\t\treturn;\n\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) &lt;= 0 )\n\t\t\t\treturn;\n\n\t\t\tif( memcmp( line, "GPSD,P=", 7 ) != 0 )\n\t\t\t\tcontinue;\n\n\t\t\t/* make sure the coordinates are present */\n\n\t\t\tif( line[7] == \'?\' )\n\t\t\t\tcontinue;\n\n\t\t\tret = sscanf( line + 7, "%f %f", &amp;G.gps_loc[0], &amp;G.gps_loc[1] );\n\n\t\t\tif( ( temp = strstr( line, "V=" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, "%f", &amp;G.gps_loc[2] ); /* speed */\n\n\t\t\tif( ( temp = strstr( line, "T=" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, "%f", &amp;G.gps_loc[3] ); /* heading */\n\n\t\t\tif( ( temp = strstr( line, "A=" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, "%f", &amp;G.gps_loc[4] ); /* altitude */\n        }\n\n        if (G.record_data)\n\t\t\tfputs( line, G.f_gps );\n\n\t\tG.save_gps = 1;\n\n        if (G.do_exit == 0)\n\t\t{\n\t\t\tunused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 );\n\t\t\tkill( getppid(), SIGUSR2 );\n\t\t}\n    }\n}',
 'static void coerce_reg_to_size(struct bpf_reg_state *reg, int size)\n{\n\tu64 mask;\n\n\t/* clear high bits in bit representation */\n\treg-&gt;var_off = tnum_cast(reg-&gt;var_off, size);\n\n\t/* fix arithmetic bounds */\n\tmask = ((u64)1 &lt;&lt; (size * 8)) - 1;\n\tif ((reg-&gt;umin_value &amp; ~mask) == (reg-&gt;umax_value &amp; ~mask)) {\n\t\treg-&gt;umin_value &amp;= mask;\n\t\treg-&gt;umax_value &amp;= mask;\n\t} else {\n\t\treg-&gt;umin_value = 0;\n\t\treg-&gt;umax_value = mask;\n\t}\n\treg-&gt;smin_value = reg-&gt;umin_value;\n\treg-&gt;smax_value = reg-&gt;umax_value;\n}',
 'static void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len)\n{\n    char buf[100], *dp = buf;\n    const char *cp = str;\n    int ulen;\n    \n    while ((cp-str)&lt;len) {\n        if (*cp == \'\\\\\') {\n            switch (cp[1]) {\n                case \'b\': *dp++ = \'\\b\'; break;\n                case \'n\': *dp++ = \'\\n\'; break;\n                case \'r\': *dp++ = \'\\r\'; break;\n                case \'f\': *dp++ = \'\\f\'; break;\n                case \'t\': *dp++ = \'\\t\'; break;\n                case \'\\"\': *dp++ = \'\\"\'; break;\n                case \'\\\\\': *dp++ = \'\\\\\'; break;\n                case \'u\': \n                    if ((ulen=Jsi_UtfDecode(cp+2, dp))) {\n                        dp += ulen;\n                        cp += 4;\n                    } else {                    \n                        *dp++ = \'\\\\\';\n                        *dp++ = \'u\';\n                    }\n                    break;\n            }\n            cp+=2;\n        } else {\n            *dp++ = *cp++;\n        }\n        if ((dp-buf)&gt;90) {\n            *dp = 0;\n            Jsi_DSAppendLen(dStr, buf, dp-buf);\n            dp = buf;\n        }\n    }\n    *dp = 0;\n    Jsi_DSAppendLen(dStr, buf, dp-buf);\n}',
 "    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        // Согласно спецификации Type1, первый байт не должен быть ASCII пробелом\n        // (пробел, таб, перенос каретки или перенос строки).\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur &lt; (unsigned char*)(*ppEexecBuffer) + nLen &amp;&amp; ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n        {\n            ++sCur;\n            --nLen;\n        }\n\n        // Теперь нам надо определить в каком формате у нас данные: ASKII или бинарные данные.\n        // Если первые четыре байта являются шестнадцатиричными символами, значит, кодировка ASCII.\n        bool bASCII = false;\n\n        if ( nLen &gt; 3 &amp;&amp; isxdigit( sCur[0] ) &amp;&amp; isxdigit( sCur[1] ) &amp;&amp; isxdigit( sCur[2] ) &amp;&amp; isxdigit( sCur[3] ) )\n            bASCII = true;\n\n        if ( bASCII )\n            ASCIIHexDecode( &amp;sCur, sCur + nLen, sCur, nLen );\n\n        unsigned short ushKey = 55665U;\n        EexecDecode( &amp;sCur, *ppEexecBuffer + nLen, sCur, nLen, &amp;ushKey );\n    }",
 'qboolean S_AL_Init( soundInterface_t *si )\n{\n#ifdef USE_OPENAL\n\tconst char* device = NULL;\n\tconst char* inputdevice = NULL;\n\tint i;\n\n\tif( !si ) {\n\t\treturn qfalse;\n\t}\n\n\tfor (i = 0; i &lt; MAX_RAW_STREAMS; i++) {\n\t\tstreamSourceHandles[i] = -1;\n\t\tstreamPlaying[i] = qfalse;\n\t\tstreamSources[i] = 0;\n\t\tstreamNumBuffers[i] = 0;\n\t\tstreamBufIndex[i] = 0;\n\t}\n\n\t// New console variables\n\ts_alPrecache = Cvar_Get( "s_alPrecache", "1", CVAR_ARCHIVE );\n\ts_alGain = Cvar_Get( "s_alGain", "1.0", CVAR_ARCHIVE );\n\ts_alSources = Cvar_Get( "s_alSources", "96", CVAR_ARCHIVE );\n\ts_alDopplerFactor = Cvar_Get( "s_alDopplerFactor", "1.0", CVAR_ARCHIVE );\n\ts_alDopplerSpeed = Cvar_Get( "s_alDopplerSpeed", "9000", CVAR_ARCHIVE );\n\ts_alMinDistance = Cvar_Get( "s_alMinDistance", "120", CVAR_CHEAT );\n\ts_alMaxDistance = Cvar_Get("s_alMaxDistance", "1024", CVAR_CHEAT);\n\ts_alRolloff = Cvar_Get( "s_alRolloff", "2", CVAR_CHEAT);\n\ts_alGraceDistance = Cvar_Get("s_alGraceDistance", "512", CVAR_CHEAT);\n\n\ts_alDriver = Cvar_Get( "s_alDriver", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );\n\n\ts_alInputDevice = Cvar_Get( "s_alInputDevice", "", CVAR_ARCHIVE | CVAR_LATCH );\n\ts_alDevice = Cvar_Get("s_alDevice", "", CVAR_ARCHIVE | CVAR_LATCH);\n\n\t// Load QAL\n\tif( !QAL_Init( s_alDriver-&gt;string ) )\n\t{\n\t\tCom_Printf( "Failed to load library: \\"%s\\".\\n", s_alDriver-&gt;string );\n\t\tif( !Q_stricmp( s_alDriver-&gt;string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\n\tdevice = s_alDevice-&gt;string;\n\tif(device &amp;&amp; !*device)\n\t\tdevice = NULL;\n\n\tinputdevice = s_alInputDevice-&gt;string;\n\tif(inputdevice &amp;&amp; !*inputdevice)\n\t\tinputdevice = NULL;\n\n\n\t// Device enumeration support\n\tenumeration_all_ext = qalcIsExtensionPresent(NULL, "ALC_ENUMERATE_ALL_EXT");\n\tenumeration_ext = qalcIsExtensionPresent(NULL, "ALC_ENUMERATION_EXT");\n\n\tif(enumeration_ext || enumeration_all_ext)\n\t{\n\t\tchar devicenames[16384] = "";\n\t\tconst char *devicelist;\n#ifdef _WIN32\n\t\tconst char *defaultdevice;\n#endif\n\t\tint curlen;\n\n\t\t// get all available devices + the default device name.\n\t\tif(enumeration_all_ext)\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// We don\'t have ALC_ENUMERATE_ALL_EXT but normal enumeration.\n\t\t\tdevicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);\n#endif\n\t\t\tenumeration_ext = qtrue;\n\t\t}\n\n#ifdef _WIN32\n\t\t// check whether the default device is generic hardware. If it is, change to\n\t\t// Generic Software as that one works more reliably with various sound systems.\n\t\t// If it\'s not, use OpenAL\'s default selection as we don\'t want to ignore\n\t\t// native hardware acceleration.\n\t\tif(!device &amp;&amp; defaultdevice &amp;&amp; !strcmp(defaultdevice, "Generic Hardware"))\n\t\t\tdevice = "Generic Software";\n#endif\n\n\t\t// dump a list of available devices to a cvar for the user to see.\n\n\t\tif(devicelist)\n\t\t{\n\t\t\twhile((curlen = strlen(devicelist)))\n\t\t\t{\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), devicelist);\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), "\\n");\n\n\t\t\t\tdevicelist += curlen + 1;\n\t\t\t}\n\t\t}\n\n\t\ts_alAvailableDevices = Cvar_Get("s_alAvailableDevices", devicenames, CVAR_ROM | CVAR_NORESTART);\n\t}\n\n\talDevice = qalcOpenDevice(device);\n\tif( !alDevice &amp;&amp; device )\n\t{\n\t\tCom_Printf( "Failed to open OpenAL device \'%s\', trying default.\\n", device );\n\t\talDevice = qalcOpenDevice(NULL);\n\t}\n\n\tif( !alDevice )\n\t{\n\t\tQAL_Shutdown( );\n\t\tCom_Printf( "Failed to open OpenAL device.\\n" );\n\t\treturn qfalse;\n\t}\n\n\t// Create OpenAL context\n\talContext = qalcCreateContext( alDevice, NULL );\n\tif( !alContext )\n\t{\n\t\tQAL_Shutdown( );\n\t\tqalcCloseDevice( alDevice );\n\t\tCom_Printf( "Failed to create OpenAL context.\\n" );\n\t\treturn qfalse;\n\t}\n\tqalcMakeContextCurrent( alContext );\n\n\t// Initialize sources, buffers, music\n\tS_AL_BufferInit( );\n\tS_AL_SrcInit( );\n\n\t// Set up OpenAL parameters (doppler, etc)\n\tqalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);\n\tqalDopplerFactor( s_alDopplerFactor-&gt;value );\n\tqalSpeedOfSound( s_alDopplerSpeed-&gt;value );\n\n#ifdef USE_VOIP\n\t// !!! FIXME: some of these alcCaptureOpenDevice() values should be cvars.\n\t// !!! FIXME: add support for capture device enumeration.\n\t// !!! FIXME: add some better error reporting.\n\ts_alCapture = Cvar_Get( "s_alCapture", "1", CVAR_ARCHIVE | CVAR_LATCH );\n\tif (!s_alCapture-&gt;integer)\n\t{\n\t\tCom_Printf("OpenAL capture support disabled by user (\'+set s_alCapture 1\' to enable)\\n");\n\t}\n#if USE_MUMBLE\n\telse if (cl_useMumble-&gt;integer)\n\t{\n\t\tCom_Printf("OpenAL capture support disabled for Mumble support\\n");\n\t}\n#endif\n\telse\n\t{\n#ifdef __APPLE__\n\t\t// !!! FIXME: Apple has a 1.1-compliant OpenAL, which includes\n\t\t// !!! FIXME:  capture support, but they don\'t list it in the\n\t\t// !!! FIXME:  extension string. We need to check the version string,\n\t\t// !!! FIXME:  then the extension string, but that\'s too much trouble,\n\t\t// !!! FIXME:  so we\'ll just check the function pointer for now.\n\t\tif (qalcCaptureOpenDevice == NULL)\n#else\n\t\tif (!qalcIsExtensionPresent(NULL, "ALC_EXT_capture"))\n#endif\n\t\t{\n\t\t\tCom_Printf("No ALC_EXT_capture support, can\'t record audio.\\n");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar inputdevicenames[16384] = "";\n\t\t\tconst char *inputdevicelist;\n\t\t\tconst char *defaultinputdevice;\n\t\t\tint curlen;\n\n\t\t\tcapture_ext = qtrue;\n\n\t\t\t// get all available input devices + the default input device name.\n\t\t\tinputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);\n\t\t\tdefaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);\n\n\t\t\t// dump a list of available devices to a cvar for the user to see.\n\t\t\tif (inputdevicelist)\n\t\t\t{\n\t\t\t\twhile((curlen = strlen(inputdevicelist)))\n\t\t\t\t{\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), "\\n");\n\t\t\t\t\tinputdevicelist += curlen + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts_alAvailableInputDevices = Cvar_Get("s_alAvailableInputDevices", inputdevicenames, CVAR_ROM | CVAR_NORESTART);\n\n\t\t\tCom_Printf("OpenAL default capture device is \'%s\'\\n", defaultinputdevice ? defaultinputdevice : "none");\n\t\t\talCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\tif( !alCaptureDevice &amp;&amp; inputdevice )\n\t\t\t{\n\t\t\t\tCom_Printf( "Failed to open OpenAL Input device \'%s\', trying default.\\n", inputdevice );\n\t\t\t\talCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\t}\n\t\t\tCom_Printf( "OpenAL capture device %s.\\n",\n\t\t\t\t    (alCaptureDevice == NULL) ? "failed to open" : "opened");\n\t\t}\n\t}\n#endif\n\n\tsi-&gt;Shutdown = S_AL_Shutdown;\n\tsi-&gt;StartSound = S_AL_StartSound;\n\tsi-&gt;StartLocalSound = S_AL_StartLocalSound;\n\tsi-&gt;StartBackgroundTrack = S_AL_StartBackgroundTrack;\n\tsi-&gt;StopBackgroundTrack = S_AL_StopBackgroundTrack;\n\tsi-&gt;RawSamples = S_AL_RawSamples;\n\tsi-&gt;StopAllSounds = S_AL_StopAllSounds;\n\tsi-&gt;ClearLoopingSounds = S_AL_ClearLoopingSounds;\n\tsi-&gt;AddLoopingSound = S_AL_AddLoopingSound;\n\tsi-&gt;AddRealLoopingSound = S_AL_AddRealLoopingSound;\n\tsi-&gt;StopLoopingSound = S_AL_StopLoopingSound;\n\tsi-&gt;Respatialize = S_AL_Respatialize;\n\tsi-&gt;UpdateEntityPosition = S_AL_UpdateEntityPosition;\n\tsi-&gt;Update = S_AL_Update;\n\tsi-&gt;DisableSounds = S_AL_DisableSounds;\n\tsi-&gt;BeginRegistration = S_AL_BeginRegistration;\n\tsi-&gt;RegisterSound = S_AL_RegisterSound;\n\tsi-&gt;ClearSoundBuffer = S_AL_ClearSoundBuffer;\n\tsi-&gt;SoundInfo = S_AL_SoundInfo;\n\tsi-&gt;SoundList = S_AL_SoundList;\n\n#ifdef USE_VOIP\n\tsi-&gt;StartCapture = S_AL_StartCapture;\n\tsi-&gt;AvailableCaptureSamples = S_AL_AvailableCaptureSamples;\n\tsi-&gt;Capture = S_AL_Capture;\n\tsi-&gt;StopCapture = S_AL_StopCapture;\n\tsi-&gt;MasterGain = S_AL_MasterGain;\n#endif\n\n\treturn qtrue;\n#else\n\treturn qfalse;\n#endif\n}',
 'static int unix_getpw(UNUSED void *instance, REQUEST *request,\n\t\t      VALUE_PAIR **vp_list)\n{\n\tconst char\t*name;\n\tconst char\t*encrypted_pass;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd\t*spwd = NULL;\n#endif\n#ifdef OSFC2\n\tstruct pr_passwd *pr_pw;\n#else\n\tstruct passwd\t*pwd;\n#endif\n#ifdef HAVE_GETUSERSHELL\n\tchar\t\t*shell;\n#endif\n\tVALUE_PAIR\t*vp;\n\n\t/*\n\t *\tWe can only authenticate user requests which HAVE\n\t *\ta User-Name attribute.\n\t */\n\tif (!request-&gt;username) {\n\t\treturn RLM_MODULE_NOOP;\n\t}\n\n\tname = (char *)request-&gt;username-&gt;vp_strvalue;\n\tencrypted_pass = NULL;\n\n#ifdef OSFC2\n\tif ((pr_pw = getprpwnam(name)) == NULL)\n\t\treturn RLM_MODULE_NOTFOUND;\n\tencrypted_pass = pr_pw-&gt;ufld.fd_encrypt;\n\n\t/*\n\t *\tCheck if account is locked.\n\t */\n\tif (pr_pw-&gt;uflg.fg_lock!=1) {\n\t\tradlog(L_AUTH, "rlm_unix: [%s]: account locked", name);\n\t\treturn RLM_MODULE_USERLOCK;\n\t}\n#else /* OSFC2 */\n\tif ((pwd = getpwnam(name)) == NULL) {\n\t\treturn RLM_MODULE_NOTFOUND;\n\t}\n\tencrypted_pass = pwd-&gt;pw_passwd;\n#endif /* OSFC2 */\n\n#ifdef HAVE_GETSPNAM\n\t/*\n\t *      See if there is a shadow password.\n\t *\n\t *\tOnly query the _system_ shadow file if the encrypted\n\t *\tpassword from the passwd file is &lt; 10 characters (i.e.\n\t *\ta valid password would never crypt() to it).  This will\n\t *\tprevents users from using NULL password fields as things\n\t *\tstand right now.\n\t */\n\tif ((encrypted_pass == NULL) || (strlen(encrypted_pass) &lt; 10)) {\n\t\tif ((spwd = getspnam(name)) == NULL) {\n\t\t\treturn RLM_MODULE_NOTFOUND;\n\t\t}\n\t\tencrypted_pass = spwd-&gt;sp_pwdp;\n\t}\n#endif\t/* HAVE_GETSPNAM */\n\n/*\n *\tThese require \'pwd != NULL\', which isn\'t true on OSFC2\n */\n#ifndef OSFC2\n#ifdef DENY_SHELL\n\t/*\n\t *\tUsers with a particular shell are denied access\n\t */\n\tif (strcmp(pwd-&gt;pw_shell, DENY_SHELL) == 0) {\n\t\tradlog_request(L_AUTH, 0, request,\n\t\t\t       "rlm_unix: [%s]: invalid shell", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#ifdef HAVE_GETUSERSHELL\n\t/*\n\t *\tCheck /etc/shells for a valid shell. If that file\n\t *\tcontains /RADIUSD/ANY/SHELL then any shell will do.\n\t */\n\twhile ((shell = getusershell()) != NULL) {\n\t\tif (strcmp(shell, pwd-&gt;pw_shell) == 0 ||\n\t\t    strcmp(shell, "/RADIUSD/ANY/SHELL") == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendusershell();\n\tif (shell == NULL) {\n\t\tradlog_request(L_AUTH, 0, request, "[%s]: invalid shell [%s]",\n\t\t       name, pwd-&gt;pw_shell);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n#endif /* OSFC2 */\n\n#if defined(HAVE_GETSPNAM) &amp;&amp; !defined(M_UNIX)\n\t/*\n\t *      Check if password has expired.\n\t */\n\tif (spwd &amp;&amp; spwd-&gt;sp_expire &gt; 0 &amp;&amp;\n\t    (request-&gt;timestamp / 86400) &gt; spwd-&gt;sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, "[%s]: password has expired", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)\n\t/*\n\t *\tCheck if password has expired.\n\t */\n\tif ((pwd-&gt;pw_expire &gt; 0) &amp;&amp;\n\t    (request-&gt;timestamp &gt; pwd-&gt;pw_expire)) {\n\t\tradlog_request(L_AUTH, 0, request, "[%s]: password has expired", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n\t/*\n\t *\tWe might have a passwordless account.\n\t *\n\t *\tFIXME: Maybe add Auth-Type := Accept?\n\t */\n\tif (encrypted_pass[0] == 0)\n\t\treturn RLM_MODULE_NOOP;\n\n\tvp = pairmake("Crypt-Password", encrypted_pass, T_OP_SET);\n\tif (!vp) return RLM_MODULE_FAIL;\n\n\tpairmove(vp_list, &amp;vp);\n\tpairfree(&amp;vp);\t\t/* might not be NULL; */\n\n\treturn RLM_MODULE_UPDATED;\n}',
 'static int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tuid_t ruid, suid, euid;\n\tint fret = -1;\n\tint fd = -1, ifindex = -1, ofd = -1, ret;\n\tbool grab_newname = false;\n\n\tofd = lxc_preserve_ns(getpid(), "net");\n\tif (ofd &lt; 0) {\n\t\tusernic_error("Failed opening network namespace path for \'%d\'.", getpid());\n\t\treturn fret;\n\t}\n\n\tfd = lxc_preserve_ns(pid, "net");\n\tif (fd &lt; 0) {\n\t\tusernic_error("Failed opening network namespace path for \'%d\'.", pid);\n\t\tgoto do_partial_cleanup;\n\t}\n\n\tret = getresuid(&amp;ruid, &amp;euid, &amp;suid);\n\tif (ret &lt; 0) {\n\t\tusernic_error("Failed to retrieve real, effective, and saved "\n\t\t\t      "user IDs: %s\\n",\n\t\t\t      strerror(errno));\n\t\tgoto do_partial_cleanup;\n\t}\n\n\tret = setns(fd, CLONE_NEWNET);\n\tclose(fd);\n\tfd = -1;\n\tif (ret &lt; 0) {\n\t\tusernic_error("Failed to setns() to the network namespace of "\n\t\t\t      "the container with PID %d: %s.\\n",\n\t\t\t      pid, strerror(errno));\n\t\tgoto do_partial_cleanup;\n\t}\n\n\tret = setresuid(ruid, ruid, 0);\n\tif (ret &lt; 0) {\n\t\tusernic_error("Failed to drop privilege by setting effective "\n\t\t\t      "user id and real user id to %d, and saved user "\n\t\t\t      "ID to 0: %s.\\n",\n\t\t\t      ruid, strerror(errno));\n\t\t// COMMENT(brauner): It\'s ok to jump to do_full_cleanup here\n\t\t// since setresuid() will succeed when trying to set real,\n\t\t// effective, and saved to values they currently have.\n\t\tgoto do_full_cleanup;\n\t}\n\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\n\t\tifindex = if_nametoindex(oldname);\n\t\tif (!ifindex) {\n\t\t\tusernic_error("Failed to get netdev index: %s.\\n", strerror(errno));\n\t\t\tgoto do_full_cleanup;\n\t\t}\n\t}\n\n\tret = lxc_netdev_rename_by_name(oldname, *newnamep);\n\tif (ret &lt; 0) {\n\t\tusernic_error("Error %d renaming netdev %s to %s in container.\\n", ret, oldname, *newnamep);\n\t\tgoto do_full_cleanup;\n\t}\n\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ];\n\t\tchar *namep = ifname;\n\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tusernic_error("Failed to get new netdev name: %s.\\n", strerror(errno));\n\t\t\tgoto do_full_cleanup;\n\t\t}\n\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto do_full_cleanup;\n\t}\n\n\tfret = 0;\n\ndo_full_cleanup:\n\tret = setresuid(ruid, euid, suid);\n\tif (ret &lt; 0) {\n\t\tusernic_error("Failed to restore privilege by setting effective "\n\t\t\t      "user id to %d, real user id to %d, and saved user "\n\t\t\t      "ID to %d: %s.\\n",\n\t\t\t      ruid, euid, suid, strerror(errno));\n\t\tfret = -1;\n\t\t// COMMENT(brauner): setns() should fail if setresuid() doesn\'t\n\t\t// succeed but there\'s no harm in falling through; keeps the\n\t\t// code cleaner.\n\t}\n\n\tret = setns(ofd, CLONE_NEWNET);\n\tif (ret &lt; 0) {\n\t\tusernic_error("Failed to setns() to original network namespace "\n\t\t\t      "of PID %d: %s.\\n",\n\t\t\t      ofd, strerror(errno));\n\t\tfret = -1;\n\t}\n\ndo_partial_cleanup:\n\tif (fd &gt;= 0)\n\t\tclose(fd);\n\tclose(ofd);\n\n\treturn fret;\n}',
 'static int iowarrior_probe(struct usb_interface *interface,\n\t\t\t   const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct iowarrior *dev = NULL;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint i;\n\tint retval = -ENOMEM;\n\n\t/* allocate memory for our device state and initialize it */\n\tdev = kzalloc(sizeof(struct iowarrior), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tdev_err(&amp;interface-&gt;dev, "Out of memory\\n");\n\t\treturn retval;\n\t}\n\n\tmutex_init(&amp;dev-&gt;mutex);\n\n\tatomic_set(&amp;dev-&gt;intr_idx, 0);\n\tatomic_set(&amp;dev-&gt;read_idx, 0);\n\tspin_lock_init(&amp;dev-&gt;intr_idx_lock);\n\tatomic_set(&amp;dev-&gt;overflow_flag, 0);\n\tinit_waitqueue_head(&amp;dev-&gt;read_wait);\n\tatomic_set(&amp;dev-&gt;write_busy, 0);\n\tinit_waitqueue_head(&amp;dev-&gt;write_wait);\n\n\tdev-&gt;udev = udev;\n\tdev-&gt;interface = interface;\n\n\tiface_desc = interface-&gt;cur_altsetting;\n\tdev-&gt;product_id = le16_to_cpu(udev-&gt;descriptor.idProduct);\n\n\tif (iface_desc-&gt;desc.bNumEndpoints &lt; 1) {\n\t\tdev_err(&amp;interface-&gt;dev, "Invalid number of endpoints\\n");\n\t\tretval = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t/* set up the endpoint information */\n\tfor (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i) {\n\t\tendpoint = &amp;iface_desc-&gt;endpoint[i].desc;\n\n\t\tif (usb_endpoint_is_int_in(endpoint))\n\t\t\tdev-&gt;int_in_endpoint = endpoint;\n\t\tif (usb_endpoint_is_int_out(endpoint))\n\t\t\t/* this one will match for the IOWarrior56 only */\n\t\t\tdev-&gt;int_out_endpoint = endpoint;\n\t}\n\t/* we have to check the report_size often, so remember it in the endianness suitable for our machine */\n\tdev-&gt;report_size = usb_endpoint_maxp(dev-&gt;int_in_endpoint);\n\tif ((dev-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber == 0) &amp;&amp;\n\t    (dev-&gt;product_id == USB_DEVICE_ID_CODEMERCS_IOW56))\n\t\t/* IOWarrior56 has wMaxPacketSize different from report size */\n\t\tdev-&gt;report_size = 7;\n\n\t/* create the urb and buffer for reading */\n\tdev-&gt;int_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev-&gt;int_in_urb) {\n\t\tdev_err(&amp;interface-&gt;dev, "Couldn\'t allocate interrupt_in_urb\\n");\n\t\tgoto error;\n\t}\n\tdev-&gt;int_in_buffer = kmalloc(dev-&gt;report_size, GFP_KERNEL);\n\tif (!dev-&gt;int_in_buffer) {\n\t\tdev_err(&amp;interface-&gt;dev, "Couldn\'t allocate int_in_buffer\\n");\n\t\tgoto error;\n\t}\n\tusb_fill_int_urb(dev-&gt;int_in_urb, dev-&gt;udev,\n\t\t\t usb_rcvintpipe(dev-&gt;udev,\n\t\t\t\t\tdev-&gt;int_in_endpoint-&gt;bEndpointAddress),\n\t\t\t dev-&gt;int_in_buffer, dev-&gt;report_size,\n\t\t\t iowarrior_callback, dev,\n\t\t\t dev-&gt;int_in_endpoint-&gt;bInterval);\n\t/* create an internal buffer for interrupt data from the device */\n\tdev-&gt;read_queue =\n\t    kmalloc(((dev-&gt;report_size + 1) * MAX_INTERRUPT_BUFFER),\n\t\t    GFP_KERNEL);\n\tif (!dev-&gt;read_queue) {\n\t\tdev_err(&amp;interface-&gt;dev, "Couldn\'t allocate read_queue\\n");\n\t\tgoto error;\n\t}\n\t/* Get the serial-number of the chip */\n\tmemset(dev-&gt;chip_serial, 0x00, sizeof(dev-&gt;chip_serial));\n\tusb_string(udev, udev-&gt;descriptor.iSerialNumber, dev-&gt;chip_serial,\n\t\t   sizeof(dev-&gt;chip_serial));\n\tif (strlen(dev-&gt;chip_serial) != 8)\n\t\tmemset(dev-&gt;chip_serial, 0x00, sizeof(dev-&gt;chip_serial));\n\n\t/* Set the idle timeout to 0, if this is interface 0 */\n\tif (dev-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber == 0) {\n\t    usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t    0x0A,\n\t\t\t    USB_TYPE_CLASS | USB_RECIP_INTERFACE, 0,\n\t\t\t    0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\t}\n\t/* allow device read and ioctl */\n\tdev-&gt;present = 1;\n\n\t/* we can register the device now, as it is ready */\n\tusb_set_intfdata(interface, dev);\n\n\tretval = usb_register_dev(interface, &amp;iowarrior_class);\n\tif (retval) {\n\t\t/* something prevented us from registering this driver */\n\t\tdev_err(&amp;interface-&gt;dev, "Not able to get a minor for this device.\\n");\n\t\tusb_set_intfdata(interface, NULL);\n\t\tgoto error;\n\t}\n\n\tdev-&gt;minor = interface-&gt;minor;\n\n\t/* let the user know what node this device is now attached to */\n\tdev_info(&amp;interface-&gt;dev, "IOWarrior product=0x%x, serial=%s interface=%d "\n\t\t "now attached to iowarrior%d\\n", dev-&gt;product_id, dev-&gt;chip_serial,\n\t\t iface_desc-&gt;desc.bInterfaceNumber, dev-&gt;minor - IOWARRIOR_MINOR_BASE);\n\treturn retval;\n\nerror:\n\tiowarrior_delete(dev);\n\treturn retval;\n}',
 "static int DefragMfIpv6Test(void)\n{\n    int retval = 0;\n    int ip_id = 9;\n    Packet *p = NULL;\n\n    DefragInit();\n\n    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n    if (p1 == NULL || p2 == NULL || p3 == NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p1, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p2, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    /* This should return a packet as MF=0. */\n    p = Defrag(NULL, NULL, p3, NULL);\n    if (p == NULL) {\n        goto end;\n    }\n\n    /* For IPv6 the expected length is just the length of the payload\n     * of 2 fragments, so 16. */\n    if (IPV6_GET_PLEN(p) != 16) {\n        goto end;\n    }\n\n    retval = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    if (p2 != NULL) {\n        SCFree(p2);\n    }\n    if (p3 != NULL) {\n        SCFree(p3);\n    }\n    if (p != NULL) {\n        SCFree(p);\n    }\n    DefragDestroy();\n    return retval;\n}",
 'void SPECTRA::run( Session* session, const std::string&amp; argument ){\n\n  /* The argument should consist of 2 comma separated values:\n     1) resolution\n     2) tile number\n     3) pixel index in x direction\n     4) pixel index in y direction\n  */\n\n  if( session-&gt;loglevel &gt;= 3 ) (*session-&gt;logfile) &lt;&lt; "SPECTRA handler reached" &lt;&lt; endl;\n\n\n  // Make sure we have set our image\n  this-&gt;session = session;\n  checkImage();\n\n\n  // Time this command\n  if( session-&gt;loglevel &gt;= 2 ) command_timer.start();\n\n\n  // Parse the argument list\n  string arg = argument;\n  int delimitter = arg.find( "," );\n  int resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( "," );\n  int tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( "," );\n  int x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( "," );\n  int y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session-&gt;loglevel &gt;= 5 ){ \n    (*session-&gt;logfile) &lt;&lt; "SPECTRA :: resolution: " &lt;&lt; resolution\n\t\t\t&lt;&lt; ", tile: " &lt;&lt; tile\n\t\t\t&lt;&lt; ", x: " &lt;&lt; x\n\t\t\t&lt;&lt; ", y: " &lt;&lt; y &lt;&lt; endl;\n  }\n\n  // Make sure our x,y coordinates are within the tile dimensions\n  if( x &lt; 0 || x &gt;= (int)(*session-&gt;image)-&gt;getTileWidth() ||\n      y &lt; 0 || y &gt;= (int)(*session-&gt;image)-&gt;getTileHeight() ){\n    throw invalid_argument( "SPECTRA :: Error: x,y coordinates outside of tile boundaries" );\n  }\n  \n\n  TileManager tilemanager( session-&gt;tileCache, *session-&gt;image, session-&gt;watermark, session-&gt;jpeg, session-&gt;logfile, session-&gt;loglevel );\n\n  // Use our horizontal views function to get a list of available spectral images\n  list &lt;int&gt; views = (*session-&gt;image)-&gt;getHorizontalViewsList();\n  list &lt;int&gt; :: const_iterator i;\n\n  // Our list of spectral reflectance values for the requested point\n  list &lt;float&gt; spectrum;\n\n\n#ifndef DEBUG\n  // Output our HTTP header\n  stringstream header;\n  header &lt;&lt; session-&gt;response-&gt;createHTTPHeader( "xml", (*session-&gt;image)-&gt;getTimestamp() );\n  session-&gt;out-&gt;putStr( (const char*) header.str().c_str(), header.tellp() );\n  session-&gt;out-&gt;flush();\n#endif\n\n  session-&gt;out-&gt;putS( "&lt;?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?&gt;\\n" );\n  session-&gt;out-&gt;putS( "&lt;spectra&gt;\\n" );\n  session-&gt;out-&gt;flush();\n\n  for( i = views.begin(); i != views.end(); i++ ){\n\n    int n = *i;\n\n    RawTile rawtile = tilemanager.getTile( resolution, tile, n, session-&gt;view-&gt;yangle, session-&gt;view-&gt;getLayers(), UNCOMPRESSED );\n\n    // Make sure our x,y coordinates are within the tile dimensions\n    if( x &gt;= (int)rawtile.width || y &gt;= (int)rawtile.height ){\n      if( session-&gt;loglevel &gt;= 1 ){\n\t(*session-&gt;logfile) &lt;&lt; "SPECTRA :: Error: x,y coordinates outside of tile boundaries" &lt;&lt; endl;\n      }\n      break;\n    }\n\n\n    unsigned int tw = (*session-&gt;image)-&gt;getTileWidth();\n    unsigned int index = y*tw + x;\n\n    void *ptr;\n    float reflectance = 0.0;\n\n    if( session-&gt;loglevel &gt;= 5 ) (*session-&gt;logfile) &lt;&lt; "SPECTRA :: " &lt;&lt; rawtile.bpc &lt;&lt; " bits per channel data" &lt;&lt; endl;\n\n    // Handle depending on bit depth\n    if( rawtile.bpc == 8 ){\n      ptr = (unsigned char*) (rawtile.data);\n      reflectance = static_cast&lt;float&gt;((float)((unsigned char*)ptr)[index]) / 255.0;\n    }\n    else if( rawtile.bpc == 16 ){\n      ptr = (unsigned short*) (rawtile.data);\n      reflectance = static_cast&lt;float&gt;((float)((unsigned short*)ptr)[index]) / 65535.0;\n    }\n    else if( rawtile.bpc == 32 ){\n      if( rawtile.sampleType == FIXEDPOINT ) {\n        ptr = (unsigned int*) rawtile.data;\n        reflectance = static_cast&lt;float&gt;((float)((unsigned int*)ptr)[index]);\n      }\n      else {\n        ptr = (float*) rawtile.data;\n        reflectance = static_cast&lt;float&gt;((float)((float*)ptr)[index]);\n      }\n    }\n\n    spectrum.push_front( reflectance );\n\n    string metadata = (*session-&gt;image)-&gt;getMetadata( "subject" );\n\n    char tmp[1024];\n    snprintf( tmp, 1024, "\\t&lt;point&gt;\\n\\t\\t&lt;wavelength&gt;%d&lt;/wavelength&gt;\\n\\t\\t&lt;reflectance&gt;%f&lt;/reflectance&gt;\\n\\t&lt;/point&gt;\\n", n, reflectance );\n    session-&gt;out-&gt;putS( tmp );\n    session-&gt;out-&gt;flush();\n\n    if( session-&gt;loglevel &gt;= 3 ) (*session-&gt;logfile) &lt;&lt; "SPECTRA :: Band: " &lt;&lt; n &lt;&lt; ", reflectance: " &lt;&lt; reflectance &lt;&lt; endl;\n  }\n\n\n  session-&gt;out-&gt;putS( "&lt;/spectra&gt;" );\n\n  if( session-&gt;out-&gt;flush() == -1 ) {\n    if( session-&gt;loglevel &gt;= 1 ){\n      *(session-&gt;logfile) &lt;&lt; "SPECTRA :: Error flushing XML" &lt;&lt; endl;\n    }\n  }\n\n\n  // Inform our response object that we have sent something to the client\n  session-&gt;response-&gt;setImageSent();\n\n  // Total SPECTRA response time\n  if( session-&gt;loglevel &gt;= 2 ){\n    *(session-&gt;logfile) &lt;&lt; "SPECTRA :: Total command time " &lt;&lt; command_timer.getTime() &lt;&lt; " microseconds" &lt;&lt; endl;\n  }\n\n}',
 "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\n\tint i;\n\tif (huff-&gt;loc[ch] == NULL) { \n\t\t/* node_t hasn't been transmitted, send a NYT, then the symbol */\n\t\tHuff_transmit(huff, NYT, fout);\n\t\tfor (i = 7; i &gt;= 0; i--) {\n\t\t\tadd_bit((char)((ch &gt;&gt; i) &amp; 0x1), fout);\n\t\t}\n\t} else {\n\t\tsend(huff-&gt;loc[ch], NULL, fout);\n\t}\n}",
 'static int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c-&gt;rcurr &lt;= (c-&gt;rbuf + c-&gt;rsize));\n    assert(c-&gt;rbytes &gt; 0);\n\n    if (c-&gt;protocol == negotiating_prot || c-&gt;transport == udp_transport)  {\n        if ((unsigned char)c-&gt;rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c-&gt;protocol = binary_prot;\n        } else {\n            c-&gt;protocol = ascii_prot;\n        }\n\n        if (settings.verbose &gt; 1) {\n            fprintf(stderr, "%d: Client using the %s protocol\\n", c-&gt;sfd,\n                    prot_text(c-&gt;protocol));\n        }\n    }\n\n    if (c-&gt;protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c-&gt;rbytes &lt; sizeof(c-&gt;binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c-&gt;rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c-&gt;rbuf, c-&gt;rcurr, c-&gt;rbytes);\n                c-&gt;rcurr = c-&gt;rbuf;\n                if (settings.verbose &gt; 1) {\n                    fprintf(stderr, "%d: Realign input buffer\\n", c-&gt;sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c-&gt;rcurr;\n\n            if (settings.verbose &gt; 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, "&lt;%d Read binary protocol data:", c-&gt;sfd);\n                for (ii = 0; ii &lt; sizeof(req-&gt;bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, "\\n&lt;%d   ", c-&gt;sfd);\n                    }\n                    fprintf(stderr, " 0x%02x", req-&gt;bytes[ii]);\n                }\n                fprintf(stderr, "\\n");\n            }\n\n            c-&gt;binary_header = *req;\n            c-&gt;binary_header.request.keylen = ntohs(req-&gt;request.keylen);\n            c-&gt;binary_header.request.bodylen = ntohl(req-&gt;request.bodylen);\n            c-&gt;binary_header.request.cas = ntohll(req-&gt;request.cas);\n\n            if (c-&gt;binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, "Invalid magic:  %x\\n",\n                            c-&gt;binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c-&gt;msgcurr = 0;\n            c-&gt;msgused = 0;\n            c-&gt;iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, "SERVER_ERROR out of memory");\n                return 0;\n            }\n\n            c-&gt;cmd = c-&gt;binary_header.request.opcode;\n            c-&gt;keylen = c-&gt;binary_header.request.keylen;\n            c-&gt;opaque = c-&gt;binary_header.request.opaque;\n            /* clear the returned cas value */\n            c-&gt;cas = 0;\n\n            dispatch_bin_command(c);\n\n            c-&gt;rbytes -= sizeof(c-&gt;binary_header);\n            c-&gt;rcurr += sizeof(c-&gt;binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c-&gt;rbytes == 0)\n            return 0;\n        el = memchr(c-&gt;rcurr, \'\\n\', c-&gt;rbytes);\n        if (!el)\n            return 0;\n        cont = el + 1;\n        if ((el - c-&gt;rcurr) &gt; 1 &amp;&amp; *(el - 1) == \'\\r\') {\n            el--;\n        }\n        *el = \'\\0\';\n\n        assert(cont &lt;= (c-&gt;rcurr + c-&gt;rbytes));\n\n        process_command(c, c-&gt;rcurr);\n\n        c-&gt;rbytes -= (cont - c-&gt;rcurr);\n        c-&gt;rcurr = cont;\n\n        assert(c-&gt;rcurr &lt;= (c-&gt;rbuf + c-&gt;rsize));\n    }\n\n    return 1;\n}',
 'static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\n\tsbi-&gt;s_log_groups_per_flex = sbi-&gt;s_es-&gt;s_log_groups_per_flex;\n\tgroups_per_flex = 1 &lt;&lt; sbi-&gt;s_log_groups_per_flex;\n\n\tif (groups_per_flex &lt; 2) {\n\t\tsbi-&gt;s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\n\t/* We allocate both existing and potentially added groups */\n\tflex_group_count = ((sbi-&gt;s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi-&gt;s_es-&gt;s_reserved_gdt_blocks) + 1) &lt;&lt;\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi-&gt;s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi-&gt;s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, "not enough memory for %u flex groups",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i &lt; sbi-&gt;s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &amp;sbi-&gt;s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &amp;sbi-&gt;s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &amp;sbi-&gt;s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}',
 'struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n\t\t\t\t   struct tcp_sock_t *sock6)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR("Calloc for connection struct failed");\n\t\tgoto error;\n\t}\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint retval = 0;\n\tint nfds = 0;\n\twhile (retval == 0) {\n\t\tFD_ZERO(&amp;rfds);\n\t\tif (sock) {\n\t\t\tFD_SET(sock-&gt;sd, &amp;rfds);\n\t\t\tnfds = sock-&gt;sd;\n\t\t}\n\t\tif (sock6) {\n\t\t\tFD_SET(sock6-&gt;sd, &amp;rfds);\n\t\t\tif (sock6-&gt;sd &gt; nfds)\n\t\t\t\tnfds = sock6-&gt;sd;\n\t\t}\n\t\tif (nfds == 0) {\n\t\t\tERR("No valid TCP socket supplied.");\n\t\t\tgoto error;\n\t\t}\n\t\tnfds += 1;\n\t\t/* Wait up to five seconds. */\n\t\ttv.tv_sec = 5;\n\t\ttv.tv_usec = 0;\n\t\tretval = select(nfds, &amp;rfds, NULL, NULL, &amp;tv);\n\t\tif (retval == -1) {\n\t\t\tERR("Failed to open tcp connection");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (sock &amp;&amp; FD_ISSET(sock-&gt;sd, &amp;rfds)) {\n\t\tconn-&gt;sd = accept(sock-&gt;sd, NULL, NULL);\n\t\tNOTE ("Using IPv4");\n\t} else if (sock6 &amp;&amp; FD_ISSET(sock6-&gt;sd, &amp;rfds)) {\n\t\tconn-&gt;sd = accept(sock6-&gt;sd, NULL, NULL);\n\t\tNOTE ("Using IPv6");\n\t} else {\n\t\tERR("select failed");\n\t\tgoto error;\n\t}\n\tif (conn-&gt;sd &lt; 0) {\n\t\tERR("accept failed");\n\t\tgoto error;\n\t}\n\treturn conn;\n\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}',
 'diff_mark_adjust_tp(\n    tabpage_T\t*tp,\n    int\t\tidx,\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    diff_T\t*dp;\n    diff_T\t*dprev;\n    diff_T\t*dnext;\n    int\t\ti;\n    int\t\tinserted, deleted;\n    int\t\tn, off;\n    linenr_T\tlast;\n    linenr_T\tlnum_deleted = line1;\t// lnum of remaining deletion\n    int\t\tcheck_unchanged;\n\n    if (diff_internal())\n    {\n\t// Will update diffs before redrawing.  Set _invalid to update the\n\t// diffs themselves, set _update to also update folds properly just\n\t// before redrawing.\n\t// Do update marks here, it is needed for :%diffput.\n\ttp-&gt;tp_diff_invalid = TRUE;\n\ttp-&gt;tp_diff_update = TRUE;\n    }\n\n    if (line2 == MAXLNUM)\n    {\n\t// mark_adjust(99, MAXLNUM, 9, 0): insert lines\n\tinserted = amount;\n\tdeleted = 0;\n    }\n    else if (amount_after &gt; 0)\n    {\n\t// mark_adjust(99, 98, MAXLNUM, 9): a change that inserts lines\n\tinserted = amount_after;\n\tdeleted = 0;\n    }\n    else\n    {\n\t// mark_adjust(98, 99, MAXLNUM, -2): delete lines\n\tinserted = 0;\n\tdeleted = -amount_after;\n    }\n\n    dprev = NULL;\n    dp = tp-&gt;tp_first_diff;\n    for (;;)\n    {\n\t// If the change is after the previous diff block and before the next\n\t// diff block, thus not touching an existing change, create a new diff\n\t// block.  Don\'t do this when ex_diffgetput() is busy.\n\tif ((dp == NULL || dp-&gt;df_lnum[idx] - 1 &gt; line2\n\t\t    || (line2 == MAXLNUM &amp;&amp; dp-&gt;df_lnum[idx] &gt; line1))\n\t\t&amp;&amp; (dprev == NULL\n\t\t    || dprev-&gt;df_lnum[idx] + dprev-&gt;df_count[idx] &lt; line1)\n\t\t&amp;&amp; !diff_busy)\n\t{\n\t    dnext = diff_alloc_new(tp, dprev, dp);\n\t    if (dnext == NULL)\n\t\treturn;\n\n\t    dnext-&gt;df_lnum[idx] = line1;\n\t    dnext-&gt;df_count[idx] = inserted;\n\t    for (i = 0; i &lt; DB_COUNT; ++i)\n\t\tif (tp-&gt;tp_diffbuf[i] != NULL &amp;&amp; i != idx)\n\t\t{\n\t\t    if (dprev == NULL)\n\t\t\tdnext-&gt;df_lnum[i] = line1;\n\t\t    else\n\t\t\tdnext-&gt;df_lnum[i] = line1\n\t\t\t    + (dprev-&gt;df_lnum[i] + dprev-&gt;df_count[i])\n\t\t\t    - (dprev-&gt;df_lnum[idx] + dprev-&gt;df_count[idx]);\n\t\t    dnext-&gt;df_count[i] = deleted;\n\t\t}\n\t}\n\n\t// if at end of the list, quit\n\tif (dp == NULL)\n\t    break;\n\n\t/*\n\t * Check for these situations:\n\t *\t  1  2\t3\n\t *\t  1  2\t3\n\t * line1     2\t3  4  5\n\t *\t     2\t3  4  5\n\t *\t     2\t3  4  5\n\t * line2     2\t3  4  5\n\t *\t\t3     5  6\n\t *\t\t3     5  6\n\t */\n\t// compute last line of this change\n\tlast = dp-&gt;df_lnum[idx] + dp-&gt;df_count[idx] - 1;\n\n\t// 1. change completely above line1: nothing to do\n\tif (last &gt;= line1 - 1)\n\t{\n\t    // 6. change below line2: only adjust for amount_after; also when\n\t    // "deleted" became zero when deleted all lines between two diffs\n\t    if (dp-&gt;df_lnum[idx] - (deleted + inserted != 0) &gt; line2)\n\t    {\n\t\tif (amount_after == 0)\n\t\t    break;\t// nothing left to change\n\t\tdp-&gt;df_lnum[idx] += amount_after;\n\t    }\n\t    else\n\t    {\n\t\tcheck_unchanged = FALSE;\n\n\t\t// 2. 3. 4. 5.: inserted/deleted lines touching this diff.\n\t\tif (deleted &gt; 0)\n\t\t{\n\t\t    off = 0;\n\t\t    if (dp-&gt;df_lnum[idx] &gt;= line1)\n\t\t    {\n\t\t\tif (last &lt;= line2)\n\t\t\t{\n\t\t\t    // 4. delete all lines of diff\n\t\t\t    if (dp-&gt;df_next != NULL\n\t\t\t\t    &amp;&amp; dp-&gt;df_next-&gt;df_lnum[idx] - 1 &lt;= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp-&gt;df_next-&gt;df_lnum[idx] - lnum_deleted;\n\t\t\t\tdeleted -= n;\n\t\t\t\tn -= dp-&gt;df_count[idx];\n\t\t\t\tlnum_deleted = dp-&gt;df_next-&gt;df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = deleted - dp-&gt;df_count[idx];\n\t\t\t    dp-&gt;df_count[idx] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 5. delete lines at or just before top of diff\n\t\t\t    off = dp-&gt;df_lnum[idx] - lnum_deleted;\n\t\t\t    n = off;\n\t\t\t    dp-&gt;df_count[idx] -= line2 - dp-&gt;df_lnum[idx] + 1;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\tdp-&gt;df_lnum[idx] = line1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (last &lt; line2)\n\t\t\t{\n\t\t\t    // 2. delete at end of diff\n\t\t\t    dp-&gt;df_count[idx] -= last - lnum_deleted + 1;\n\t\t\t    if (dp-&gt;df_next != NULL\n\t\t\t\t    &amp;&amp; dp-&gt;df_next-&gt;df_lnum[idx] - 1 &lt;= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp-&gt;df_next-&gt;df_lnum[idx] - 1 - last;\n\t\t\t\tdeleted -= dp-&gt;df_next-&gt;df_lnum[idx]\n\t\t\t\t\t\t\t       - lnum_deleted;\n\t\t\t\tlnum_deleted = dp-&gt;df_next-&gt;df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = line2 - last;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 3. delete lines inside the diff\n\t\t\t    n = 0;\n\t\t\t    dp-&gt;df_count[idx] -= deleted;\n\t\t\t}\n\t\t    }\n\n\t\t    for (i = 0; i &lt; DB_COUNT; ++i)\n\t\t\tif (tp-&gt;tp_diffbuf[i] != NULL &amp;&amp; i != idx)\n\t\t\t{\n\t\t\t    dp-&gt;df_lnum[i] -= off;\n\t\t\t    dp-&gt;df_count[i] += n;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (dp-&gt;df_lnum[idx] &lt;= line1)\n\t\t    {\n\t\t\t// inserted lines somewhere in this diff\n\t\t\tdp-&gt;df_count[idx] += inserted;\n\t\t\tcheck_unchanged = TRUE;\n\t\t    }\n\t\t    else\n\t\t\t// inserted lines somewhere above this diff\n\t\t\tdp-&gt;df_lnum[idx] += inserted;\n\t\t}\n\n\t\tif (check_unchanged)\n\t\t    // Check if inserted lines are equal, may reduce the\n\t\t    // size of the diff.  TODO: also check for equal lines\n\t\t    // in the middle and perhaps split the block.\n\t\t    diff_check_unchanged(tp, dp);\n\t    }\n\t}\n\n\t// check if this block touches the previous one, may merge them.\n\tif (dprev != NULL &amp;&amp; dprev-&gt;df_lnum[idx] + dprev-&gt;df_count[idx]\n\t\t\t\t\t\t\t  == dp-&gt;df_lnum[idx])\n\t{\n\t    for (i = 0; i &lt; DB_COUNT; ++i)\n\t\tif (tp-&gt;tp_diffbuf[i] != NULL)\n\t\t    dprev-&gt;df_count[i] += dp-&gt;df_count[i];\n\t    dprev-&gt;df_next = dp-&gt;df_next;\n\t    vim_free(dp);\n\t    dp = dprev-&gt;df_next;\n\t}\n\telse\n\t{\n\t    // Advance to next entry.\n\t    dprev = dp;\n\t    dp = dp-&gt;df_next;\n\t}\n    }\n\n    dprev = NULL;\n    dp = tp-&gt;tp_first_diff;\n    while (dp != NULL)\n    {\n\t// All counts are zero, remove this entry.\n\tfor (i = 0; i &lt; DB_COUNT; ++i)\n\t    if (tp-&gt;tp_diffbuf[i] != NULL &amp;&amp; dp-&gt;df_count[i] != 0)\n\t\tbreak;\n\tif (i == DB_COUNT)\n\t{\n\t    dnext = dp-&gt;df_next;\n\t    vim_free(dp);\n\t    dp = dnext;\n\t    if (dprev == NULL)\n\t\ttp-&gt;tp_first_diff = dnext;\n\t    else\n\t\tdprev-&gt;df_next = dnext;\n\t}\n\telse\n\t{\n\t    // Advance to next entry.\n\t    dprev = dp;\n\t    dp = dp-&gt;df_next;\n\t}\n\n    }\n\n    if (tp == curtab)\n    {\n\t// Don\'t redraw right away, this updates the diffs, which can be slow.\n\tneed_diff_redraw = TRUE;\n\n\t// Need to recompute the scroll binding, may remove or add filler\n\t// lines (e.g., when adding lines above w_topline). But it\'s slow when\n\t// making many changes, postpone until redrawing.\n\tdiff_need_scrollbind = TRUE;\n    }\n}',
 'void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)-&gt;cmsg_flags &amp; IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare &amp;&amp; skb_rtable(skb)) {\n\t\t/* skb-&gt;cb is overloaded: prior to this point it is IP{6}CB\n\t\t * which has interface index (iif) as the first member of the\n\t\t * underlying inet{6}_skb_parm struct. This code then overlays\n\t\t * PKTINFO_SKB_CB and in_pktinfo also has iif as the first\n\t\t * element so the iif is picked up from the prior IPCB. If iif\n\t\t * is the loopback interface, then return the sending interface\n\t\t * (e.g., process binds socket to eth0 for Tx which is\n\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo-&gt;ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo-&gt;ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo-&gt;ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo-&gt;ipi_ifindex = 0;\n\t\tpktinfo-&gt;ipi_spec_dst.s_addr = 0;\n\t}\n\t/* We need to keep the dst for __ip_options_echo()\n\t * We could restrict the test to opt.ts_needtime || opt.srr,\n\t * but the following is good enough as IP options are not often used.\n\t */\n\tif (unlikely(IPCB(skb)-&gt;opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);\n}',
 'snmp_ber_decode_unsigned_integer(snmp_packet_t *snmp_packet, uint8_t expected_type, uint32_t *num)\n{\n  uint8_t i, len, type;\n\n  if(!snmp_ber_decode_type(snmp_packet, &amp;type)) {\n    return 0;\n  }\n\n  if(type != expected_type) {\n    /*\n     * Sanity check\n     * Invalid type in buffer\n     */\n    return 0;\n  }\n\n  if(!snmp_ber_decode_length(snmp_packet, &amp;len)) {\n    return 0;\n  }\n\n  if(len &gt; 4) {\n    /*\n     * Sanity check\n     * It will not fit in the uint32_t\n     */\n    return 0;\n  }\n\n  if(snmp_packet-&gt;used == 0) {\n    return 0;\n  }\n\n  *num = (uint32_t)(*snmp_packet-&gt;in++ &amp; 0xFF);\n  snmp_packet-&gt;used--;\n\n  for(i = 1; i &lt; len; ++i) {\n    *num &lt;&lt;= 8;\n    if(snmp_packet-&gt;used == 0) {\n      return 0;\n    }\n    *num |= (uint8_t)(*snmp_packet-&gt;in++ &amp; 0xFF);\n    snmp_packet-&gt;used--;\n  }\n\n  return 1;\n}',
 "char *url_decode_r(char *to, char *url, size_t size) {\n    char *s = url,           // source\n         *d = to,            // destination\n         *e = &amp;to[size - 1]; // destination end\n\n    while(*s &amp;&amp; d &lt; e) {\n        if(unlikely(*s == '%')) {\n            if(likely(s[1] &amp;&amp; s[2])) {\n                char t = from_hex(s[1]) &lt;&lt; 4 | from_hex(s[2]);\n                // avoid HTTP header injection\n                *d++ = (char)((isprint(t))? t : ' ');\n                s += 2;\n            }\n        }\n        else if(unlikely(*s == '+'))\n            *d++ = ' ';\n\n        else\n            *d++ = *s;\n\n        s++;\n    }\n\n    *d = '\\0';\n\n    return to;\n}",
 'ast2obj_excepthandler(void* _o)\n{\n    excepthandler_ty o = (excepthandler_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    switch (o-&gt;kind) {\n    case ExceptHandler_kind:\n        result = PyType_GenericNew(ExceptHandler_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_expr(o-&gt;v.ExceptHandler.type);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &amp;PyId_type, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        value = ast2obj_identifier(o-&gt;v.ExceptHandler.name);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &amp;PyId_name, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        value = ast2obj_list(o-&gt;v.ExceptHandler.body, ast2obj_stmt);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &amp;PyId_body, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    }\n    value = ast2obj_int(o-&gt;lineno);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &amp;PyId_lineno, value) &lt; 0)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_int(o-&gt;col_offset);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &amp;PyId_col_offset, value) &lt; 0)\n        goto failed;\n    Py_DECREF(value);\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}',
 'static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&amp;handle-&gt;rb-&gt;poll, POLL_IN);\n\n\thandle-&gt;event-&gt;pending_wakeup = 1;\n\tirq_work_queue(&amp;handle-&gt;event-&gt;pending);\n}',
 'static inline int verify_replay(struct xfrm_usersa_info *p,\n\t\t\t\tstruct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct xfrm_replay_state_esn *rs;\n\n\tif (p-&gt;flags &amp; XFRM_STATE_ESN) {\n\t\tif (!rt)\n\t\t\treturn -EINVAL;\n\n\t\trs = nla_data(rt);\n\n\t\tif (rs-&gt;bmp_len &gt; XFRMA_REPLAY_ESN_MAX / sizeof(rs-&gt;bmp[0]) / 8)\n\t\t\treturn -EINVAL;\n\n\t\tif (nla_len(rt) &lt; xfrm_replay_state_esn_len(rs) &amp;&amp;\n\t\t    nla_len(rt) != sizeof(*rs))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rt)\n\t\treturn 0;\n\n\tif (p-&gt;id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (p-&gt;replay_window != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}',
 'int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER("my_redel");\n  DBUG_PRINT("my",("org_name: \'%s\' tmp_name: \'%s\'  MyFlags: %d",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (my_copystat(org_name,tmp_name,MyFlags) &lt; 0)\n    goto end;\n  if (MyFlags &amp; MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN+20];    \n    char ext[20];\n    ext[0]=\'-\';\n    get_date(ext+1,2+4,(time_t) 0);\n    strmov(strend(ext),REDEL_EXT);\n    if (my_rename(org_name, fn_format(name_buff, org_name, "", ext, 2),\n\t\t  MyFlags))\n      goto end;\n  }\n  else if (my_delete_allow_opened(org_name, MyFlags))\n      goto end;\n  if (my_rename(tmp_name,org_name,MyFlags))\n    goto end;\n\n  error=0;\nend:\n  DBUG_RETURN(error);\n} /* my_redel */',
 'vrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data-&gt;vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\n\tif (!tfile-&gt;file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, "No file set for track_file %s - removing", tfile-&gt;fname);\n\t\tfree_list_element(vrrp_data-&gt;vrrp_track_files, vrrp_data-&gt;vrrp_track_files-&gt;tail);\n\t\treturn;\n\t}\n\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\n\tret = stat(tfile-&gt;file_path, &amp;statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\t/* The file exists */\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode &amp; S_IFMT) != S_IFREG) {\n\t\t\t/* It is not a regular file */\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, "Cannot initialise track file %s - it is not a regular file", tfile-&gt;fname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Don\'t overwrite a file on reload */\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &amp;debug)) {\n\t\t/* Write the value to the file */\n\t\tif ((tf = fopen(tfile-&gt;file_path, "w"))) {\n\t\t\tfprintf(tf, "%d\\n", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, "Unable to initialise track file %s", tfile-&gt;fname);\n\t}\n}',
 'static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm-&gt;classperms);\n}',
 'idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &amp;length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, &amp;output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n\n      free(output_u8);\n    }\n\n  return rc;\n}',
 'static pj_bool_t on_accept_complete2(pj_ssl_sock_t *ssock,\n\t\t\t\t     pj_ssl_sock_t *new_ssock,\n\t\t\t\t     const pj_sockaddr_t *src_addr,\n\t\t\t\t     int src_addr_len, \n\t\t\t\t     pj_status_t accept_status)\n{    \n    struct tls_listener *listener;\n    struct tls_transport *tls;\n    pj_ssl_sock_info ssl_info;\n    char addr[PJ_INET6_ADDRSTRLEN+10];\n    pjsip_tp_state_callback state_cb;\n    pj_sockaddr tmp_src_addr;\n    pj_bool_t is_shutdown;\n    pj_status_t status;\n    char addr_buf[PJ_INET6_ADDRSTRLEN+10];        \n\n    PJ_UNUSED_ARG(src_addr_len);\n\n    listener = (struct tls_listener*) pj_ssl_sock_get_user_data(ssock);\n\n    if (accept_status != PJ_SUCCESS) {\n\tif (listener &amp;&amp; listener-&gt;tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_ssl_sock_info ssi;\n\n\t    pj_bzero(&amp;param, sizeof(param));\n\t    param.status = accept_status;\n\t    param.local_addr = &amp;listener-&gt;factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    if (new_ssock &amp;&amp;\n\t\tpj_ssl_sock_get_info(new_ssock, &amp;ssi) == PJ_SUCCESS)\n\t    {\n\t\tparam.last_native_err = ssi.last_native_err;\n\t    }\n\n\t    (*listener-&gt;tls_setting.on_accept_fail_cb) (&amp;param);\n\t}\n\n\treturn PJ_FALSE;\n    }\n\n    PJ_ASSERT_RETURN(new_ssock, PJ_TRUE);\n\n    if (!listener-&gt;is_registered) {\n\tif (listener-&gt;tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_bzero(&amp;param, sizeof(param));\n\t    param.status = PJSIP_TLS_EACCEPT;\n\t    param.local_addr = &amp;listener-&gt;factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    (*listener-&gt;tls_setting.on_accept_fail_cb) (&amp;param);\n\t}\n\treturn PJ_FALSE;\n    }\t\n\n    PJ_LOG(4,(listener-&gt;factory.obj_name, \n\t      "TLS listener %s: got incoming TLS connection "\n\t      "from %s, sock=%d",\n\t      pj_addr_str_print(&amp;listener-&gt;factory.addr_name.host, \n\t\t\t\tlistener-&gt;factory.addr_name.port, addr_buf, \n\t\t\t\tsizeof(addr_buf), 1),\n\t      pj_sockaddr_print(src_addr, addr, sizeof(addr), 3),\n\t      new_ssock));\n\n    /* Retrieve SSL socket info, close the socket if this is failed\n     * as the SSL socket info availability is rather critical here.\n     */\n    status = pj_ssl_sock_get_info(new_ssock, &amp;ssl_info);\n    if (status != PJ_SUCCESS) {\n\tpj_ssl_sock_close(new_ssock);\n\n\tif (listener-&gt;tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_bzero(&amp;param, sizeof(param));\n\t    param.status = status;\n\t    param.local_addr = &amp;listener-&gt;factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    (*listener-&gt;tls_setting.on_accept_fail_cb) (&amp;param);\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Copy to larger buffer, just in case */\n    pj_bzero(&amp;tmp_src_addr, sizeof(tmp_src_addr));\n    pj_sockaddr_cp(&amp;tmp_src_addr, src_addr);\n\n    /* \n     * Incoming connection!\n     * Create TLS transport for the new socket.\n     */\n    status = tls_create( listener, NULL, new_ssock, PJ_TRUE,\n\t\t\t &amp;ssl_info.local_addr, &amp;tmp_src_addr, NULL,\n\t\t\t ssl_info.grp_lock, &amp;tls);\n    \n    if (status != PJ_SUCCESS) {\n\tif (listener-&gt;tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_bzero(&amp;param, sizeof(param));\n\t    param.status = status;\n\t    param.local_addr = &amp;listener-&gt;factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    (*listener-&gt;tls_setting.on_accept_fail_cb) (&amp;param);\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Set the "pending" SSL socket user data */\n    pj_ssl_sock_set_user_data(new_ssock, tls);\n\n    /* Prevent immediate transport destroy as application may access it \n     * (getting info, etc) in transport state notification callback.\n     */\n    pjsip_transport_add_ref(&amp;tls-&gt;base);\n\n    /* If there is verification error and verification is mandatory, shutdown\n     * and destroy the transport.\n     */\n    if (ssl_info.verify_status &amp;&amp; listener-&gt;tls_setting.verify_client) {\n\tif (tls-&gt;close_reason == PJ_SUCCESS) \n\t    tls-&gt;close_reason = PJSIP_TLS_ECERTVERIF;\n\tpjsip_transport_shutdown(&amp;tls-&gt;base);\n    }\n    /* Notify transport state to application */\n    state_cb = pjsip_tpmgr_get_state_cb(tls-&gt;base.tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\tpjsip_tls_state_info tls_info;\n\tpjsip_transport_state tp_state;\n\n\t/* Init transport state info */\n\tpj_bzero(&amp;tls_info, sizeof(tls_info));\n\tpj_bzero(&amp;state_info, sizeof(state_info));\n\ttls_info.ssl_sock_info = &amp;ssl_info;\n\tstate_info.ext_info = &amp;tls_info;\n\n\t/* Set transport state based on verification status */\n\tif (ssl_info.verify_status &amp;&amp; listener-&gt;tls_setting.verify_client)\n\t{\n\t    tp_state = PJSIP_TP_STATE_DISCONNECTED;\n\t    state_info.status = PJSIP_TLS_ECERTVERIF;\n\t} else {\n\t    tp_state = PJSIP_TP_STATE_CONNECTED;\n\t    state_info.status = PJ_SUCCESS;\n\t}\n\n\t(*state_cb)(&amp;tls-&gt;base, tp_state, &amp;state_info);\n    }\n\n    /* Release transport reference. If transport is shutting down, it may\n     * get destroyed here.\n     */\n    is_shutdown = tls-&gt;base.is_shutdown;\n    pjsip_transport_dec_ref(&amp;tls-&gt;base);\n    if (is_shutdown)\n\treturn PJ_TRUE;\n\n\n    status = tls_start_read(tls);\n    if (status != PJ_SUCCESS) {\n\tPJ_LOG(3,(tls-&gt;base.obj_name, "New transport cancelled"));\n\ttls_init_shutdown(tls, status);\n\ttls_destroy(&amp;tls-&gt;base, status);\n    } else {\n\t/* Start keep-alive timer */\n\tif (pjsip_cfg()-&gt;tls.keep_alive_interval) {\n\t    pj_time_val delay = {0};\t    \n\t    delay.sec = pjsip_cfg()-&gt;tls.keep_alive_interval;\n\t    pjsip_endpt_schedule_timer(listener-&gt;endpt, \n\t\t\t\t       &amp;tls-&gt;ka_timer, \n\t\t\t\t       &amp;delay);\n\t    tls-&gt;ka_timer.id = PJ_TRUE;\n\t    pj_gettimeofday(&amp;tls-&gt;last_activity);\n\t}\n    }\n\n    return PJ_TRUE;\n}',
 'R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse-&gt;tag = type;\n\tif (se-&gt;tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse-&gt;info.obj_val_cp_idx = (ut16) value;\n\t} else if (se-&gt;tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\t/*if (bin-&gt;offset_sz == 4) {\n\t\tse-&gt;info.uninit_offset = value;\n\t\t} else {\n\t\tse-&gt;info.uninit_offset = (ut16) value;\n\t\t}*/\n\t\tse-&gt;info.uninit_offset = (ut16) value;\n\t}\n\treturn se;\n}',
 'static int ext4_split_extent(handle_t *handle,\n\t\t\t      struct inode *inode,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      int split_flag,\n\t\t\t      int flags)\n{\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\tint uninitialized;\n\tint split_flag1, flags1;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex-&gt;ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tuninitialized = ext4_ext_is_uninitialized(ex);\n\n\tif (map-&gt;m_lblk + map-&gt;m_len &lt; ee_block + ee_len) {\n\t\tsplit_flag1 = split_flag &amp; EXT4_EXT_MAY_ZEROOUT;\n\t\tflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n\t\t\t\t       EXT4_EXT_MARK_UNINIT2;\n\t\tif (split_flag &amp; EXT4_EXT_DATA_VALID2)\n\t\t\tsplit_flag1 |= EXT4_EXT_DATA_VALID1;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap-&gt;m_lblk + map-&gt;m_len, split_flag1, flags1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\text4_ext_drop_refs(path);\n\tpath = ext4_ext_find_extent(inode, map-&gt;m_lblk, path);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tif (map-&gt;m_lblk &gt;= ee_block) {\n\t\tsplit_flag1 = split_flag &amp; (EXT4_EXT_MAY_ZEROOUT |\n\t\t\t\t\t    EXT4_EXT_DATA_VALID2);\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\n\t\tif (split_flag &amp; EXT4_EXT_MARK_UNINIT2)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap-&gt;m_lblk, split_flag1, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\text4_ext_show_leaf(inode, path);\nout:\n\treturn err ? err : map-&gt;m_len;\n}',
 'int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) &amp; RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) &amp; RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    FD_t firstlinkfile = NULL;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&amp;tid, ";%08x", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc &amp;&amp; (fx = rpmfiNext(fi)) &gt;= 0) {\n\tstruct filedata_s *fp = &amp;fdata[fx];\n\tif (rpmfiFFlags(fi) &amp; RPMFILE_GHOST)\n            fp-&gt;action = FA_SKIP;\n\telse\n\t    fp-&gt;action = rpmfsGetAction(fs, fx);\n\tfp-&gt;skip = XFA_SKIPPING(fp-&gt;action);\n\tfp-&gt;setmeta = 1;\n\tif (XFA_CREATING(fp-&gt;action) &amp;&amp; !S_ISDIR(rpmfiFMode(fi)))\n\t    fp-&gt;suffix = tid;\n\tfp-&gt;fpath = fsmFsPath(fi, fp-&gt;suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &amp;fp-&gt;sb);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp-&gt;fpath, fp-&gt;action, &amp;fp-&gt;sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp-&gt;fpath,\n\t\t\t\t      fp-&gt;sb.st_mode, fp-&gt;action);\n\tfp-&gt;stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    if (rpmteType(te) == TR_ADDED)\n\tfi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    else\n\tfi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Detect and create directories not explicitly in package. */\n    if (!rc)\n\trc = fsmMkdirs(files, fs, plugins);\n\n    /* Process the payload */\n    while (!rc &amp;&amp; (fx = rpmfiNext(fi)) &gt;= 0) {\n\tstruct filedata_s *fp = &amp;fdata[fx];\n\n        if (!fp-&gt;skip) {\n\t    /* Directories replacing something need early backup */\n\t    if (!fp-&gt;suffix) {\n\t\trc = fsmBackup(fi, fp-&gt;action);\n\t    }\n\t    /* Assume file does\'t exist when tmp suffix is in use */\n\t    if (!fp-&gt;suffix) {\n\t\tif (fp-&gt;action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(fp-&gt;fpath, 1, &amp;sb);\n\t\t} else {\n\t\t    rc = fsmVerify(fp-&gt;fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT &amp;&amp; fp-&gt;action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, "file %s vanished unexpectedly\\n",\n\t\t\tfp-&gt;fpath);\n\t\tfp-&gt;action = FA_CREATE;\n\t\tfsmDebug(fp-&gt;fpath, fp-&gt;action, &amp;fp-&gt;sb);\n\t    }\n\n\t    /* When touching we don\'t need any of this... */\n\t    if (fp-&gt;action == FA_TOUCH)\n\t\tcontinue;\n\n            if (S_ISREG(fp-&gt;sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fp, files, psm, nodigest,\n\t\t\t\t   &amp;firstlink, &amp;firstlinkfile);\n\t\t}\n            } else if (S_ISDIR(fp-&gt;sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp-&gt;sb.st_mode;\n                    mode &amp;= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fp-&gt;fpath, mode);\n                }\n            } else if (S_ISLNK(fp-&gt;sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fp-&gt;fpath);\n\t\t}\n            } else if (S_ISFIFO(fp-&gt;sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn\'t right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fp-&gt;fpath, 0000);\n                }\n            } else if (S_ISCHR(fp-&gt;sb.st_mode) ||\n                       S_ISBLK(fp-&gt;sb.st_mode) ||\n                       S_ISSOCK(fp-&gt;sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fp-&gt;fpath, fp-&gt;sb.st_mode, fp-&gt;sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn\'t be packaged anyways */\n                if (!IS_DEV_LOG(fp-&gt;fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t} else if (firstlink &amp;&amp; rpmfiArchiveHasContent(fi)) {\n\t    /*\n\t     * Tricksy case: this file is a being skipped, but it\'s part of\n\t     * a hardlinked set and has the actual content linked with it.\n\t     * Write the content to the first non-skipped file of the set\n\t     * instead.\n\t     */\n\t    rc = fsmMkfile(fi, firstlink, files, psm, nodigest,\n\t\t\t   &amp;firstlink, &amp;firstlinkfile);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp-&gt;fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp-&gt;stage = FILE_UNPACK;\n    }\n    fi = rpmfiFree(fi);\n\n    if (!rc &amp;&amp; fx &lt; 0 &amp;&amp; fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* Set permissions, timestamps etc for non-hardlink entries */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc &amp;&amp; (fx = rpmfiNext(fi)) &gt;= 0) {\n\tstruct filedata_s *fp = &amp;fdata[fx];\n\tif (!fp-&gt;skip &amp;&amp; fp-&gt;setmeta) {\n\t    rc = fsmSetmeta(fp-&gt;fpath, fi, plugins, fp-&gt;action,\n\t\t\t    &amp;fp-&gt;sb, nofcaps);\n\t}\n\tif (rc)\n\t    *failedFile = xstrdup(fp-&gt;fpath);\n\tfp-&gt;stage = FILE_PREP;\n    }\n    fi = rpmfiFree(fi);\n\n    /* If all went well, commit files to final destination */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc &amp;&amp; (fx = rpmfiNext(fi)) &gt;= 0) {\n\tstruct filedata_s *fp = &amp;fdata[fx];\n\n\tif (!fp-&gt;skip) {\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc &amp;&amp; fp-&gt;suffix)\n\t\trc = fsmBackup(fi, fp-&gt;action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(&amp;fp-&gt;fpath, fi, fp-&gt;action, fp-&gt;suffix);\n\n\t    if (!rc)\n\t\tfp-&gt;stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp-&gt;fpath);\n\t}\n    }\n    fi = rpmfiFree(fi);\n\n    /* Walk backwards in case we need to erase */\n    fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    while ((fx = rpmfiNext(fi)) &gt;= 0) {\n\tstruct filedata_s *fp = &amp;fdata[fx];\n\t/* Run fsm file post hook for all plugins for all processed files */\n\tif (fp-&gt;stage) {\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp-&gt;fpath,\n\t\t\t\t      fp-&gt;sb.st_mode, fp-&gt;action, rc);\n\t}\n\n\t/* On failure, erase non-committed files */\n\tif (rc &amp;&amp; fp-&gt;stage &gt; FILE_NONE &amp;&amp; !fp-&gt;skip) {\n\t    (void) fsmRemove(fp-&gt;fpath, fp-&gt;sb.st_mode);\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i &lt; fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}',
 'static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field-&gt;report_count;\n\tunsigned offset = field-&gt;report_offset;\n\tunsigned size = field-&gt;report_size;\n\t__s32 min = field-&gt;logical_minimum;\n\t__s32 max = field-&gt;logical_maximum;\n\t__s32 *value;\n\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\n\tfor (n = 0; n &lt; count; n++) {\n\n\t\tvalue[n] = min &lt; 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\n\t\t/* Ignore report if ErrorRollOver */\n\t\tif (!(field-&gt;flags &amp; HID_MAIN_ITEM_VARIABLE) &amp;&amp;\n\t\t    value[n] &gt;= min &amp;&amp; value[n] &lt;= max &amp;&amp;\n\t\t    value[n] - min &lt; field-&gt;maxusage &amp;&amp;\n\t\t    field-&gt;usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n\t\t\tgoto exit;\n\t}\n\n\tfor (n = 0; n &lt; count; n++) {\n\n\t\tif (HID_MAIN_ITEM_VARIABLE &amp; field-&gt;flags) {\n\t\t\thid_process_event(hid, field, &amp;field-&gt;usage[n], value[n], interrupt);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (field-&gt;value[n] &gt;= min &amp;&amp; field-&gt;value[n] &lt;= max\n\t\t\t&amp;&amp; field-&gt;value[n] - min &lt; field-&gt;maxusage\n\t\t\t&amp;&amp; field-&gt;usage[field-&gt;value[n] - min].hid\n\t\t\t&amp;&amp; search(value, field-&gt;value[n], count))\n\t\t\t\thid_process_event(hid, field, &amp;field-&gt;usage[field-&gt;value[n] - min], 0, interrupt);\n\n\t\tif (value[n] &gt;= min &amp;&amp; value[n] &lt;= max\n\t\t\t&amp;&amp; value[n] - min &lt; field-&gt;maxusage\n\t\t\t&amp;&amp; field-&gt;usage[value[n] - min].hid\n\t\t\t&amp;&amp; search(field-&gt;value, value[n], count))\n\t\t\t\thid_process_event(hid, field, &amp;field-&gt;usage[value[n] - min], 1, interrupt);\n\t}\n\n\tmemcpy(field-&gt;value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}',
 'Unpickler_set_memo(UnpicklerObject *self, PyObject *obj)\n{\n    PyObject **new_memo;\n    size_t new_memo_size = 0;\n\n    if (obj == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        "attribute deletion is not supported");\n        return -1;\n    }\n\n    if (Py_TYPE(obj) == &amp;UnpicklerMemoProxyType) {\n        UnpicklerObject *unpickler =\n            ((UnpicklerMemoProxyObject *)obj)-&gt;unpickler;\n\n        new_memo_size = unpickler-&gt;memo_size;\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        for (size_t i = 0; i &lt; new_memo_size; i++) {\n            Py_XINCREF(unpickler-&gt;memo[i]);\n            new_memo[i] = unpickler-&gt;memo[i];\n        }\n    }\n    else if (PyDict_Check(obj)) {\n        Py_ssize_t i = 0;\n        PyObject *key, *value;\n\n        new_memo_size = PyDict_GET_SIZE(obj);\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        while (PyDict_Next(obj, &amp;i, &amp;key, &amp;value)) {\n            Py_ssize_t idx;\n            if (!PyLong_Check(key)) {\n                PyErr_SetString(PyExc_TypeError,\n                                "memo key must be integers");\n                goto error;\n            }\n            idx = PyLong_AsSsize_t(key);\n            if (idx == -1 &amp;&amp; PyErr_Occurred())\n                goto error;\n            if (idx &lt; 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                "memo key must be positive integers.");\n                goto error;\n            }\n            if (_Unpickler_MemoPut(self, idx, value) &lt; 0)\n                goto error;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     "\'memo\' attribute must be an UnpicklerMemoProxy object"\n                     "or dict, not %.200s", Py_TYPE(obj)-&gt;tp_name);\n        return -1;\n    }\n\n    _Unpickler_MemoCleanup(self);\n    self-&gt;memo_size = new_memo_size;\n    self-&gt;memo = new_memo;\n\n    return 0;\n\n  error:\n    if (new_memo_size) {\n        for (size_t i = new_memo_size - 1; i != SIZE_MAX; i--) {\n            Py_XDECREF(new_memo[i]);\n        }\n        PyMem_FREE(new_memo);\n    }\n    return -1;\n}',
 'void grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf-&gt;file &amp;&amp; gf-&gt;file-&gt;device)\n\t\t\tfree (gf-&gt;file-&gt;device-&gt;disk);\n\t\t//free (gf-&gt;file-&gt;device);\n\t\tfree (gf-&gt;file);\n\t\tfree (gf);\n\t}\n}',
 '      void Init(void)\n      {\n        for(int i = 0;i &lt; 15;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }',
 "B44Compressor::B44Compressor\n    (const Header &amp;hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    // TODO: Remove this when we can change the ABI\n    (void)_maxScanLineSize;\n    //\n    // Allocate buffers for compressed an uncompressed pixel data,\n    // allocate a set of ChannelData structs to help speed up the\n    // compress() and uncompress() functions, below, and determine\n    // if uncompressed pixel data should be in native or Xdr format.\n    //\n\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize / sizeof(unsigned short), numScanLines),\n                         sizeof (unsigned short))];\n\n    const ChannelList &amp;channels = header().channels();\n    int numHalfChans = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n\n    //\n    // Compressed data may be larger than the input data\n    //\n\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n\n    _channelData = new ChannelData[_numChans];\n\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n\n    const Box2i &amp;dataWindow = hdr.dataWindow();\n\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n\n    //\n    // We can support uncompressed data in the machine's native\n    // format only if all image channels are of type HALF.\n    //\n\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}",
 'static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, "%s", "ahash");\n\n\trhash.blocksize = alg-&gt;cra_blocksize;\n\trhash.digestsize = __crypto_hash_alg_common(alg)-&gt;digestsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &amp;rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}',
 'LogLuvSetupEncode(TIFF* tif)\n{\n\tstatic const char module[] = "LogLuvSetupEncode";\n\tLogLuvState* sp = EncoderState(tif);\n\tTIFFDirectory* td = &amp;tif-&gt;tif_dir;\n\n\tswitch (td-&gt;td_photometric) {\n\tcase PHOTOMETRIC_LOGLUV:\n\t\tif (!LogLuvInitState(tif))\n\t\t\tbreak;\n\t\tif (td-&gt;td_compression == COMPRESSION_SGILOG24) {\n\t\t\ttif-&gt;tif_encoderow = LogLuvEncode24;\n\t\t\tswitch (sp-&gt;user_datafmt) {\n\t\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\t\tsp-&gt;tfunc = Luv24fromXYZ;\n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\t\tsp-&gt;tfunc = Luv24fromLuv48;  \n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_RAW:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto notsupported;\n\t\t\t}\n\t\t} else {\n\t\t\ttif-&gt;tif_encoderow = LogLuvEncode32;  \n\t\t\tswitch (sp-&gt;user_datafmt) {\n\t\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\t\tsp-&gt;tfunc = Luv32fromXYZ;  \n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\t\tsp-&gt;tfunc = Luv32fromLuv48;  \n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_RAW:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto notsupported;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_LOGL:\n\t\tif (!LogL16InitState(tif))\n\t\t\tbreak;\n\t\ttif-&gt;tif_encoderow = LogL16Encode;  \n\t\tswitch (sp-&gt;user_datafmt) {\n\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\tsp-&gt;tfunc = L16fromY;\n\t\t\tbreak;\n\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto notsupported;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(tif-&gt;tif_clientdata, module,\n\t\t    "Inappropriate photometric interpretation %d for SGILog compression; %s",\n\t\t    td-&gt;td_photometric, "must be either LogLUV or LogL");\n\t\tbreak;\n\t}\n\tsp-&gt;encoder_state = 1;\n\treturn (1);\nnotsupported:\n\tTIFFErrorExt(tif-&gt;tif_clientdata, module,\n\t    "SGILog compression supported only for %s, or raw data",\n\t    td-&gt;td_photometric == PHOTOMETRIC_LOGL ? "Y, L" : "XYZ, Luv");\n\treturn (0);\n}',
 '  void onComplete(const Status&amp; status, ContextImpl&amp; context) const override {\n    auto&amp; completion_state = context.getCompletionState(this);\n    if (completion_state.is_completed_) {\n      return;\n    }\n\n    // If any of children is OK, return OK\n    if (Status::Ok == status) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n      return;\n    }\n\n    // Then wait for all children to be done.\n    if (++completion_state.number_completed_children_ == verifiers_.size()) {\n      // Aggregate all children status into a final status.\n      // JwtMissing should be treated differently than other failure status\n      // since it simply means there is not Jwt token for the required provider.\n      // If there is a failure status other than JwtMissing in the children,\n      // it should be used as the final status.\n      Status final_status = Status::JwtMissed;\n      for (const auto&amp; it : verifiers_) {\n        // If a Jwt is extracted from a location not specified by the required provider,\n        // the authenticator returns JwtUnknownIssuer. It should be treated the same as\n        // JwtMissed.\n        Status child_status = context.getCompletionState(it.get()).status_;\n        if (child_status != Status::JwtMissed &amp;&amp; child_status != Status::JwtUnknownIssuer) {\n          final_status = child_status;\n        }\n      }\n\n      if (is_allow_missing_or_failed_) {\n        final_status = Status::Ok;\n      } else if (is_allow_missing_ &amp;&amp; final_status == Status::JwtMissed) {\n        final_status = Status::Ok;\n      }\n      completion_state.is_completed_ = true;\n      completeWithStatus(final_status, context);\n    }\n  }',
 'static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&amp;init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt-&gt;mnt_ns = new_ns;\n\t\tnew_ns-&gt;root = mnt;\n\t\tnew_ns-&gt;mounts++;\n\t\tlist_add(&amp;mnt-&gt;mnt_list, &amp;new_ns-&gt;list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}',
 "choose_filters(struct archive_read *a)\n{\n\tint number_bidders, i, bid, best_bid;\n\tstruct archive_read_filter_bidder *bidder, *best_bidder;\n\tstruct archive_read_filter *filter;\n\tssize_t avail;\n\tint r;\n\n\tfor (;;) {\n\t\tnumber_bidders = sizeof(a-&gt;bidders) / sizeof(a-&gt;bidders[0]);\n\n\t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\n\t\tbidder = a-&gt;bidders;\n\t\tfor (i = 0; i &lt; number_bidders; i++, bidder++) {\n\t\t\tif (bidder-&gt;bid != NULL) {\n\t\t\t\tbid = (bidder-&gt;bid)(bidder, a-&gt;filter);\n\t\t\t\tif (bid &gt; best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If no bidder, we're done. */\n\t\tif (best_bidder == NULL) {\n\t\t\t/* Verify the filter by asking it for some data. */\n\t\t\t__archive_read_filter_ahead(a-&gt;filter, 1, &amp;avail);\n\t\t\tif (avail &lt; 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta-&gt;archive.compression_name = a-&gt;filter-&gt;name;\n\t\t\ta-&gt;archive.compression_code = a-&gt;filter-&gt;code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter-&gt;bidder = best_bidder;\n\t\tfilter-&gt;archive = a;\n\t\tfilter-&gt;upstream = a-&gt;filter;\n\t\ta-&gt;filter = filter;\n\t\tr = (best_bidder-&gt;init)(a-&gt;filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n}",
 'xfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp-&gt;b_addr;\n\tASSERT(mapindex &gt;= 0 &amp;&amp; mapindex &lt; XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args-&gt;index &gt;= 0 &amp;&amp; args-&gt;index &lt;= ichdr-&gt;count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &amp;xfs_attr3_leaf_entryp(leaf)[args-&gt;index];\n\tif (args-&gt;index &lt; ichdr-&gt;count) {\n\t\ttmp  = ichdr-&gt;count - args-&gt;index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args-&gt;trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr-&gt;count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args-&gt;trans-&gt;t_mountp;\n\tASSERT(ichdr-&gt;freemap[mapindex].base &lt; XFS_LBSIZE(mp));\n\tASSERT((ichdr-&gt;freemap[mapindex].base &amp; 0x3) == 0);\n\tASSERT(ichdr-&gt;freemap[mapindex].size &gt;=\n\t\txfs_attr_leaf_newentsize(args-&gt;namelen, args-&gt;valuelen,\n\t\t\t\t\t mp-&gt;m_sb.sb_blocksize, NULL));\n\tASSERT(ichdr-&gt;freemap[mapindex].size &lt; XFS_LBSIZE(mp));\n\tASSERT((ichdr-&gt;freemap[mapindex].size &amp; 0x3) == 0);\n\n\tichdr-&gt;freemap[mapindex].size -=\n\t\t\txfs_attr_leaf_newentsize(args-&gt;namelen, args-&gt;valuelen,\n\t\t\t\t\t\t mp-&gt;m_sb.sb_blocksize, &amp;tmp);\n\n\tentry-&gt;nameidx = cpu_to_be16(ichdr-&gt;freemap[mapindex].base +\n\t\t\t\t     ichdr-&gt;freemap[mapindex].size);\n\tentry-&gt;hashval = cpu_to_be32(args-&gt;hashval);\n\tentry-&gt;flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry-&gt;flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args-&gt;flags);\n\tif (args-&gt;op_flags &amp; XFS_DA_OP_RENAME) {\n\t\tentry-&gt;flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args-&gt;blkno2 == args-&gt;blkno) &amp;&amp;\n\t\t    (args-&gt;index2 &lt;= args-&gt;index)) {\n\t\t\targs-&gt;index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args-&gt;trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args-&gt;index == 0) ||\n\t       (be32_to_cpu(entry-&gt;hashval) &gt;= be32_to_cpu((entry-1)-&gt;hashval)));\n\tASSERT((args-&gt;index == ichdr-&gt;count - 1) ||\n\t       (be32_to_cpu(entry-&gt;hashval) &lt;= be32_to_cpu((entry+1)-&gt;hashval)));\n\n\t/*\n\t * For "remote" attribute values, simply note that we need to\n\t * allocate space for the "remote" value.  We can\'t actually\n\t * allocate the extents in this transaction, and we can\'t decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry-&gt;flags &amp; XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args-&gt;index);\n\t\tname_loc-&gt;namelen = args-&gt;namelen;\n\t\tname_loc-&gt;valuelen = cpu_to_be16(args-&gt;valuelen);\n\t\tmemcpy((char *)name_loc-&gt;nameval, args-&gt;name, args-&gt;namelen);\n\t\tmemcpy((char *)&amp;name_loc-&gt;nameval[args-&gt;namelen], args-&gt;value,\n\t\t\t\t   be16_to_cpu(name_loc-&gt;valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args-&gt;index);\n\t\tname_rmt-&gt;namelen = args-&gt;namelen;\n\t\tmemcpy((char *)name_rmt-&gt;name, args-&gt;name, args-&gt;namelen);\n\t\tentry-&gt;flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt-&gt;valuelen = 0;\n\t\tname_rmt-&gt;valueblk = 0;\n\t\targs-&gt;rmtblkno = 1;\n\t\targs-&gt;rmtblkcnt = xfs_attr3_rmt_blocks(mp, args-&gt;valuelen);\n\t\targs-&gt;rmtvaluelen = args-&gt;valuelen;\n\t}\n\txfs_trans_log_buf(args-&gt;trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args-&gt;index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args-&gt;index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry-&gt;nameidx) &lt; ichdr-&gt;firstused)\n\t\tichdr-&gt;firstused = be16_to_cpu(entry-&gt;nameidx);\n\n\tASSERT(ichdr-&gt;firstused &gt;= ichdr-&gt;count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr-&gt;count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i &lt; XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr-&gt;freemap[i].base == tmp) {\n\t\t\tichdr-&gt;freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr-&gt;freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr-&gt;usedbytes += xfs_attr_leaf_entsize(leaf, args-&gt;index);\n\treturn 0;\n}',
 'AP4_AvccAtom::InspectFields(AP4_AtomInspector&amp; inspector)\n{\n    inspector.AddField("Configuration Version", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField("Profile", profile_name);\n    } else {\n        inspector.AddField("Profile", m_Profile);\n    }\n    inspector.AddField("Profile Compatibility", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField("Level", m_Level);\n    inspector.AddField("NALU Length Size", m_NaluLengthSize);\n    for (unsigned int i=0; i&lt;m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField("Sequence Parameter", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i&lt;m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField("Picture Parameter", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}',
 "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n\n    assert(seq-&gt;n_fields &gt; 0);\n    for (i = 0; i &lt; seq-&gt;n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &amp;t, &amp;contents, &amp;clen, &amp;asn1, &amp;len);\n        if (ret)\n            goto error;\n        /*\n         * Find the applicable sequence field.  This logic is a little\n         * oversimplified; we could match an element to an optional extensible\n         * choice or optional stored-DER type when we ought to match a\n         * subsequent non-optional field.  But it's unwise and (hopefully) very\n         * rare for ASN.1 modules to require such precision.\n         */\n        for (; i &lt; seq-&gt;n_fields; i++) {\n            if (check_atype_tag(seq-&gt;fields[i], &amp;t))\n                break;\n            ret = omit_atype(seq-&gt;fields[i], val);\n            if (ret)\n                goto error;\n        }\n        /* We currently model all sequences as extensible.  We should consider\n         * changing this before making the encoder visible to plugins. */\n        if (i == seq-&gt;n_fields)\n            break;\n        ret = decode_atype(&amp;t, contents, clen, seq-&gt;fields[i], val);\n        if (ret)\n            goto error;\n    }\n    /* Initialize any fields in the C object which were not accounted for in\n     * the sequence.  Error out if any of them aren't optional. */\n    for (; i &lt; seq-&gt;n_fields; i++) {\n        ret = omit_atype(seq-&gt;fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\n\nerror:\n    /* Free what we've decoded so far.  Free pointers in a second pass in\n     * case multiple fields refer to the same pointer. */\n    for (j = 0; j &lt; i; j++)\n        free_atype(seq-&gt;fields[j], val);\n    for (j = 0; j &lt; i; j++)\n        free_atype_ptr(seq-&gt;fields[j], val);\n    return ret;\n}",
 'unsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (tgt_clobbers &amp; ~site_clobbers)\n\t\treturn len;\t/* target would clobber too much for this site */\n\tif (len &lt; 5)\n\t\treturn len;\t/* call too long for patch site */\n\n\tb-&gt;opcode = 0xe8; /* call */\n\tb-&gt;delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\n\treturn 5;\n}',
 'size_t TLSInStream::readTLS(U8* buf, size_t len, bool wait)\n{\n  int n;\n\n  n = in-&gt;check(1, 1, wait);\n  if (n == 0)\n    return 0;\n\n  n = gnutls_record_recv(session, (void *) buf, len);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n &lt; 0) throw TLSException("readTLS", n);\n\n  return n;\n}',
 'char *FLTGetIsLikeComparisonCommonExpression(FilterEncodingNode *psFilterNode)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char szTmp[256];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  int  bCaseInsensitive = 0;\n  FEPropertyIsLike* propIsLike;\n\n  int nLength=0, i=0, iTmp=0;\n\n  if (!psFilterNode || !psFilterNode-&gt;pOther || !psFilterNode-&gt;psLeftNode || !psFilterNode-&gt;psRightNode || !psFilterNode-&gt;psRightNode-&gt;pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode-&gt;pOther;\n  pszWild = propIsLike-&gt;pszWildCard;\n  pszSingle = propIsLike-&gt;pszSingleChar;\n  pszEscape = propIsLike-&gt;pszEscapeChar;\n  bCaseInsensitive = propIsLike-&gt;bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 || !pszSingle || strlen(pszSingle) == 0 || !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Use operand with regular expressions.                           */\n  /* -------------------------------------------------------------------- */\n  szBuffer[0] = \'\\0\';\n  sprintf(szTmp, "%s", "(\\"[");\n  szTmp[4] = \'\\0\';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode-&gt;psLeftNode-&gt;pszValue, bufferSize);\n  szBuffer[strlen(szBuffer)] = \'\\0\';\n\n  /* #3521 */\n  if (bCaseInsensitive == 1)\n    sprintf(szTmp, "%s", "]\\" ~* \\"");\n  else\n    sprintf(szTmp, "%s", "]\\" ~ \\"");\n  szTmp[7] = \'\\0\';\n  strlcat(szBuffer, szTmp, bufferSize);\n  szBuffer[strlen(szBuffer)] = \'\\0\';\n\n  pszValue = psFilterNode-&gt;psRightNode-&gt;pszValue;\n  nLength = strlen(pszValue);\n  if( 1 + 2 * nLength + 1 + 1 &gt;= sizeof(szTmp) )\n      return NULL;\n\n  iTmp =0;\n  if (nLength &gt; 0 &amp;&amp; pszValue[0] != pszWild[0] &amp;&amp; pszValue[0] != pszSingle[0] &amp;&amp; pszValue[0] != pszEscape[0]) {\n    szTmp[iTmp]= \'^\';\n    iTmp++;\n  }\n  for (i=0; i&lt;nLength; i++) {\n    if (pszValue[i] != pszWild[0] &amp;&amp; pszValue[i] != pszSingle[0] &amp;&amp; pszValue[i] != pszEscape[0]) {\n      szTmp[iTmp] = pszValue[i];\n      iTmp++;\n      szTmp[iTmp] = \'\\0\';\n    } else if (pszValue[i] == pszSingle[0]) {\n      szTmp[iTmp] = \'.\';\n      iTmp++;\n      szTmp[iTmp] = \'\\0\';\n    } else if (pszValue[i] == pszEscape[0]) {\n      szTmp[iTmp] = \'\\\\\';\n      iTmp++;\n      szTmp[iTmp] = \'\\0\';\n    } else if (pszValue[i] == pszWild[0]) {\n      szTmp[iTmp++] = \'.\';\n      szTmp[iTmp++] = \'*\';\n      szTmp[iTmp] = \'\\0\';\n    }\n  }\n  szTmp[iTmp] = \'"\';\n  szTmp[++iTmp] = \'\\0\';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n  strlcat(szBuffer, ")", bufferSize);\n  return msStrdup(szBuffer);\n}',
 'get_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source-&gt;rescale;\n  JDIMENSION col;\n  unsigned int maxval = source-&gt;maxval;\n\n  if (!ReadOK(source-&gt;pub.input_file, source-&gt;iobuffer, source-&gt;buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source-&gt;pub.buffer[0];\n  bufferptr = source-&gt;iobuffer;\n  for (col = cinfo-&gt;image_width; col &gt; 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) &lt;&lt; 8;\n    temp |= UCH(*bufferptr++);\n    if (temp &gt; maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}',
 '  void Compute(OpKernelContext* context) override {\n    const Tensor&amp; prefix = context-&gt;input(0);\n    const Tensor&amp; tensor_names = context-&gt;input(1);\n    const Tensor&amp; shape_and_slices = context-&gt;input(2);\n    ValidateInputs(true /* is save op */, context, prefix, tensor_names,\n                   shape_and_slices);\n    if (!context-&gt;status().ok()) return;\n\n    const int kFixedInputs = 3;  // Prefix, tensor names, shape_and_slices.\n    const int num_tensors = static_cast&lt;int&gt;(tensor_names.NumElements());\n    const string&amp; prefix_string = prefix.scalar&lt;tstring&gt;()();\n    const auto&amp; tensor_names_flat = tensor_names.flat&lt;tstring&gt;();\n    const auto&amp; shape_and_slices_flat = shape_and_slices.flat&lt;tstring&gt;();\n\n    BundleWriter writer(Env::Default(), prefix_string);\n    OP_REQUIRES_OK(context, writer.status());\n    VLOG(1) &lt;&lt; "BundleWriter, prefix_string: " &lt;&lt; prefix_string;\n\n    for (int i = 0; i &lt; num_tensors; ++i) {\n      const string&amp; tensor_name = tensor_names_flat(i);\n      const Tensor&amp; tensor = context-&gt;input(i + kFixedInputs);\n      VLOG(2) &lt;&lt; "Starting save of " &lt;&lt; tensor_name;\n\n      if (!shape_and_slices_flat(i).empty()) {\n        const string&amp; shape_spec = shape_and_slices_flat(i);\n        TensorShape shape;\n        TensorSlice slice(tensor.dims());\n        TensorShape slice_shape;\n\n        OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                    shape_spec, &amp;shape, &amp;slice, &amp;slice_shape));\n        OP_REQUIRES(context, slice_shape.IsSameSize(tensor.shape()),\n                    errors::InvalidArgument("Slice in shape_and_slice "\n                                            "specification does not match the "\n                                            "shape of the tensor to  save: ",\n                                            shape_spec, ", tensor: ",\n                                            tensor.shape().DebugString()));\n\n        OP_REQUIRES_OK(context,\n                       writer.AddSlice(tensor_name, shape, slice, tensor));\n      } else {\n        OP_REQUIRES_OK(context, writer.Add(tensor_name, tensor));\n      }\n\n      if (VLOG_IS_ON(5)) {\n        if (tensor.dtype() == DT_FLOAT) {\n          const float* t_data = tensor.flat&lt;float&gt;().data();\n          float min = std::numeric_limits&lt;float&gt;::infinity();\n          float max = -std::numeric_limits&lt;float&gt;::infinity();\n          double avg = 0.0;\n          for (int i = 0; i &lt; tensor.NumElements(); ++i) {\n            if (t_data[i] &lt; min) min = t_data[i];\n            if (t_data[i] &gt; max) max = t_data[i];\n            avg += t_data[i];\n          }\n          VLOG(5) &lt;&lt; " min " &lt;&lt; min &lt;&lt; " max " &lt;&lt; max &lt;&lt; " avg "\n                  &lt;&lt; avg / tensor.NumElements() &lt;&lt; " total elts "\n                  &lt;&lt; tensor.NumElements();\n        }\n      }\n\n      VLOG(2) &lt;&lt; "Done save of " &lt;&lt; tensor_name;\n    }\n    OP_REQUIRES_OK(context, writer.Finish());\n    VLOG(1) &lt;&lt; "Done BundleWriter, prefix_string: " &lt;&lt; prefix_string;\n  }',
 'static void tokenadd(struct jv_parser* p, char c) {\n  assert(p-&gt;tokenpos &lt;= p-&gt;tokenlen);\n  if (p-&gt;tokenpos == p-&gt;tokenlen) {\n    p-&gt;tokenlen = p-&gt;tokenlen*2 + 256;\n    p-&gt;tokenbuf = jv_mem_realloc(p-&gt;tokenbuf, p-&gt;tokenlen);\n  }\n  assert(p-&gt;tokenpos &lt; p-&gt;tokenlen);\n  p-&gt;tokenbuf[p-&gt;tokenpos++] = c;\n}',
 'static bool checkCurl() {\n\tconst char nul[] = R_SYS_DEVNULL;\n\tif (r_sys_cmdf ("curl --version &gt; %s", nul) != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}',
 'get_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin-&gt;w_cursor;\n    curwin-&gt;w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, \'(\')) == NULL)\n\tpos = findmatch(NULL, \'[\');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, \'[\');\n\tif (pos == NULL || LT_POSP(pos, &amp;paren))\n\t    pos = &amp;paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin-&gt;w_cursor.lnum &gt;= pos-&gt;lnum)\n\t{\n\t    if (linewhite(curwin-&gt;w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == \';\')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == \'\\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == \'"\' &amp;&amp; *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that &amp;&amp; *that != \'"\')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == \'\\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (*that == NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (*that == \'(\' || *that == \'[\')\n\t\t    ++parencount;\n\t\telse if (*that == \')\' || *that == \']\')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin-&gt;w_cursor.lnum = pos-&gt;lnum;\n\t    curwin-&gt;w_cursor.col = pos-&gt;col;\n\t    col = pos-&gt;col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp &amp;&amp; get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that &amp;&amp; col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &amp;that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require "body" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp &amp;&amp; (*that == \'(\' || *that == \'[\')\n\t\t\t\t\t\t      &amp;&amp; lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    if (*that != NUL)\n\t\t    {\n\t\t\tthat++;\n\t\t\tamount++;\n\t\t    }\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that &amp;&amp; *that != \';\') // not a comment line\n\t\t    {\n\t\t\t// test *that != \'(\' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp &amp;&amp; *that != \'(\' &amp;&amp; *that != \'[\')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != \'"\'\n\t\t\t\t    &amp;&amp; *that != \'\\\'\'\n\t\t\t\t    &amp;&amp; *that != \'#\'\n\t\t\t\t    &amp;&amp; (*that &lt; \'0\' || *that &gt; \'9\')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    &amp;&amp; (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    &amp;&amp; (!((*that == \'(\' || *that == \'[\')\n\t\t\t\t\t    &amp;&amp; !quotecount\n\t\t\t\t\t    &amp;&amp; !parencount\n\t\t\t\t\t    &amp;&amp; vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == \'"\')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == \'(\' || *that == \'[\')\n\t\t\t\t\t\t\t       &amp;&amp; !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == \')\' || *that == \']\')\n\t\t\t\t\t\t\t       &amp;&amp; !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == \'\\\\\' &amp;&amp; *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &amp;that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &amp;that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == \';\')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching \'(\' or \'[\' found, use zero indent\n\n    curwin-&gt;w_cursor = realpos;\n\n    return amount;\n}',
 'videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma-&gt;vm_private_data;\n\tstruct videobuf_queue *q = map-&gt;q;\n\tint i;\n\n\tdprintk(2,"vm_close %p [count=%d,vma=%08lx-%08lx]\\n",map,\n\t\tmap-&gt;count,vma-&gt;vm_start,vma-&gt;vm_end);\n\n\tmap-&gt;count--;\n\tif (0 == map-&gt;count) {\n\t\tdprintk(1,"munmap %p q=%p\\n",map,q);\n\t\tmutex_lock(&amp;q-&gt;lock);\n\t\tfor (i = 0; i &lt; VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q-&gt;bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q-&gt;bufs[i]-&gt;map != map)\n\t\t\t\tcontinue;\n\n\t\t\tq-&gt;ops-&gt;buf_release(q,q-&gt;bufs[i]);\n\n\t\t\tq-&gt;bufs[i]-&gt;map   = NULL;\n\t\t\tq-&gt;bufs[i]-&gt;baddr = 0;\n\t\t}\n\t\tmutex_unlock(&amp;q-&gt;lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}',
 '  void Compute(OpKernelContext* ctx) override {\n    const Tensor&amp; values_tensor = ctx-&gt;input(0);\n    const Tensor&amp; value_range_tensor = ctx-&gt;input(1);\n    const Tensor&amp; nbins_tensor = ctx-&gt;input(2);\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(value_range_tensor.shape()),\n                errors::InvalidArgument("value_range should be a vector."));\n    OP_REQUIRES(ctx, (value_range_tensor.shape().num_elements() == 2),\n                errors::InvalidArgument(\n                    "value_range should be a vector of 2 elements."));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(nbins_tensor.shape()),\n                errors::InvalidArgument("nbins should be a scalar."));\n\n    const auto values = values_tensor.flat&lt;T&gt;();\n    const auto value_range = value_range_tensor.flat&lt;T&gt;();\n    const auto nbins = nbins_tensor.scalar&lt;int32&gt;()();\n\n    OP_REQUIRES(\n        ctx, value_range(0) &lt; value_range(1),\n        errors::InvalidArgument("value_range should satisfy value_range[0] &lt; "\n                                "value_range[1], but got \'[",\n                                value_range(0), ", ", value_range(1), "]\'"));\n    OP_REQUIRES(\n        ctx, nbins &gt; 0,\n        errors::InvalidArgument("nbins should be a positive number, but got \'",\n                                nbins, "\'"));\n\n    Tensor* out_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx-&gt;allocate_output(0, TensorShape({nbins}), &amp;out_tensor));\n    auto out = out_tensor-&gt;flat&lt;Tout&gt;();\n\n    OP_REQUIRES_OK(\n        ctx, functor::HistogramFixedWidthFunctor&lt;Device, T, Tout&gt;::Compute(\n                 ctx, values, value_range, nbins, out));\n  }',
 'TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* dims;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kDimsTensor, &amp;dims));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kValueTensor, &amp;value));\n\n  // Make sure the 1st input tensor is 1-D.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(dims), 1);\n\n  // Make sure the 1st input tensor is int32 or int64.\n  const auto dtype = dims-&gt;type;\n  TF_LITE_ENSURE(context, dtype == kTfLiteInt32 || dtype == kTfLiteInt64);\n\n  // Make sure the 2nd input tensor is a scalar.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(value), 0);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &amp;output));\n  output-&gt;type = value-&gt;type;\n\n  if (IsConstantTensor(dims)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, dims, output));\n  } else {\n    SetTensorToDynamic(output);\n  }\n  return kTfLiteOk;\n}',
 'iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,\n                                  const gss_buffer_t value)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (ctx == NULL || ctx-&gt;gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_UNAVAILABLE;\n\n    return krb5_gss_set_sec_context_option(minor_status, &amp;ctx-&gt;gssc,\n                                           desired_object, value);\n}',
 'static void handle_doaction(HttpRequest req, HttpResponse res) {\n        Service_T s;\n        Action_Type doaction = Action_Ignored;\n        const char *action = get_parameter(req, "action");\n        const char *token = get_parameter(req, "token");\n        if (action) {\n                if (is_readonly(req)) {\n                        send_error(req, res, SC_FORBIDDEN, "You do not have sufficient privileges to access this page");\n                        return;\n                }\n                if ((doaction = Util_getAction(action)) == Action_Ignored) {\n                        send_error(req, res, SC_BAD_REQUEST, "Invalid action \\"%s\\"", action);\n                        return;\n                }\n                for (HttpParameter p = req-&gt;params; p; p = p-&gt;next) {\n                        if (IS(p-&gt;name, "service")) {\n                                s  = Util_getService(p-&gt;value);\n                                if (! s) {\n                                        send_error(req, res, SC_BAD_REQUEST, "There is no service named \\"%s\\"", p-&gt;value ? p-&gt;value : "");\n                                        return;\n                                }\n                                s-&gt;doaction = doaction;\n                                LogInfo("\'%s\' %s on user request\\n", s-&gt;name, action);\n                        }\n                }\n                /* Set token for last service only so we\'ll get it back after all services were handled */\n                if (token) {\n                        Service_T q = NULL;\n                        for (s = servicelist; s; s = s-&gt;next)\n                                if (s-&gt;doaction == doaction)\n                                        q = s;\n                        if (q) {\n                                FREE(q-&gt;token);\n                                q-&gt;token = Str_dup(token);\n                        }\n                }\n                Run.flags |= Run_ActionPending;\n                do_wakeupcall();\n        }\n}',
 'static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tunsigned long sp, next_sp;\n\tunsigned long next_ip;\n\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs-&gt;link;\n\tsp = regs-&gt;gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\n\twhile (entry-&gt;nr &lt; PERF_MAX_STACK_DEPTH) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &amp;next_sp))\n\t\t\treturn;\n\t\tif (level &gt; 0 &amp;&amp; read_user_stack_64(&amp;fp[2], &amp;next_ip))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Note: the next_sp - sp &gt;= signal frame size check\n\t\t * is true when next_sp &lt; sp, which can happen when\n\t\t * transitioning from an alternate signal stack to the\n\t\t * normal stack.\n\t\t */\n\t\tif (next_sp - sp &gt;= sizeof(struct signal_frame_64) &amp;&amp;\n\t\t    (is_sigreturn_64_address(next_ip, sp) ||\n\t\t     (level &lt;= 1 &amp;&amp; is_sigreturn_64_address(lr, sp))) &amp;&amp;\n\t\t    sane_signal_64_frame(sp)) {\n\t\t\t/*\n\t\t\t * This looks like an signal frame\n\t\t\t */\n\t\t\tsigframe = (struct signal_frame_64 __user *) sp;\n\t\t\turegs = sigframe-&gt;uc.uc_mcontext.gp_regs;\n\t\t\tif (read_user_stack_64(&amp;uregs[PT_NIP], &amp;next_ip) ||\n\t\t\t    read_user_stack_64(&amp;uregs[PT_LNK], &amp;lr) ||\n\t\t\t    read_user_stack_64(&amp;uregs[PT_R1], &amp;sp))\n\t\t\t\treturn;\n\t\t\tlevel = 0;\n\t\t\tperf_callchain_store(entry, PERF_CONTEXT_USER);\n\t\t\tperf_callchain_store(entry, next_ip);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tnext_ip = lr;\n\t\tperf_callchain_store(entry, next_ip);\n\t\t++level;\n\t\tsp = next_sp;\n\t}\n}',
 'static void Process_ipfix_template_add(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\ninput_translation_t *translation_table;\nipfix_template_record_t *ipfix_template_record;\nipfix_template_elements_std_t *NextElement;\nint i;\n\n\t// a template flowset can contain multiple records ( templates )\n\twhile ( size_left ) {\n\t\tuint32_t table_id, count, size_required;\n\t\tuint32_t num_extensions = 0;\n\n\t\tif ( size_left &amp;&amp; size_left &lt; 4 ) {\n\t\t\tLogError("Process_ipfix [%u] Template size error at %s line %u" , \n\t\t\t\texporter-&gt;info.id, __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// map next record.\n\t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n\t\tsize_left \t\t-= 4;\n\n\t\ttable_id = ntohs(ipfix_template_record-&gt;TemplateID);\n\t\tcount\t = ntohs(ipfix_template_record-&gt;FieldCount);\n\n\t\tdbg_printf("\\n[%u] Template ID: %u\\n", exporter-&gt;info.id, table_id);\n\t\tdbg_printf("FieldCount: %u buffersize: %u\\n", count, size_left);\n\n\t\t// prepare\n\t\t// clear helper tables\n\t\tmemset((void *)cache.common_extensions, 0,  (Max_num_extensions+1)*sizeof(uint32_t));\n\t\tmemset((void *)cache.lookup_info, 0, 65536 * sizeof(struct element_param_s));\n\t\tfor (i=1; ipfix_element_map[i].id != 0; i++ ) {\n\t\t\tuint32_t Type = ipfix_element_map[i].id;\n\t\t\tif ( ipfix_element_map[i].id == ipfix_element_map[i-1].id )\n\t\t\t\tcontinue;\n\t\t\tcache.lookup_info[Type].index   = i;\n\t\t\t// other elements cleard be memset\n\t\t}\n\t\tcache.input_order = calloc(count, sizeof(struct order_s));\n\t\tif ( !cache.input_order ) {\n\t\t\tLogError("Process_ipfix: Panic! malloc(): %s line %d: %s", __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcache.input_count = count;\n\n\t\t// assume all elements in template are std elements. correct this value, if we find an enterprise element\n\t\tsize_required   = 4*count;\n\t\tif ( size_left &lt; size_required ) {\n\t\t\t// if we fail this check, this flowset must be skipped.\n\t\t\tLogError("Process_ipfix: [%u] Not enough data for template elements! required: %i, left: %u", \n\t\t\t\t\texporter-&gt;info.id, size_required, size_left);\n\t\t\tdbg_printf("ERROR: Not enough data for template elements! required: %i, left: %u", size_required, size_left);\n\t\t\treturn;\n\t\t}\n\n\t\t// process all elements in this record\n\t\tNextElement \t = (ipfix_template_elements_std_t *)ipfix_template_record-&gt;elements;\n\t\tfor ( i=0; i&lt;count; i++ ) {\n\t\t\tuint16_t Type, Length;\n\t\t\tuint32_t ext_id;\n\t\t\tint Enterprise;\n\t\n\t\t\tType   = ntohs(NextElement-&gt;Type);\n\t\t\tLength = ntohs(NextElement-&gt;Length);\n\t\t\tEnterprise = Type &amp; 0x8000 ? 1 : 0;\n\t\t\tType = Type &amp; 0x7FFF;\n\n\t\t\text_id = MapElement(Type, Length, i);\n\n\t\t\t// do we store this extension? enabled != 0\n\t\t\t// more than 1 v9 tag may map to an extension - so count this extension once only\n\t\t\tif ( ext_id &amp;&amp; extension_descriptor[ext_id].enabled ) {\n\t\t\t\tif ( cache.common_extensions[ext_id] == 0 ) {\n\t\t\t\t\tcache.common_extensions[ext_id] = 1;\n\t\t\t\t\tnum_extensions++;\n\t\t\t\t}\n\t\t\t} \n\t\n\t\t\tif ( Enterprise ) {\n\t\t\t\tipfix_template_elements_e_t *e = (ipfix_template_elements_e_t *)NextElement;\n\t\t\t\tsize_required += 4;\t// ad 4 for enterprise value\n\t\t\t\tif ( size_left &lt; size_required ) {\n\t\t\t\t\tLogError("Process_ipfix: [%u] Not enough data for template elements! required: %i, left: %u", \n\t\t\t\t\t\t\texporter-&gt;info.id, size_required, size_left);\n\t\t\t\t\tdbg_printf("ERROR: Not enough data for template elements! required: %i, left: %u", size_required, size_left);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( ntohl(e-&gt;EnterpriseNumber) == IPFIX_ReverseInformationElement ) {\n\t\t\t\t\tdbg_printf(" [%i] Enterprise: 1, Type: %u, Length %u Reverse Information Element: %u\\n", i, Type, Length, ntohl(e-&gt;EnterpriseNumber));\n\t\t\t\t} else {\n\t\t\t\t\tdbg_printf(" [%i] Enterprise: 1, Type: %u, Length %u EnterpriseNumber: %u\\n", i, Type, Length, ntohl(e-&gt;EnterpriseNumber));\n\t\t\t\t}\n\t\t\t\te++;\n\t\t\t\tNextElement = (ipfix_template_elements_std_t *)e;\n\t\t\t} else {\n\t\t\t\tdbg_printf(" [%i] Enterprise: 0, Type: %u, Length %u\\n", i, Type, Length);\n\t\t\t\tNextElement++;\n\t\t\t}\n\t\t}\n\n\t\tdbg_printf("Processed: %u\\n", size_required);\n\n\t\t// compact input order and reorder sequencer\n\t\tif ( compact_input_order() ) {\n\t\t\t// valid template with common inout fields\n\n\t\t\t// as the router IP address extension is not part announced in a template, we need to deal with it here\n\t\t\tif ( extension_descriptor[EX_ROUTER_IP_v4].enabled ) {\n\t\t\t\tif ( cache.common_extensions[EX_ROUTER_IP_v4] == 0 ) {\n\t\t\t\t\tcache.common_extensions[EX_ROUTER_IP_v4] = 1;\n\t\t\t\t\tnum_extensions++;\n\t\t\t\t}\n\t\t\t\tdbg_printf("Add sending router IP address (%s) =&gt; Extension: %u\\n", \n\t\t\t\t\tfs-&gt;sa_family == PF_INET6 ? "ipv6" : "ipv4", EX_ROUTER_IP_v4);\n\t\t\t}\n\t\n\t\t\t// XXX for now, we do not store router ID in IPFIX\n\t\t\textension_descriptor[EX_ROUTER_ID].enabled = 0;\n\n/*\t\n\t\t// as the router IP address extension is not part announced in a template, we need to deal with it here\n\t\tif ( extension_descriptor[EX_ROUTER_ID].enabled ) {\n\t\t\tif ( cache.common_extensions[EX_ROUTER_ID] == 0 ) {\n\t\t\t\tcache.common_extensions[EX_ROUTER_ID] = 1;\n\t\t\t\tnum_extensions++;\n\t\t\t}\n\t\t\tdbg_printf("Force add router ID (engine type/ID), Extension: %u\\n", EX_ROUTER_ID);\n\t\t}\n*/\n\t\t\t// received time \n\t\t\tif ( extension_descriptor[EX_RECEIVED].enabled ) {\n\t\t\t\tif ( cache.common_extensions[EX_RECEIVED] == 0 ) {\n\t\t\t\t\tcache.common_extensions[EX_RECEIVED] = 1;\n\t\t\t\t\tnum_extensions++;\n\t\t\t\t}\n\t\t\t\tdbg_printf("Force add packet received time, Extension: %u\\n", EX_RECEIVED);\n\t\t\t}\n\n#ifdef DEVEL\n\t\t{\n\t\t\tint i;\n\t\t\tfor (i=4; extension_descriptor[i].id; i++ ) {\n\t\t\t\tif ( cache.common_extensions[i] ) {\n\t\t\t\t\tprintf("Enabled extension: %i\\n", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\n\t\t\ttranslation_table = setup_translation_table(exporter, table_id);\n\t\t\tif (translation_table-&gt;extension_map_changed ) {\n\t\t\t\t// refresh he map in the ouput buffer\n\t\t\t\tdbg_printf("Translation Table changed! Add extension map ID: %i\\n", translation_table-&gt;extension_info.map-&gt;map_id);\n\t\t\t\tAddExtensionMap(fs, translation_table-&gt;extension_info.map);\n\t\t\t\ttranslation_table-&gt;extension_map_changed = 0;\n\t\t\t\tdbg_printf("Translation Table added! map ID: %i\\n", translation_table-&gt;extension_info.map-&gt;map_id);\n\t\t\t}\n\t\n\t\t\tif ( !reorder_sequencer(translation_table) ) {\n\t\t\t\tLogError("Process_ipfix: [%u] Failed to reorder sequencer. Remove table id: %u", \n\t\t\t\t\t\t\texporter-&gt;info.id, table_id);\n\t\t\t\tremove_translation_table(fs, exporter, table_id);\n\t\t\t}\n\t\t} else {\n\t\t\tdbg_printf("Template does not contain any common fields - skip\\n");\n\t\t}\n\t\t// update size left of this flowset\n\t\tsize_left -= size_required;\n\t\tDataPtr = DataPtr + size_required+4;\t// +4 for header\n\t\tif ( size_left &lt; 4 ) {\n\t\t\t// pading\n\t\t\tdbg_printf("Skip %u bytes padding\\n", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t\tfree(cache.input_order);\n\t\tcache.input_order = NULL;\n\t}\n\n} // End of Process_ipfix_template_add',
 'TEST_P(SslSocketTest, Ipv4San) {\n  const std::string client_ctx_yaml = R"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: "{{ test_rundir }}/test/config/integration/certs/upstreamcacert.pem"\n      match_subject_alt_names:\n        exact: "127.0.0.1"\n)EOF";\n\n  const std::string server_ctx_yaml = R"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: "{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostcert.pem"\n      private_key:\n        filename: "{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostkey.pem"\n)EOF";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options);\n}',
 'mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n\n\tdebug3("%s", __func__);\n\tbuffer_init(&amp;m);\n\tbuffer_put_cstring(&amp;m, authctxt-&gt;user);\n\tmm_request_send(pmonitor-&gt;m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &amp;m);\n\tdebug3("%s: waiting for MONITOR_ANS_PAM_INIT_CTX", __func__);\n\tmm_request_receive_expect(pmonitor-&gt;m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &amp;m);\n\tsuccess = buffer_get_int(&amp;m);\n\tif (success == 0) {\n\t\tdebug3("%s: pam_init_ctx failed", __func__);\n\t\tbuffer_free(&amp;m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&amp;m);\n\treturn (authctxt);\n}',
 'TEST_F(ClusterInfoImplTest, Http3BadConfig) {\n  const std::string yaml = TestEnvironment::substitute(R"EOF(\n    name: name\n    connect_timeout: 0.25s\n    type: STRICT_DNS\n    lb_policy: MAGLEV\n    load_assignment:\n        endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: foo.bar.com\n                    port_value: 443\n    transport_socket:\n      name: envoy.transport_sockets.not_quic\n      typed_config:\n        "@type": type.googleapis.com/envoy.extensions.transport_sockets.quic.v3.QuicUpstreamTransport\n        upstream_tls_context:\n          common_tls_context:\n            tls_certificates:\n            - certificate_chain:\n                filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem"\n              private_key:\n                filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem"\n            validation_context:\n              trusted_ca:\n                filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem"\n              match_subject_alt_names:\n              - exact: localhost\n              - exact: 127.0.0.1\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        use_downstream_protocol_config:\n          http3_protocol_options: {}\n        common_http_protocol_options:\n          idle_timeout: 1s\n  )EOF",\n                                                       Network::Address::IpVersion::v4);\n\n  EXPECT_THROW_WITH_REGEX(makeCluster(yaml), EnvoyException,\n                          "HTTP3 requires a QuicUpstreamTransport transport socket: name.*");\n}',
 'ins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can\'t delete anything in an empty file\n     * can\'t backup past first character in buffer\n     * can\'t backup past starting point unless \'backspace\' &gt; 1\n     * can backup to a previous line if \'backspace\' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &amp;&amp;\n#endif\n\t\t((curwin-&gt;w_cursor.lnum == 1 &amp;&amp; curwin-&gt;w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&amp;&amp; ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&amp;&amp; !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin-&gt;w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&amp;&amp; curwin-&gt;w_cursor.col &lt;= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) &amp;&amp; !arrow_used &amp;&amp; ai_col &gt; 0\n\t\t\t\t\t &amp;&amp; curwin-&gt;w_cursor.col &lt;= ai_col)\n\t\t    || (!can_bs(BS_EOL) &amp;&amp; curwin-&gt;w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don\'t auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin-&gt;w_cursor.coladd &gt; 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin-&gt;w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin-&gt;w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin-&gt;w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin-&gt;w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin-&gt;w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin-&gt;w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin-&gt;w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc &lt; 0: NL was inserted, delete it\n\t * cc &gt;= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State &amp; REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State &amp; REPLACE_FLAG) &amp;&amp; curwin-&gt;w_cursor.lnum &lt;= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State &amp; VREPLACE_FLAG)\n\t\t\t\t   || curwin-&gt;w_cursor.lnum &gt; orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin-&gt;w_cursor.lnum;\n\n\t\t// When "aw" is in \'formatoptions\' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   &amp;&amp; has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin-&gt;w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len &gt; 0 &amp;&amp; ptr[len - 1] == \' \')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL &amp;&amp; gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State &amp; REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc &gt; 0)\n\t\t{\n\t\t    save_col = curwin-&gt;w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin-&gt;w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&amp;&amp; (curbuf-&gt;b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&amp;&amp; !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin-&gt;w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin-&gt;w_cursor.col &lt; save_col)\n\t    {\n\t\tmincol = curwin-&gt;w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin-&gt;w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one \'shiftwidth\' or \'softtabstop\'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&amp;&amp; ((p_sta &amp;&amp; in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf-&gt;b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&amp;&amp; curwin-&gt;w_cursor.col &gt; 0\n\t\t\t&amp;&amp; (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == \' \'\n\t\t\t\t&amp;&amp; (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // \'showbreak\' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta &amp;&amp; in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf-&gt;b_p_vsts_array);\n#else\n\t    if (p_sta &amp;&amp; in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol &gt; want_vcol\n\t\t    &amp;&amp; (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&amp;vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol &lt; want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin-&gt;w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   &amp;&amp; curwin-&gt;w_cursor.col &lt; Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin-&gt;w_cursor.col;\n\n\t\tif (State &amp; VREPLACE_FLAG)\n\t\t    ins_char(\' \');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)" ");\n\t\t    if ((State &amp; REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using \'sts\' and \'linebreak\'.\n\t    if (vcol &gt;= start_vcol)\n\t\tins_bs_one(&amp;vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD &amp;&amp; !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&amp;&amp; ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State &amp; REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State &amp; REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 &amp;&amp; p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and \'delcombine\' is set\n\t\t     * move the cursor back.  Don\'t back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 &amp;&amp; p_deco &amp;&amp; cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on &amp;&amp; gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin-&gt;w_cursor.col &gt; mincol\n\t\t    &amp;&amp;  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin-&gt;w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin-&gt;w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin-&gt;w_cursor.col &lt;= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It\'s a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin-&gt;w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  &amp;&amp; curwin-&gt;w_cursor.col &lt; Insstart_orig.col)\n\tInsstart_orig.col = curwin-&gt;w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn\'t.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL &amp;&amp; dollar_vcol == -1)\n\tdollar_vcol = curwin-&gt;w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when \'foldmethod\' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}',
 "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\n\tif (flags &amp; LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)-&gt;i_sb-&gt;s_cop-&gt;is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\n\tci = d_inode(dir)-&gt;i_crypt_info;\n\tif (ci &amp;&amp; ci-&gt;ci_keyring_key &amp;&amp;\n\t    (ci-&gt;ci_keyring_key-&gt;flags &amp; ((1 &lt;&lt; KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 &lt;&lt; KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 &lt;&lt; KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\n\t/* this should eventually be an flag in d_flags */\n\tspin_lock(&amp;dentry-&gt;d_lock);\n\tcached_with_key = dentry-&gt;d_flags &amp; DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&amp;dentry-&gt;d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\n\t/*\n\t * If the dentry was cached without the key, and it is a\n\t * negative dentry, it might be a valid name.  We can't check\n\t * if the key has since been made available due to locking\n\t * reasons, so we fail the validation so ext4_lookup() can do\n\t * this check.\n\t *\n\t * We also fail the validation if the dentry was created with\n\t * the key present, but we no longer have the key, or vice versa.\n\t */\n\tif ((!cached_with_key &amp;&amp; d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key &amp;&amp; dir_has_key) ||\n\t\t\t(cached_with_key &amp;&amp; !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}",
 'ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 &amp;&amp; flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push&lt;int&gt;(sockfd);\n  input.Push&lt;uint64_t&gt;(len);\n  input.Push&lt;int&gt;(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &amp;input, &amp;output);\n  CheckStatusAndParamCount(status, output, "enc_untrusted_recvfrom", 4);\n\n  int result = output.next&lt;int&gt;();\n  int klinux_errno = output.next&lt;int&gt;();\n  // recvfrom() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), len);\n\n  // If |src_addr| is not NULL, and the underlying protocol provides the source\n  // address, this source address is filled in. When |src_addr| is NULL, nothing\n  // is filled in; in this case, |addrlen| is not used, and should also be NULL.\n  if (src_addr != nullptr &amp;&amp; addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As&lt;struct klinux_sockaddr&gt;();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n\n  return result;\n}',
 'static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\n\tif (dnlen &lt;= 1)\n\t    continue;\n\n\tif (dnlen == ldnlen &amp;&amp; rstreq(dpath, ldn))\n\t    continue;\n\n\t/* Copy as we need to modify the string */\n\t(void) stpcpy(dn, dpath);\n\n\t/* Assume \'/\' directory exists, "mkdir -p" for others if non-existent */\n\tfor (i = 1, te = dn + 1; *te != \'\\0\'; te++, i++) {\n\t    if (*te != \'/\')\n\t\tcontinue;\n\n\t    /* Already validated? */\n\t    if (i &lt; ldnlen &amp;&amp;\n\t\t(ldn[i] == \'/\' || ldn[i] == \'\\0\') &amp;&amp; rstreqn(dn, ldn, i))\n\t\tcontinue;\n\n\t    /* Validate next component of path. */\n\t    *te = \'\\0\';\n\t    rc = fsmStat(dn, 1, &amp;sb); /* lstat */\n\t    *te = \'/\';\n\n\t    /* Directory already exists? */\n\t    if (rc == 0 &amp;&amp; S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = \'\\0\';\n\t\tmode_t mode = S_IFDIR | (_dirPerms &amp; 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\n\t\t/* Run fsm file pre hook for all plugins */\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(dn, mode);\n\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\n\t\t/* Run fsm file post hook for all plugins */\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    "%s directory created with perms %04o\\n",\n\t\t\t    dn, (unsigned)(mode &amp; 07777));\n\t\t}\n\t\t*te = \'/\';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\n\t/* Save last validated path. */\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n\n    return rc;\n}',
 '  void Compute(OpKernelContext* context) override {\n    const auto&amp; input = context-&gt;input(0);\n    auto flat_in = input.flat&lt;tstring&gt;();\n\n    int fixed_length;\n    const auto&amp; length_input = context-&gt;input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                errors::InvalidArgument("k must be scalar, got shape ",\n                                        length_input.shape().DebugString()));\n    fixed_length = length_input.scalar&lt;int32&gt;()();\n\n    OP_REQUIRES(\n        context, fixed_length % sizeof(T) == 0,\n        errors::InvalidArgument(\n            "fixed_length (", fixed_length,\n            ") must be a multiple of the size of out_type (", sizeof(T), ")"));\n\n    OP_REQUIRES(context, fixed_length &gt; 0,\n                errors::InvalidArgument("fixed_length (", fixed_length,\n                                        ") must be greater than zero."));\n\n    int width = fixed_length / sizeof(T);\n\n    TensorShape out_shape = input.shape();\n    out_shape.AddDim(width);\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context-&gt;allocate_output("output", out_shape, &amp;output_tensor));\n\n    if (flat_in.size() == 0) {  // Empty input\n      return;\n    }\n\n    auto out = output_tensor-&gt;flat_inner_dims&lt;T&gt;();\n    T* out_data = out.data();\n\n    // Forcibly clear memory - we\'re going to copy variable length strings in,\n    // and need to ensure that if we don\'t write to byte N when we copy, that\n    // we\'re not getting random data.\n    memset(out_data, 0, fixed_length * flat_in.size());\n\n    // If the data is already in the host\'s byte order, or if the width of the\n    // output type is a single byte (meaning the ordering doesn\'t matter), we\n    // can copy the memory directly.\n    if (!convert_data_endianness_ || sizeof(T) == 1) {\n      for (int64 i = 0; i &lt; flat_in.size(); ++i) {\n        const auto to_copy =\n            std::min(flat_in(i).size(), static_cast&lt;size_t&gt;(fixed_length));\n        memcpy(out_data, flat_in(i).data(), to_copy);\n        // Note: increase out_data by width since it\'s already of type T* so\n        // each shift amount is implicitly multiplied by sizeof(T) according to\n        // pointer arithmetic rules.\n        out_data += width;\n      }\n    } else {\n      // Otherwise, the data is not in the host\'s byte order, and rather than a\n      // direct copy, we need to reverse the byte ordering of each element.\n      for (int64 i = 0; i &lt; flat_in.size(); ++i) {\n        const char* in_data_bytes =\n            reinterpret_cast&lt;const char*&gt;(flat_in(i).data());\n        char* out_data_bytes = reinterpret_cast&lt;char*&gt;(out_data);\n        const char* p_in = in_data_bytes;\n        char* p_out = out_data_bytes;\n        for (; p_in &lt; in_data_bytes + fixed_length;\n             p_in += sizeof(T), p_out += sizeof(T)) {\n          std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n        }\n        // Note: increase out_data by width since it\'s already of type T* so\n        // each shift amount is implicitly multiplied by sizeof(T) according to\n        // pointer arithmetic rules.\n        out_data += width;\n      }\n    }\n  }',
 '  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n                             const int kx, const int ky, const int sx,\n                             const int sy, const string&amp; data_format,\n                             const string&amp; padding) {\n    OpContext op_context;\n\n    const std::vector&lt;int&gt; x = {n, h, w, c};\n    const std::vector&lt;int&gt; ksize = {1, kx, ky, 1};\n    std::vector&lt;int&gt; strides;\n    if (data_format == "NHWC") {\n      strides = {1, sy, sx, 1};\n    } else {\n      strides = {1, 1, sy, sx};\n    }\n\n    auto&amp; op_info = op_context.op_info;\n    SetCpuDevice(&amp;op_info);\n    op_info.set_op("MaxPool");\n\n    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n    auto* attr = op_info.mutable_attr();\n    SetAttrValue(data_format, &amp;(*attr)["data_format"]);\n    SetAttrValue(padding, &amp;(*attr)["padding"]);\n    SetAttrValue(strides, &amp;(*attr)["strides"]);\n    SetAttrValue(ksize, &amp;(*attr)["ksize"]);\n    bool found_unknown_shapes;\n    return OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &amp;found_unknown_shapes);\n  }',
 "static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data)\n\t\treturn 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top-&gt;addr = addr;\n\top-&gt;type = R_ANAL_OP_TYPE_UNK;\n\top-&gt;jump = op-&gt;fail = -1;\n\top-&gt;ptr = op-&gt;val = -1;\n\n\top-&gt;size = 2;\n\n\top_MSB = anal-&gt;big_endian? data[0]: data[1];\n\top_LSB = anal-&gt;big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB&gt;&gt;4) &amp; 0x0F](anal, op, (ut16)(op_MSB&lt;&lt;8 | op_LSB));\n\treturn ret;\n}",
 'Status ComputeConv2DDimension(const Conv2DParameters&amp; params,\n                              const Tensor&amp; input, const Tensor&amp; filter,\n                              Conv2DDimensions* dimensions) {\n  // Check that 2D convolution input and filter have exactly 4 dimensions.\n  TF_REQUIRES(input.dims() == 4,\n              errors::InvalidArgument("input must be 4-dimensional",\n                                      input.shape().DebugString()));\n  TF_REQUIRES(filter.dims() == 4,\n              errors::InvalidArgument("filter must be 4-dimensional: ",\n                                      filter.shape().DebugString()));\n  for (int i = 0; i &lt; 3; i++) {\n    TF_REQUIRES(\n        FastBoundsCheck(filter.dim_size(i), std::numeric_limits&lt;int&gt;::max()),\n        errors::InvalidArgument("filter too large"));\n  }\n\n  // The last dimension for input is in_depth. Check that it is the same as the\n  // filter\'s in_depth or it is evenly divisible by filter\'s in_depth.\n  const int64 in_depth_raw = GetTensorDim(input, params.data_format, \'C\');\n  const int64 patch_depth_raw = filter.dim_size(2);\n  TF_REQUIRES(FastBoundsCheck(in_depth_raw, std::numeric_limits&lt;int&gt;::max()),\n              errors::InvalidArgument("Input depth too large"));\n  TF_REQUIRES(FastBoundsCheck(patch_depth_raw, std::numeric_limits&lt;int&gt;::max()),\n              errors::InvalidArgument("Patch depth too large"));\n  const int in_depth = static_cast&lt;int&gt;(in_depth_raw);\n  const int patch_depth = static_cast&lt;int&gt;(patch_depth_raw);\n  TF_REQUIRES(patch_depth &gt; 0,\n              errors::InvalidArgument(\n                  "filter depth must be stricly positive, got ", patch_depth));\n  TF_REQUIRES(in_depth % patch_depth == 0,\n              errors::InvalidArgument(\n                  "input depth must be evenly divisible by filter depth: ",\n                  in_depth, " vs ", patch_depth));\n\n  // The last dimension for filter is out_depth.\n  const int out_depth = static_cast&lt;int&gt;(filter.dim_size(3));\n\n  // The second dimension for input is rows/height.\n  // The first dimension for filter is rows/height.\n  const int64 input_rows_raw = GetTensorDim(input, params.data_format, \'H\');\n  TF_REQUIRES(FastBoundsCheck(input_rows_raw, std::numeric_limits&lt;int&gt;::max()),\n              errors::InvalidArgument("Input rows too large"));\n  const int input_rows = static_cast&lt;int&gt;(input_rows_raw);\n  const int filter_rows = static_cast&lt;int&gt;(filter.dim_size(0));\n\n  // The third dimension for input is columns/width.\n  // The second dimension for filter is columns/width.\n  const int64 input_cols_raw = GetTensorDim(input, params.data_format, \'W\');\n  TF_REQUIRES(FastBoundsCheck(input_cols_raw, std::numeric_limits&lt;int&gt;::max()),\n              errors::InvalidArgument("Input cols too large"));\n  const int input_cols = static_cast&lt;int&gt;(input_cols_raw);\n  const int filter_cols = static_cast&lt;int&gt;(filter.dim_size(1));\n\n  // The first dimension for input is batch.\n  const int64 batch_raw = GetTensorDim(input, params.data_format, \'N\');\n  TF_REQUIRES(FastBoundsCheck(batch_raw, std::numeric_limits&lt;int&gt;::max()),\n              errors::InvalidArgument("batch is too large"));\n  const int batch = static_cast&lt;int&gt;(batch_raw);\n\n  // Take the stride and dilation from the second and third dimensions only (we\n  // do not support striding or dilation on the batch or depth dimension).\n  const int stride_rows = GetTensorDim(params.strides, params.data_format, \'H\');\n  const int stride_cols = GetTensorDim(params.strides, params.data_format, \'W\');\n  const int dilation_rows =\n      GetTensorDim(params.dilations, params.data_format, \'H\');\n  const int dilation_cols =\n      GetTensorDim(params.dilations, params.data_format, \'W\');\n\n  int64 pad_rows_before, pad_rows_after, pad_cols_before, pad_cols_after;\n  if (params.padding == Padding::EXPLICIT) {\n    GetExplicitPaddingForDim(params.explicit_paddings, params.data_format, \'H\',\n                             &amp;pad_rows_before, &amp;pad_rows_after);\n    GetExplicitPaddingForDim(params.explicit_paddings, params.data_format, \'W\',\n                             &amp;pad_cols_before, &amp;pad_cols_after);\n  }\n\n  // Compute windowed output sizes for rows and columns.\n  int64 out_rows = 0, out_cols = 0;\n  TF_RETURN_IF_ERROR(GetWindowedOutputSizeVerboseV2(\n      input_rows, filter_rows, dilation_rows, stride_rows, params.padding,\n      &amp;out_rows, &amp;pad_rows_before, &amp;pad_rows_after));\n  TF_RETURN_IF_ERROR(GetWindowedOutputSizeVerboseV2(\n      input_cols, filter_cols, dilation_cols, stride_cols, params.padding,\n      &amp;out_cols, &amp;pad_cols_before, &amp;pad_cols_after));\n\n  dimensions-&gt;batch = batch;\n  dimensions-&gt;input_rows = input_rows;\n  dimensions-&gt;input_cols = input_cols;\n  dimensions-&gt;in_depth = in_depth;\n  dimensions-&gt;filter_rows = filter_rows;\n  dimensions-&gt;filter_cols = filter_cols;\n  dimensions-&gt;patch_depth = patch_depth;\n  dimensions-&gt;out_depth = out_depth;\n  dimensions-&gt;stride_rows = stride_rows;\n  dimensions-&gt;stride_cols = stride_cols;\n  dimensions-&gt;dilation_rows = dilation_rows;\n  dimensions-&gt;dilation_cols = dilation_cols;\n  dimensions-&gt;out_rows = out_rows;\n  dimensions-&gt;out_cols = out_cols;\n  dimensions-&gt;pad_rows_before = pad_rows_before;\n  dimensions-&gt;pad_rows_after = pad_rows_after;\n  dimensions-&gt;pad_cols_before = pad_cols_before;\n  dimensions-&gt;pad_cols_after = pad_cols_after;\n\n  return Status::OK();\n}',
 "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&amp;save, buf);\n    gotoLine(buf, a-&gt;start.line);\n    switch (form-&gt;type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a-&gt;start.pos;\n\tepos = a-&gt;end.pos;\n\tbreak;\n    default:\n\tspos = a-&gt;start.pos + 1;\n\tepos = a-&gt;end.pos - 1;\n    }\n    switch (form-&gt;type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf-&gt;currentLine == NULL ||\n\t    spos &gt;= buf-&gt;currentLine-&gt;len || spos &lt; 0)\n\t    break;\n\tif (form-&gt;checked)\n\t    buf-&gt;currentLine-&gt;lineBuf[spos] = '*';\n\telse\n\t    buf-&gt;currentLine-&gt;lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form-&gt;type == FORM_SELECT) {\n\t    p = form-&gt;label-&gt;ptr;\n\t    updateSelectOption(form, form-&gt;select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form-&gt;value)\n\t\tbreak;\n\t    p = form-&gt;value-&gt;ptr;\n\t}\n\tl = buf-&gt;currentLine;\n\tif (!l)\n\t    break;\n\tif (form-&gt;type == FORM_TEXTAREA) {\n\t    int n = a-&gt;y - buf-&gt;currentLine-&gt;linenumber;\n\t    if (n &gt; 0)\n\t\tfor (; l &amp;&amp; n; l = l-&gt;prev, n--) ;\n\t    else if (n &lt; 0)\n\t\tfor (; l &amp;&amp; n; l = l-&gt;prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form-&gt;rows ? form-&gt;rows : 1;\n\tcol = COLPOS(l, a-&gt;start.pos);\n\tfor (c_rows = 0; c_rows &lt; rows; c_rows++, l = l-&gt;next) {\n\t    if (l == NULL)\n\t\tbreak;\n\t    if (rows &gt; 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf-&gt;formitem, l-&gt;linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a-&gt;start.pos;\n\t\tepos = a-&gt;end.pos;\n\t    }\n\t    if (a-&gt;start.line != a-&gt;end.line || spos &gt; epos || epos &gt;= l-&gt;len ||\n\t\tspos &lt; 0 || epos &lt; 0 || COLPOS(l, epos) &lt; col)\n\t\tbreak;\n\t    pos = form_update_line(l, &amp;p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows &gt; 1,\n\t\t\t\t   form-&gt;type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf-&gt;href, buf-&gt;hmarklist,\n\t\t\t\t    a-&gt;start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf-&gt;name, buf-&gt;hmarklist,\n\t\t\t\t    a-&gt;start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf-&gt;img, buf-&gt;hmarklist,\n\t\t\t\t    a-&gt;start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf-&gt;formitem, buf-&gt;hmarklist,\n\t\t\t\t    a-&gt;start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &amp;save);\n    arrangeLine(buf);\n}",
 'TEST_F(ListenerManagerImplQuicOnlyTest, QuicListenerFactoryWithWrongTransportSocket) {\n  const std::string yaml = TestEnvironment::substitute(R"EOF(\naddress:\n  socket_address:\n    address: 127.0.0.1\n    protocol: UDP\n    port_value: 1234\nfilter_chains:\n- filter_chain_match:\n    transport_protocol: "quic"\n  filters: []\n  transport_socket:\n    name: envoy.transport_sockets.quic\n    typed_config:\n      "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext\n      common_tls_context:\n        tls_certificates:\n        - certificate_chain:\n            filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem"\n          private_key:\n            filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem"\n        validation_context:\n          trusted_ca:\n            filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem"\n          match_subject_alt_names:\n          - exact: localhost\n          - exact: 127.0.0.1\nudp_listener_config:\n  quic_options: {}\n  )EOF",\n                                                       Network::Address::IpVersion::v4);\n\n  envoy::config::listener::v3::Listener listener_proto = parseListenerFromV3Yaml(yaml);\n\n#if defined(ENVOY_ENABLE_QUIC)\n  EXPECT_THROW_WITH_REGEX(manager_-&gt;addOrUpdateListener(listener_proto, "", true), EnvoyException,\n                          "wrong transport socket config specified for quic transport socket");\n#else\n  EXPECT_THROW_WITH_REGEX(manager_-&gt;addOrUpdateListener(listener_proto, "", true), EnvoyException,\n                          "QUIC is configured but not enabled in the build.");\n#endif\n}',
 'void ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(c = 0;c &lt; m_ucCount;c++) {\n    struct QMContextSet &amp;contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line-&gt;m_pData + x;\n    LONG *pp = (pline)?(pline-&gt;m_pData + x):(NULL);\n    //\n    // Parse MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        // Decode now the difference between the predicted value and\n        // the real value.\n        LONG v;\n        //\n        // Get the sign coding context.\n        struct QMContextSet::ContextZeroSet &amp;zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        //\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); // true for negative.\n          //\n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &amp;mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            //\n            while(m_Coder.Get(mset.X[i])) {\n              m &lt;&lt;= 1;\n              i++;\n            }\n            //\n            m &gt;&gt;= 1;\n            sz  = m;\n            while((m &gt;&gt;= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          //\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        //\n        // Use the prediction to fill in the sample.\n        lp[0] = pred-&gt;DecodeSample(v,lp,pp);\n        // Update Da and Db.\n        // Is this a bug? 32768 does not exist, but -32768 does. The streams\n        // seem to use -32768 instead.\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm &amp;&amp; (lp++,pp++,x++,pred = pred-&gt;MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym &amp;&amp; (pp = line-&gt;m_pData + (x = m_ulX[c]),line = (line-&gt;m_pNext)?(line-&gt;m_pNext):(line),\n                     lp = line-&gt;m_pData + x,mcupred = mcupred-&gt;MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}',
 'static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\n\tscm-&gt;fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\n\tfor (i = scm-&gt;fp-&gt;count-1; i &gt;= 0; i--)\n\t\tunix_notinflight(scm-&gt;fp-&gt;fp[i]);\n}',
 'umask_handler(vector_t *strvec)\n{\n\tlong umask_long;\n\tmode_t umask_val = 0;\n\tchar *mask = strvec_slot(strvec, 1);\n\tchar *endptr;\n\tunsigned i;\n\tchar *p;\n\n\tif (umask_cmdline) {\n\t\tlog_message(LOG_INFO, "umask command line option specified, ignoring config option");\n\t\treturn;\n\t}\n\n\tif (isdigit(mask[0])) {\n\t\tif (vector_size(strvec) != 2) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, "%s parameter(s) to umask option", vector_size(strvec) == 1 ? "Missing" : "Extra");\n\t\t\treturn;\n\t\t}\n\t\tumask_long = strtol(mask, &amp;endptr, 0);\n\t\tif (*endptr || umask_long &lt; 0 || umask_long &amp; ~0777L) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, "invalid umask value %s", mask);\n\t\t\treturn;\n\t\t}\n\t\tumask_val = umask_long &amp; 0777;\n\t}\n\telse {\n\t\tbool need_or = false;\n\t\tfor (i = 1; i &lt; vector_size(strvec); i++) {\n\t\t\tfor (p = strvec_slot(strvec, i); *p; ) {\n\t\t\t\tif (need_or) {\n\t\t\t\t\tif (*p == \'|\') {\n\t\t\t\t\t\tneed_or = false;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, "Invalid umask syntax %s", FMT_STR_VSLOT(strvec, i));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif      (!strncmp(p, "IRUSR", 5)) umask_val |= S_IRUSR;\n\t\t\t\telse if (!strncmp(p, "IWUSR", 5)) umask_val |= S_IWUSR;\n\t\t\t\telse if (!strncmp(p, "IXUSR", 5)) umask_val |= S_IXUSR;\n\t\t\t\telse if (!strncmp(p, "IRGRP", 5)) umask_val |= S_IRGRP;\n\t\t\t\telse if (!strncmp(p, "IWGRP", 5)) umask_val |= S_IWGRP;\n\t\t\t\telse if (!strncmp(p, "IXGRP", 5)) umask_val |= S_IXGRP;\n\t\t\t\telse if (!strncmp(p, "IROTH", 5)) umask_val |= S_IROTH;\n\t\t\t\telse if (!strncmp(p, "IWOTH", 5)) umask_val |= S_IWOTH;\n\t\t\t\telse if (!strncmp(p, "IXOTH", 5)) umask_val |= S_IXOTH;\n\t\t\t\telse {\n\t\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, "Unknown umask bit %s", p);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tp += 5;\n\t\t\t\tneed_or = true;\n\t\t\t}\n\t\t}\n\t\tif (!need_or) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, "umask missing bit value");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tglobal_data-&gt;umask = umask_val;\n\tumask(umask_val);\n}',
 "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\n\tif ((bprm-&gt;buf[0] != '#') || (bprm-&gt;buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\t/*\n\t * This section does the #! interpretation.\n\t * Sorta complicated, but hopefully it will work.  -TYT\n\t */\n\n\tallow_write_access(bprm-&gt;file);\n\tfput(bprm-&gt;file);\n\tbprm-&gt;file = NULL;\n\n\tbprm-&gt;buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm-&gt;buf, '\\n')) == NULL)\n\t\tcp = bprm-&gt;buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp &gt; bprm-&gt;buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm-&gt;buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; /* No interpreter name found */\n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp &amp;&amp; (*cp != ' ') &amp;&amp; (*cp != '\\t'); cp++)\n\t\t/* nothing */ ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\t/*\n\t * OK, we've parsed out the interpreter name and\n\t * (optional) argument.\n\t * Splice in (1) the interpreter's name for argv[0]\n\t *           (2) (optional) argument to interpreter\n\t *           (3) filename of shell script (replace argv[0])\n\t *\n\t * This is done in reverse order, because of how the\n\t * user environment and arguments are stored.\n\t */\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &amp;bprm-&gt;interp, bprm);\n\tif (retval &lt; 0) return retval; \n\tbprm-&gt;argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &amp;i_arg, bprm);\n\t\tif (retval &lt; 0) return retval; \n\t\tbprm-&gt;argc++;\n\t}\n\tretval = copy_strings_kernel(1, &amp;i_name, bprm);\n\tif (retval) return retval; \n\tbprm-&gt;argc++;\n\tbprm-&gt;interp = interp;\n\n\t/*\n\t * OK, now restart the process with the interpreter's dentry.\n\t */\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tbprm-&gt;file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval &lt; 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}",
 'void HeaderMapImpl::removePrefix(const LowerCaseString&amp; prefix) {\n  headers_.remove_if([&amp;](const HeaderEntryImpl&amp; entry) {\n    bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());\n    if (to_remove) {\n      // If this header should be removed, make sure any references in the\n      // static lookup table are cleared as well.\n      EntryCb cb = ConstSingleton&lt;StaticLookupTable&gt;::get().find(entry.key().getStringView());\n      if (cb) {\n        StaticLookupResponse ref_lookup_response = cb(*this);\n        if (ref_lookup_response.entry_) {\n          *ref_lookup_response.entry_ = nullptr;\n        }\n      }\n    }\n    return to_remove;\n  });\n}',
 'ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_char *b, *s, *t, c;\n\tint i, proto;\n\tconst void *se;\n\n        if (length &lt;= 0)\n                return;\n\n\tb = (uint8_t *)malloc(length);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = (u_char *)p, t = b, i = length; i &gt; 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i &gt; 1) {\n\t\t\t\ti--;\n\t\t\t\tc = *s++ ^ 0x20;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo-&gt;ndo_snapend;\n\tndo-&gt;ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length &lt; 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length &lt; 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS &lt;&lt; 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length &lt; 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo-&gt;ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo-&gt;ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, "[|ppp]"));\n}',
 "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n\n        /* Removes one specific child of the specified directory */\n\n        if (fd &lt; 0)\n                return -EBADF;\n\n        if (!filename_is_valid(name))\n                return -EINVAL;\n\n        if ((flags &amp; (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) /* Doesn't really make sense here, we are not supposed to remove 'fd' anyway */\n                return -EINVAL;\n\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}",
 'static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program)\n{\n    AVStream *stream = ist-&gt;st;\n    AVCodecParameters *par;\n    AVCodecContext *dec_ctx;\n    char val_str[128];\n    const char *s;\n    AVRational sar, dar;\n    AVBPrint pbuf;\n    const AVCodecDescriptor *cd;\n    int ret = 0;\n    const char *profile = NULL;\n\n    av_bprint_init(&amp;pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n    print_int("index", stream-&gt;index);\n\n    par     = stream-&gt;codecpar;\n    dec_ctx = ist-&gt;dec_ctx;\n    if (cd = avcodec_descriptor_get(par-&gt;codec_id)) {\n        print_str("codec_name", cd-&gt;name);\n        if (!do_bitexact) {\n            print_str("codec_long_name",\n                      cd-&gt;long_name ? cd-&gt;long_name : "unknown");\n        }\n    } else {\n        print_str_opt("codec_name", "unknown");\n        if (!do_bitexact) {\n            print_str_opt("codec_long_name", "unknown");\n        }\n    }\n\n    if (!do_bitexact &amp;&amp; (profile = avcodec_profile_name(par-&gt;codec_id, par-&gt;profile)))\n        print_str("profile", profile);\n    else {\n        if (par-&gt;profile != FF_PROFILE_UNKNOWN) {\n            char profile_num[12];\n            snprintf(profile_num, sizeof(profile_num), "%d", par-&gt;profile);\n            print_str("profile", profile_num);\n        } else\n            print_str_opt("profile", "unknown");\n    }\n\n    s = av_get_media_type_string(par-&gt;codec_type);\n    if (s) print_str    ("codec_type", s);\n    else   print_str_opt("codec_type", "unknown");\n#if FF_API_LAVF_AVCTX\n    if (dec_ctx)\n        print_q("codec_time_base", dec_ctx-&gt;time_base, \'/\');\n#endif\n\n    /* print AVI/FourCC tag */\n    print_str("codec_tag_string",    av_fourcc2str(par-&gt;codec_tag));\n    print_fmt("codec_tag", "0x%04"PRIx32, par-&gt;codec_tag);\n\n    switch (par-&gt;codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        print_int("width",        par-&gt;width);\n        print_int("height",       par-&gt;height);\n        if (dec_ctx) {\n            print_int("coded_width",  dec_ctx-&gt;coded_width);\n            print_int("coded_height", dec_ctx-&gt;coded_height);\n        }\n        print_int("has_b_frames", par-&gt;video_delay);\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n        if (sar.den) {\n            print_q("sample_aspect_ratio", sar, \':\');\n            av_reduce(&amp;dar.num, &amp;dar.den,\n                      par-&gt;width  * sar.num,\n                      par-&gt;height * sar.den,\n                      1024*1024);\n            print_q("display_aspect_ratio", dar, \':\');\n        } else {\n            print_str_opt("sample_aspect_ratio", "N/A");\n            print_str_opt("display_aspect_ratio", "N/A");\n        }\n        s = av_get_pix_fmt_name(par-&gt;format);\n        if (s) print_str    ("pix_fmt", s);\n        else   print_str_opt("pix_fmt", "unknown");\n        print_int("level",   par-&gt;level);\n        if (par-&gt;color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str    ("color_range", av_color_range_name(par-&gt;color_range));\n        else\n            print_str_opt("color_range", "N/A");\n\n        if (par-&gt;color_space != AVCOL_SPC_UNSPECIFIED)\n            print_str("color_space", av_color_space_name(par-&gt;color_space));\n        else\n            print_str_opt("color_space", av_color_space_name(par-&gt;color_space));\n\n        if (par-&gt;color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str("color_transfer", av_color_transfer_name(par-&gt;color_trc));\n        else\n            print_str_opt("color_transfer", av_color_transfer_name(par-&gt;color_trc));\n\n        if (par-&gt;color_primaries != AVCOL_PRI_UNSPECIFIED)\n            print_str("color_primaries", av_color_primaries_name(par-&gt;color_primaries));\n        else\n            print_str_opt("color_primaries", av_color_primaries_name(par-&gt;color_primaries));\n\n        if (par-&gt;chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str("chroma_location", av_chroma_location_name(par-&gt;chroma_location));\n        else\n            print_str_opt("chroma_location", av_chroma_location_name(par-&gt;chroma_location));\n\n        if (par-&gt;field_order == AV_FIELD_PROGRESSIVE)\n            print_str("field_order", "progressive");\n        else if (par-&gt;field_order == AV_FIELD_TT)\n            print_str("field_order", "tt");\n        else if (par-&gt;field_order == AV_FIELD_BB)\n            print_str("field_order", "bb");\n        else if (par-&gt;field_order == AV_FIELD_TB)\n            print_str("field_order", "tb");\n        else if (par-&gt;field_order == AV_FIELD_BT)\n            print_str("field_order", "bt");\n        else\n            print_str_opt("field_order", "unknown");\n\n#if FF_API_PRIVATE_OPT\n        if (dec_ctx &amp;&amp; dec_ctx-&gt;timecode_frame_start &gt;= 0) {\n            char tcbuf[AV_TIMECODE_STR_SIZE];\n            av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx-&gt;timecode_frame_start);\n            print_str("timecode", tcbuf);\n        } else {\n            print_str_opt("timecode", "N/A");\n        }\n#endif\n        if (dec_ctx)\n            print_int("refs", dec_ctx-&gt;refs);\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(par-&gt;format);\n        if (s) print_str    ("sample_fmt", s);\n        else   print_str_opt("sample_fmt", "unknown");\n        print_val("sample_rate",     par-&gt;sample_rate, unit_hertz_str);\n        print_int("channels",        par-&gt;channels);\n\n        if (par-&gt;channel_layout) {\n            av_bprint_clear(&amp;pbuf);\n            av_bprint_channel_layout(&amp;pbuf, par-&gt;channels, par-&gt;channel_layout);\n            print_str    ("channel_layout", pbuf.str);\n        } else {\n            print_str_opt("channel_layout", "unknown");\n        }\n\n        print_int("bits_per_sample", av_get_bits_per_sample(par-&gt;codec_id));\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n        if (par-&gt;width)\n            print_int("width",       par-&gt;width);\n        else\n            print_str_opt("width",   "N/A");\n        if (par-&gt;height)\n            print_int("height",      par-&gt;height);\n        else\n            print_str_opt("height",  "N/A");\n        break;\n    }\n\n    if (dec_ctx &amp;&amp; dec_ctx-&gt;codec &amp;&amp; dec_ctx-&gt;codec-&gt;priv_class &amp;&amp; show_private_data) {\n        const AVOption *opt = NULL;\n        while (opt = av_opt_next(dec_ctx-&gt;priv_data,opt)) {\n            uint8_t *str;\n            if (opt-&gt;flags) continue;\n            if (av_opt_get(dec_ctx-&gt;priv_data, opt-&gt;name, 0, &amp;str) &gt;= 0) {\n                print_str(opt-&gt;name, str);\n                av_free(str);\n            }\n        }\n    }\n\n    if (fmt_ctx-&gt;iformat-&gt;flags &amp; AVFMT_SHOW_IDS) print_fmt    ("id", "0x%x", stream-&gt;id);\n    else                                          print_str_opt("id", "N/A");\n    print_q("r_frame_rate",   stream-&gt;r_frame_rate,   \'/\');\n    print_q("avg_frame_rate", stream-&gt;avg_frame_rate, \'/\');\n    print_q("time_base",      stream-&gt;time_base,      \'/\');\n    print_ts  ("start_pts",   stream-&gt;start_time);\n    print_time("start_time",  stream-&gt;start_time, &amp;stream-&gt;time_base);\n    print_ts  ("duration_ts", stream-&gt;duration);\n    print_time("duration",    stream-&gt;duration, &amp;stream-&gt;time_base);\n    if (par-&gt;bit_rate &gt; 0)     print_val    ("bit_rate", par-&gt;bit_rate, unit_bit_per_second_str);\n    else                       print_str_opt("bit_rate", "N/A");\n#if FF_API_LAVF_AVCTX\n    if (stream-&gt;codec-&gt;rc_max_rate &gt; 0) print_val ("max_bit_rate", stream-&gt;codec-&gt;rc_max_rate, unit_bit_per_second_str);\n    else                                print_str_opt("max_bit_rate", "N/A");\n#endif\n    if (dec_ctx &amp;&amp; dec_ctx-&gt;bits_per_raw_sample &gt; 0) print_fmt("bits_per_raw_sample", "%d", dec_ctx-&gt;bits_per_raw_sample);\n    else                                             print_str_opt("bits_per_raw_sample", "N/A");\n    if (stream-&gt;nb_frames) print_fmt    ("nb_frames", "%"PRId64, stream-&gt;nb_frames);\n    else                   print_str_opt("nb_frames", "N/A");\n    if (nb_streams_frames[stream_idx])  print_fmt    ("nb_read_frames", "%"PRIu64, nb_streams_frames[stream_idx]);\n    else                                print_str_opt("nb_read_frames", "N/A");\n    if (nb_streams_packets[stream_idx]) print_fmt    ("nb_read_packets", "%"PRIu64, nb_streams_packets[stream_idx]);\n    else                                print_str_opt("nb_read_packets", "N/A");\n    if (do_show_data)\n        writer_print_data(w, "extradata", par-&gt;extradata,\n                                          par-&gt;extradata_size);\n    writer_print_data_hash(w, "extradata_hash", par-&gt;extradata,\n                                                par-&gt;extradata_size);\n\n    /* Print disposition information */\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n        print_int(name, !!(stream-&gt;disposition &amp; AV_DISPOSITION_##flagname)); \\\n    } while (0)\n\n    if (do_show_stream_disposition) {\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n    PRINT_DISPOSITION(DEFAULT,          "default");\n    PRINT_DISPOSITION(DUB,              "dub");\n    PRINT_DISPOSITION(ORIGINAL,         "original");\n    PRINT_DISPOSITION(COMMENT,          "comment");\n    PRINT_DISPOSITION(LYRICS,           "lyrics");\n    PRINT_DISPOSITION(KARAOKE,          "karaoke");\n    PRINT_DISPOSITION(FORCED,           "forced");\n    PRINT_DISPOSITION(HEARING_IMPAIRED, "hearing_impaired");\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  "visual_impaired");\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    "clean_effects");\n    PRINT_DISPOSITION(ATTACHED_PIC,     "attached_pic");\n    PRINT_DISPOSITION(TIMED_THUMBNAILS, "timed_thumbnails");\n    writer_print_section_footer(w);\n    }\n\n    if (do_show_stream_tags)\n        ret = show_tags(w, stream-&gt;metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n    if (stream-&gt;nb_side_data) {\n        print_pkt_side_data(w, stream-&gt;codecpar, stream-&gt;side_data, stream-&gt;nb_side_data,\n                            SECTION_ID_STREAM_SIDE_DATA_LIST,\n                            SECTION_ID_STREAM_SIDE_DATA);\n    }\n\n    writer_print_section_footer(w);\n    av_bprint_finalize(&amp;pbuf, NULL);\n    fflush(stdout);\n\n    return ret;\n}',
 'int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode;\n\n\t\t\trc = posix_acl_update_mode(inode, &amp;mode, &amp;acl);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tif (inode-&gt;i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &amp;attr);\n\t\t\t\tif (rc &lt; 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode-&gt;i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}',
 'void CConfig::Write(CFile&amp; File, unsigned int iIndentation) {\n    CString sIndentation = CString(iIndentation, \'\\t\');\n\n    for (const auto&amp; it : m_ConfigEntries) {\n        for (const CString&amp; sValue : it.second) {\n            File.Write(sIndentation + it.first + " = " + sValue + "\\n");\n        }\n    }\n\n    for (const auto&amp; it : m_SubConfigs) {\n        for (const auto&amp; it2 : it.second) {\n            File.Write("\\n");\n\n            File.Write(sIndentation + "&lt;" + it.first + " " + it2.first + "&gt;\\n");\n            it2.second.m_pSubConfig-&gt;Write(File, iIndentation + 1);\n            File.Write(sIndentation + "&lt;/" + it.first + "&gt;\\n");\n        }\n    }\n}',
 'GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp-&gt;content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}',
 'static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb-&gt;ki_filp;\n\tstruct qrtr_tun *tun = filp-&gt;private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tret = qrtr_endpoint_post(&amp;tun-&gt;ep, kbuf, len);\n\n\treturn ret &lt; 0 ? ret : len;\n}',
 'PGTYPESinterval_from_asc(char *str, char **endptr)\n{\n\tinterval   *result = NULL;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &amp;tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &amp;realptr;\n\n\ttm-&gt;tm_year = 0;\n\ttm-&gt;tm_mon = 0;\n\ttm-&gt;tm_mday = 0;\n\ttm-&gt;tm_hour = 0;\n\ttm-&gt;tm_min = 0;\n\ttm-&gt;tm_sec = 0;\n\tfsec = 0;\n\n\tif (strlen(str) &gt;= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\n\tif (ParseDateTime(str, lowstr, field, ftype, &amp;nf, ptr) != 0 ||\n\t\t(DecodeInterval(field, ftype, nf, &amp;dtype, tm, &amp;fsec) != 0 &amp;&amp;\n\t\t DecodeISO8601Interval(str, &amp;dtype, tm, &amp;fsec) != 0))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\n\tresult = (interval *) pgtypes_alloc(sizeof(interval));\n\tif (!result)\n\t\treturn NULL;\n\n\tif (dtype != DTK_DELTA)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\tif (tm2interval(tm, fsec, result) != 0)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\terrno = 0;\n\treturn result;\n}',
 'int ZlibOutStream::length()\n{\n  return offset + ptr - start;\n}',
 'create_pty_only(term_T *term, jobopt_T *opt)\n{\n    create_vterm(term, term-&gt;tl_rows, term-&gt;tl_cols);\n\n    term-&gt;tl_job = job_alloc();\n    if (term-&gt;tl_job == NULL)\n\treturn FAIL;\n    ++term-&gt;tl_job-&gt;jv_refcount;\n\n    /* behave like the job is already finished */\n    term-&gt;tl_job-&gt;jv_status = JOB_FINISHED;\n\n    return mch_create_pty_channel(term-&gt;tl_job, opt);\n}',
 'static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string&amp; xpath)\n{\n\txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n\n\tif (!result) {\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt-&gt;doc);\n\n\t\tthrow XMLException("Invalid XPath: " + xpath);\n\t}\n\n\tif (result-&gt;type != XPATH_NODESET) {\n\t\txmlXPathFreeObject(result);\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt-&gt;doc);\n\n\t\tthrow XMLException("Only nodeset result types are supported.");\n\t}\n\n\txmlNodeSet* nodeset = result-&gt;nodesetval;\n\tXMLSharedNodeList* nodes = new XMLSharedNodeList();\n\tif (nodeset) {\n\t\tfor (int i = 0; i &lt; nodeset-&gt;nodeNr; ++i) {\n\t\t\tXMLNode* node = readnode(nodeset-&gt;nodeTab[i]);\n\t\t\tnodes-&gt;push_back(boost::shared_ptr&lt;XMLNode&gt;(node));\n\t\t}\n\t} else {\n\t\t// return empty set\n\t}\n\n\txmlXPathFreeObject(result);\n\n\treturn nodes;\n}',
 'static int cg_getattr(const char *path, struct stat *sb)\n{\n\tstruct timespec now;\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar * cgdir = NULL;\n\tchar *fpath = NULL, *path1, *path2;\n\tstruct cgfs_files *k = NULL;\n\tconst char *cgroup;\n\tconst char *controller = NULL;\n\tint ret = -ENOENT;\n\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tmemset(sb, 0, sizeof(struct stat));\n\n\tif (clock_gettime(CLOCK_REALTIME, &amp;now) &lt; 0)\n\t\treturn -EINVAL;\n\n\tsb-&gt;st_uid = sb-&gt;st_gid = 0;\n\tsb-&gt;st_atim = sb-&gt;st_mtim = sb-&gt;st_ctim = now;\n\tsb-&gt;st_size = 0;\n\n\tif (strcmp(path, "/cgroup") == 0) {\n\t\tsb-&gt;st_mode = S_IFDIR | 00755;\n\t\tsb-&gt;st_nlink = 2;\n\t\treturn 0;\n\t}\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EIO;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup) {\n\t\t/* this is just /cgroup/controller, return it as a dir */\n\t\tsb-&gt;st_mode = S_IFDIR | 00755;\n\t\tsb-&gt;st_nlink = 2;\n\t\treturn 0;\n\t}\n\n\tget_cgdir_and_path(cgroup, &amp;cgdir, &amp;fpath);\n\n\tif (!fpath) {\n\t\tpath1 = "/";\n\t\tpath2 = cgdir;\n\t} else {\n\t\tpath1 = cgdir;\n\t\tpath2 = fpath;\n\t}\n\n\t/* check that cgcopy is either a child cgroup of cgdir, or listed in its keys.\n\t * Then check that caller\'s cgroup is under path if fpath is a child\n\t * cgroup, or cgdir if fpath is a file */\n\n\tif (is_child_cgroup(controller, path1, path2)) {\n\t\tif (!caller_may_see_dir(fc-&gt;pid, controller, cgroup)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!caller_is_in_ancestor(fc-&gt;pid, controller, cgroup, NULL)) {\n\t\t\t/* this is just /cgroup/controller, return it as a dir */\n\t\t\tsb-&gt;st_mode = S_IFDIR | 00555;\n\t\t\tsb-&gt;st_nlink = 2;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\t// get uid, gid, from \'/tasks\' file and make up a mode\n\t\t// That is a hack, until cgmanager gains a GetCgroupPerms fn.\n\t\tsb-&gt;st_mode = S_IFDIR | 00755;\n\t\tk = cgfs_get_key(controller, cgroup, "tasks");\n\t\tif (!k) {\n\t\t\tsb-&gt;st_uid = sb-&gt;st_gid = 0;\n\t\t} else {\n\t\t\tsb-&gt;st_uid = k-&gt;uid;\n\t\t\tsb-&gt;st_gid = k-&gt;gid;\n\t\t}\n\t\tfree_key(k);\n\t\tsb-&gt;st_nlink = 2;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif ((k = cgfs_get_key(controller, path1, path2)) != NULL) {\n\t\tsb-&gt;st_mode = S_IFREG | k-&gt;mode;\n\t\tsb-&gt;st_nlink = 1;\n\t\tsb-&gt;st_uid = k-&gt;uid;\n\t\tsb-&gt;st_gid = k-&gt;gid;\n\t\tsb-&gt;st_size = 0;\n\t\tfree_key(k);\n\t\tif (!caller_is_in_ancestor(fc-&gt;pid, controller, path1, NULL)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fc_may_access(fc, controller, path1, path2, O_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = 0;\n\t}\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}',
 'Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g,\n                                                    ControlFlowInfo* cf_info) {\n  const int num_nodes = g-&gt;num_node_ids();\n  cf_info-&gt;frame_names.resize(num_nodes);\n  std::vector&lt;Node*&gt; parent_nodes;\n  parent_nodes.resize(num_nodes);\n  std::vector&lt;bool&gt; visited;\n  visited.resize(num_nodes);\n\n  string frame_name;\n  std::deque&lt;Node*&gt; ready;\n\n  // Initialize with the root nodes.\n  for (Node* n : g-&gt;nodes()) {\n    if (n-&gt;in_edges().empty()) {\n      visited[n-&gt;id()] = true;\n      cf_info-&gt;unique_frame_names.insert(frame_name);\n      ready.push_back(n);\n    }\n  }\n\n  while (!ready.empty()) {\n    Node* curr_node = ready.front();\n    int curr_id = curr_node-&gt;id();\n    ready.pop_front();\n\n    Node* parent = nullptr;\n    if (IsEnter(curr_node)) {\n      // Enter a child frame.\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(curr_node-&gt;attrs(), "frame_name", &amp;frame_name));\n      parent = curr_node;\n    } else if (IsExit(curr_node)) {\n      // Exit to the parent frame.\n      parent = parent_nodes[curr_id];\n      if (!parent) {\n        return errors::InvalidArgument(\n            "Invalid Exit op: Cannot find a corresponding Enter op.");\n      }\n      frame_name = cf_info-&gt;frame_names[parent-&gt;id()];\n      parent = parent_nodes[parent-&gt;id()];\n    } else {\n      parent = parent_nodes[curr_id];\n      frame_name = cf_info-&gt;frame_names[curr_id];\n    }\n\n    for (const Edge* out_edge : curr_node-&gt;out_edges()) {\n      Node* out = out_edge-&gt;dst();\n      if (IsSink(out)) continue;\n      const int out_id = out-&gt;id();\n\n      // Add to ready queue if not visited.\n      bool is_visited = visited[out_id];\n      if (!is_visited) {\n        ready.push_back(out);\n        visited[out_id] = true;\n\n        // Process the node \'out\'.\n        cf_info-&gt;frame_names[out_id] = frame_name;\n        parent_nodes[out_id] = parent;\n        cf_info-&gt;unique_frame_names.insert(frame_name);\n      }\n    }\n  }\n\n  return Status::OK();\n}',
 'static boolean_t is_authenticated(HttpRequest req, HttpResponse res) {\n        if (Run.httpd.credentials) {\n                if (! basic_authenticate(req)) {\n                        // Send just generic error message to the client to not disclose e.g. username existence in case of credentials harvesting attack\n                        send_error(req, res, SC_UNAUTHORIZED, "You are not authorized to access monit. Either you supplied the wrong credentials (e.g. bad password), or your browser doesn\'t understand how to supply the credentials required");\n                        set_header(res, "WWW-Authenticate", "Basic realm=\\"monit\\"");\n                        return false;\n                }\n        }\n        if (IS(req-&gt;method, METHOD_POST)) {\n                // Check CSRF double-submit cookie (https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Double_Submit_Cookie)\n                const char *cookie = get_header(req, "Cookie");\n                const char *token = get_parameter(req, "securitytoken");\n                if (! cookie) {\n                        LogError("HttpRequest: access denied -- client [%s]: missing CSRF token cookie\\n", NVLSTR(Socket_getRemoteHost(req-&gt;S)));\n                        send_error(req, res, SC_FORBIDDEN, "Invalid CSRF Token");\n                        return false;\n                }\n                if (! token) {\n                        LogError("HttpRequest: access denied -- client [%s]: missing CSRF token in HTTP parameter\\n", NVLSTR(Socket_getRemoteHost(req-&gt;S)));\n                        send_error(req, res, SC_FORBIDDEN, "Invalid CSRF Token");\n                        return false;\n                }\n                if (! Str_startsWith(cookie, "securitytoken=")) {\n                        LogError("HttpRequest: access denied -- client [%s]: no CSRF token in cookie\\n", NVLSTR(Socket_getRemoteHost(req-&gt;S)));\n                        send_error(req, res, SC_FORBIDDEN, "Invalid CSRF Token");\n                        return false;\n                }\n                if (Str_compareConstantTime(cookie + 14, token)) {\n                        LogError("HttpRequest: access denied -- client [%s]: CSRF token mismatch\\n", NVLSTR(Socket_getRemoteHost(req-&gt;S)));\n                        send_error(req, res, SC_FORBIDDEN, "Invalid CSRF Token");\n                        return false;\n                }\n        }\n        return true;\n}',
 'TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n  const int32_t* fft_length_data = GetTensorData&lt;int32_t&gt;(fft_length);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output-&gt;type != kTfLiteComplex64) {\n    context-&gt;ReportError(context,\n                         "Type \'%s\' for output is not supported by rfft2d.",\n                         TfLiteTypeGetName(output-&gt;type));\n    return kTfLiteError;\n  }\n\n  // Resize the output tensor if the fft_length tensor is not constant.\n  // Otherwise, check if the output shape is correct.\n  if (!IsConstantTensor(fft_length)) {\n    TF_LITE_ENSURE_STATUS(ResizeOutputandTemporaryTensors(context, node));\n  } else {\n    int num_dims_output = NumDimensions(output);\n    const RuntimeShape output_shape = GetTensorShape(output);\n    TF_LITE_ENSURE_EQ(context, num_dims_output, NumDimensions(input));\n    TF_LITE_ENSURE(context, num_dims_output &gt;= 2);\n    TF_LITE_ENSURE_EQ(context, output_shape.Dims(num_dims_output - 2),\n                      fft_length_data[0]);\n    TF_LITE_ENSURE_EQ(context, output_shape.Dims(num_dims_output - 1),\n                      fft_length_data[1] / 2 + 1);\n  }\n\n  return Rfft2dHelper(context, node);\n}',
 'void stm32h7xxEthInitGpio(NetInterface *interface)\n{\n   GPIO_InitTypeDef GPIO_InitStructure;\n\n//STM32F743I-EVAL, STM32F747I-EVAL or STM32H747I-Discovery evaluation board?\n#if defined(USE_STM32H743I_EVAL) || defined(USE_STM32H747I_EVAL) || \\\n   defined(USE_STM32H747I_DISCO)\n   //Enable SYSCFG clock\n   __HAL_RCC_SYSCFG_CLK_ENABLE();\n\n   //Enable GPIO clocks\n   __HAL_RCC_GPIOA_CLK_ENABLE();\n   __HAL_RCC_GPIOC_CLK_ENABLE();\n   __HAL_RCC_GPIOG_CLK_ENABLE();\n\n   //Select RMII interface mode\n   HAL_SYSCFG_ETHInterfaceSelect(SYSCFG_ETH_RMII);\n\n   //Configure RMII pins\n   GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;\n   GPIO_InitStructure.Pull = GPIO_NOPULL;\n   GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n   GPIO_InitStructure.Alternate = GPIO_AF11_ETH;\n\n   //Configure ETH_RMII_REF_CLK (PA1), ETH_MDIO (PA2) and ETH_RMII_CRS_DV (PA7)\n   GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;\n   HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStructure);\n\n   //Configure ETH_MDC (PC1), ETH_RMII_RXD0 (PC4) and ETH_RMII_RXD1 (PC5)\n   GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;\n   HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStructure);\n\n   //Configure RMII_TX_EN (PG11), ETH_RMII_TXD1 (PG12) and ETH_RMII_TXD0 (PG13)\n   GPIO_InitStructure.Pin = GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13;\n   HAL_GPIO_Init(GPIOG, &amp;GPIO_InitStructure);\n\n//STM32H745I-Discovery or STM32H750B-DK evaluation board?\n#elif defined(USE_STM32H745I_DISCO) || defined(USE_STM32H750B_DISCO)\n   //Enable SYSCFG clock\n   __HAL_RCC_SYSCFG_CLK_ENABLE();\n\n   //Enable GPIO clocks\n   __HAL_RCC_GPIOA_CLK_ENABLE();\n   __HAL_RCC_GPIOB_CLK_ENABLE();\n   __HAL_RCC_GPIOC_CLK_ENABLE();\n   __HAL_RCC_GPIOE_CLK_ENABLE();\n   __HAL_RCC_GPIOG_CLK_ENABLE();\n   __HAL_RCC_GPIOH_CLK_ENABLE();\n   __HAL_RCC_GPIOI_CLK_ENABLE();\n\n   //Select MII interface mode\n   HAL_SYSCFG_ETHInterfaceSelect(SYSCFG_ETH_MII);\n\n   //Configure MII pins\n   GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;\n   GPIO_InitStructure.Pull = GPIO_NOPULL;\n   GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n   GPIO_InitStructure.Alternate = GPIO_AF11_ETH;\n\n   //Configure ETH_MII_RX_CLK (PA1), ETH_MDIO (PA2) and ETH_MII_RX_DV (PA7)\n   GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;\n   HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStructure);\n\n   //Configure ETH_MII_RXD2 (PB0), ETH_MII_RXD3 (PB1) and ETH_MII_RX_ER (PB2)\n   GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2;\n   HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStructure);\n\n   //Configure ETH_MDC (PC1), ETH_MII_TXD2 (PC2), ETH_MII_TX_CLK (PC3),\n   //ETH_MII_RXD0 (PC4) and ETH_MII_RXD1 (PC5)\n   GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_5;\n   HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStructure);\n\n   //Configure ETH_MII_TXD3 (PE2)\n   GPIO_InitStructure.Pin = GPIO_PIN_2;\n   HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStructure);\n\n   //Configure ETH_MII_TX_EN (PG11), ETH_MII_TXD1 (PG12) and ETH_MII_TXD0 (PG13)\n   GPIO_InitStructure.Pin = GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13;\n   HAL_GPIO_Init(GPIOG, &amp;GPIO_InitStructure);\n\n   //Configure ETH_MII_CRS (PH2) and ETH_MII_COL (PH3)\n   //GPIO_InitStructure.Pin = GPIO_PIN_2 | GPIO_PIN_3;\n   //HAL_GPIO_Init(GPIOH, &amp;GPIO_InitStructure);\n\n   //Configure ETH_MII_RX_ER (PI10)\n   GPIO_InitStructure.Pin = GPIO_PIN_10;\n   HAL_GPIO_Init(GPIOI, &amp;GPIO_InitStructure);\n\n//Nucleo-H743ZI, Nucleo-H743ZI2 or Nucleo-H745ZI-Q evaluation board?\n#elif defined(USE_STM32H7XX_NUCLEO_144) || defined(USE_STM32H7XX_NUCLEO_144_MB1363) || \\\n   defined(USE_STM32H7XX_NUCLEO_144_MB1364)\n   //Enable SYSCFG clock\n   __HAL_RCC_SYSCFG_CLK_ENABLE();\n\n   //Enable GPIO clocks\n   __HAL_RCC_GPIOA_CLK_ENABLE();\n   __HAL_RCC_GPIOB_CLK_ENABLE();\n   __HAL_RCC_GPIOC_CLK_ENABLE();\n   __HAL_RCC_GPIOG_CLK_ENABLE();\n\n   //Select RMII interface mode\n   HAL_SYSCFG_ETHInterfaceSelect(SYSCFG_ETH_RMII);\n\n   //Configure RMII pins\n   GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;\n   GPIO_InitStructure.Pull = GPIO_NOPULL;\n   GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n   GPIO_InitStructure.Alternate = GPIO_AF11_ETH;\n\n   //Configure ETH_RMII_REF_CLK (PA1), ETH_MDIO (PA2) and ETH_RMII_CRS_DV (PA7)\n   GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;\n   HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStructure);\n\n   //Configure ETH_RMII_TXD1 (PB13)\n   GPIO_InitStructure.Pin = GPIO_PIN_13;\n   HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStructure);\n\n   //Configure ETH_MDC (PC1), ETH_RMII_RXD0 (PC4) and ETH_RMII_RXD1 (PC5)\n   GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;\n   HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStructure);\n\n   //Configure RMII_TX_EN (PG11) and ETH_RMII_TXD0 (PG13)\n   GPIO_InitStructure.Pin = GPIO_PIN_11 | GPIO_PIN_13;\n   HAL_GPIO_Init(GPIOG, &amp;GPIO_InitStructure);\n#endif\n}',
 'void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &amp;x1, &amp;y1, &amp;w1, &amp;h1, "rfbScaledScreenUpdateRect");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen-&gt;bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen-&gt;frameBuffer +\n     (y0 * screen-&gt;paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr-&gt;frameBuffer +\n     ( y1 * ptr-&gt;paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) &gt; (ptr-&gt;width))\n    {\n      if (x1==0) w1=ptr-&gt;width; else x1 = ptr-&gt;width - w1;\n    }\n    if ((y1+h1) &gt; (ptr-&gt;height))\n    {\n      if (y1==0) h1=ptr-&gt;height; else y1 = ptr-&gt;height - h1;\n    }\n    /*\n     * rfbLog("rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  -&gt;  %dXx%dY-%dWx%dH &lt;%dx%d&gt;) {%dWx%dH -&gt; %dWx%dH} 0x%p\\n",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen-&gt;width, screen-&gt;height, ptr-&gt;width, ptr-&gt;height, ptr-&gt;frameBuffer);\n     */\n\n    if (screen-&gt;serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen-&gt;serverFormat.redShift;\n      unsigned int greenShift = screen-&gt;serverFormat.greenShift;\n      unsigned int blueShift = screen-&gt;serverFormat.blueShift;\n      unsigned long redMax = screen-&gt;serverFormat.redMax;\n      unsigned long greenMax = screen-&gt;serverFormat.greenMax;\n      unsigned long blueMax = screen-&gt;serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y &lt; h1; y++) {\n       for (x = 0; x &lt; w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w &lt; areaX; w++) {\n           for (v = 0; v &lt; areaY; v++) {\n             srcptr2 = &amp;srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen-&gt;paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z &lt; bytesPerPixel; z++)\n                 pixel_value += (srcptr2[z] &lt;&lt; (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value &gt;&gt; redShift) &amp; redMax);\n            green += ((pixel_value &gt;&gt; greenShift) &amp; greenMax);\n            blue += ((pixel_value &gt;&gt; blueShift) &amp; blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red &amp; redMax) &lt;&lt; redShift) | ((green &amp; greenMax) &lt;&lt; greenShift) | ((blue &amp; blueMax) &lt;&lt; blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z &lt; bytesPerPixel; z++)\n             dstptr[z]=(pixel_value &gt;&gt; (8 * z)) &amp; 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen-&gt;paddedWidthInBytes * areaY);\n       dstptr += (ptr-&gt;paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can\'t blend. Just use the top-left pixel instead */\n     for (y = y1; y &lt; (y1+h1); y++) {\n       for (x = x1; x &lt; (x1+w1); x++)\n         memcpy (&amp;ptr-&gt;frameBuffer[(y *ptr-&gt;paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &amp;screen-&gt;frameBuffer[(y * areaY * screen-&gt;paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}',
 'static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n\n    written++;\n    channel_id = hdr &amp; 0x3F;\n\n    if (channel_id &lt; 2) { //special case for channel number &gt;= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    }\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) &lt; 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n\n    hdr &gt;&gt;= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n            }\n        }\n    }\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    }\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n\n    if (prev_pkt[channel_id].read &amp;&amp; size != prev_pkt[channel_id].size) {\n        av_log(NULL, AV_LOG_ERROR, "RTMP packet size mismatch %d != %d\\n",\n                size,\n                prev_pkt[channel_id].size);\n        ff_rtmp_packet_destroy(&amp;prev_pkt[channel_id]);\n        prev_pkt[channel_id].read = 0;\n    }\n\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) &lt; 0)\n            return ret;\n        p-&gt;read = written;\n        p-&gt;offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn\'t completed reading\n        RTMPPacket *prev = &amp;prev_pkt[channel_id];\n        p-&gt;data          = prev-&gt;data;\n        p-&gt;size          = prev-&gt;size;\n        p-&gt;channel_id    = prev-&gt;channel_id;\n        p-&gt;type          = prev-&gt;type;\n        p-&gt;ts_field      = prev-&gt;ts_field;\n        p-&gt;extra         = prev-&gt;extra;\n        p-&gt;offset        = prev-&gt;offset;\n        p-&gt;read          = prev-&gt;read + written;\n        p-&gt;timestamp     = prev-&gt;timestamp;\n        prev-&gt;data       = NULL;\n    }\n    p-&gt;extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p-&gt;offset;\n\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p-&gt;data + p-&gt;offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    }\n    size      -= toread;\n    p-&gt;read   += toread;\n    p-&gt;offset += toread;\n\n    if (size &gt; 0) {\n       RTMPPacket *prev = &amp;prev_pkt[channel_id];\n       prev-&gt;data = p-&gt;data;\n       prev-&gt;read = p-&gt;read;\n       prev-&gt;offset = p-&gt;offset;\n       p-&gt;data      = NULL;\n       return AVERROR(EAGAIN);\n    }\n\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p-&gt;read;\n}',
 'spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}',
 'ga_add_string(garray_T *gap, char_u *p)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ((char_u **)(gap-&gt;ga_data))[gap-&gt;ga_len++] = p;\n    return OK;\n}',
 'static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev-&gt;parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar *data;\n\n\tdata = kmalloc(2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret &lt; 0) {\n\t\tdev_warn(dev, "Failed to get K90 initial mode (error %d).\\n",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = "HW";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = "SW";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, "K90 in unknown mode: %02hhx.\\n",\n\t\t\t data[0]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, "%s\\n", macro_mode);\nout:\n\tkfree(data);\n\n\treturn ret;\n}',
 'ignore_error_for_testing(char_u *error)\n{\n    if (ignore_error_list.ga_itemsize == 0)\n\tga_init2(&amp;ignore_error_list, sizeof(char_u *), 1);\n\n    if (STRCMP("RESET", error) == 0)\n\tga_clear_strings(&amp;ignore_error_list);\n    else\n\tga_copy_string(&amp;ignore_error_list, error);\n}',
 'static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 2, &amp;tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}',
 'static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path("I0012", &amp;path);\n\tr = sc_select_file(card, &amp;path, &amp;file);\n\tif (r) {\n\t\tfprintf(stderr, "Unable to select private key file: %s\\n", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e-&gt;method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = MIN(file-&gt;size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r &lt; 0) {\n\t\tfprintf(stderr, "Unable to read private key file: %s\\n", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize &lt; 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] &lt;&lt; 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize &lt; 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf("Key number %d not found.\\n", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}',
 'static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (!(*value = strchr(*cp, \'=\')))\n\t\treturn 0;\n\n\t**value = \'\\0\';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\n\tif (**value == \'"\') {\n\t\tchar *p = end = *value + 1;\n\n\t\t/* convert \'foo\\"bar\'  to \'foo"bar\' */\n\t\twhile (*p) {\n\t\t\tif (*p == \'\\\\\') {\n\t\t\t\tp++;\n\t\t\t\t*end = *p;\n\t\t\t} else {\n\t\t\t\t*end = *p;\n\t\t\t\tif (*p == \'"\')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tend++;\n\t\t}\n\n\t\tif (*end != \'"\') {\n\t\t\tDBG(READ, ul_debug("unbalanced quotes at: %s", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = \'\\0\';\n\t\tend = ++p;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = \'\\0\';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\n\treturn 1;\n}',
 "_zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n    zip_uint64_t offset;\n    zip_uint8_t eocd[EOCD64LEN];\n    zip_uint64_t eocd_offset;\n    zip_uint64_t size, nentry, i, eocdloc_offset;\n    bool free_buffer;\n    zip_uint32_t num_disks, num_disks64, eocd_disk, eocd_disk64;\n\n    eocdloc_offset = _zip_buffer_offset(buffer);\n\n    _zip_buffer_get(buffer, 4); /* magic already verified */\n\n    num_disks = _zip_buffer_get_16(buffer);\n    eocd_disk = _zip_buffer_get_16(buffer);\n    eocd_offset = _zip_buffer_get_64(buffer);\n\n    if (eocd_offset &gt; ZIP_INT64_MAX || eocd_offset + EOCD64LEN &lt; eocd_offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n\n    if (eocd_offset + EOCD64LEN &gt; eocdloc_offset + buf_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if (eocd_offset &gt;= buf_offset &amp;&amp; eocd_offset + EOCD64LEN &lt;= buf_offset + _zip_buffer_size(buffer)) {\n        _zip_buffer_set_offset(buffer, eocd_offset - buf_offset);\n        free_buffer = false;\n    }\n    else {\n        if (zip_source_seek(src, (zip_int64_t)eocd_offset, SEEK_SET) &lt; 0) {\n            _zip_error_set_from_source(error, src);\n            return NULL;\n        }\n        if ((buffer = _zip_buffer_new_from_source(src, EOCD64LEN, eocd, error)) == NULL) {\n            return NULL;\n        }\n        free_buffer = true;\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), EOCD64_MAGIC, 4) != 0) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_64(buffer);\n\n    if ((flags &amp; ZIP_CHECKCONS) &amp;&amp; size + eocd_offset + 12 != buf_offset + eocdloc_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return NULL;\n    }\n\n    _zip_buffer_get(buffer, 4); /* skip version made by/needed */\n\n    num_disks64 = _zip_buffer_get_32(buffer);\n    eocd_disk64 = _zip_buffer_get_32(buffer);\n\n    /* if eocd values are 0xffff, we have to use eocd64 values.\n       otherwise, if the values are not the same, it's inconsistent;\n       in any case, if the value is not 0, we don't support it */\n    if (num_disks == 0xffff) {\n\tnum_disks = num_disks64;\n    }\n    if (eocd_disk == 0xffff) {\n\teocd_disk = eocd_disk64;\n    }\n    if ((flags &amp; ZIP_CHECKCONS) &amp;&amp; (eocd_disk != eocd_disk64 || num_disks != num_disks64)) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n    if (num_disks != 0 || eocd_disk != 0) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    nentry = _zip_buffer_get_64(buffer);\n    i = _zip_buffer_get_64(buffer);\n\n    if (nentry != i) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_64(buffer);\n    offset = _zip_buffer_get_64(buffer);\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return NULL;\n    }\n\n    if (free_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    if (offset &gt; ZIP_INT64_MAX || offset+size &lt; offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n    if ((flags &amp; ZIP_CHECKCONS) &amp;&amp; offset+size != eocd_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if ((cd=_zip_cdir_new(nentry, error)) == NULL)\n\treturn NULL;\n\n    cd-&gt;is_zip64 = true;\n    cd-&gt;size = size;\n    cd-&gt;offset = offset;\n\n    return cd;\n}",
 'static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd-&gt;len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd-&gt;id = cmd_id;\n\tcmd-&gt;u.simple.channel = priv-&gt;channel;\n\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd-&gt;len);\n\tif (err)\n\t\tkfree(cmd);\n\n\treturn err;\n}',
 'static int check_options(int argc, char **argv, char *operation)\n{\n  int i= 0;                    // loop counter\n  int num_found= 0;            // number of options found (shortcut loop)\n  char config_file[FN_REFLEN]; // configuration file name\n  char plugin_name[FN_REFLEN]; // plugin name\n  \n  /* Form prefix strings for the options. */\n  const char *basedir_prefix = "--basedir=";\n  int basedir_len= strlen(basedir_prefix);\n  const char *datadir_prefix = "--datadir=";\n  int datadir_len= strlen(datadir_prefix);\n  const char *plugin_dir_prefix = "--plugin_dir=";\n  int plugin_dir_len= strlen(plugin_dir_prefix);\n\n  strcpy(plugin_name, "");\n  for (i = 0; i &lt; argc &amp;&amp; num_found &lt; 5; i++)\n  {\n\n    if (!argv[i])\n    {\n      continue;\n    }\n    if ((strcasecmp(argv[i], "ENABLE") == 0) ||\n        (strcasecmp(argv[i], "DISABLE") == 0))\n    {\n      strcpy(operation, argv[i]);\n      num_found++;\n    }\n    else if ((strncasecmp(argv[i], basedir_prefix, basedir_len) == 0) &amp;&amp;\n             !opt_basedir)\n    {\n      opt_basedir= my_strndup(argv[i]+basedir_len,\n                              strlen(argv[i])-basedir_len, MYF(MY_FAE));\n      num_found++;\n    }\n    else if ((strncasecmp(argv[i], datadir_prefix, datadir_len) == 0) &amp;&amp;\n             !opt_datadir)\n    {\n      opt_datadir= my_strndup(argv[i]+datadir_len,\n                              strlen(argv[i])-datadir_len, MYF(MY_FAE));\n      num_found++;\n    }\n    else if ((strncasecmp(argv[i], plugin_dir_prefix, plugin_dir_len) == 0) &amp;&amp;\n             !opt_plugin_dir)\n    {\n      opt_plugin_dir= my_strndup(argv[i]+plugin_dir_len,\n                                 strlen(argv[i])-plugin_dir_len, MYF(MY_FAE));\n      num_found++;\n    }\n    /* read the plugin config file and check for match against argument */\n    else\n    {\n      if (strlen(argv[i]) + 4 + 1 &gt; FN_REFLEN)\n      {\n        fprintf(stderr, "ERROR: argument is too long.\\n");\n        return 1;\n      }\n      strcpy(plugin_name, argv[i]);\n      strcpy(config_file, argv[i]);\n      strcat(config_file, ".ini");\n    }\n  }\n\n  if (!opt_basedir)\n  {\n    fprintf(stderr, "ERROR: Missing --basedir option.\\n");\n    return 1;\n  }\n\n  if (!opt_datadir)\n  {\n    fprintf(stderr, "ERROR: Missing --datadir option.\\n");\n    return 1;\n  }\n\n  if (!opt_plugin_dir)\n  {\n    fprintf(stderr, "ERROR: Missing --plugin_dir option.\\n");\n    return 1;\n  }\n  /* If a plugin was specified, read the config file. */\n  else if (strlen(plugin_name) &gt; 0) \n  {\n    if (load_plugin_data(plugin_name, config_file))\n    {\n      return 1;\n    }\n    if (strcasecmp(plugin_data.name, plugin_name) != 0)\n    {\n      fprintf(stderr, "ERROR: plugin name requested does not match config "\n              "file data.\\n");\n      return 1;\n    }\n  }\n  else\n  {\n    fprintf(stderr, "ERROR: No plugin specified.\\n");\n    return 1;\n  }\n\n  if ((strlen(operation) == 0))\n  {\n    fprintf(stderr, "ERROR: missing operation. Please specify either "\n            "\'&lt;plugin&gt; ENABLE\' or \'&lt;plugin&gt; DISABLE\'.\\n");\n    return 1;\n  }\n\n  return 0;\n}',
 'static int closeVirtualHostDirective(MaState *state, cchar *key, cchar *value)\n{\n    HttpEndpoint    *endpoint;\n    char            *address, *ip, *addresses, *tok;\n    int             port;\n\n    if (state-&gt;enabled) { \n        if (state-&gt;endpoints &amp;&amp; *state-&gt;endpoints) {\n            for (addresses = sclone(state-&gt;endpoints); (address = stok(addresses, " \\t,", &amp;tok)) != 0 ; addresses = tok) {\n                mprParseSocketAddress(address, &amp;ip, &amp;port, NULL, -1);\n                if ((endpoint = httpLookupEndpoint(ip, port)) == 0) {\n                    mprLog("error appweb config", 0, "Cannot find listen directive for virtual host %s", address);\n                    return MPR_ERR_BAD_SYNTAX;\n                } else {\n                    httpAddHostToEndpoint(endpoint, state-&gt;host);\n                }\n            }\n        } else {\n            httpAddHostToEndpoints(state-&gt;host);\n        }\n    }\n    closeDirective(state, key, value);\n    return 0;\n}',
 'int main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&amp;tmpname, NULL);\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}',
 'makepol(QPRS_STATE *state)\n{\n\tint32\t\tval = 0,\n\t\t\t\ttype;\n\tint32\t\tlenval = 0;\n\tchar\t   *strval = NULL;\n\tint32\t\tstack[STACKDEPTH];\n\tint32\t\tlenstack = 0;\n\tuint16\t\tflag = 0;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\twhile ((type = gettoken_query(state, &amp;val, &amp;lenval, &amp;strval, &amp;flag)) != END)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase VAL:\n\t\t\t\tpushval_asis(state, VAL, strval, lenval, flag);\n\t\t\t\twhile (lenstack &amp;&amp; (stack[lenstack - 1] == (int32) \'&amp;\' ||\n\t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) \'!\'))\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OPR:\n\t\t\t\tif (lenstack &amp;&amp; val == (int32) \'|\')\n\t\t\t\t\tpushquery(state, OPR, val, 0, 0, 0);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (lenstack == STACKDEPTH)\n\t\t\t\t\t\t/* internal error */\n\t\t\t\t\t\telog(ERROR, "stack too short");\n\t\t\t\t\tstack[lenstack] = val;\n\t\t\t\t\tlenstack++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OPEN:\n\t\t\t\tif (makepol(state) == ERR)\n\t\t\t\t\treturn ERR;\n\t\t\t\twhile (lenstack &amp;&amp; (stack[lenstack - 1] == (int32) \'&amp;\' ||\n\t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) \'!\'))\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\twhile (lenstack)\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t};\n\t\t\t\treturn END;\n\t\t\t\tbreak;\n\t\t\tcase ERR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg("syntax error")));\n\n\t\t\t\treturn ERR;\n\n\t\t}\n\t}\n\twhile (lenstack)\n\t{\n\t\tlenstack--;\n\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t};\n\treturn END;\n}',
 'int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\n\t\t       unsigned int cmd, void __user *arg)\n{\n\tint ret;\n\n\tret = scsi_verify_blk_ioctl(bd, cmd);\n\tif (ret &lt; 0)\n\t\treturn ret;\n\n\treturn scsi_cmd_ioctl(bd-&gt;bd_disk-&gt;queue, bd-&gt;bd_disk, mode, cmd, arg);\n}',
 'destroyPresentationContextList(LST_HEAD ** l)\n{\n    PRV_PRESENTATIONCONTEXTITEM\n    * prvCtx;\n    DUL_SUBITEM\n        * subItem;\n\n    if (*l == NULL)\n        return;\n\n    prvCtx = (PRV_PRESENTATIONCONTEXTITEM*)LST_Dequeue(l);\n    while (prvCtx != NULL) {\n        subItem = (DUL_SUBITEM*)LST_Dequeue(&amp;prvCtx-&gt;transferSyntaxList);\n        while (subItem != NULL) {\n            free(subItem);\n            subItem = (DUL_SUBITEM*)LST_Dequeue(&amp;prvCtx-&gt;transferSyntaxList);\n        }\n        LST_Destroy(&amp;prvCtx-&gt;transferSyntaxList);\n        free(prvCtx);\n        prvCtx = (PRV_PRESENTATIONCONTEXTITEM*)LST_Dequeue(l);\n    }\n    LST_Destroy(l);\n}',
 'int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q-&gt;mq_ops);\n\n\tq-&gt;fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q-&gt;cmd_size);\n\tif (!q-&gt;fq)\n\t\treturn -ENOMEM;\n\n\tif (q-&gt;init_rq_fn &amp;&amp; q-&gt;init_rq_fn(q, q-&gt;fq-&gt;flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&amp;q-&gt;root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&amp;q-&gt;timeout_work, blk_timeout_work);\n\tq-&gt;queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t/*\n\t * This also sets hw/phys segments, boundary and size\n\t */\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq-&gt;sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q-&gt;exit_rq_fn)\n\t\tq-&gt;exit_rq_fn(q, q-&gt;fq-&gt;flush_rq);\nout_free_flush_queue:\n\tblk_free_flush_queue(q-&gt;fq);\n\tq-&gt;fq = NULL;\n\treturn -ENOMEM;\n}',
 'string encryptBLSKeyShare2Hex(int *errStatus, char *err_string, const char *_key) {\n    CHECK_STATE(errStatus);\n    CHECK_STATE(err_string);\n    CHECK_STATE(_key);\n    auto keyArray = make_shared&lt;vector&lt;char&gt;&gt;(BUF_LEN, 0);\n    auto encryptedKey = make_shared&lt;vector&lt;uint8_t&gt;&gt;(BUF_LEN, 0);\n\n    vector&lt;char&gt; errMsg(BUF_LEN, 0);\n\n    strncpy(keyArray-&gt;data(), _key, BUF_LEN);\n    *errStatus = 0;\n\n    uint64_t encryptedLen = 0;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray-&gt;data(), encryptedKey-&gt;data(), &amp;encryptedLen);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, *errStatus, errMsg.data());\n\n    SAFE_CHAR_BUF(resultBuf, 2 * BUF_LEN + 1);\n\n    carray2Hex(encryptedKey-&gt;data(), encryptedLen, resultBuf, 2 * BUF_LEN + 1);\n\n    return string(resultBuf);\n}',
 'vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg &amp;&amp; lun) {\n\t\t/* TODO: share lun setup code with virtio-scsi.ko */\n\t\t/*\n\t\t * Note: evt-&gt;event is zeroed when we allocate it and\n\t\t * lun[4-7] need to be zero according to virtio-scsi spec.\n\t\t */\n\t\tevt-&gt;event.lun[0] = 0x01;\n\t\tevt-&gt;event.lun[1] = tpg-&gt;tport_tpgt &amp; 0xFF;\n\t\tif (lun-&gt;unpacked_lun &gt;= 256)\n\t\t\tevt-&gt;event.lun[2] = lun-&gt;unpacked_lun &gt;&gt; 8 | 0x40 ;\n\t\tevt-&gt;event.lun[3] = lun-&gt;unpacked_lun &amp; 0xFF;\n\t}\n\n\tllist_add(&amp;evt-&gt;list, &amp;vs-&gt;vs_event_list);\n\tvhost_work_queue(&amp;vs-&gt;dev, &amp;vs-&gt;vs_event_work);\n}',
 'static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp-&gt;input, 28);\n\t/* DesiredAccess(4) AllocationSize(8), FileAttributes(4) */\n\t/* SharedAccess(4) CreateDisposition(4), CreateOptions(4) */\n\tStream_Read_UINT32(irp-&gt;input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp-&gt;input), PathLength / 2,\n\t                            &amp;path, 0, NULL, NULL);\n\n\tif (status &lt; 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, "calloc failed!");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\tparallel-&gt;id = irp-&gt;devman-&gt;id_sequence++;\n\tparallel-&gt;file = open(parallel-&gt;path, O_RDWR);\n\n\tif (parallel-&gt;file &lt; 0)\n\t{\n\t\tirp-&gt;IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel-&gt;id = 0;\n\t}\n\telse\n\t{\n\t\t/* all read and write operations should be non-blocking */\n\t\tif (fcntl(parallel-&gt;file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp-&gt;output, parallel-&gt;id);\n\tStream_Write_UINT8(irp-&gt;output, 0);\n\tfree(path);\n\treturn irp-&gt;Complete(irp);\n}',
 'cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n\n\t/* Sanity checks\n\t */\n\tif ((conn-&gt;validator == NULL) ||\n\t    cherokee_buffer_is_empty (&amp;conn-&gt;validator-&gt;user) ||\n\t    cherokee_buffer_is_empty (&amp;conn-&gt;validator-&gt;passwd))\n\t\treturn ret_error;\n\n\tsize = cherokee_buffer_cnt_cspn (&amp;conn-&gt;validator-&gt;user, 0, "*()");\n\tif (size != conn-&gt;validator-&gt;user.len)\n\t\treturn ret_error;\n\n\t/* Build filter\n\t */\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\n\t/* Search\n\t */\n\tre = ldap_search_s (ldap-&gt;conn, props-&gt;basedn.buf, LDAP_SCOPE_SUBTREE, ldap-&gt;filter.buf, attrs, 0, &amp;message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props-&gt;filter.buf ? props-&gt;filter.buf : "");\n\t\treturn ret_error;\n\t}\n\n\tTRACE (ENTRIES, "subtree search (%s): done\\n", ldap-&gt;filter.buf ? ldap-&gt;filter.buf : "");\n\n\t/* Check that there a single entry\n\t */\n\tre = ldap_count_entries (ldap-&gt;conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\n\t/* Pick up the first one\n\t */\n\tfirst = ldap_first_entry (ldap-&gt;conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\n\t/* Get DN\n\t */\n\tdn = ldap_get_dn (ldap-&gt;conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\n\tldap_msgfree (message);\n\n\t/* Check that it\'s right\n\t */\n\tret = validate_dn (props, dn, conn-&gt;validator-&gt;passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\n\t/* Disconnect from the LDAP server\n\t */\n\tre = ldap_unbind_s (ldap-&gt;conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\n\t/* Validated!\n\t */\n\tTRACE (ENTRIES, "Access to use %s has been granted\\n", conn-&gt;validator-&gt;user.buf);\n\n\treturn ret_ok;\n}',
 'ConnectClientToUnixSock(const char *sockFile)\n{\n#ifdef WIN32\n  rfbClientErr("Windows doesn\'t support UNIX sockets\\n");\n  return -1;\n#else\n  int sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  if(strlen(sockFile) + 1 &gt; sizeof(addr.sun_path)) {\n      rfbClientErr("ConnectToUnixSock: socket file name too long\\n");\n      return -1;\n  }\n  strcpy(addr.sun_path, sockFile);\n\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock &lt; 0) {\n    rfbClientErr("ConnectToUnixSock: socket (%s)\\n",strerror(errno));\n    return -1;\n  }\n\n  if (connect(sock, (struct sockaddr *)&amp;addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) &lt; 0) {\n    rfbClientErr("ConnectToUnixSock: connect\\n");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n#endif\n}',
 'isis_print_mt_port_cap_subtlv(netdissect_options *ndo,\n                              const uint8_t *tptr, int len)\n{\n  int stlv_type, stlv_len;\n  const struct isis_subtlv_spb_mcid *subtlv_spb_mcid;\n  int i;\n\n  while (len &gt; 2)\n  {\n    stlv_type = *(tptr++);\n    stlv_len  = *(tptr++);\n\n    /* first lets see if we know the subTLVs name*/\n    ND_PRINT((ndo, "\\n\\t       %s subTLV #%u, length: %u",\n               tok2str(isis_mt_port_cap_subtlv_values, "unknown", stlv_type),\n               stlv_type,\n               stlv_len));\n\n    /*len -= TLV_TYPE_LEN_OFFSET;*/\n    len = len -2;\n\n    switch (stlv_type)\n    {\n      case ISIS_SUBTLV_SPB_MCID:\n      {\n        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_MCID_MIN_LEN);\n\n        subtlv_spb_mcid = (const struct isis_subtlv_spb_mcid *)tptr;\n\n        ND_PRINT((ndo,  "\\n\\t         MCID: "));\n        isis_print_mcid(ndo, &amp;(subtlv_spb_mcid-&gt;mcid));\n\n          /*tptr += SPB_MCID_MIN_LEN;\n            len -= SPB_MCID_MIN_LEN; */\n\n        ND_PRINT((ndo,  "\\n\\t         AUX-MCID: "));\n        isis_print_mcid(ndo, &amp;(subtlv_spb_mcid-&gt;aux_mcid));\n\n          /*tptr += SPB_MCID_MIN_LEN;\n            len -= SPB_MCID_MIN_LEN; */\n        tptr = tptr + sizeof(struct isis_subtlv_spb_mcid);\n        len = len - sizeof(struct isis_subtlv_spb_mcid);\n\n        break;\n      }\n\n      case ISIS_SUBTLV_SPB_DIGEST:\n      {\n        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_DIGEST_MIN_LEN);\n\n        ND_PRINT((ndo, "\\n\\t        RES: %d V: %d A: %d D: %d",\n                        (*(tptr) &gt;&gt; 5), (((*tptr)&gt;&gt; 4) &amp; 0x01),\n                        ((*(tptr) &gt;&gt; 2) &amp; 0x03), ((*tptr) &amp; 0x03)));\n\n        tptr++;\n\n        ND_PRINT((ndo,  "\\n\\t         Digest: "));\n\n        for(i=1;i&lt;=8; i++)\n        {\n            ND_PRINT((ndo, "%08x ", EXTRACT_32BITS(tptr)));\n            if (i%4 == 0 &amp;&amp; i != 8)\n              ND_PRINT((ndo, "\\n\\t                 "));\n            tptr = tptr + 4;\n        }\n\n        len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;\n\n        break;\n      }\n\n      case ISIS_SUBTLV_SPB_BVID:\n      {\n        ND_TCHECK2(*(tptr), stlv_len);\n\n        while (len &gt;= ISIS_SUBTLV_SPB_BVID_MIN_LEN)\n        {\n          ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_BVID_MIN_LEN);\n\n          ND_PRINT((ndo, "\\n\\t           ECT: %08x",\n                      EXTRACT_32BITS(tptr)));\n\n          tptr = tptr+4;\n\n          ND_PRINT((ndo, " BVID: %d, U:%01x M:%01x ",\n                     (EXTRACT_16BITS (tptr) &gt;&gt; 4) ,\n                     (EXTRACT_16BITS (tptr) &gt;&gt; 3) &amp; 0x01,\n                     (EXTRACT_16BITS (tptr) &gt;&gt; 2) &amp; 0x01));\n\n          tptr = tptr + 2;\n          len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN;\n        }\n\n        break;\n      }\n\n      default:\n          break;\n    }\n  }\n\n  return 0;\n\n  trunc:\n    ND_PRINT((ndo, "\\n\\t\\t"));\n    ND_PRINT((ndo, "%s", tstr));\n    return(1);\n}',
 'static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock-&gt;sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint val;\n\tint err;\n\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\n\tif (optlen &lt; sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\terr = -ENOTCONN;\n\tif (sk-&gt;sk_user_data == NULL)\n\t\tgoto end;\n\n\t/* Get session context from the socket */\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\n\t/* Special case: if session_id == 0x0000, treat as operation on tunnel\n\t */\n\tps = l2tp_session_priv(session);\n\tif ((session-&gt;session_id == 0) &amp;&amp;\n\t    (session-&gt;peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps-&gt;tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\n\t\terr = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\n\t\tsock_put(ps-&gt;tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_setsockopt(sk, session, optname, val);\n\n\terr = 0;\n\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}',
 'bool Archive::Close()\n{\n#ifdef USE_ARCMEM\n  if (ArcMem.Unload())\n    return true;\n#endif\n  return File::Close();\n}',
 'void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csr_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, "r" );\n  if ( l_csr_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose(l_csr_file_handle); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == \'%\' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, "%u %u %u", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC data-structure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csr_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i &lt;= *o_row_count; ++l_i )\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_DESC );\n          fclose( l_csr_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, "%u %u %lf", &amp;l_row, &amp;l_column, &amp;l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csr_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_LEN );\n    return;\n  }\n\n  if ( l_row_idx_id != NULL ) {\n    /* let\'s handle empty rows */\n    for ( l_i = 0; l_i &lt; (*o_row_count); l_i++) {\n      if ( l_row_idx_id[l_i] == 0 ) {\n        (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_row_idx_id );\n  }\n}',
 "int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char *tag;\n\tunsigned char opt_iter;\n\tunsigned char err_offset = 0;\n\tu8 opt_len;\n\tu8 tag_len;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tu32 tag_iter;\n\n\t/* caller already checks for length values that are too large */\n\topt_len = opt[1];\n\tif (opt_len &lt; 8) {\n\t\terr_offset = 1;\n\t\tgoto validate_return;\n\t}\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(get_unaligned_be32(&amp;opt[2]));\n\tif (doi_def == NULL) {\n\t\terr_offset = 2;\n\t\tgoto validate_return_locked;\n\t}\n\n\topt_iter = CIPSO_V4_HDR_LEN;\n\ttag = opt + opt_iter;\n\twhile (opt_iter &lt; opt_len) {\n\t\tfor (tag_iter = 0; doi_def-&gt;tags[tag_iter] != tag[0];)\n\t\t\tif (doi_def-&gt;tags[tag_iter] == CIPSO_V4_TAG_INVALID ||\n\t\t\t    ++tag_iter == CIPSO_V4_TAG_MAXCNT) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\ttag_len = tag[1];\n\t\tif (tag_len &gt; (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\tswitch (tag[0]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tif (tag_len &lt; CIPSO_V4_TAG_RBM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\t/* We are already going to do all the verification\n\t\t\t * necessary at the socket layer so from our point of\n\t\t\t * view it is safe to turn these checks off (and less\n\t\t\t * work), however, the CIPSO draft says we should do\n\t\t\t * all the CIPSO validations here but it doesn't\n\t\t\t * really specify _exactly_ what we need to validate\n\t\t\t * ... so, just make it a sysctl tunable. */\n\t\t\tif (cipso_v4_rbm_strictvalid) {\n\t\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t\t   tag[3]) &lt; 0) {\n\t\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t\tif (tag_len &gt; CIPSO_V4_TAG_RBM_BLEN &amp;&amp;\n\t\t\t\t    cipso_v4_map_cat_rbm_valid(doi_def,\n\t\t\t\t\t\t\t    &amp;tag[4],\n\t\t\t\t\t\t\t    tag_len - 4) &lt; 0) {\n\t\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tif (tag_len &lt; CIPSO_V4_TAG_ENUM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) &lt; 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len &gt; CIPSO_V4_TAG_ENUM_BLEN &amp;&amp;\n\t\t\t    cipso_v4_map_cat_enum_valid(doi_def,\n\t\t\t\t\t\t\t&amp;tag[4],\n\t\t\t\t\t\t\ttag_len - 4) &lt; 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\t\tif (tag_len &lt; CIPSO_V4_TAG_RNG_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) &lt; 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len &gt; CIPSO_V4_TAG_RNG_BLEN &amp;&amp;\n\t\t\t    cipso_v4_map_cat_rng_valid(doi_def,\n\t\t\t\t\t\t       &amp;tag[4],\n\t\t\t\t\t\t       tag_len - 4) &lt; 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_LOCAL:\n\t\t\t/* This is a non-standard tag that we only allow for\n\t\t\t * local connections, so if the incoming interface is\n\t\t\t * not the loopback device drop the packet. Further,\n\t\t\t * there is no legitimate reason for setting this from\n\t\t\t * userspace so reject it if skb is NULL. */\n\t\t\tif (skb == NULL || !(skb-&gt;dev-&gt;flags &amp; IFF_LOOPBACK)) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len != CIPSO_V4_TAG_LOC_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_offset = opt_iter;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\ttag += tag_len;\n\t\topt_iter += tag_len;\n\t}\n\nvalidate_return_locked:\n\trcu_read_unlock();\nvalidate_return:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}",
 'HexOutStream::overrun(int itemSize, int nItems) {\n  if (itemSize &gt; bufSize)\n    throw Exception("HexOutStream overrun: max itemSize exceeded");\n\n  writeBuffer();\n\n  if (itemSize * nItems &gt; end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}',
 'static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n{\n    int i;\n    uint16_t limit;\n    VncDisplay *vd = vs-&gt;vd;\n\n    if (data[0] &gt; 3) {\n        update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_BASE);\n    }\n\n    switch (data[0]) {\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n        if (len == 1)\n            return 20;\n\n        set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),\n                         read_u8(data, 6), read_u8(data, 7),\n                         read_u16(data, 8), read_u16(data, 10),\n                         read_u16(data, 12), read_u8(data, 14),\n                         read_u8(data, 15), read_u8(data, 16));\n        break;\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n        if (len == 1)\n            return 4;\n\n        if (len == 4) {\n            limit = read_u16(data, 2);\n            if (limit &gt; 0)\n                return 4 + (limit * 4);\n        } else\n            limit = read_u16(data, 2);\n\n        for (i = 0; i &lt; limit; i++) {\n            int32_t val = read_s32(data, 4 + (i * 4));\n            memcpy(data + 4 + (i * 4), &amp;val, sizeof(val));\n        }\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n        break;\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n        if (len == 1)\n            return 10;\n\n        framebuffer_update_request(vs,\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                   read_u16(data, 6), read_u16(data, 8));\n        break;\n    case VNC_MSG_CLIENT_KEY_EVENT:\n        if (len == 1)\n            return 8;\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n        break;\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n        if (len == 1)\n            return 6;\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n        break;\n    case VNC_MSG_CLIENT_CUT_TEXT:\n        if (len == 1) {\n            return 8;\n        }\n        if (len == 8) {\n            uint32_t dlen = read_u32(data, 4);\n            if (dlen &gt; (1 &lt;&lt; 20)) {\n                error_report("vnc: client_cut_text msg payload has %u bytes"\n                             " which exceeds our limit of 1MB.", dlen);\n                vnc_client_error(vs);\n                break;\n            }\n            if (dlen &gt; 0) {\n                return 8 + dlen;\n            }\n        }\n\n        client_cut_text(vs, read_u32(data, 4), data + 8);\n        break;\n    case VNC_MSG_CLIENT_QEMU:\n        if (len == 1)\n            return 2;\n\n        switch (read_u8(data, 1)) {\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n            if (len == 2)\n                return 12;\n\n            ext_key_event(vs, read_u16(data, 2),\n                          read_u32(data, 4), read_u32(data, 8));\n            break;\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n            if (len == 2)\n                return 4;\n\n            switch (read_u16 (data, 2)) {\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                audio_add(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                audio_del(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                if (len == 4)\n                    return 10;\n                switch (read_u8(data, 4)) {\n                case 0: vs-&gt;as.fmt = AUD_FMT_U8; break;\n                case 1: vs-&gt;as.fmt = AUD_FMT_S8; break;\n                case 2: vs-&gt;as.fmt = AUD_FMT_U16; break;\n                case 3: vs-&gt;as.fmt = AUD_FMT_S16; break;\n                case 4: vs-&gt;as.fmt = AUD_FMT_U32; break;\n                case 5: vs-&gt;as.fmt = AUD_FMT_S32; break;\n                default:\n                    printf("Invalid audio format %d\\n", read_u8(data, 4));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs-&gt;as.nchannels = read_u8(data, 5);\n                if (vs-&gt;as.nchannels != 1 &amp;&amp; vs-&gt;as.nchannels != 2) {\n                    printf("Invalid audio channel coount %d\\n",\n                           read_u8(data, 5));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs-&gt;as.freq = read_u32(data, 6);\n                break;\n            default:\n                printf ("Invalid audio message %d\\n", read_u8(data, 4));\n                vnc_client_error(vs);\n                break;\n            }\n            break;\n\n        default:\n            printf("Msg: %d\\n", read_u16(data, 0));\n            vnc_client_error(vs);\n            break;\n        }\n        break;\n    default:\n        printf("Msg: %d\\n", data[0]);\n        vnc_client_error(vs);\n        break;\n    }\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n    return 0;\n}',
 'kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data-&gt;length;\n    req_data.data = (char *)pa_data-&gt;contents;\n\n    code = decode_krb5_pa_for_user(&amp;req_data, &amp;for_user);\n    if (code)\n        return code;\n\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = "INVALID_S4U2SELF_CHECKSUM";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n\n    (*s4u_x509_user)-&gt;user_id.user = for_user-&gt;user;\n    for_user-&gt;user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n\n    return 0;\n}',
 'dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * ftrace must be first, everything else may cause a recursive crash.\n\t * See note by declaration of modifying_ftrace_code in ftrace.c\n\t */\n\tif (unlikely(atomic_read(&amp;modifying_ftrace_code)) &amp;&amp;\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), "entry code didn\'t wake RCU");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, "int3", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif /* CONFIG_KGDB_LOW_LEVEL_TRAP */\n\n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\n\tif (notify_die(DIE_INT3, "int3", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\n\t/*\n\t * Let others (NMI) know that the debug stack is in use\n\t * as we may switch to the interrupt stack.\n\t */\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, "int3", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}',
 'static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\n\t/*s-&gt;current_picture.reference= h-&gt;nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, "first_mb_in_slice");\n\tsi-&gt;slice_type = gf_bs_read_ue_log(bs, "slice_type");\n\tif (si-&gt;slice_type &gt; 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, "pps_id");\n\tif (pps_id &gt; 255) return -1;\n\tsi-&gt;pps = &amp;avc-&gt;pps[pps_id];\n\tif (!si-&gt;pps-&gt;slice_group_count) return -2;\n\tsi-&gt;sps = &amp;avc-&gt;sps[si-&gt;pps-&gt;sps_id];\n\tif (!si-&gt;sps-&gt;log2_max_frame_num) return -2;\n\tavc-&gt;sps_active_idx = si-&gt;pps-&gt;sps_id;\n\tavc-&gt;pps_active_idx = pps_id;\n\n\tsi-&gt;frame_num = gf_bs_read_int_log(bs, si-&gt;sps-&gt;log2_max_frame_num, "frame_num");\n\n\tsi-&gt;field_pic_flag = 0;\n\tsi-&gt;bottom_field_flag = 0;\n\tif (!si-&gt;sps-&gt;frame_mbs_only_flag) {\n\t\tsi-&gt;field_pic_flag = gf_bs_read_int_log(bs, 1, "field_pic_flag");\n\t\tif (si-&gt;field_pic_flag)\n\t\t\tsi-&gt;bottom_field_flag = gf_bs_read_int_log(bs, 1, "bottom_field_flag");\n\t}\n\n\tif ((si-&gt;nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)\n\t\tsi-&gt;idr_pic_id = gf_bs_read_ue_log(bs, "idr_pic_id");\n\n\tif (si-&gt;sps-&gt;poc_type == 0) {\n\t\tsi-&gt;poc_lsb = gf_bs_read_int_log(bs, si-&gt;sps-&gt;log2_max_poc_lsb, "poc_lsb");\n\t\tif (si-&gt;pps-&gt;pic_order_present &amp;&amp; !si-&gt;field_pic_flag) {\n\t\t\tsi-&gt;delta_poc_bottom = gf_bs_read_se_log(bs, "poc_lsb");\n\t\t}\n\t}\n\telse if ((si-&gt;sps-&gt;poc_type == 1) &amp;&amp; !si-&gt;sps-&gt;delta_pic_order_always_zero_flag) {\n\t\tsi-&gt;delta_poc[0] = gf_bs_read_se_log(bs, "delta_poc0");\n\t\tif ((si-&gt;pps-&gt;pic_order_present == 1) &amp;&amp; !si-&gt;field_pic_flag)\n\t\t\tsi-&gt;delta_poc[1] = gf_bs_read_se_log(bs, "delta_poc1");\n\t}\n\n\tif (si-&gt;pps-&gt;redundant_pic_cnt_present) {\n\t\tsi-&gt;redundant_pic_cnt = gf_bs_read_ue_log(bs, "redundant_pic_cnt");\n\t}\n\n\tif (si-&gt;slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tgf_bs_read_int_log(bs, 1, "direct_spatial_mv_pred_flag");\n\t}\n\n\tnum_ref_idx_l0_active_minus1 = si-&gt;pps-&gt;num_ref_idx_l0_default_active_minus1;\n\tnum_ref_idx_l1_active_minus1 = si-&gt;pps-&gt;num_ref_idx_l1_default_active_minus1;\n\n\tif (si-&gt;slice_type % 5 == GF_AVC_TYPE_P || si-&gt;slice_type % 5 == GF_AVC_TYPE_SP || si-&gt;slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tBool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, "num_ref_idx_active_override_flag");\n\t\tif (num_ref_idx_active_override_flag) {\n\t\t\tnum_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, "num_ref_idx_l0_active_minus1");\n\t\t\tif (si-&gt;slice_type % 5 == GF_AVC_TYPE_B) {\n\t\t\t\tnum_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, "num_ref_idx_l1_active_minus1");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (si-&gt;nal_unit_type == 20 || si-&gt;nal_unit_type == 21) {\n\t\t//ref_pic_list_mvc_modification(); /* specified in Annex H */\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\\n"));\n\t\tassert(0);\n\t\treturn -1;\n\t}\n\telse {\n\t\tref_pic_list_modification(bs, si-&gt;slice_type);\n\t}\n\n\tif ((si-&gt;pps-&gt;weighted_pred_flag &amp;&amp; (si-&gt;slice_type % 5 == GF_AVC_TYPE_P || si-&gt;slice_type % 5 == GF_AVC_TYPE_SP))\n\t\t|| (si-&gt;pps-&gt;weighted_bipred_idc == 1 &amp;&amp; si-&gt;slice_type % 5 == GF_AVC_TYPE_B)) {\n\t\tpred_weight_table(bs, si-&gt;slice_type, si-&gt;sps-&gt;ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);\n\t}\n\n\tif (si-&gt;nal_ref_idc != 0) {\n\t\tdec_ref_pic_marking(bs, (si-&gt;nal_unit_type == GF_AVC_NALU_IDR_SLICE));\n\t}\n\n\tif (si-&gt;pps-&gt;entropy_coding_mode_flag &amp;&amp; si-&gt;slice_type % 5 != GF_AVC_TYPE_I &amp;&amp; si-&gt;slice_type % 5 != GF_AVC_TYPE_SI) {\n\t\tgf_bs_read_ue_log(bs, "cabac_init_idc");\n\t}\n\n\t/*slice_qp_delta = */gf_bs_read_se(bs);\n\tif (si-&gt;slice_type % 5 == GF_AVC_TYPE_SP || si-&gt;slice_type % 5 == GF_AVC_TYPE_SI) {\n\t\tif (si-&gt;slice_type % 5 == GF_AVC_TYPE_SP) {\n\t\t\tgf_bs_read_int_log(bs, 1, "sp_for_switch_flag");\n\t\t}\n\t\tgf_bs_read_se_log(bs, "slice_qs_delta");\n\t}\n\n\tif (si-&gt;pps-&gt;deblocking_filter_control_present_flag) {\n\t\tif (gf_bs_read_ue_log(bs, "disable_deblocking_filter_idc") != 1) {\n\t\t\tgf_bs_read_se_log(bs, "slice_alpha_c0_offset_div2");\n\t\t\tgf_bs_read_se_log(bs, "slice_beta_offset_div2");\n\t\t}\n\t}\n\n\tif (si-&gt;pps-&gt;slice_group_count &gt; 1 &amp;&amp; si-&gt;pps-&gt;mb_slice_group_map_type &gt;= 3 &amp;&amp; si-&gt;pps-&gt;mb_slice_group_map_type &lt;= 5) {\n\t\tgf_bs_read_int_log(bs, (u32)ceil(log1p((si-&gt;pps-&gt;pic_size_in_map_units_minus1 + 1) / (si-&gt;pps-&gt;slice_group_change_rate_minus1 + 1) ) / log(2)), "slice_group_change_cycle");\n\t}\n\treturn 0;\n}',
 'void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csr_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, "r" );\n  if ( l_csr_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose(l_csr_file_handle); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == \'%\' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, "%u %u %u", o_row_count, o_column_count, o_element_count) &amp;&amp;\n            0 != *o_row_count &amp;&amp; 0 != *o_column_count &amp;&amp; 0 != *o_element_count)\n        {\n          /* allocate CSC data-structure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csr_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i &lt;= *o_row_count; ++l_i )\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_DESC );\n          fclose( l_csr_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, "%u %u %lf", &amp;l_row, &amp;l_column, &amp;l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csr_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        LIBXSMM_ASSERT(0 != l_row &amp;&amp; 0 != l_column);\n        l_row--; l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_LEN );\n    return;\n  }\n\n  if ( l_row_idx_id != NULL ) {\n    /* let\'s handle empty rows */\n    for ( l_i = 0; l_i &lt; (*o_row_count); l_i++) {\n      if ( l_row_idx_id[l_i] == 0 ) {\n        (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_row_idx_id );\n  }\n}',
 'PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp-&gt;decodetile != NULL);\n\n\tif ((*sp-&gt;decodetile)(tif, op0, occ0, s)) {\n\t\ttmsize_t rowsize = sp-&gt;rowsize;\n\t\tassert(rowsize &gt; 0);\n\t\tif((occ0%rowsize) !=0)\n        {\n            TIFFErrorExt(tif-&gt;tif_clientdata, "PredictorDecodeTile",\n                         "%s", "occ0%rowsize != 0");\n            return 0;\n        }\n\t\tassert(sp-&gt;decodepfunc != NULL);\n\t\twhile (occ0 &gt; 0) {\n\t\t\tif( !(*sp-&gt;decodepfunc)(tif, op0, rowsize) )\n                return 0;\n\t\t\tocc0 -= rowsize;\n\t\t\top0 += rowsize;\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}',
 'int main(int argc, char **argv)\n{\n\tint fmtid;\n\tint id;\n\tchar *infile;\n\tjas_stream_t *instream;\n\tjas_image_t *image;\n\tint width;\n\tint height;\n\tint depth;\n\tint numcmpts;\n\tint verbose;\n\tchar *fmtname;\n\tint debug;\n\n\tif (jas_init()) {\n\t\tabort();\n\t}\n\n\tcmdname = argv[0];\n\n\tinfile = 0;\n\tverbose = 0;\n\tdebug = 0;\n\n\t/* Parse the command line options. */\n\twhile ((id = jas_getopt(argc, argv, opts)) &gt;= 0) {\n\t\tswitch (id) {\n\t\tcase OPT_VERBOSE:\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase OPT_VERSION:\n\t\t\tprintf("%s\\n", JAS_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\tdebug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase OPT_INFILE:\n\t\t\tinfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase OPT_HELP:\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_setdbglevel(debug);\n\n\t/* Open the image file. */\n\tif (infile) {\n\t\t/* The image is to be read from a file. */\n\t\tif (!(instream = jas_stream_fopen(infile, "rb"))) {\n\t\t\tfprintf(stderr, "cannot open input image file %s\\n", infile);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else {\n\t\t/* The image is to be read from standard input. */\n\t\tif (!(instream = jas_stream_fdopen(0, "rb"))) {\n\t\t\tfprintf(stderr, "cannot open standard input\\n");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif ((fmtid = jas_image_getfmt(instream)) &lt; 0) {\n\t\tfprintf(stderr, "unknown image format\\n");\n\t}\n\n\t/* Decode the image. */\n\tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n\t\tjas_stream_close(instream);\n\t\tfprintf(stderr, "cannot load image\\n");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t/* Close the image file. */\n\tjas_stream_close(instream);\n\n\tnumcmpts = jas_image_numcmpts(image);\n\twidth = jas_image_cmptwidth(image, 0);\n\theight = jas_image_cmptheight(image, 0);\n\tdepth = jas_image_cmptprec(image, 0);\n\tif (!(fmtname = jas_image_fmttostr(fmtid))) {\n\t\tabort();\n\t}\n\tprintf("%s %d %d %d %d %ld\\n", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));\n\n\tjas_image_destroy(image);\n\tjas_image_clearfmts();\n\n\treturn EXIT_SUCCESS;\n}',
 'static void __udf_read_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode-&gt;i_sb);\n\tunsigned int link_count;\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb-&gt;s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode-&gt;i_sb, &amp;iinfo-&gt;i_location, 0, &amp;ident);\n\tif (!bh) {\n\t\tudf_err(inode-&gt;i_sb, "(ino %ld) failed !bh\\n", inode-&gt;i_ino);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tif (ident != TAG_IDENT_FE &amp;&amp; ident != TAG_IDENT_EFE &amp;&amp;\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode-&gt;i_sb, "(ino %ld) failed ident=%d\\n",\n\t\t\tinode-&gt;i_ino, ident);\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tfe = (struct fileEntry *)bh-&gt;b_data;\n\tefe = (struct extendedFileEntry *)bh-&gt;b_data;\n\n\tif (fe-&gt;icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode-&gt;i_sb, &amp;iinfo-&gt;i_location, 1,\n\t\t\t\t\t&amp;ident);\n\t\tif (ident == TAG_IDENT_IE &amp;&amp; ibh) {\n\t\t\tstruct buffer_head *nbh = NULL;\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh-&gt;b_data;\n\t\t\tloc = lelb_to_cpu(ie-&gt;indirectICB.extLocation);\n\n\t\t\tif (ie-&gt;indirectICB.extLength &amp;&amp;\n\t\t\t\t(nbh = udf_read_ptagged(inode-&gt;i_sb, &amp;loc, 0,\n\t\t\t\t\t\t\t&amp;ident))) {\n\t\t\t\tif (ident == TAG_IDENT_FE ||\n\t\t\t\t\tident == TAG_IDENT_EFE) {\n\t\t\t\t\tmemcpy(&amp;iinfo-&gt;i_location,\n\t\t\t\t\t\t&amp;loc,\n\t\t\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbrelse(ibh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t\t__udf_read_inode(inode);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbrelse(nbh);\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe-&gt;icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode-&gt;i_sb, "unsupported strategy type: %d\\n",\n\t\t\tle16_to_cpu(fe-&gt;icbTag.strategyType));\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (fe-&gt;icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo-&gt;i_strat4096 = 0;\n\telse /* if (fe-&gt;icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo-&gt;i_strat4096 = 1;\n\n\tiinfo-&gt;i_alloc_type = le16_to_cpu(fe-&gt;icbTag.flags) &amp;\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo-&gt;i_unique = 0;\n\tiinfo-&gt;i_lenEAttr = 0;\n\tiinfo-&gt;i_lenExtents = 0;\n\tiinfo-&gt;i_lenAlloc = 0;\n\tiinfo-&gt;i_next_alloc_block = 0;\n\tiinfo-&gt;i_next_alloc_goal = 0;\n\tif (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo-&gt;i_efe = 1;\n\t\tiinfo-&gt;i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo-&gt;i_ext.i_data,\n\t\t       bh-&gt;b_data + sizeof(struct extendedFileEntry),\n\t\t       inode-&gt;i_sb-&gt;s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t} else if (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo-&gt;i_efe = 0;\n\t\tiinfo-&gt;i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -\n\t\t\t\t\t\tsizeof(struct fileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo-&gt;i_ext.i_data,\n\t\t       bh-&gt;b_data + sizeof(struct fileEntry),\n\t\t       inode-&gt;i_sb-&gt;s_blocksize - sizeof(struct fileEntry));\n\t} else if (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo-&gt;i_efe = 0;\n\t\tiinfo-&gt;i_use = 1;\n\t\tiinfo-&gt;i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh-&gt;b_data)-&gt;\n\t\t\t\t lengthAllocDescs);\n\t\tif (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo-&gt;i_ext.i_data,\n\t\t       bh-&gt;b_data + sizeof(struct unallocSpaceEntry),\n\t\t       inode-&gt;i_sb-&gt;s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\treturn;\n\t}\n\n\tread_lock(&amp;sbi-&gt;s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe-&gt;uid));\n\tif (!uid_valid(inode-&gt;i_uid) ||\n\t    UDF_QUERY_FLAG(inode-&gt;i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode-&gt;i_sb, UDF_FLAG_UID_SET))\n\t\tinode-&gt;i_uid = UDF_SB(inode-&gt;i_sb)-&gt;s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe-&gt;gid));\n\tif (!gid_valid(inode-&gt;i_gid) ||\n\t    UDF_QUERY_FLAG(inode-&gt;i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode-&gt;i_sb, UDF_FLAG_GID_SET))\n\t\tinode-&gt;i_gid = UDF_SB(inode-&gt;i_sb)-&gt;s_gid;\n\n\tif (fe-&gt;icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &amp;&amp;\n\t\t\tsbi-&gt;s_fmode != UDF_INVALID_MODE)\n\t\tinode-&gt;i_mode = sbi-&gt;s_fmode;\n\telse if (fe-&gt;icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &amp;&amp;\n\t\t\tsbi-&gt;s_dmode != UDF_INVALID_MODE)\n\t\tinode-&gt;i_mode = sbi-&gt;s_dmode;\n\telse\n\t\tinode-&gt;i_mode = udf_convert_permissions(fe);\n\tinode-&gt;i_mode &amp;= ~sbi-&gt;s_umask;\n\tread_unlock(&amp;sbi-&gt;s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe-&gt;fileLinkCount);\n\tif (!link_count)\n\t\tlink_count = 1;\n\tset_nlink(inode, link_count);\n\n\tinode-&gt;i_size = le64_to_cpu(fe-&gt;informationLength);\n\tiinfo-&gt;i_lenExtents = inode-&gt;i_size;\n\n\tif (iinfo-&gt;i_efe == 0) {\n\t\tinode-&gt;i_blocks = le64_to_cpu(fe-&gt;logicalBlocksRecorded) &lt;&lt;\n\t\t\t(inode-&gt;i_sb-&gt;s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_atime, fe-&gt;accessTime))\n\t\t\tinode-&gt;i_atime = sbi-&gt;s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_mtime,\n\t\t\t\t\t    fe-&gt;modificationTime))\n\t\t\tinode-&gt;i_mtime = sbi-&gt;s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_ctime, fe-&gt;attrTime))\n\t\t\tinode-&gt;i_ctime = sbi-&gt;s_record_time;\n\n\t\tiinfo-&gt;i_unique = le64_to_cpu(fe-&gt;uniqueID);\n\t\tiinfo-&gt;i_lenEAttr = le32_to_cpu(fe-&gt;lengthExtendedAttr);\n\t\tiinfo-&gt;i_lenAlloc = le32_to_cpu(fe-&gt;lengthAllocDescs);\n\t\tiinfo-&gt;i_checkpoint = le32_to_cpu(fe-&gt;checkpoint);\n\t} else {\n\t\tinode-&gt;i_blocks = le64_to_cpu(efe-&gt;logicalBlocksRecorded) &lt;&lt;\n\t\t    (inode-&gt;i_sb-&gt;s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_atime, efe-&gt;accessTime))\n\t\t\tinode-&gt;i_atime = sbi-&gt;s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_mtime,\n\t\t\t\t\t    efe-&gt;modificationTime))\n\t\t\tinode-&gt;i_mtime = sbi-&gt;s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&amp;iinfo-&gt;i_crtime, efe-&gt;createTime))\n\t\t\tiinfo-&gt;i_crtime = sbi-&gt;s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_ctime, efe-&gt;attrTime))\n\t\t\tinode-&gt;i_ctime = sbi-&gt;s_record_time;\n\n\t\tiinfo-&gt;i_unique = le64_to_cpu(efe-&gt;uniqueID);\n\t\tiinfo-&gt;i_lenEAttr = le32_to_cpu(efe-&gt;lengthExtendedAttr);\n\t\tiinfo-&gt;i_lenAlloc = le32_to_cpu(efe-&gt;lengthAllocDescs);\n\t\tiinfo-&gt;i_checkpoint = le32_to_cpu(efe-&gt;checkpoint);\n\t}\n\n\tswitch (fe-&gt;icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode-&gt;i_op = &amp;udf_dir_inode_operations;\n\t\tinode-&gt;i_fop = &amp;udf_dir_operations;\n\t\tinode-&gt;i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo-&gt;i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode-&gt;i_data.a_ops = &amp;udf_adinicb_aops;\n\t\telse\n\t\t\tinode-&gt;i_data.a_ops = &amp;udf_aops;\n\t\tinode-&gt;i_op = &amp;udf_file_inode_operations;\n\t\tinode-&gt;i_fop = &amp;udf_file_operations;\n\t\tinode-&gt;i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode-&gt;i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode-&gt;i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode-&gt;i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode-&gt;i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode-&gt;i_data.a_ops = &amp;udf_symlink_aops;\n\t\tinode-&gt;i_op = &amp;udf_symlink_inode_operations;\n\t\tinode-&gt;i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug("METADATA FILE-----\\n");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug("METADATA MIRROR FILE-----\\n");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug("METADATA BITMAP FILE-----\\n");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode-&gt;i_sb, "(ino %ld) failed unknown file type=%d\\n",\n\t\t\tinode-&gt;i_ino, fe-&gt;icbTag.fileType);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (S_ISCHR(inode-&gt;i_mode) || S_ISBLK(inode-&gt;i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode-&gt;i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea-&gt;majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea-&gt;minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tmake_bad_inode(inode);\n\t}\n\tbrelse(bh);\n}',
 'static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tstruct dev_pagemap *pgmap = NULL;\n\tint nr_start = *nr, ret = 0;\n\tpte_t *ptep, *ptem;\n\n\tptem = ptep = pte_offset_map(&amp;pmd, addr);\n\tdo {\n\t\tpte_t pte = gup_get_pte(ptep);\n\t\tstruct page *head, *page;\n\n\t\t/*\n\t\t * Similar to the PMD case below, NUMA hinting must take slow\n\t\t * path using the pte_protnone check.\n\t\t */\n\t\tif (pte_protnone(pte))\n\t\t\tgoto pte_unmap;\n\n\t\tif (!pte_access_permitted(pte, write))\n\t\t\tgoto pte_unmap;\n\n\t\tif (pte_devmap(pte)) {\n\t\t\tpgmap = get_dev_pagemap(pte_pfn(pte), pgmap);\n\t\t\tif (unlikely(!pgmap)) {\n\t\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\t\tgoto pte_unmap;\n\t\t\t}\n\t\t} else if (pte_special(pte))\n\t\t\tgoto pte_unmap;\n\n\t\tVM_BUG_ON(!pfn_valid(pte_pfn(pte)));\n\t\tpage = pte_page(pte);\n\t\thead = compound_head(page);\n\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto pte_unmap;\n\n\t\tif (unlikely(pte_val(pte) != pte_val(*ptep))) {\n\t\t\tput_page(head);\n\t\t\tgoto pte_unmap;\n\t\t}\n\n\t\tVM_BUG_ON_PAGE(compound_head(page) != head, page);\n\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\n\t} while (ptep++, addr += PAGE_SIZE, addr != end);\n\n\tret = 1;\n\npte_unmap:\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\tpte_unmap(ptem);\n\treturn ret;\n}',
 'static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n\n    if (item_len != 18) {\n        avpriv_request_sample(pb, "Primer pack item length %d", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num &gt; 65536) {\n        av_log(mxf-&gt;fc, AV_LOG_ERROR, "item_num %d is too large\\n", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf-&gt;local_tags)\n        av_log(mxf-&gt;fc, AV_LOG_VERBOSE, "Multiple primer packs\\n");\n    av_free(mxf-&gt;local_tags);\n    mxf-&gt;local_tags_count = 0;\n    mxf-&gt;local_tags = av_calloc(item_num, item_len);\n    if (!mxf-&gt;local_tags)\n        return AVERROR(ENOMEM);\n    mxf-&gt;local_tags_count = item_num;\n    avio_read(pb, mxf-&gt;local_tags, item_num*item_len);\n    return 0;\n}',
 'SPIFFEValidator::SPIFFEValidator(const Envoy::Ssl::CertificateValidationContextConfig* config,\n                                 SslStats&amp; stats, TimeSource&amp; time_source)\n    : stats_(stats), time_source_(time_source) {\n  ASSERT(config != nullptr);\n  allow_expired_certificate_ = config-&gt;allowExpiredCertificate();\n\n  SPIFFEConfig message;\n  Config::Utility::translateOpaqueConfig(config-&gt;customValidatorConfig().value().typed_config(),\n                                         ProtobufMessage::getStrictValidationVisitor(), message);\n\n  if (!config-&gt;subjectAltNameMatchers().empty()) {\n    for (const auto&amp; matcher : config-&gt;subjectAltNameMatchers()) {\n      if (matcher.san_type() ==\n          envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI) {\n        // Only match against URI SAN since SPIFFE specification does not restrict values in other\n        // SAN types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392\n        // TODO(pradeepcrao): Throw an exception when a non-URI matcher is encountered after the\n        // deprecated field match_subject_alt_names is removed\n        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n      }\n    }\n  }\n\n  const auto size = message.trust_domains().size();\n  trust_bundle_stores_.reserve(size);\n  for (auto&amp; domain : message.trust_domains()) {\n    if (trust_bundle_stores_.find(domain.name()) != trust_bundle_stores_.end()) {\n      throw EnvoyException(absl::StrCat(\n          "Multiple trust bundles are given for one trust domain for ", domain.name()));\n    }\n\n    auto cert = Config::DataSource::read(domain.trust_bundle(), true, config-&gt;api());\n    bssl::UniquePtr&lt;BIO&gt; bio(BIO_new_mem_buf(const_cast&lt;char*&gt;(cert.data()), cert.size()));\n    RELEASE_ASSERT(bio != nullptr, "");\n    bssl::UniquePtr&lt;STACK_OF(X509_INFO)&gt; list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr || sk_X509_INFO_num(list.get()) == 0) {\n      throw EnvoyException(\n          absl::StrCat("Failed to load trusted CA certificate for ", domain.name()));\n    }\n\n    auto store = X509StorePtr(X509_STORE_new());\n    bool has_crl = false;\n    bool ca_loaded = false;\n    for (const X509_INFO* item : list.get()) {\n      if (item-&gt;x509) {\n        X509_STORE_add_cert(store.get(), item-&gt;x509);\n        ca_certs_.push_back(bssl::UniquePtr&lt;X509&gt;(item-&gt;x509));\n        X509_up_ref(item-&gt;x509);\n        if (!ca_loaded) {\n          // TODO: With the current interface, we cannot return the multiple\n          // cert information on getCaCertInformation method.\n          // So temporarily we return the first CA\'s info here.\n          ca_loaded = true;\n          ca_file_name_ = absl::StrCat(domain.name(), ": ",\n                                       domain.trust_bundle().filename().empty()\n                                           ? "&lt;inline&gt;"\n                                           : domain.trust_bundle().filename());\n        }\n      }\n\n      if (item-&gt;crl) {\n        has_crl = true;\n        X509_STORE_add_crl(store.get(), item-&gt;crl);\n      }\n    }\n    if (has_crl) {\n      X509_STORE_set_flags(store.get(), X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n    trust_bundle_stores_[domain.name()] = std::move(store);\n  }\n}',
 'static int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_16 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tctxt-&gt;_eip = tss-&gt;ip;\n\tctxt-&gt;eflags = tss-&gt;flag | 2;\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss-&gt;ax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss-&gt;cx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss-&gt;dx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss-&gt;bx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss-&gt;sp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss-&gt;bp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss-&gt;si;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss-&gt;di;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss-&gt;ldt, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss-&gt;es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss-&gt;cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss-&gt;ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss-&gt;ds, VCPU_SREG_DS);\n\n\tcpl = tss-&gt;cs &amp; 3;\n\n\t/*\n\t * Now load segment descriptors. If fault happens at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss-&gt;ldt, VCPU_SREG_LDTR, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss-&gt;es, VCPU_SREG_ES, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss-&gt;cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss-&gt;ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss-&gt;ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}',
 'bool ParseAttrValue(StringPiece type, StringPiece text, AttrValue* out) {\n  // Parse type.\n  string field_name;\n  bool is_list = absl::ConsumePrefix(&amp;type, "list(");\n  if (absl::ConsumePrefix(&amp;type, "string")) {\n    field_name = "s";\n  } else if (absl::ConsumePrefix(&amp;type, "int")) {\n    field_name = "i";\n  } else if (absl::ConsumePrefix(&amp;type, "float")) {\n    field_name = "f";\n  } else if (absl::ConsumePrefix(&amp;type, "bool")) {\n    field_name = "b";\n  } else if (absl::ConsumePrefix(&amp;type, "type")) {\n    field_name = "type";\n  } else if (absl::ConsumePrefix(&amp;type, "shape")) {\n    field_name = "shape";\n  } else if (absl::ConsumePrefix(&amp;type, "tensor")) {\n    field_name = "tensor";\n  } else if (absl::ConsumePrefix(&amp;type, "func")) {\n    field_name = "func";\n  } else if (absl::ConsumePrefix(&amp;type, "placeholder")) {\n    field_name = "placeholder";\n  } else {\n    return false;\n  }\n  if (is_list &amp;&amp; !absl::ConsumePrefix(&amp;type, ")")) {\n    return false;\n  }\n\n  // Construct a valid text proto message to parse.\n  string to_parse;\n  if (is_list) {\n    // TextFormat parser considers "i: 7" to be the same as "i: [7]",\n    // but we only want to allow list values with [].\n    StringPiece cleaned = text;\n    str_util::RemoveLeadingWhitespace(&amp;cleaned);\n    str_util::RemoveTrailingWhitespace(&amp;cleaned);\n    if (cleaned.size() &lt; 2 || cleaned[0] != \'[\' ||\n        cleaned[cleaned.size() - 1] != \']\') {\n      return false;\n    }\n    cleaned.remove_prefix(1);\n    str_util::RemoveLeadingWhitespace(&amp;cleaned);\n    if (cleaned.size() == 1) {\n      // User wrote "[]", so return empty list without invoking the TextFormat\n      // parse which returns an error for "i: []".\n      out-&gt;Clear();\n      out-&gt;mutable_list();\n      return true;\n    }\n    to_parse = strings::StrCat("list { ", field_name, ": ", text, " }");\n  } else {\n    to_parse = strings::StrCat(field_name, ": ", text);\n  }\n\n  return ProtoParseFromString(to_parse, out);\n}',
 'add_mibdir(const char *dirname)\n{\n    FILE           *ip;\n    const char     *oldFile = File;\n    char          **filenames;\n    int             count = 0;\n    int             filename_count, i;\n#if !(defined(WIN32) || defined(cygwin))\n    char           *token;\n    char space;\n    char newline;\n    struct stat     dir_stat, idx_stat;\n    char            tmpstr[300];\n    char            tmpstr1[300];\n#endif\n\n    DEBUGMSGTL(("parse-mibs", "Scanning directory %s\\n", dirname));\n#if !(defined(WIN32) || defined(cygwin))\n    token = netsnmp_mibindex_lookup( dirname );\n    if (token &amp;&amp; stat(token, &amp;idx_stat) == 0 &amp;&amp; stat(dirname, &amp;dir_stat) == 0) {\n        if (dir_stat.st_mtime &lt; idx_stat.st_mtime) {\n            DEBUGMSGTL(("parse-mibs", "The index is good\\n"));\n            if ((ip = fopen(token, "r")) != NULL) {\n                fgets(tmpstr, sizeof(tmpstr), ip); /* Skip dir line */\n                while (fscanf(ip, "%127s%c%299[^\\n]%c", token, &amp;space, tmpstr,\n\t\t    &amp;newline) == 4) {\n\n\t\t    /*\n\t\t     * If an overflow of the token or tmpstr buffers has been\n\t\t     * found log a message and break out of the while loop,\n\t\t     * thus the rest of the file tokens will be ignored.\n\t\t     */\n\t\t    if (space != \' \' || newline != \'\\n\') {\n\t\t\tsnmp_log(LOG_ERR,\n\t\t\t    "add_mibdir: strings scanned in from %s/%s " \\\n\t\t\t    "are too large.  count = %d\\n ", dirname,\n\t\t\t    ".index", count);\n\t\t\t    break;\n\t\t    }\n\t\t   \n\t\t    snprintf(tmpstr1, sizeof(tmpstr1), "%s/%s", dirname, tmpstr);\n                    tmpstr1[ sizeof(tmpstr1)-1 ] = 0;\n                    new_module(token, tmpstr1);\n                    count++;\n                }\n                fclose(ip);\n                return count;\n            } else\n                DEBUGMSGTL(("parse-mibs", "Can\'t read index\\n"));\n        } else\n            DEBUGMSGTL(("parse-mibs", "Index outdated\\n"));\n    } else\n        DEBUGMSGTL(("parse-mibs", "No index\\n"));\n#endif\n\n    filename_count = scan_directory(&amp;filenames, dirname);\n\n    if (filename_count &gt;= 0) {\n        ip = netsnmp_mibindex_new(dirname);\n        for (i = 0; i &lt; filename_count; i++) {\n            if (add_mibfile(filenames[i], strrchr(filenames[i], \'/\'), ip) == 0)\n                count++;\n\t    free(filenames[i]);\n        }\n        File = oldFile;\n        if (ip)\n            fclose(ip);\n        free(filenames);\n        return (count);\n    }\n    else\n        DEBUGMSGTL(("parse-mibs","cannot open MIB directory %s\\n", dirname));\n\n    return (-1);\n}',
 'void color_sycc_to_rgb(opj_image_t *img)\n{\n\tif(img-&gt;numcomps &lt; 3)\n\t{\n\t\timg-&gt;color_space = OPJ_CLRSPC_GRAY;\n\t\treturn;\n\t}\n\n\tif((img-&gt;comps[0].dx == 1)\n\t&amp;&amp; (img-&gt;comps[1].dx == 2)\n\t&amp;&amp; (img-&gt;comps[2].dx == 2)\n\t&amp;&amp; (img-&gt;comps[0].dy == 1)\n\t&amp;&amp; (img-&gt;comps[1].dy == 2)\n\t&amp;&amp; (img-&gt;comps[2].dy == 2))/* horizontal and vertical sub-sample */\n  {\n\t\tsycc420_to_rgb(img);\n  }\n\telse\n\tif((img-&gt;comps[0].dx == 1)\n\t&amp;&amp; (img-&gt;comps[1].dx == 2)\n\t&amp;&amp; (img-&gt;comps[2].dx == 2)\n\t&amp;&amp; (img-&gt;comps[0].dy == 1)\n\t&amp;&amp; (img-&gt;comps[1].dy == 1)\n\t&amp;&amp; (img-&gt;comps[2].dy == 1))/* horizontal sub-sample only */\n  {\n\t\tsycc422_to_rgb(img);\n  }\n\telse\n\tif((img-&gt;comps[0].dx == 1)\n\t&amp;&amp; (img-&gt;comps[1].dx == 1)\n\t&amp;&amp; (img-&gt;comps[2].dx == 1)\n\t&amp;&amp; (img-&gt;comps[0].dy == 1)\n\t&amp;&amp; (img-&gt;comps[1].dy == 1)\n\t&amp;&amp; (img-&gt;comps[2].dy == 1))/* no sub-sample */\n  {\n\t\tsycc444_to_rgb(img);\n  }\n\telse\n  {\n\t\tfprintf(stderr,"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n", __FILE__,__LINE__);\n\t\treturn;\n  }\n\timg-&gt;color_space = OPJ_CLRSPC_SRGB;\n\n}/* color_sycc_to_rgb() */',
 'int mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, ".");\n\n\tmemset(&amp;user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i&lt;(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, "-c") || !strcmp(arg, "-cfg")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, "-mem-track") || !strcmp(arg, "-mem-track-stack")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, "-mem-track-stack") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, "WARNING - GPAC not compiled with Memory Tracker - ignoring \\"%s\\"\\n", arg);\n#endif\n\t\t} else if (!strcmp(arg, "-gui")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, "-guid")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, "-h") || !strcmp(arg, "-help")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, "Error: Configuration File not found\\n");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, "General", "Logs") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, "General", "Logs") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, "General", "ForceGUI");\n\t\tif (str &amp;&amp; !strcmp(str, "yes")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i&lt;(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, "-rti")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-rtix")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, "-size")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], "%dx%d", &amp;forced_width, &amp;forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-quiet")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, "-strict-error")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, "-log-file") || !strcmp(arg, "-lf")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], "wt");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-logs") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-log-clock") || !strcmp(arg, "-lc")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, "-log-utc") || !strcmp(arg, "-lu")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, "-thread")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, "-no-thread")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, "-no-cthread") || !strcmp(arg, "-no-compositor-thread")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, "-no-audio")) no_audio = 1;\n\t\telse if (!strcmp(arg, "-no-regulation")) no_regulation = 1;\n\t\telse if (!strcmp(arg, "-fs")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, "-opt")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-conf")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, "-ifce")) {\n\t\t\tgf_cfg_set_key(cfg_file, "Network", "DefaultMCastInterface", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, "-help")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, "-noprog")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, "-no-save") || !stricmp(arg, "--no-save") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, "-ntp-shift")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, "-run-for")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, "-out")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, "-fps")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, "-avi") || !strcmp(arg, "-sha")) {\n\t\t\tdump_mode &amp;= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, "-sha")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2&lt;(u32)argc)) &amp;&amp; get_time_list(argv[i+1], times, &amp;nb_times)) {\n\t\t\t\tif (!strcmp(arg, "-avi") &amp;&amp; (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, "Only one time arg found for -avi - check usage\\n");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, "-rgbds")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, "-rgbd")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, "-depth")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, "-bmp")) {\n\t\t\tdump_mode &amp;= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2&lt;(u32)argc)) &amp;&amp; get_time_list(argv[i+1], times, &amp;nb_times)) i++;\n\t\t} else if (!strcmp(arg, "-png")) {\n\t\t\tdump_mode &amp;= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2&lt;(u32)argc)) &amp;&amp; get_time_list(argv[i+1], times, &amp;nb_times)) i++;\n\t\t} else if (!strcmp(arg, "-raw")) {\n\t\t\tdump_mode &amp;= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2&lt;(u32)argc)) &amp;&amp; get_time_list(argv[i+1], times, &amp;nb_times)) i++;\n\t\t} else if (!stricmp(arg, "-scale")) {\n\t\t\tsscanf(argv[i+1], "%f", &amp;scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, "-c") || !strcmp(arg, "-cfg")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != \'-\') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, "Several input URLs provided (\\"%s\\", \\"%s\\"). Check your command-line.\\n", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, "-loop")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, "-bench")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, "-vbench")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, "-sbench")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, "-no-addon")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, "-pause")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, "-play-from")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, "-speed")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed &lt;= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, "-no-wnd")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, "-no-back")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, "-align")) {\n\t\t\t\tif (argv[i+1][0]==\'m\') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]==\'b\') align_mode = 2;\n\t\t\t\talign_mode &lt;&lt;= 8;\n\t\t\t\tif (argv[i+1][1]==\'m\') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]==\'r\') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, "-fill")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, "-show")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, "-uncache")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, "-exit")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, "-views")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, "-mosaic")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, "-com")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, "-service")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, "GPAC Config updated\\n");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, "General", "CacheDirectory");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, "GPAC Cache dir %s flattened\\n", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode &amp;&amp; !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, "General", "StartupFile");\n\t\ttest = url_arg ? gf_fopen(url_arg, "rt") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, "Missing argument for dump\\n");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode &amp;&amp; !url_arg &amp;&amp; (gf_cfg_get_key(cfg_file, "General", "StartupFile") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, "General", "ModulesDirectory");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg &amp;&amp; simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\t//only override default log callback when needed\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &amp;rti, 0))\n\t\t\tfprintf(stderr, "System info: %d MB RAM - %d cores\\n", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, "Audio", "DriverName", "Raw Audio Output");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, "Error: no modules found - exiting\\n");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, "Modules Found : %d \\n", i);\n\n\tstr = gf_cfg_get_key(cfg_file, "General", "GPACVersion");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, "PluginsCache");\n\t\tgf_cfg_set_key(cfg_file, "General", "GPACVersion", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags &amp; (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\t//in dump mode we don\'t want to rely on system clock but on the number of samples being consumed\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, "Audio", "DriverName", "Raw Audio Output");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, "Video", "DriverName", "Raw Video Output");\n\t\t\tgf_cfg_set_key(user.config, "RAWVideo", "RawOutput", "null");\n\t\t\tgf_cfg_set_key(user.config, "Compositor", "OpenGLMode", "disable");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, "Video", "DisableVSync", "yes");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, "%d", forced_width);\n\t\tgf_cfg_set_key(user.config, "Compositor", "DefaultWidth", forced_width ? dim : NULL);\n\t\tsprintf(dim, "%d", forced_height);\n\t\tgf_cfg_set_key(user.config, "Compositor", "DefaultHeight", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, "Loading GPAC Terminal\\n");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&amp;user);\n\tif (!term) {\n\t\tfprintf(stderr, "\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, "Terminal Loaded in %d ms\\n", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n//\t\tgf_term_set_option(term, GF_OPT_VISIBLE, 0);\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, "Video", "DriverName");\n\t\tif (!bench_mode &amp;&amp; !strcmp(str, "Raw Video Output")) fprintf(stderr, "WARNING: using raw output video (memory only) - no display used\\n");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, "Audio", "DriverName");\n\t\tif (!str || !strcmp(str, "No Audio Output Available")) fprintf(stderr, "WARNING: no audio output available - make sure no other program is locking the sound card\\n");\n\n\t\tstr = gf_cfg_get_key(cfg_file, "General", "NoMIMETypeFetch");\n\t\tno_mime_check = (str &amp;&amp; !stricmp(str, "yes")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, "HTTPProxy", "Enabled");\n\tif (str &amp;&amp; !strcmp(str, "yes")) {\n\t\tstr = gf_cfg_get_key(cfg_file, "HTTPProxy", "Name");\n\t\tif (str) fprintf(stderr, "HTTP Proxy %s enabled\\n", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, "General", "RTIRefreshPeriod");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, "General", "RTIRefreshPeriod", "200");\n\t\t}\n\t\tUpdateRTInfo("At GPAC load time\\n");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode &amp;&amp; url_arg) {\n\t\tchar *ext;\n\n\t\tif (strlen(url_arg) &gt;= sizeof(the_url)) {\n\t\t\tfprintf(stderr, "Input url %s is too long, truncating to %d chars.\\n", url_arg, (int)(sizeof(the_url) - 1));\n\t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t}\n\t\telse {\n\t\t\tstrcpy(the_url, url_arg);\n\t\t}\n\t\text = strrchr(the_url, \'.\');\n\t\tif (ext &amp;&amp; (!stricmp(ext, ".m3u") || !stricmp(ext, ".pls"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, "Opening Playlist %s\\n", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp("http:", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term-&gt;downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &amp;e);\n\t\t\t\tif (sess) {\n\t\t\t\t\te = gf_dm_sess_process(sess);\n\t\t\t\t\tif (!e) {\n\t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);\n\t\t\t\t\t\tthe_url[sizeof(the_cfg) - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, "rt");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, "Failed to open playlist %s: %s\\n", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, "Hit \'h\' for help\\n\\n");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, "Opening URL %s\\n", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, "[Status: Paused]\\n");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, "Hit \'h\' for help\\n\\n");\n\t\tstr = gf_cfg_get_key(cfg_file, "General", "StartupFile");\n\t\tif (str) {\n\t\t\tstrncpy(the_url, "MP4Client "GPAC_FULL_VERSION , sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, "views://%s", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, "mosaic://%s", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don\'t want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, "General", "StartupFile") : the_url);\n\t\t\t}\n\t\t\tif (restart &amp;&amp; gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = \'\\n\';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command &amp;&amp; is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i&lt;(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], "-com")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id &amp;&amp; is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit &amp;&amp; eos_seen &amp;&amp; gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        &amp;&amp; ( (gf_term_get_elapsed_time_in_ms(term)&gt;simulation_time_in_ms) || (!url_arg &amp;&amp; gf_sys_clock()&gt;simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase \'q\':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&amp;evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &amp;evt);\n\t\t}\n//\t\t\tRun = 0;\n\t\tbreak;\n\t\tcase \'X\':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase \'Q\':\n\t\t\tbreak;\n\t\tcase \'o\':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, "Enter the absolute URL\\n");\n\t\t\tif (1 &gt; scanf("%s", the_url)) {\n\t\t\t\tfprintf(stderr, "Cannot read absolute URL, aborting\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase \'O\':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, "Enter the absolute URL to the playlist\\n");\n\t\t\tif (1 &gt; scanf("%s", the_url)) {\n\t\t\t\tfprintf(stderr, "Cannot read the absolute URL, aborting.\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, "rt");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 &gt;\tfscanf(playlist, "%s", the_url)) {\n\t\t\t\t\tfprintf(stderr, "Cannot read any URL from playlist, aborting.\\n");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, "Opening URL %s\\n", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'\\n\':\n\t\tcase \'N\':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, "%s", the_url);\n\t\t\t\tif ((res == EOF) &amp;&amp; loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, "%s", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, "No more items - exiting\\n");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == \'#\') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, "Opening URL %s\\n", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'P\':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 &gt; scanf("%u", &amp;count)) {\n\t\t\t\t\tfprintf(stderr, "Cannot read number, aborting.\\n");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, "%s", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, "Failed to read line, aborting\\n");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, "Opening URL %s\\n", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'r\':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase \'D\':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase \'p\':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, "[Status: %s]\\n", is_pause ? "Playing" : "Paused");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'s\':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, "Step time: ");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, "\\n");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase \'z\':\n\t\tcase \'T\':\n\t\t\tif (!CanSeek || (Duration&lt;=2000)) {\n\t\t\t\tfprintf(stderr, "scene not seekable\\n");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, "Duration: ");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c==\'z\') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, " (current %.2f %%)\\nEnter Seek percentage:\\n", res);\n\t\t\t\t\tif (scanf("%d", &amp;seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo &gt; 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, " - Current Time: ");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, "\\nEnter seek time (Format: s, m:s or h:m:s):\\n");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r &amp;&amp; (r&lt;=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase \'t\':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, "Current Time: ");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, " - Duration: ");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, "\\n");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase \'w\':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase \'v\':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, "Root");\n\t\t\tbreak;\n\t\tcase \'i\':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, "Enter OD ID (0 for main OD): ");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf("%ud", &amp;ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf("%s", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'j\':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, "Enter OD number (0 for main OD): ");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 &gt; scanf("%ud", &amp;num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'b\':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase \'m\':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase \'l\':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase \'n\':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase \'x\':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase \'d\':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, "Enter Inline OD ID if any or 0 : ");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 &gt;  scanf("%ud", &amp;odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i&lt;count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &amp;info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od-&gt;objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, "Enter file radical name (+\\\'.x\\\' for XML dumping) - \\"std\\" for stderr: ");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 &gt; scanf("%s", radname));\n\t\t\t\tsExt = strrchr(radname, \'.\');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, ".x")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, "std", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, "Dump done (%s)\\n", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase \'c\':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase \'3\':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, "Using %s for 2D drawing\\n", use_3d ? "OpenGL" : "2D rasterizer");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase \'k\':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, "Turning stress mode %s\\n", opt ? "on" : "off");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase \'4\':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase \'5\':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase \'6\':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase \'7\':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase \'C\':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, "Streaming Cache is running - please stop it first\\n");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, "Streaming Cache Enabled\\n");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, "Streaming Cache Disabled\\n");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, "Streaming Cache Running\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'S\':\n\t\tcase \'A\':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c==\'S\') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, "Streaming Cache stopped\\n");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, "Streaming Cache not running\\n");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \'R\':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase \'F\':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase \'u\':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, "Enter command to send:\\n");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 &gt; scanf("%[^\\t\\n]", szCom)) {\n\t\t\t\tfprintf(stderr, "Cannot read command to send, aborting.\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, "Processing command failed: %s\\n", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase \'e\':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, "Enter JavaScript code to evaluate:\\n");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 &gt; scanf("%[^\\t\\n]", jsCode)) {\n\t\t\t\tfprintf(stderr, "Cannot read code to evaluate, aborting.\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, "application/ecmascript", jsCode);\n\t\t\tif (e) fprintf(stderr, "Processing JS code failed: %s\\n", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase \'L\':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, "Enter new log level (current tools %s):\\n", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf("%s", szLog) &lt; 1) {\n\t\t\t\tfprintf(stderr, "Cannot read new log level, aborting.\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase \'g\':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &amp;rti, 0);\n\t\t\tfprintf(stderr, "GPAC allocated memory "LLD"\\n", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase \'M\':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, "Enter new video cache memory in kBytes (current %ud):\\n", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 &gt; scanf("%ud", &amp;size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase \'H\':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, "Enter new http bitrate in bps (0 for none) - current limit: %d\\n", http_bitrate);\n\t\t\t} while (1 &gt; scanf("%ud", &amp;http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase \'E\':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase \'B\':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase \'Y\':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, "Enter option to set (Section:Name=Value):\\n");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 &gt; scanf("%[^\\t\\n]", szOpt)) {\n\t\t\t\tfprintf(stderr, "Cannot read option\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase \'Z\':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views&gt;1) {\n\t\t\t\tfprintf(stderr, "Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf("%d", &amp;offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, "view%d_dump.png", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &amp;fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, "gpac_video_dump_"LLU".png", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &amp;fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, "Error dumping screen buffer %s\\n", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &amp;dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, "Error encoding PNG %s\\n", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, "wb");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, "Error writing file %s\\n", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, "Dump to %s\\n", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &amp;fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, "Done: %s\\n", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase \'G\':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, "Enter 0-based index of object to select or service ID:\\n");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 &gt; scanf("%[^\\t\\n]", szOpt)) {\n\t\t\t\tfprintf(stderr, "Cannot read OD ID\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, "Cannot find service %d - trying with object index\\n", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, "Cannot find object at index %d\\n", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase \'h\':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo("Disconnected\\n");\n\n\tfprintf(stderr, "Deleting terminal... ");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, "done (in %d ms) - ran for %d ms\\n", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, "GPAC cleanup ...\\n");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track &amp;&amp; (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}',
 'static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *start, *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\n\tif (var-&gt;ptr &gt;= var-&gt;end) {\n\t\treturn 0;\n\t}\n\n\tstart = var-&gt;ptr + var-&gt;already_scanned;\n\tvsep = memchr(start, \'&amp;\', var-&gt;end - start);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\tvar-&gt;already_scanned = var-&gt;end - var-&gt;ptr;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var-&gt;end;\n\t\t}\n\t}\n\n\tksep = memchr(var-&gt;ptr, \'=\', vsep - var-&gt;ptr);\n\tif (ksep) {\n\t\t*ksep = \'\\0\';\n\t\t/* "foo=bar&amp;" or "foo=&amp;" */\n\t\tklen = ksep - var-&gt;ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = "";\n\t\t/* "foo&amp;" */\n\t\tklen = vsep - var-&gt;ptr;\n\t\tvlen = 0;\n\t}\n\n\tphp_url_decode(var-&gt;ptr, klen);\n\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\n\tif (sapi_module.input_filter(PARSE_POST, var-&gt;ptr, &amp;val, vlen, &amp;new_vlen)) {\n\t\tphp_register_variable_safe(var-&gt;ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\n\tvar-&gt;ptr = vsep + (vsep != var-&gt;end);\n\tvar-&gt;already_scanned = 0;\n\treturn 1;\n}',
 'int prepare_binprm(struct linux_binprm *bprm)\n{\n\tint retval;\n\n\tbprm_fill_uid(bprm);\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm-&gt;cred_prepared = 1;\n\n\tmemset(bprm-&gt;buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm-&gt;file, 0, bprm-&gt;buf, BINPRM_BUF_SIZE);\n}',
 'int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint status = 0, size_change;\n\tint inode_locked = 0;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = inode-&gt;i_sb;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct dquot *transfer_to[MAXQUOTAS] = { };\n\tint qtype;\n\tint had_lock;\n\tstruct ocfs2_lock_holder oh;\n\n\ttrace_ocfs2_setattr(inode, dentry,\n\t\t\t    (unsigned long long)OCFS2_I(inode)-&gt;ip_blkno,\n\t\t\t    dentry-&gt;d_name.len, dentry-&gt;d_name.name,\n\t\t\t    attr-&gt;ia_valid, attr-&gt;ia_mode,\n\t\t\t    from_kuid(&amp;init_user_ns, attr-&gt;ia_uid),\n\t\t\t    from_kgid(&amp;init_user_ns, attr-&gt;ia_gid));\n\n\t/* ensuring we don\'t even attempt to truncate a symlink */\n\tif (S_ISLNK(inode-&gt;i_mode))\n\t\tattr-&gt;ia_valid &amp;= ~ATTR_SIZE;\n\n#define OCFS2_VALID_ATTRS (ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE \\\n\t\t\t   | ATTR_GID | ATTR_UID | ATTR_MODE)\n\tif (!(attr-&gt;ia_valid &amp; OCFS2_VALID_ATTRS))\n\t\treturn 0;\n\n\tstatus = setattr_prepare(dentry, attr);\n\tif (status)\n\t\treturn status;\n\n\tif (is_quota_modification(inode, attr)) {\n\t\tstatus = dquot_initialize(inode);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\tsize_change = S_ISREG(inode-&gt;i_mode) &amp;&amp; attr-&gt;ia_valid &amp; ATTR_SIZE;\n\tif (size_change) {\n\t\t/*\n\t\t * Here we should wait dio to finish before inode lock\n\t\t * to avoid a deadlock between ocfs2_setattr() and\n\t\t * ocfs2_dio_end_io_write()\n\t\t */\n\t\tinode_dio_wait(inode);\n\n\t\tstatus = ocfs2_rw_lock(inode, 1);\n\t\tif (status &lt; 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\thad_lock = ocfs2_inode_lock_tracker(inode, &amp;bh, 1, &amp;oh);\n\tif (had_lock &lt; 0) {\n\t\tstatus = had_lock;\n\t\tgoto bail_unlock_rw;\n\t} else if (had_lock) {\n\t\t/*\n\t\t * As far as we know, ocfs2_setattr() could only be the first\n\t\t * VFS entry point in the call chain of recursive cluster\n\t\t * locking issue.\n\t\t *\n\t\t * For instance:\n\t\t * chmod_common()\n\t\t *  notify_change()\n\t\t *   ocfs2_setattr()\n\t\t *    posix_acl_chmod()\n\t\t *     ocfs2_iop_get_acl()\n\t\t *\n\t\t * But, we\'re not 100% sure if it\'s always true, because the\n\t\t * ordering of the VFS entry points in the call chain is out\n\t\t * of our control. So, we\'d better dump the stack here to\n\t\t * catch the other cases of recursive locking.\n\t\t */\n\t\tmlog(ML_ERROR, "Another case of recursive locking:\\n");\n\t\tdump_stack();\n\t}\n\tinode_locked = 1;\n\n\tif (size_change) {\n\t\tstatus = inode_newsize_ok(inode, attr-&gt;ia_size);\n\t\tif (status)\n\t\t\tgoto bail_unlock;\n\n\t\tif (i_size_read(inode) &gt;= attr-&gt;ia_size) {\n\t\t\tif (ocfs2_should_order_data(inode)) {\n\t\t\t\tstatus = ocfs2_begin_ordered_truncate(inode,\n\t\t\t\t\t\t\t\t      attr-&gt;ia_size);\n\t\t\t\tif (status)\n\t\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t\tstatus = ocfs2_truncate_file(inode, bh, attr-&gt;ia_size);\n\t\t} else\n\t\t\tstatus = ocfs2_extend_file(inode, bh, attr-&gt;ia_size);\n\t\tif (status &lt; 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail_unlock;\n\t\t}\n\t}\n\n\tif ((attr-&gt;ia_valid &amp; ATTR_UID &amp;&amp; !uid_eq(attr-&gt;ia_uid, inode-&gt;i_uid)) ||\n\t    (attr-&gt;ia_valid &amp; ATTR_GID &amp;&amp; !gid_eq(attr-&gt;ia_gid, inode-&gt;i_gid))) {\n\t\t/*\n\t\t * Gather pointers to quota structures so that allocation /\n\t\t * freeing of quota structures happens here and not inside\n\t\t * dquot_transfer() where we have problems with lock ordering\n\t\t */\n\t\tif (attr-&gt;ia_valid &amp; ATTR_UID &amp;&amp; !uid_eq(attr-&gt;ia_uid, inode-&gt;i_uid)\n\t\t    &amp;&amp; OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t    OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(attr-&gt;ia_uid));\n\t\t\tif (IS_ERR(transfer_to[USRQUOTA])) {\n\t\t\t\tstatus = PTR_ERR(transfer_to[USRQUOTA]);\n\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t}\n\t\tif (attr-&gt;ia_valid &amp; ATTR_GID &amp;&amp; !gid_eq(attr-&gt;ia_gid, inode-&gt;i_gid)\n\t\t    &amp;&amp; OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t    OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(attr-&gt;ia_gid));\n\t\t\tif (IS_ERR(transfer_to[GRPQUOTA])) {\n\t\t\t\tstatus = PTR_ERR(transfer_to[GRPQUOTA]);\n\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t}\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS +\n\t\t\t\t\t   2 * ocfs2_quota_trans_credits(sb));\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t\tstatus = __dquot_transfer(inode, transfer_to);\n\t\tif (status &lt; 0)\n\t\t\tgoto bail_commit;\n\t} else {\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, bh);\n\tif (status &lt; 0)\n\t\tmlog_errno(status);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\nbail_unlock:\n\tif (status &amp;&amp; inode_locked) {\n\t\tocfs2_inode_unlock_tracker(inode, 1, &amp;oh, had_lock);\n\t\tinode_locked = 0;\n\t}\nbail_unlock_rw:\n\tif (size_change)\n\t\tocfs2_rw_unlock(inode, 1);\nbail:\n\n\t/* Release quota pointers in case we acquired them */\n\tfor (qtype = 0; qtype &lt; OCFS2_MAXQUOTAS; qtype++)\n\t\tdqput(transfer_to[qtype]);\n\n\tif (!status &amp;&amp; attr-&gt;ia_valid &amp; ATTR_MODE) {\n\t\tstatus = ocfs2_acl_chmod(inode, bh);\n\t\tif (status &lt; 0)\n\t\t\tmlog_errno(status);\n\t}\n\tif (inode_locked)\n\t\tocfs2_inode_unlock_tracker(inode, 1, &amp;oh, had_lock);\n\n\tbrelse(bh);\n\treturn status;\n}',
 'static int can_open_cached(struct nfs4_state *state, int mode)\n{\n\tint ret = 0;\n\tswitch (mode &amp; (FMODE_READ|FMODE_WRITE|O_EXCL)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &amp;state-&gt;flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &amp;state-&gt;flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &amp;state-&gt;flags) != 0;\n\t}\n\treturn ret;\n}',
 'static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = dump_one_state(x, 0, &amp;info);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}',
 'win_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n#endif\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp-&gt;tp_localdir = (tp-&gt;tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp-&gt;tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp-&gt;tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp-&gt;tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after &gt; 0)\n\t    {\n\t\t// Put new tab page before tab page "after".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp-&gt;tp_next != NULL\n\t\t\t\t\t       &amp;&amp; n &lt; after; tp = tp-&gt;tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp-&gt;tp_next = tp-&gt;tp_next;\n\t    tp-&gt;tp_next = newtp;\n\t}\n\tnewtp-&gt;tp_firstwin = newtp-&gt;tp_lastwin = newtp-&gt;tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin-&gt;w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp-&gt;tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When \'guioptions\' includes \'L\' or \'R\' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}',
 'static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == \'x\' || **buf == \'X\'); /* TODO: XML apparently disallows "X" */\n\tchar *endptr;\n\n\tif (hexadecimal &amp;&amp; (**buf != \'\\0\'))\n\t\t(*buf)++;\n\n\t/* strtol allows whitespace and other stuff in the beginning\n\t\t* we\'re not interested */\n\tif ((hexadecimal &amp;&amp; !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal &amp;&amp; !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\n\tcode_l = strtol(*buf, &amp;endptr, hexadecimal ? 16 : 10);\n\t/* we\'re guaranteed there were valid digits, so *endptr &gt; buf */\n\t*buf = endptr;\n\n\tif (**buf != \';\')\n\t\treturn FAILURE;\n\n\t/* many more are invalid, but that depends on whether it\'s HTML\n\t * (and which version) or XML. */\n\tif (code_l &gt; 0x10FFFFL)\n\t\treturn FAILURE;\n\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\n\treturn SUCCESS;\n}',
 'R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io &amp;&amp; bank &amp;&amp; map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank-&gt;submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank-&gt;maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank-&gt;last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry-&gt;data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &amp;&amp;\n\t\tr_io_submap_from (bd) &gt;= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank-&gt;maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) &lt; r_io_submap_from (sm) &amp;&amp;\n\t\tr_io_submap_to (sm) &lt; r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps =&gt; bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank-&gt;submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank-&gt;submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank-&gt;submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank-&gt;maprefs, mapref);\n\t\treturn true;\n\t}\n\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) &lt; r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry &amp;&amp; r_io_submap_to (((RIOSubMap *)entry-&gt;data)) &lt;= r_io_submap_to (sm)) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\tr_crbtree_delete (bank-&gt;submaps, entry-&gt;data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tentry = next;\n\t}\n\tif (entry &amp;&amp; r_io_submap_from (((RIOSubMap *)entry-&gt;data)) &lt;= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry-&gt;data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank-&gt;submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank-&gt;maprefs, mapref);\n\treturn true;\n}',
 'static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context-&gt;ChromaSubsamplingLevel &gt; 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n}',
 '_SSL_check_hostname (X509 *cert, const char *host)\n{\n\tint rv;\n\n\trv = _SSL_check_subject_altname (cert, host);\n\tif (rv == 0 || rv == -2)\n\t\treturn rv;\n\n\treturn _SSL_check_common_name (cert, host);\n}',
 'static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\n\tif (size_left == 0)\n\t\treturn 0;\n\n\tbuf = (char *) match32;\n\n\twhile (size_left &gt;= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\n\t\tmatch_kern = (struct ebt_entry_match *) state-&gt;buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state-&gt;buf_kern_start + state-&gt;buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret &lt; 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\n\t\t/* add padding before match-&gt;data (if any) */\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret &lt; 0)\n\t\t\treturn ret;\n\n\t\tif (match32-&gt;match_size &gt; size_left)\n\t\t\treturn -EINVAL;\n\n\t\tsize_left -= match32-&gt;match_size;\n\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret &lt; 0)\n\t\t\treturn ret;\n\n\t\tif (WARN_ON(ret &lt; match32-&gt;match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32-&gt;match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32-&gt;match_size;\n\n\t\tif (match_kern)\n\t\t\tmatch_kern-&gt;match_size = ret;\n\n\t\tif (WARN_ON(type == EBT_COMPAT_TARGET &amp;&amp; size_left))\n\t\t\treturn -EINVAL;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\n\treturn growth;\n}',
 'int check_directory(struct dir *dir)\n{\n\tint i;\n\tstruct dir_ent *ent;\n\n\tif(dir-&gt;dir_count &lt; 2)\n\t\treturn TRUE;\n\n\tfor(ent = dir-&gt;dirs, i = 0; i &lt; dir-&gt;dir_count - 1; ent = ent-&gt;next, i++)\n\t\tif(strcmp(ent-&gt;name, ent-&gt;next-&gt;name) &gt;= 0)\n\t\t\treturn FALSE;\n\n\treturn TRUE;\n}',
 'static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)\n{\n    uint16_t type = 0;\n    uint64_t size = 0;\n\n    if (!object)\n        return NULL;\n\n    type = (**object) &amp; BPLIST_MASK;\n    size = (**object) &amp; BPLIST_FILL;\n    (*object)++;\n\n    if (size == BPLIST_FILL) {\n        switch (type) {\n        case BPLIST_DATA:\n        case BPLIST_STRING:\n        case BPLIST_UNICODE:\n        case BPLIST_ARRAY:\n        case BPLIST_SET:\n        case BPLIST_DICT:\n        {\n            uint16_t next_size = **object &amp; BPLIST_FILL;\n            if ((**object &amp; BPLIST_MASK) != BPLIST_UINT) {\n                PLIST_BIN_ERR("%s: invalid size node type for node type 0x%02x: found 0x%02x, expected 0x%02x\\n", __func__, type, **object &amp; BPLIST_MASK, BPLIST_UINT);\n                return NULL;\n            }\n            (*object)++;\n            next_size = 1 &lt;&lt; next_size;\n            if (*object + next_size &gt; bplist-&gt;offset_table) {\n                PLIST_BIN_ERR("%s: size node data bytes for node type 0x%02x point outside of valid range\\n", __func__, type);\n                return NULL;\n            }\n            size = UINT_TO_HOST(*object, next_size);\n            (*object) += next_size;\n            break;\n        }\n        default:\n            break;\n        }\n    }\n\n    switch (type)\n    {\n\n    case BPLIST_NULL:\n        switch (size)\n        {\n\n        case BPLIST_TRUE:\n        {\n            plist_data_t data = plist_new_plist_data();\n            data-&gt;type = PLIST_BOOLEAN;\n            data-&gt;boolval = TRUE;\n            data-&gt;length = 1;\n            return node_create(NULL, data);\n        }\n\n        case BPLIST_FALSE:\n        {\n            plist_data_t data = plist_new_plist_data();\n            data-&gt;type = PLIST_BOOLEAN;\n            data-&gt;boolval = FALSE;\n            data-&gt;length = 1;\n            return node_create(NULL, data);\n        }\n\n        case BPLIST_NULL:\n        default:\n            return NULL;\n        }\n\n    case BPLIST_UINT:\n        if (*object + (uint64_t)(1 &lt;&lt; size) &gt; bplist-&gt;offset_table) {\n            PLIST_BIN_ERR("%s: BPLIST_UINT data bytes point outside of valid range\\n", __func__);\n            return NULL;\n        }\n        return parse_uint_node(object, size);\n\n    case BPLIST_REAL:\n        if (*object + (uint64_t)(1 &lt;&lt; size) &gt; bplist-&gt;offset_table) {\n            PLIST_BIN_ERR("%s: BPLIST_REAL data bytes point outside of valid range\\n", __func__);\n            return NULL;\n        }\n        return parse_real_node(object, size);\n\n    case BPLIST_DATE:\n        if (3 != size) {\n            PLIST_BIN_ERR("%s: invalid data size for BPLIST_DATE node\\n", __func__);\n            return NULL;\n        }\n        if (*object + (uint64_t)(1 &lt;&lt; size) &gt; bplist-&gt;offset_table) {\n            PLIST_BIN_ERR("%s: BPLIST_DATE data bytes point outside of valid range\\n", __func__);\n            return NULL;\n        }\n        return parse_date_node(object, size);\n\n    case BPLIST_DATA:\n        if (*object + size &lt; *object || *object + size &gt; bplist-&gt;offset_table) {\n            PLIST_BIN_ERR("%s: BPLIST_DATA data bytes point outside of valid range\\n", __func__);\n            return NULL;\n        }\n        return parse_data_node(object, size);\n\n    case BPLIST_STRING:\n        if (*object + size &lt; *object || *object + size &gt; bplist-&gt;offset_table) {\n            PLIST_BIN_ERR("%s: BPLIST_STRING data bytes point outside of valid range\\n", __func__);\n            return NULL;\n        }\n        return parse_string_node(object, size);\n\n    case BPLIST_UNICODE:\n        if (size*2 &lt; size) {\n            PLIST_BIN_ERR("%s: Integer overflow when calculating BPLIST_UNICODE data size.\\n", __func__);\n            return NULL;\n        }\n        if (*object + size*2 &lt; *object || *object + size*2 &gt; bplist-&gt;offset_table) {\n            PLIST_BIN_ERR("%s: BPLIST_UNICODE data bytes point outside of valid range\\n", __func__);\n            return NULL;\n        }\n        return parse_unicode_node(object, size);\n\n    case BPLIST_SET:\n    case BPLIST_ARRAY:\n        if (*object + size &lt; *object || *object + size &gt; bplist-&gt;offset_table) {\n            PLIST_BIN_ERR("%s: BPLIST_ARRAY data bytes point outside of valid range\\n", __func__);\n            return NULL;\n        }\n        return parse_array_node(bplist, object, size);\n\n    case BPLIST_UID:\n        if (*object + size+1 &gt; bplist-&gt;offset_table) {\n            PLIST_BIN_ERR("%s: BPLIST_UID data bytes point outside of valid range\\n", __func__);\n            return NULL;\n        }\n        return parse_uid_node(object, size);\n\n    case BPLIST_DICT:\n        if (*object + size &lt; *object || *object + size &gt; bplist-&gt;offset_table) {\n            PLIST_BIN_ERR("%s: BPLIST_DICT data bytes point outside of valid range\\n", __func__);\n            return NULL;\n        }\n        return parse_dict_node(bplist, object, size);\n\n    default:\n        PLIST_BIN_ERR("%s: unexpected node type 0x%02x\\n", __func__, type);\n        return NULL;\n    }\n    return NULL;\n}',
 '  Status CheckInputs(Tensor group_size_t, Tensor group_key_t) {\n    if (group_size_t.dims() &gt; 0) {\n      return errors::Internal(\n          "Unexpected dimensions on input group_size. "\n          "It shoulbe a scalar, got tensor with shape ",\n          group_size_t.shape().DebugString());\n    }\n    if (group_key_t.dims() &gt; 0) {\n      return errors::Internal("Unexpected dimensions on input group_key, got ",\n                              group_key_t.shape().DebugString());\n    }\n\n    auto group_size = group_size_t.unaligned_flat&lt;int32&gt;()(0);\n    if (group_size &lt;= 0) {\n      return errors::InvalidArgument(\n          "group_size must be positive integer but got ", group_size);\n    }\n    return Status::OK();\n  }',
 '\tvirtual bool OnWebRequest(CWebSock&amp; WebSock, const CString&amp; sPageName, CTemplate&amp; Tmpl) {\n\t\tCSmartPtr&lt;CWebSession&gt; spSession = WebSock.GetSession();\n\n\t\tif (sPageName == "settings") {\n\t\t\t// Admin Check\n\t\t\tif (!spSession-&gt;IsAdmin()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn SettingsPage(WebSock, Tmpl);\n\t\t} else if (sPageName == "adduser") {\n\t\t\t// Admin Check\n\t\t\tif (!spSession-&gt;IsAdmin()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn UserPage(WebSock, Tmpl);\n\t\t} else if (sPageName == "addnetwork") {\n\t\t\tCUser* pUser = SafeGetUserFromParam(WebSock);\n\n\t\t\t// Admin||Self Check\n\t\t\tif (!spSession-&gt;IsAdmin() &amp;&amp; (!spSession-&gt;GetUser() || spSession-&gt;GetUser() != pUser)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (pUser) {\n\t\t\t\treturn NetworkPage(WebSock, Tmpl, pUser);\n\t\t\t}\n\n\t\t\tWebSock.PrintErrorPage("No such username");\n\t\t\treturn true;\n\t\t} else if (sPageName == "editnetwork") {\n\t\t\tCIRCNetwork* pNetwork = SafeGetNetworkFromParam(WebSock);\n\n\t\t\t// Admin||Self Check\n\t\t\tif (!spSession-&gt;IsAdmin() &amp;&amp; (!spSession-&gt;GetUser() || !pNetwork || spSession-&gt;GetUser() != pNetwork-&gt;GetUser())) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!pNetwork) {\n\t\t\t\tWebSock.PrintErrorPage("No such username or network");\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn NetworkPage(WebSock, Tmpl, pNetwork-&gt;GetUser(), pNetwork);\n\n\t\t} else if (sPageName == "delnetwork") {\n\t\t\tCString sUser = WebSock.GetParam("user");\n\t\t\tif (sUser.empty() &amp;&amp; !WebSock.IsPost()) {\n\t\t\t\tsUser = WebSock.GetParam("user", false);\n\t\t\t}\n\n\t\t\tCUser* pUser = CZNC::Get().FindUser(sUser);\n\n\t\t\t// Admin||Self Check\n\t\t\tif (!spSession-&gt;IsAdmin() &amp;&amp; (!spSession-&gt;GetUser() || spSession-&gt;GetUser() != pUser)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn DelNetwork(WebSock, pUser, Tmpl);\n\t\t} else if (sPageName == "editchan") {\n\t\t\tCIRCNetwork* pNetwork = SafeGetNetworkFromParam(WebSock);\n\n\t\t\t// Admin||Self Check\n\t\t\tif (!spSession-&gt;IsAdmin() &amp;&amp; (!spSession-&gt;GetUser() || !pNetwork || spSession-&gt;GetUser() != pNetwork-&gt;GetUser())) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!pNetwork) {\n\t\t\t\tWebSock.PrintErrorPage("No such username or network");\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tCString sChan = WebSock.GetParam("name");\n\t\t\tif(sChan.empty() &amp;&amp; !WebSock.IsPost()) {\n\t\t\t\tsChan = WebSock.GetParam("name", false);\n\t\t\t}\n\t\t\tCChan* pChan = pNetwork-&gt;FindChan(sChan);\n\t\t\tif (!pChan) {\n\t\t\t\tWebSock.PrintErrorPage("No such channel");\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn ChanPage(WebSock, Tmpl, pNetwork, pChan);\n\t\t} else if (sPageName == "addchan") {\n\t\t\tCIRCNetwork* pNetwork = SafeGetNetworkFromParam(WebSock);\n\n\t\t\t// Admin||Self Check\n\t\t\tif (!spSession-&gt;IsAdmin() &amp;&amp; (!spSession-&gt;GetUser() || !pNetwork || spSession-&gt;GetUser() != pNetwork-&gt;GetUser())) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (pNetwork) {\n\t\t\t\treturn ChanPage(WebSock, Tmpl, pNetwork);\n\t\t\t}\n\n\t\t\tWebSock.PrintErrorPage("No such username or network");\n\t\t\treturn true;\n\t\t} else if (sPageName == "delchan") {\n\t\t\tCIRCNetwork* pNetwork = SafeGetNetworkFromParam(WebSock);\n\n\t\t\t// Admin||Self Check\n\t\t\tif (!spSession-&gt;IsAdmin() &amp;&amp; (!spSession-&gt;GetUser() || !pNetwork || spSession-&gt;GetUser() != pNetwork-&gt;GetUser())) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (pNetwork) {\n\t\t\t\treturn DelChan(WebSock, pNetwork);\n\t\t\t}\n\n\t\t\tWebSock.PrintErrorPage("No such username or network");\n\t\t\treturn true;\n\t\t} else if (sPageName == "deluser") {\n\t\t\tif (!spSession-&gt;IsAdmin()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!WebSock.IsPost()) {\n\t\t\t\t// Show the "Are you sure?" page:\n\n\t\t\t\tCString sUser = WebSock.GetParam("user", false);\n\t\t\t\tCUser* pUser = CZNC::Get().FindUser(sUser);\n\n\t\t\t\tif (!pUser) {\n\t\t\t\t\tWebSock.PrintErrorPage("No such username");\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tTmpl.SetFile("del_user.tmpl");\n\t\t\t\tTmpl["Username"] = sUser;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// The "Are you sure?" page has been submitted with "Yes",\n\t\t\t// so we actually delete the user now:\n\n\t\t\tCString sUser = WebSock.GetParam("user");\n\t\t\tCUser* pUser = CZNC::Get().FindUser(sUser);\n\n\t\t\tif (pUser &amp;&amp; pUser == spSession-&gt;GetUser()) {\n\t\t\t\tWebSock.PrintErrorPage("Please don\'t delete yourself, suicide is not the answer!");\n\t\t\t\treturn true;\n\t\t\t} else if (CZNC::Get().DeleteUser(sUser)) {\n\t\t\t\tWebSock.Redirect("listusers");\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tWebSock.PrintErrorPage("No such username");\n\t\t\treturn true;\n\t\t} else if (sPageName == "edituser") {\n\t\t\tCString sUserName = SafeGetUserNameParam(WebSock);\n\t\t\tCUser* pUser = CZNC::Get().FindUser(sUserName);\n\n\t\t\tif(!pUser) {\n\t\t\t\tif(sUserName.empty()) {\n\t\t\t\t\tpUser = spSession-&gt;GetUser();\n\t\t\t\t} // else: the "no such user" message will be printed.\n\t\t\t}\n\n\t\t\t// Admin||Self Check\n\t\t\tif (!spSession-&gt;IsAdmin() &amp;&amp; (!spSession-&gt;GetUser() || spSession-&gt;GetUser() != pUser)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (pUser) {\n\t\t\t\treturn UserPage(WebSock, Tmpl, pUser);\n\t\t\t}\n\n\t\t\tWebSock.PrintErrorPage("No such username");\n\t\t\treturn true;\n\t\t} else if (sPageName == "listusers" &amp;&amp; spSession-&gt;IsAdmin()) {\n\t\t\treturn ListUsersPage(WebSock, Tmpl);\n\t\t} else if (sPageName == "traffic" &amp;&amp; spSession-&gt;IsAdmin()) {\n\t\t\treturn TrafficPage(WebSock, Tmpl);\n\t\t} else if (sPageName == "index") {\n\t\t\treturn true;\n\t\t} else if (sPageName == "add_listener") {\n\t\t\t// Admin Check\n\t\t\tif (!spSession-&gt;IsAdmin()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn AddListener(WebSock, Tmpl);\n\t\t} else if (sPageName == "del_listener") {\n\t\t\t// Admin Check\n\t\t\tif (!spSession-&gt;IsAdmin()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn DelListener(WebSock, Tmpl);\n\t\t}\n\n\t\treturn false;\n\t}',
 'hcom_client_init\r\n(\r\n\t\tOUT\tp_hsm_com_client_hdl_t\t*p_hdl,\r\n\tIN\t\tchar\t\t\t\t\t*server_path,\r\n\tIN\t\tchar\t\t\t\t\t*client_path,\r\n\tIN\t\tint\t\t\t\t\t\tmax_data_len\r\n)\r\n{\r\n\thsm_com_client_hdl_t\t*hdl = NULL;\r\n\thsm_com_errno_t\t\t\tres = HSM_COM_OK;\r\n\t\r\n\r\n\tif((strlen(server_path) &gt; (HSM_COM_SVR_MAX_PATH - 1)) ||\r\n\t   (strlen(server_path) == 0)){\r\n\t\tres = HSM_COM_PATH_ERR;\r\n\t\tgoto cleanup;\r\n\t}\r\n\r\n\tif((strlen(client_path) &gt; (HSM_COM_SVR_MAX_PATH - 1)) ||\r\n\t   (strlen(client_path) == 0)){\r\n\t\tres = HSM_COM_PATH_ERR;\r\n\t\tgoto cleanup;\r\n\t}\r\n\r\n\r\n\tif((hdl = calloc(1,sizeof(hsm_com_client_hdl_t))) == NULL)\r\n\t{\r\n\t\tres = HSM_COM_NO_MEM;\r\n\t\tgoto cleanup;\r\n\t}\r\n\r\n\tif((hdl-&gt;scr.scratch = malloc(max_data_len)) == NULL) \r\n\t{\r\n\t\tres = HSM_COM_NO_MEM;\r\n\t\tgoto cleanup;\r\n\t}\r\n\r\n\tif((hdl-&gt;recv_buf = malloc(max_data_len)) == NULL) \r\n\t{\r\n\t\tres = HSM_COM_NO_MEM;\r\n\t\tgoto cleanup;\r\n\t}\r\n\r\n\tif((hdl-&gt;send_buf = malloc(max_data_len)) == NULL) \r\n\t{\r\n\t\tres = HSM_COM_NO_MEM;\r\n\t\tgoto cleanup;\r\n\t}\r\n\r\n\thdl-&gt;scr.scratch_fill = 0;\r\n\thdl-&gt;scr.scratch_len = max_data_len;\r\n\thdl-&gt;buf_len = max_data_len;\r\n\thdl-&gt;trans_id = 1;\r\n\r\n\r\n\tstrcpy(hdl-&gt;s_path,server_path);\r\n\tstrcpy(hdl-&gt;c_path,client_path);\r\n\r\n\tif (mkstemp(hdl-&gt;c_path) == -1)\r\n\t{\r\n\t\tres = HSM_COM_PATH_ERR;\r\n\t\tgoto cleanup;\r\n\t}\r\n\r\n\thdl-&gt;client_state = HSM_COM_C_STATE_IN;\r\n\r\n\t*p_hdl = hdl;\r\n\r\n\treturn res;\r\n\r\ncleanup:\r\n\tif(hdl)\r\n\t{\r\n\t\tif (hdl-&gt;scr.scratch) {\r\n\t\t\tfree(hdl-&gt;scr.scratch);\r\n\t\t}\r\n\t\tif (hdl-&gt;recv_buf) {\r\n\t\t\tfree(hdl-&gt;recv_buf);\r\n\t\t}\r\n\t\tfree(hdl);\r\n\t}\r\n\r\n\treturn res;\r\n\r\n}\r',
 'static int startEspAppDirective(MaState *state, cchar *key, cchar *value)\n{\n    HttpRoute   *route;\n    cchar       *auth, *database, *name, *prefix, *dir, *routeSet, *combine;\n    char        *option, *ovalue, *tok;\n\n    dir = ".";\n    routeSet = 0;\n    combine = 0;\n    prefix = 0;\n    database = 0;\n    auth = 0;\n    name = 0;\n\n    if (scontains(value, "=")) {\n        for (option = maGetNextArg(sclone(value), &amp;tok); option; option = maGetNextArg(tok, &amp;tok)) {\n            option = stok(option, " =\\t,", &amp;ovalue);\n            ovalue = strim(ovalue, "\\"\'", MPR_TRIM_BOTH);\n            if (smatch(option, "auth")) {\n                auth = ovalue;\n            } else if (smatch(option, "database")) {\n                database = ovalue;\n            } else if (smatch(option, "dir")) {\n                dir = ovalue;\n            } else if (smatch(option, "combine")) {\n                combine = ovalue;\n#if DEPRECATED || 1\n            } else if (smatch(option, "combined")) {\n                combine = ovalue;\n#endif\n            } else if (smatch(option, "name")) {\n                name = ovalue;\n            } else if (smatch(option, "prefix")) {\n                prefix = ovalue;\n            } else if (smatch(option, "routes")) {\n                routeSet = ovalue;\n            } else {\n                mprLog("error esp", 0, "Unknown EspApp option \\"%s\\"", option);\n            }\n        }\n    }\n    if (mprSamePath(state-&gt;route-&gt;documents, dir)) {\n        /*\n            Can use existing route as it has the same prefix and documents directory.\n         */\n        route = state-&gt;route;\n    } else {\n        route = httpCreateInheritedRoute(state-&gt;route);\n    }\n    state-&gt;route = route;\n    if (auth) {\n        if (httpSetAuthStore(route-&gt;auth, auth) &lt; 0) {\n            mprLog("error esp", 0, "The %s AuthStore is not available on this platform", auth);\n            return MPR_ERR_BAD_STATE;\n        }\n    }\n    if (combine) {\n        route-&gt;combine = scaselessmatch(combine, "true") || smatch(combine, "1");\n    }\n    if (database) {\n        if (espDbDirective(state, key, database) &lt; 0) {\n            return MPR_ERR_BAD_STATE;\n        }\n    }\n    if (espDefineApp(route, dir, name, prefix, routeSet) &lt; 0) {\n        return MPR_ERR_CANT_CREATE;\n    }\n    if (prefix) {\n        espSetConfig(route, "esp.appPrefix", prefix);\n    }\n    return 0;\n}',
 'static inline struct inode *isofs_iget(struct super_block *sb,\n\t\t\t\t       unsigned long block,\n\t\t\t\t       unsigned long offset)\n{\n\treturn __isofs_iget(sb, block, offset, 0);\n}',
 'header_read (SF_PRIVATE *psf, void *ptr, int bytes)\n{\tint count = 0 ;\n\n\tif (psf-&gt;headindex &gt;= SIGNED_SIZEOF (psf-&gt;header))\n\t\treturn psf_fread (ptr, 1, bytes, psf) ;\n\n\tif (psf-&gt;headindex + bytes &gt; SIGNED_SIZEOF (psf-&gt;header))\n\t{\tint most ;\n\n\t\tmost = SIGNED_SIZEOF (psf-&gt;header) - psf-&gt;headend ;\n\t\tpsf_fread (psf-&gt;header + psf-&gt;headend, 1, most, psf) ;\n\t\tmemcpy (ptr, psf-&gt;header + psf-&gt;headend, most) ;\n\t\tpsf-&gt;headend = psf-&gt;headindex += most ;\n\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;\n\t\treturn bytes ;\n\t\t} ;\n\n\tif (psf-&gt;headindex + bytes &gt; psf-&gt;headend)\n\t{\tcount = psf_fread (psf-&gt;header + psf-&gt;headend, 1, bytes - (psf-&gt;headend - psf-&gt;headindex), psf) ;\n\t\tif (count != bytes - (int) (psf-&gt;headend - psf-&gt;headindex))\n\t\t{\tpsf_log_printf (psf, "Error : psf_fread returned short count.\\n") ;\n\t\t\treturn count ;\n\t\t\t} ;\n\t\tpsf-&gt;headend += count ;\n\t\t} ;\n\n\tmemcpy (ptr, psf-&gt;header + psf-&gt;headindex, bytes) ;\n\tpsf-&gt;headindex += bytes ;\n\n\treturn bytes ;\n} /* header_read */',
 'static int cg_opendir(const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tconst char *cgroup;\n\tstruct file_info *dir_info;\n\tchar *controller = NULL;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tif (strcmp(path, "/cgroup") == 0) {\n\t\tcgroup = NULL;\n\t\tcontroller = NULL;\n\t} else {\n\t\t// return list of keys for the controller, and list of child cgroups\n\t\tcontroller = pick_controller_from_path(fc, path);\n\t\tif (!controller)\n\t\t\treturn -EIO;\n\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\t/* this is just /cgroup/controller, return its contents */\n\t\t\tcgroup = "/";\n\t\t}\n\t}\n\n\tif (cgroup) {\n\t\tif (!caller_may_see_dir(fc-&gt;pid, controller, cgroup))\n\t\t\treturn -ENOENT;\n\t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))\n\t\t\treturn -EACCES;\n\t}\n\n\t/* we\'ll free this at cg_releasedir */\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info-&gt;controller = must_copy_string(controller);\n\tdir_info-&gt;cgroup = must_copy_string(cgroup);\n\tdir_info-&gt;type = LXC_TYPE_CGDIR;\n\tdir_info-&gt;buf = NULL;\n\tdir_info-&gt;file = NULL;\n\tdir_info-&gt;buflen = 0;\n\n\tfi-&gt;fh = (unsigned long)dir_info;\n\treturn 0;\n}',
 'pthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\tLeaveCriticalSection(mutex-&gt;lock);\n\treturn 0;\n}',
 'TfLiteStatus EluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &amp;input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &amp;output));\n  OpData* data = reinterpret_cast&lt;OpData*&gt;(node-&gt;user_data);\n\n  // Use LUT to handle quantized elu path.\n  if (input-&gt;type == kTfLiteInt8) {\n    PopulateLookupTable&lt;int8_t&gt;(data, input, output, [](float value) {\n      return value &lt; 0.0 ? std::exp(value) - 1.0f : value;\n    });\n  }\n  return GenericPrepare(context, node);\n}',
 'static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool compat)\n{\n\tstruct file *file = kiocb-&gt;ki_filp;\n\tssize_t ret = 0;\n\n\tswitch (kiocb-&gt;ki_opcode) {\n\tcase IOCB_CMD_PREAD:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file-&gt;f_mode &amp; FMODE_READ)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_WRITE, kiocb-&gt;ki_buf,\n\t\t\tkiocb-&gt;ki_left)))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(READ, file, kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file-&gt;f_op-&gt;aio_read)\n\t\t\tkiocb-&gt;ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITE:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file-&gt;f_mode &amp; FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_READ, kiocb-&gt;ki_buf,\n\t\t\tkiocb-&gt;ki_left)))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(WRITE, file, kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file-&gt;f_op-&gt;aio_write)\n\t\t\tkiocb-&gt;ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PREADV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file-&gt;f_mode &amp; FMODE_READ)))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(READ, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file-&gt;f_op-&gt;aio_read)\n\t\t\tkiocb-&gt;ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITEV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file-&gt;f_mode &amp; FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(WRITE, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file-&gt;f_op-&gt;aio_write)\n\t\t\tkiocb-&gt;ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_FDSYNC:\n\t\tret = -EINVAL;\n\t\tif (file-&gt;f_op-&gt;aio_fsync)\n\t\t\tkiocb-&gt;ki_retry = aio_fdsync;\n\t\tbreak;\n\tcase IOCB_CMD_FSYNC:\n\t\tret = -EINVAL;\n\t\tif (file-&gt;f_op-&gt;aio_fsync)\n\t\t\tkiocb-&gt;ki_retry = aio_fsync;\n\t\tbreak;\n\tdefault:\n\t\tdprintk("EINVAL: io_submit: no operation provided\\n");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!kiocb-&gt;ki_retry)\n\t\treturn ret;\n\n\treturn 0;\n}',
 'static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification-&gt;sigev_notify != SIGEV_NONE &amp;&amp;\n\t\t\t     notification-&gt;sigev_notify != SIGEV_SIGNAL &amp;&amp;\n\t\t\t     notification-&gt;sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification-&gt;sigev_notify == SIGEV_SIGNAL &amp;&amp;\n\t\t\t!valid_signal(notification-&gt;sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification-&gt;sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t/* create the notify skb */\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc-&gt;data,\n\t\t\t\t\tnotification-&gt;sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* TODO: add a header? */\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t/* and attach it to the socket */\nretry:\n\t\t\tf = fdget(notification-&gt;sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n\t\t\tret = netlink_attachskb(sock, nc, &amp;timeo, NULL);\n\t\t\tif (ret == 1) {\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tsock = NULL;\n\t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file-&gt;f_op != &amp;mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&amp;info-&gt;lock);\n\tif (notification == NULL) {\n\t\tif (info-&gt;notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode-&gt;i_atime = inode-&gt;i_ctime = current_time(inode);\n\t\t}\n\t} else if (info-&gt;notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification-&gt;sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo-&gt;notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo-&gt;notify_sock = sock;\n\t\t\tinfo-&gt;notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo-&gt;notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo-&gt;notify.sigev_signo = notification-&gt;sigev_signo;\n\t\t\tinfo-&gt;notify.sigev_value = notification-&gt;sigev_value;\n\t\t\tinfo-&gt;notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo-&gt;notify_owner = get_pid(task_tgid(current));\n\t\tinfo-&gt;notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode-&gt;i_atime = inode-&gt;i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&amp;info-&gt;lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}',
 'void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (!(item-&gt;type&amp;cJSON_StringIsConst) &amp;&amp; item-&gt;string) cJSON_free(item-&gt;string);item-&gt;string=(char*)string;item-&gt;type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}',
 'static void generateTable(int argc, char **argv)\n{\n    Edi         *edi;\n    cchar       *field;\n    char        *typeString;\n    int         rc, i, type;\n\n    app-&gt;table = app-&gt;table ? app-&gt;table : sclone(argv[0]);\n    if ((edi = app-&gt;eroute-&gt;edi) == 0) {\n        fail("Database not defined");\n        return;\n    }\n    edi-&gt;flags |= EDI_SUPPRESS_SAVE;\n    if ((rc = ediAddTable(edi, app-&gt;table)) &lt; 0) {\n        if (rc != MPR_ERR_ALREADY_EXISTS) {\n            fail("Cannot add table \'%s\'", app-&gt;table);\n        }\n    } else {\n        if ((rc = ediAddColumn(edi, app-&gt;table, "id", EDI_TYPE_INT, EDI_AUTO_INC | EDI_INDEX | EDI_KEY)) != 0) {\n            fail("Cannot add column \'id\'");\n        }\n    }\n    for (i = 1; i &lt; argc &amp;&amp; !app-&gt;error; i++) {\n        field = ssplit(sclone(argv[i]), ":", &amp;typeString);\n        if ((type = ediParseTypeString(typeString)) &lt; 0) {\n            fail("Unknown type \'%s\' for field \'%s\'", typeString, field);\n            break;\n        }\n        if ((rc = ediAddColumn(edi, app-&gt;table, field, type, 0)) != 0) {\n            if (rc != MPR_ERR_ALREADY_EXISTS) {\n                fail("Cannot add column \'%s\'", field);\n                break;\n            } else {\n                ediChangeColumn(edi, app-&gt;table, field, type, 0);\n            }\n        }\n    }\n    edi-&gt;flags &amp;= ~EDI_SUPPRESS_SAVE;\n    ediSave(edi);\n    qtrace("Update", "Database schema");\n}',
 'static void perf_event_exit_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &amp;per_cpu(swevent_htable, cpu);\n\n\tperf_event_exit_cpu_context(cpu);\n\n\tmutex_lock(&amp;swhash-&gt;hlist_mutex);\n\tswhash-&gt;online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&amp;swhash-&gt;hlist_mutex);\n}',
 "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\n\tvmcb_mark_dirty(svm-&gt;vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&amp;svm-&gt;vcpu))\n\t\treturn;\n\n\tc = &amp;svm-&gt;vmcb-&gt;control;\n\th = &amp;svm-&gt;vmcb01.ptr-&gt;control;\n\tg = &amp;svm-&gt;nested.ctl;\n\n\tfor (i = 0; i &lt; MAX_INTERCEPT; i++)\n\t\tc-&gt;intercepts[i] = h-&gt;intercepts[i];\n\n\tif (g-&gt;int_ctl &amp; V_INTR_MASKING_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\n\tfor (i = 0; i &lt; MAX_INTERCEPT; i++)\n\t\tc-&gt;intercepts[i] |= g-&gt;intercepts[i];\n\n\t/* If SMI is not intercepted, ignore guest SMI intercept as well  */\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n\n\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n}",
 'void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag-&gt;header()-&gt;majorVersion() &lt; 4 &amp;&amp;\n     tag-&gt;frameList("TDRC").size() == 1 &amp;&amp;\n     tag-&gt;frameList("TDAT").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast&lt;TextIdentificationFrame *&gt;(tag-&gt;frameList("TDRC").front());\n    UnknownFrame *tdat = static_cast&lt;UnknownFrame *&gt;(tag-&gt;frameList("TDAT").front());\n\n    if(tdrc-&gt;fieldList().size() == 1 &amp;&amp;\n       tdrc-&gt;fieldList().front().size() == 4 &amp;&amp;\n       tdat-&gt;data().size() &gt;= 5)\n    {\n      String date(tdat-&gt;data().mid(1), String::Type(tdat-&gt;data()[0]));\n      if(date.length() == 4) {\n        tdrc-&gt;setText(tdrc-&gt;toString() + \'-\' + date.substr(2, 2) + \'-\' + date.substr(0, 2));\n        if(tag-&gt;frameList("TIME").size() == 1) {\n          UnknownFrame *timeframe = static_cast&lt;UnknownFrame *&gt;(tag-&gt;frameList("TIME").front());\n          if(timeframe-&gt;data().size() &gt;= 5) {\n            String time(timeframe-&gt;data().mid(1), String::Type(timeframe-&gt;data()[0]));\n            if(time.length() == 4) {\n              tdrc-&gt;setText(tdrc-&gt;toString() + \'T\' + time.substr(0, 2) + \':\' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}',
 'static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\tsize_t *acl_len)\n{\n\t__be32 *savep;\n\tuint32_t attrlen,\n\t\t bitmap[3] = {0};\n\tstruct kvec *iov = req-&gt;rq_rcv_buf.head;\n\tint status;\n\n\t*acl_len = 0;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_length(xdr, &amp;attrlen, &amp;savep)) != 0)\n\t\tgoto out;\n\n\tif (unlikely(bitmap[0] &amp; (FATTR4_WORD0_ACL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] &amp; FATTR4_WORD0_ACL)) {\n\t\tsize_t hdrlen;\n\t\tu32 recvd;\n\n\t\t/* We ignore &amp;savep and don\'t do consistency checks on\n\t\t * the attr length.  Let userspace figure it out.... */\n\t\thdrlen = (u8 *)xdr-&gt;p - (u8 *)iov-&gt;iov_base;\n\t\trecvd = req-&gt;rq_rcv_buf.len - hdrlen;\n\t\tif (attrlen &gt; recvd) {\n\t\t\tdprintk("NFS: server cheating in getattr"\n\t\t\t\t\t" acl reply: attrlen %u &gt; recvd %u\\n",\n\t\t\t\t\tattrlen, recvd);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\txdr_read_pages(xdr, attrlen);\n\t\t*acl_len = attrlen;\n\t} else\n\t\tstatus = -EOPNOTSUPP;\n\nout:\n\treturn status;\n}',
 'parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,\n    Buffer* buf, int *err, gchar **err_info)\n{\n\tguint8 *pd;\n\tgchar\tline[COSINE_LINE_LENGTH];\n\tint\ti, hex_lines, n, caplen = 0;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i &lt; hex_lines; i++) {\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (empty_line(line)) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup("cosine: hex dump line doesn\'t have 16 numbers");\n\t\t\treturn FALSE;\n\t\t}\n\t\tcaplen += n;\n\t}\n\tphdr-&gt;caplen = caplen;\n\treturn TRUE;\n}',
 'spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\n\t*minor_status = 0;\n\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\n\t/*\n\t * If this is still an SPNEGO mech, release it locally.\n\t */\n\tif ((*ctx)-&gt;magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &amp;(*ctx)-&gt;ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\n\treturn (ret);\n}',
 'static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\n\t/* we only set alt for MIDIStreaming interface */\n\tif (intf != midi-&gt;ms_id)\n\t\treturn 0;\n\n\terr = f_midi_start_ep(midi, f, midi-&gt;in_ep);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi_start_ep(midi, f, midi-&gt;out_ep);\n\tif (err)\n\t\treturn err;\n\n\t/* pre-allocate write usb requests to use on f_midi_transmit. */\n\twhile (kfifo_avail(&amp;midi-&gt;in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi-&gt;in_ep, midi-&gt;buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq-&gt;length = 0;\n\t\treq-&gt;complete = f_midi_complete;\n\n\t\tkfifo_put(&amp;midi-&gt;in_req_fifo, req);\n\t}\n\n\t/* allocate a bunch of read buffers and queue them all at once. */\n\tfor (i = 0; i &lt; midi-&gt;qlen &amp;&amp; err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi-&gt;out_ep, midi-&gt;buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq-&gt;complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi-&gt;out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, "%s: couldn\'t enqueue request: %d\\n",\n\t\t\t\t    midi-&gt;out_ep-&gt;name, err);\n\t\t\tif (req-&gt;buf != NULL)\n\t\t\t\tfree_ep_req(midi-&gt;out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}',
 'wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo-&gt;ndo_snapend;\n\n\tND_PRINT((ndo, " wb-prep:"));\n\tif (len &lt; sizeof(*prep) || !ND_TTEST(*prep))\n\t\treturn (-1);\n\tn = EXTRACT_32BITS(&amp;prep-&gt;pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n &gt;= 0 &amp;&amp; ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = \'&lt;\';\n\n\t\tND_PRINT((ndo, " %u/%s:%u",\n\t\t    EXTRACT_32BITS(&amp;ps-&gt;slot),\n\t\t    ipaddr_string(ndo, &amp;ps-&gt;page.p_sid),\n\t\t    EXTRACT_32BITS(&amp;ps-&gt;page.p_uid)));\n\t\tio = (const struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps-&gt;nid; io &lt; ie &amp;&amp; ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, "%c%s:%u", c, ipaddr_string(ndo, &amp;io-&gt;id),\n\t\t\t    EXTRACT_32BITS(&amp;io-&gt;off)));\n\t\t\tc = \',\';\n\t\t}\n\t\tND_PRINT((ndo, "&gt;"));\n\t\tps = (const struct pgstate *)io;\n\t}\n\treturn ((const u_char *)ps &lt;= ep? 0 : -1);\n}',
 'static struct bpf_insn_aux_data *cur_aux(struct bpf_verifier_env *env)\n{\n\treturn &amp;env-&gt;insn_aux_data[env-&gt;insn_idx];\n}',
 'error_t webSocketParseHeaderField(WebSocket *webSocket, char_t *line)\n{\n   char_t *separator;\n   char_t *name;\n   char_t *value;\n   WebSocketHandshakeContext *handshakeContext;\n\n   //Point to the handshake context\n   handshakeContext = &amp;webSocket-&gt;handshakeContext;\n\n   //Debug message\n   TRACE_DEBUG("%s", line);\n\n   //Check whether a separator is present\n   separator = osStrchr(line, \':\');\n\n   //Separator found?\n   if(separator != NULL)\n   {\n      //Split the line\n      *separator = \'\\0\';\n\n      //Get field name and value\n      name = strTrimWhitespace(line);\n      value = strTrimWhitespace(separator + 1);\n\n      //Upgrade header field found?\n      if(!osStrcasecmp(name, "Upgrade"))\n      {\n         if(!osStrcasecmp(value, "websocket"))\n            handshakeContext-&gt;upgradeWebSocket = TRUE;\n\n      }\n      //Connection header field found?\n      else if(!osStrcasecmp(name, "Connection"))\n      {\n         //Parse Connection header field\n         webSocketParseConnectionField(webSocket, value);\n      }\n      //Sec-WebSocket-Key header field found?\n      else if(!osStrcasecmp(name, "Sec-WebSocket-Key"))\n      {\n         //Server operation?\n         if(webSocket-&gt;endpoint == WS_ENDPOINT_SERVER)\n         {\n            //Save the contents of the Sec-WebSocket-Key header field\n            strSafeCopy(handshakeContext-&gt;clientKey, value,\n               WEB_SOCKET_CLIENT_KEY_SIZE + 1);\n         }\n      }\n      //Sec-WebSocket-Accept header field found?\n      else if(!osStrcasecmp(name, "Sec-WebSocket-Accept"))\n      {\n         //Client operation?\n         if(webSocket-&gt;endpoint == WS_ENDPOINT_CLIENT)\n         {\n            //Save the contents of the Sec-WebSocket-Accept header field\n            strSafeCopy(handshakeContext-&gt;serverKey, value,\n               WEB_SOCKET_SERVER_KEY_SIZE + 1);\n         }\n      }\n#if (WEB_SOCKET_BASIC_AUTH_SUPPORT == ENABLED || WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED)\n      //WWW-Authenticate header field found?\n      else if(!osStrcasecmp(name, "WWW-Authenticate"))\n      {\n         //Parse WWW-Authenticate header field\n         webSocketParseAuthenticateField(webSocket, value);\n      }\n#endif\n      //Content-Length header field found?\n      else if(!osStrcasecmp(name, "Content-Length"))\n      {\n         handshakeContext-&gt;contentLength = osStrtoul(value, NULL, 10);\n      }\n   }\n\n   //Successful processing\n   return NO_ERROR;\n}',
 "static int is_integer(char *string)\n{\n  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string &amp;&amp; isdigit(*string))\n      ;                                           /* deliberately empty */\n    if (!*string)\n      return 1;\n  }\n  return 0;\n}",
 'GF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp-&gt;internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}',
 'TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  auto* params = reinterpret_cast&lt;TfLiteShapeParams*&gt;(node-&gt;builtin_data);\n  switch (params-&gt;out_type) {\n    case kTfLiteInt32:\n      output-&gt;type = kTfLiteInt32;\n      break;\n    case kTfLiteInt64:\n      output-&gt;type = kTfLiteInt64;\n      break;\n    default:\n      context-&gt;ReportError(context, "Unknown shape output data type: %d",\n                           params-&gt;out_type);\n      return kTfLiteError;\n  }\n\n  // By design, the input shape is always known at the time of Prepare, even\n  // if the preceding op that generates |input| is dynamic. Thus, we can\n  // always compute the shape immediately, without waiting for Eval.\n  SetTensorToPersistentRo(output);\n\n  // Shape always produces a 1-dimensional output tensor, where each output\n  // element is the length of the corresponding input tensor\'s dimension.\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(1);\n  output_size-&gt;data[0] = NumDimensions(input);\n  TF_LITE_ENSURE_STATUS(context-&gt;ResizeTensor(context, output, output_size));\n\n  TFLITE_DCHECK_EQ(NumDimensions(output), 1);\n  TFLITE_DCHECK_EQ(SizeOfDimension(output, 0), NumDimensions(input));\n\n  // Immediately propagate the known shape to the output tensor. This allows\n  // downstream ops that rely on the value to use it during prepare.\n  switch (output-&gt;type) {\n    case kTfLiteInt32:\n      ExtractShape(input, GetTensorData&lt;int32_t&gt;(output));\n      break;\n    case kTfLiteInt64:\n      ExtractShape(input, GetTensorData&lt;int64_t&gt;(output));\n      break;\n    default:\n      return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}',
 'static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path-&gt;mnt-&gt;mnt_sb;\n\tstruct mount *mnt = real_mount(path-&gt;mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path-&gt;dentry != path-&gt;mnt-&gt;mnt_root)\n\t\treturn -EINVAL;\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&amp;sb-&gt;s_umount);\n\tif (flags &amp; MS_BIND)\n\t\terr = change_mount_flags(path-&gt;mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt-&gt;mnt.mnt_flags &amp; MNT_PROPAGATION_MASK;\n\t\tmnt-&gt;mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt-&gt;mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&amp;sb-&gt;s_umount);\n\treturn err;\n}',
 'error_t enc624j600ReceivePacket(NetInterface *interface)\n{\n   error_t error;\n   uint16_t n;\n   uint32_t status;\n   Enc624j600Context *context;\n\n   //Point to the driver context\n   context = (Enc624j600Context *) interface-&gt;nicContext;\n\n   //Verify that a packet is waiting by ensuring that PKTCNT is non-zero\n   if(enc624j600ReadReg(interface, ENC624J600_REG_ESTAT) &amp; ESTAT_PKTCNT)\n   {\n      //Point to the next packet\n      enc624j600WriteReg(interface, ENC624J600_REG_ERXRDPT, context-&gt;nextPacket);\n\n      //Read the first two bytes, which are the address of the next packet\n      enc624j600ReadBuffer(interface, ENC624J600_CMD_RRXDATA,\n         (uint8_t *) &amp;context-&gt;nextPacket, sizeof(uint16_t));\n\n      //Convert the value to host byte order\n      context-&gt;nextPacket = letoh16(context-&gt;nextPacket);\n\n      //Get the length of the received frame in bytes\n      enc624j600ReadBuffer(interface, ENC624J600_CMD_RRXDATA,\n         (uint8_t *) &amp;n, sizeof(uint16_t));\n\n      //Convert the value to host byte order\n      n = letoh16(n);\n\n      //Read the receive status vector (RSV)\n      enc624j600ReadBuffer(interface, ENC624J600_CMD_RRXDATA,\n         (uint8_t *) &amp;status, sizeof(uint32_t));\n\n      //Convert the value to host byte order\n      status = letoh32(status);\n\n      //Make sure no error occurred\n      if((status &amp; RSV_RECEIVED_OK) != 0)\n      {\n         //Limit the number of data to read\n         n = MIN(n, ETH_MAX_FRAME_SIZE);\n         //Read the Ethernet frame\n         enc624j600ReadBuffer(interface, ENC624J600_CMD_RRXDATA, context-&gt;rxBuffer, n);\n         //Valid packet received\n         error = NO_ERROR;\n      }\n      else\n      {\n         //The received packet contains an error\n         error = ERROR_INVALID_PACKET;\n      }\n\n      //Update the ERXTAIL pointer value to the point where the packet\n      //has been processed, taking care to wrap back at the end of the\n      //received memory buffer\n      if(context-&gt;nextPacket == ENC624J600_RX_BUFFER_START)\n      {\n         enc624j600WriteReg(interface, ENC624J600_REG_ERXTAIL, ENC624J600_RX_BUFFER_STOP);\n      }\n      else\n      {\n         enc624j600WriteReg(interface, ENC624J600_REG_ERXTAIL, context-&gt;nextPacket - 2);\n      }\n\n      //Set PKTDEC to decrement the PKTCNT bits\n      enc624j600SetBit(interface, ENC624J600_REG_ECON1, ECON1_PKTDEC);\n   }\n   else\n   {\n      //No more data in the receive buffer\n      error = ERROR_BUFFER_EMPTY;\n   }\n\n   //Check whether a valid packet has been received\n   if(!error)\n   {\n      NetRxAncillary ancillary;\n\n      //Additional options can be passed to the stack along with the packet\n      ancillary = NET_DEFAULT_RX_ANCILLARY;\n\n      //Pass the packet to the upper layer\n      nicProcessPacket(interface, context-&gt;rxBuffer, n, &amp;ancillary);\n   }\n\n   //Return status code\n   return error;\n}',
 'void ZRLE_DECODE (const Rect&amp; r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat&amp; pf, ModifiablePixelBuffer* pb)\n{\n  int length = is-&gt;readU32();\n  zis-&gt;setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n\n  for (t.tl.y = r.tl.y; t.tl.y &lt; r.br.y; t.tl.y += 64) {\n\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n\n    for (t.tl.x = r.tl.x; t.tl.x &lt; r.br.x; t.tl.x += 64) {\n\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n\n      int mode = zis-&gt;readU8();\n      bool rle = mode &amp; 128;\n      int palSize = mode &amp; 127;\n      PIXEL_T palette[128];\n\n      for (int i = 0; i &lt; palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb-&gt;fillRect(pf, t, &amp;pix);\n        continue;\n      }\n\n      if (!rle) {\n        if (palSize == 0) {\n\n          // raw\n\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr &lt; buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis-&gt;readBytes(buf, t.area() * (BPP / 8));\n#endif\n\n        } else {\n\n          // packed pixels\n          int bppp = ((palSize &gt; 16) ? 8 :\n                      ((palSize &gt; 4) ? 4 : ((palSize &gt; 2) ? 2 : 1)));\n\n          PIXEL_T* ptr = buf;\n\n          for (int i = 0; i &lt; t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n\n            while (ptr &lt; eol) {\n              if (nbits == 0) {\n                byte = zis-&gt;readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte &gt;&gt; nbits) &amp; ((1 &lt;&lt; bppp) - 1) &amp; 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n\n      } else {\n\n        if (palSize == 0) {\n\n          // plain RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr &lt; end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis-&gt;readU8();\n              len += b;\n            } while (b == 255);\n\n            if (end - ptr &lt; len) {\n              throw Exception ("ZRLE decode error");\n            }\n\n            while (len-- &gt; 0) *ptr++ = pix;\n\n          }\n        } else {\n\n          // palette RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr &lt; end) {\n            int index = zis-&gt;readU8();\n            int len = 1;\n            if (index &amp; 128) {\n              int b;\n              do {\n                b = zis-&gt;readU8();\n                len += b;\n              } while (b == 255);\n\n              if (end - ptr &lt; len) {\n                throw Exception ("ZRLE decode error");\n              }\n            }\n\n            index &amp;= 127;\n\n            PIXEL_T pix = palette[index];\n\n            while (len-- &gt; 0) *ptr++ = pix;\n          }\n        }\n      }\n\n      pb-&gt;imageRect(pf, t, buf);\n    }\n  }\n\n  zis-&gt;flushUnderlying();\n  zis-&gt;setUnderlying(NULL, 0);\n}',
 'static void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)\n{\n\tu32 i, count;\n\n\tif (!ptr) {\n\t\tfprintf(trace, "&lt;OperatingPointsInformation scalability_mask=\\"Multiview|Spatial scalability|Auxilary|unknown\\" num_profile_tier_level=\\"\\" num_operating_points=\\"\\" dependency_layers=\\"\\"&gt;\\n");\n\n\t\tfprintf(trace, " &lt;ProfileTierLevel general_profile_space=\\"\\" general_tier_flag=\\"\\" general_profile_idc=\\"\\" general_profile_compatibility_flags=\\"\\" general_constraint_indicator_flags=\\"\\" /&gt;\\n");\n\n\t\tfprintf(trace, "&lt;OperatingPoint output_layer_set_idx=\\"\\" max_temporal_id=\\"\\" layer_count=\\"\\" minPicWidth=\\"\\" minPicHeight=\\"\\" maxPicWidth=\\"\\" maxPicHeight=\\"\\" maxChromaFormat=\\"\\" maxBitDepth=\\"\\" frame_rate_info_flag=\\"\\" bit_rate_info_flag=\\"\\" avgFrameRate=\\"\\" constantFrameRate=\\"\\" maxBitRate=\\"\\" avgBitRate=\\"\\"/&gt;\\n");\n\n\t\tfprintf(trace, "&lt;Layer dependent_layerID=\\"\\" num_layers_dependent_on=\\"\\" dependent_on_layerID=\\"\\" dimension_identifier=\\"\\"/&gt;\\n");\n\t\tfprintf(trace, "&lt;/OperatingPointsInformation&gt;\\n");\n\t\treturn;\n\t}\n\n\n\tfprintf(trace, "&lt;OperatingPointsInformation");\n\tfprintf(trace, " scalability_mask=\\"%u (", ptr-&gt;scalability_mask);\n\tswitch (ptr-&gt;scalability_mask) {\n\tcase 2:\n\t\tfprintf(trace, "Multiview");\n\t\tbreak;\n\tcase 4:\n\t\tfprintf(trace, "Spatial scalability");\n\t\tbreak;\n\tcase 8:\n\t\tfprintf(trace, "Auxilary");\n\t\tbreak;\n\tdefault:\n\t\tfprintf(trace, "unknown");\n\t}\n\tfprintf(trace, ")\\" num_profile_tier_level=\\"%u\\"", gf_list_count(ptr-&gt;profile_tier_levels) );\n\tfprintf(trace, " num_operating_points=\\"%u\\" dependency_layers=\\"%u\\"", gf_list_count(ptr-&gt;operating_points), gf_list_count(ptr-&gt;dependency_layers));\n\tfprintf(trace, "&gt;\\n");\n\n\n\tcount=gf_list_count(ptr-&gt;profile_tier_levels);\n\tfor (i = 0; i &lt; count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr-&gt;profile_tier_levels, i);\n\t\tfprintf(trace, " &lt;ProfileTierLevel general_profile_space=\\"%u\\" general_tier_flag=\\"%u\\" general_profile_idc=\\"%u\\" general_profile_compatibility_flags=\\"%X\\" general_constraint_indicator_flags=\\""LLX"\\" /&gt;\\n", ptl-&gt;general_profile_space, ptl-&gt;general_tier_flag, ptl-&gt;general_profile_idc, ptl-&gt;general_profile_compatibility_flags, ptl-&gt;general_constraint_indicator_flags);\n\t}\n\n\n\tcount=gf_list_count(ptr-&gt;operating_points);\n\tfor (i = 0; i &lt; count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr-&gt;operating_points, i);\n\t\tfprintf(trace, "&lt;OperatingPoint output_layer_set_idx=\\"%u\\"", op-&gt;output_layer_set_idx);\n\t\tfprintf(trace, " max_temporal_id=\\"%u\\" layer_count=\\"%u\\"", op-&gt;max_temporal_id, op-&gt;layer_count);\n\t\tfprintf(trace, " minPicWidth=\\"%u\\" minPicHeight=\\"%u\\"", op-&gt;minPicWidth, op-&gt;minPicHeight);\n\t\tfprintf(trace, " maxPicWidth=\\"%u\\" maxPicHeight=\\"%u\\"", op-&gt;maxPicWidth, op-&gt;maxPicHeight);\n\t\tfprintf(trace, " maxChromaFormat=\\"%u\\" maxBitDepth=\\"%u\\"", op-&gt;maxChromaFormat, op-&gt;maxBitDepth);\n\t\tfprintf(trace, " frame_rate_info_flag=\\"%u\\" bit_rate_info_flag=\\"%u\\"", op-&gt;frame_rate_info_flag, op-&gt;bit_rate_info_flag);\n\t\tif (op-&gt;frame_rate_info_flag)\n\t\t\tfprintf(trace, " avgFrameRate=\\"%u\\" constantFrameRate=\\"%u\\"", op-&gt;avgFrameRate, op-&gt;constantFrameRate);\n\t\tif (op-&gt;bit_rate_info_flag)\n\t\t\tfprintf(trace, " maxBitRate=\\"%u\\" avgBitRate=\\"%u\\"", op-&gt;maxBitRate, op-&gt;avgBitRate);\n\t\tfprintf(trace, "/&gt;\\n");\n\t}\n\tcount=gf_list_count(ptr-&gt;dependency_layers);\n\tfor (i = 0; i &lt; count; i++) {\n\t\tu32 j;\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr-&gt;dependency_layers, i);\n\t\tfprintf(trace, "&lt;Layer dependent_layerID=\\"%u\\" num_layers_dependent_on=\\"%u\\"", dep-&gt;dependent_layerID, dep-&gt;num_layers_dependent_on);\n\t\tif (dep-&gt;num_layers_dependent_on) {\n\t\t\tfprintf(trace, " dependent_on_layerID=\\"");\n\t\t\tfor (j = 0; j &lt; dep-&gt;num_layers_dependent_on; j++)\n\t\t\t\tfprintf(trace, "%d ", dep-&gt;dependent_on_layerID[j]);\n\t\t\tfprintf(trace, "\\"");\n\t\t}\n\t\tfprintf(trace, " dimension_identifier=\\"");\n\t\tfor (j = 0; j &lt; 16; j++)\n\t\t\tif (ptr-&gt;scalability_mask &amp; (1 &lt;&lt; j))\n\t\t\t\tfprintf(trace, "%d ", dep-&gt;dimension_identifier[j]);\n\t\tfprintf(trace, "\\"/&gt;\\n");\n\t}\n\tfprintf(trace, "&lt;/OperatingPointsInformation&gt;\\n");\n\treturn;\n}',
 'bool ImplPolygon::ImplSplit( sal_uInt16 nPos, sal_uInt16 nSpace, ImplPolygon const * pInitPoly )\n{\n    //Can\'t fit this in :-(, throw ?\n    if (mnPoints + nSpace &gt; USHRT_MAX)\n    {\n        SAL_WARN("tools", "Polygon needs " &lt;&lt; mnPoints + nSpace &lt;&lt; " points, but only " &lt;&lt; USHRT_MAX &lt;&lt; " possible");\n        return false;\n    }\n\n    const sal_uInt16    nNewSize = mnPoints + nSpace;\n    const std::size_t   nSpaceSize = static_cast&lt;std::size_t&gt;(nSpace) * sizeof(Point);\n\n    if( nPos &gt;= mnPoints )\n    {\n        // Append at the back\n        nPos = mnPoints;\n        ImplSetSize( nNewSize );\n\n        if( pInitPoly )\n        {\n            memcpy( mpPointAry + nPos, pInitPoly-&gt;mpPointAry, nSpaceSize );\n\n            if( pInitPoly-&gt;mpFlagAry )\n                memcpy( mpFlagAry + nPos, pInitPoly-&gt;mpFlagAry, nSpace );\n        }\n    }\n    else\n    {\n        const sal_uInt16    nSecPos = nPos + nSpace;\n        const sal_uInt16    nRest = mnPoints - nPos;\n\n        Point* pNewAry = reinterpret_cast&lt;Point*&gt;(new char[ static_cast&lt;std::size_t&gt;(nNewSize) * sizeof(Point) ]);\n\n        memcpy( pNewAry, mpPointAry, nPos * sizeof( Point ) );\n\n        if( pInitPoly )\n            memcpy( pNewAry + nPos, pInitPoly-&gt;mpPointAry, nSpaceSize );\n        else\n            memset( pNewAry + nPos, 0, nSpaceSize );\n\n        memcpy( pNewAry + nSecPos, mpPointAry + nPos, nRest * sizeof( Point ) );\n        delete[] reinterpret_cast&lt;char*&gt;(mpPointAry);\n\n        // consider FlagArray\n        if( mpFlagAry )\n        {\n            PolyFlags* pNewFlagAry = new PolyFlags[ nNewSize ];\n\n            memcpy( pNewFlagAry, mpFlagAry, nPos );\n\n            if( pInitPoly &amp;&amp; pInitPoly-&gt;mpFlagAry )\n                memcpy( pNewFlagAry + nPos, pInitPoly-&gt;mpFlagAry, nSpace );\n            else\n                memset( pNewFlagAry + nPos, 0, nSpace );\n\n            memcpy( pNewFlagAry + nSecPos, mpFlagAry + nPos, nRest );\n            delete[] mpFlagAry;\n            mpFlagAry = pNewFlagAry;\n        }\n\n        mpPointAry = pNewAry;\n        mnPoints   = nNewSize;\n    }\n\n    return true;\n}',
 'int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos &lt; -len || pos &gt; len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos &gt;= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + std::min(pos + s_len, 0), s, s_len);\n    }\n  } else {\n    if (pos &gt;= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + std::min(pos + s_len, 0), s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}',
 'void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  // Verify requested address range is allowed.\n  if (!allow_svhandler_flash_range(dst, dst + sizeof(uint32_t))) return;\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Flash write.\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &amp;= ~FLASH_CR_PG;\n\n  // Lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}',
 'static char *getDirective(char *line, char **valuep)\n{\n    char    *key, *value;\n    ssize   len;\n    \n    assert(line);\n    assert(valuep);\n\n    *valuep = 0;\n    key = stok(line, " \\t", &amp;value);\n    key = strim(key, " \\t\\r\\n&gt;", MPR_TRIM_END);\n    if (value) {\n        value = strim(value, " \\t\\r\\n&gt;", MPR_TRIM_END);\n        /*\n            Trim quotes if wrapping the entire value and no spaces. Preserve embedded quotes and leading/trailing "" etc.\n         */\n        len = slen(value);\n        if (*value == \'\\"\' &amp;&amp; value[len - 1] == \'"\' &amp;&amp; len &gt; 2 &amp;&amp; value[1] != \'\\"\' &amp;&amp; !strpbrk(value, " \\t")) {\n            /*\n                Cannot strip quotes if multiple args are quoted, only if one single arg is quoted\n             */\n            if (schr(&amp;value[1], \'"\') == &amp;value[len - 1]) {\n                value = snclone(&amp;value[1], len - 2);\n            }\n        }\n        *valuep = value;\n    }\n    return key;\n}',
 '  void Compute(OpKernelContext* ctx) override {\n    const Tensor&amp; handle = ctx-&gt;input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument("`handle` must be scalar"));\n    const string&amp; name = handle.scalar&lt;tstring&gt;()();\n    auto session_state = ctx-&gt;session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    "DeleteSessionTensor called on null session state"));\n    OP_REQUIRES_OK(ctx, session_state-&gt;DeleteTensor(name));\n  }',
 'accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn                ice_conn;\n        GsmClient             *client;\n        GsmIceConnectionWatch *data;\n\n        /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n        if (server-&gt;priv-&gt;xsmp_sockets == NULL) {\n                g_debug ("GsmXsmpServer: In shutdown, rejecting new client");\n\n                *failure_reason_ret = strdup (_("Refusing new client connection because the session is currently being shut down\\n"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        data = ice_conn-&gt;context;\n\n        /* Each GsmXSMPClient has its own IceConn watcher */\n        free_ice_connection_watch (data);\n\n        client = gsm_xsmp_client_new (ice_conn);\n\n        gsm_store_add (server-&gt;priv-&gt;client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        /* the store will own the ref */\n        g_object_unref (client);\n\n        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}',
 'void Ogg::XiphComment::parse(const ByteVector &amp;data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  int pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d-&gt;vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  for(int i = 0; i &lt; commentFields; i++) {\n\n    // Each comment field is in the format "KEY=value" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n\n    int commentSeparatorPosition = comment.find("=");\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}',
 'static void queue_delete(struct snd_seq_queue *q)\n{\n\t/* stop and release the timer */\n\tmutex_lock(&amp;q-&gt;timer_mutex);\n\tsnd_seq_timer_stop(q-&gt;timer);\n\tsnd_seq_timer_close(q);\n\tmutex_unlock(&amp;q-&gt;timer_mutex);\n\t/* wait until access free */\n\tsnd_use_lock_sync(&amp;q-&gt;use_lock);\n\t/* release resources... */\n\tsnd_seq_prioq_delete(&amp;q-&gt;tickq);\n\tsnd_seq_prioq_delete(&amp;q-&gt;timeq);\n\tsnd_seq_timer_delete(&amp;q-&gt;timer);\n\n\tkfree(q);\n}',
 '    void Jp2Image::encodeJp2Header(const DataBuf&amp; boxBuf,DataBuf&amp; outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        int32_t       length = getLong((byte*)&amp;pBox-&gt;length, bigEndian);\n        int32_t       count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count &lt; length || !bWroteColor ) {\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox ; memcpy(&amp;subBox,pSubBox,sizeof(subBox));\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count &lt; length ) {\n                subBox.length = getLong((byte*)&amp;subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&amp;subBox.type  , bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout &lt;&lt; "Jp2Image::encodeJp2Header subbox: "&lt;&lt; toAscii(subBox.type) &lt;&lt; " length = " &lt;&lt; subBox.length &lt;&lt; std::endl;\n#endif\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            int32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = "\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid";\n                    uint32_t    psize = 15;\n                    newlen            = sizeof(newBox) + psize ;\n                    ul2Data((byte*)&amp;newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&amp;newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&amp;newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                } else {\n                    const char* pad   = "\\x02\\x00\\x00";\n                    uint32_t    psize = 3;\n                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n                    ul2Data((byte*)&amp;newBox.length,newlen,bigEndian);\n                    ul2Data((byte*)&amp;newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&amp;newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                }\n            } else {\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&amp;pBox-&gt;type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&amp;pBox-&gt;length,outlen,bigEndian);\n    } // Jp2Image::encodeJp2Header',
 'static int oidc_cache_crypto_decrypt_impl(request_rec *r,\n\t\tunsigned char *ciphertext, int ciphertext_len, const unsigned char *aad,\n\t\tint aad_len, const unsigned char *tag, int tag_len, unsigned char *key,\n\t\tconst unsigned char *iv, int iv_len, unsigned char *plaintext) {\n\tEVP_CIPHER_CTX *ctx;\n\tint len;\n\tint plaintext_len;\n\tint ret;\n\n\t/* create and initialize the context */\n\tif (!(ctx = EVP_CIPHER_CTX_new())) {\n\t\toidc_cache_crypto_openssl_error(r, "EVP_CIPHER_CTX_new");\n\t\treturn -1;\n\t}\n\n\t/* initialize the decryption cipher */\n\tif (!EVP_DecryptInit_ex(ctx, OIDC_CACHE_CIPHER, NULL, NULL, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, "EVP_DecryptInit_ex");\n\t\treturn -1;\n\t}\n\n\t/* set IV length */\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_IVLEN, iv_len, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, "EVP_CIPHER_CTX_ctrl");\n\t\treturn -1;\n\t}\n\n\t/* initialize key and IV */\n\tif (!EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv)) {\n\t\toidc_cache_crypto_openssl_error(r, "EVP_DecryptInit_ex");\n\t\treturn -1;\n\t}\n\n\t/* provide AAD data */\n\tif (!EVP_DecryptUpdate(ctx, NULL, &amp;len, aad, aad_len)) {\n\t\toidc_cache_crypto_openssl_error(r, "EVP_DecryptUpdate aad: aad_len=%d",\n\t\t\t\taad_len);\n\t\treturn -1;\n\t}\n\n\t/* provide the message to be decrypted and obtain the plaintext output */\n\tif (!EVP_DecryptUpdate(ctx, plaintext, &amp;len, ciphertext, ciphertext_len)) {\n\t\toidc_cache_crypto_openssl_error(r, "EVP_DecryptUpdate ciphertext");\n\t\treturn -1;\n\t}\n\tplaintext_len = len;\n\n\t/* set expected tag value; works in OpenSSL 1.0.1d and later */\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_TAG, tag_len,\n\t\t\t(void *) tag)) {\n\t\toidc_cache_crypto_openssl_error(r, "EVP_CIPHER_CTX_ctrl");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * finalize the decryption; a positive return value indicates success,\n\t * anything else is a failure - the plaintext is not trustworthy\n\t */\n\tret = EVP_DecryptFinal_ex(ctx, plaintext + len, &amp;len);\n\n\t/* clean up */\n\tEVP_CIPHER_CTX_free(ctx);\n\n\tif (ret &gt; 0) {\n\t\t/* success */\n\t\tplaintext_len += len;\n\t\treturn plaintext_len;\n\t} else {\n\t\t/* verify failed */\n\t\toidc_cache_crypto_openssl_error(r, "EVP_DecryptFinal_ex");\n\t\treturn -1;\n\t}\n}',
 'newkeys_from_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b = NULL;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey = NULL;\n\tsize_t keylen, ivlen, maclen;\n\tint r;\n\n\tif ((newkey = calloc(1, sizeof(*newkey))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_froms(m, &amp;b)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\tenc = &amp;newkey-&gt;enc;\n\tmac = &amp;newkey-&gt;mac;\n\tcomp = &amp;newkey-&gt;comp;\n\n\tif ((r = sshbuf_get_cstring(b, &amp;enc-&gt;name, NULL)) != 0 ||\n\t    (r = sshbuf_get(b, &amp;enc-&gt;cipher, sizeof(enc-&gt;cipher))) != 0 ||\n\t    (r = sshbuf_get_u32(b, (u_int *)&amp;enc-&gt;enabled)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &amp;enc-&gt;block_size)) != 0 ||\n\t    (r = sshbuf_get_string(b, &amp;enc-&gt;key, &amp;keylen)) != 0 ||\n\t    (r = sshbuf_get_string(b, &amp;enc-&gt;iv, &amp;ivlen)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc-&gt;cipher) == 0) {\n\t\tif ((r = sshbuf_get_cstring(b, &amp;mac-&gt;name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = mac_setup(mac, mac-&gt;name)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_get_u32(b, (u_int *)&amp;mac-&gt;enabled)) != 0 ||\n\t\t    (r = sshbuf_get_string(b, &amp;mac-&gt;key, &amp;maclen)) != 0)\n\t\t\tgoto out;\n\t\tif (maclen &gt; mac-&gt;key_len) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tmac-&gt;key_len = maclen;\n\t}\n\tif ((r = sshbuf_get_u32(b, &amp;comp-&gt;type)) != 0 ||\n\t    (r = sshbuf_get_u32(b, (u_int *)&amp;comp-&gt;enabled)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &amp;comp-&gt;name, NULL)) != 0)\n\t\tgoto out;\n\tif (enc-&gt;name == NULL ||\n\t    cipher_by_name(enc-&gt;name) != enc-&gt;cipher) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tenc-&gt;key_len = keylen;\n\tenc-&gt;iv_len = ivlen;\n\tssh-&gt;kex-&gt;newkeys[mode] = newkey;\n\tnewkey = NULL;\n\tr = 0;\n out:\n\tfree(newkey);\n\tsshbuf_free(b);\n\treturn r;\n}',
 'SYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)\n{\n\tconst char *sysinfo_table[] = {\n\t\tutsname()-&gt;sysname,\n\t\tutsname()-&gt;nodename,\n\t\tutsname()-&gt;release,\n\t\tutsname()-&gt;version,\n\t\tutsname()-&gt;machine,\n\t\t"alpha",\t/* instruction set architecture */\n\t\t"dummy",\t/* hardware serial number */\n\t\t"dummy",\t/* hardware manufacturer */\n\t\t"dummy",\t/* secure RPC domain */\n\t};\n\tunsigned long offset;\n\tconst char *res;\n\tlong len, err = -EINVAL;\n\n\toffset = command-1;\n\tif (offset &gt;= ARRAY_SIZE(sysinfo_table)) {\n\t\t/* Digital UNIX has a few unpublished interfaces here */\n\t\tprintk("sysinfo(%d)", command);\n\t\tgoto out;\n\t}\n\n\tdown_read(&amp;uts_sem);\n\tres = sysinfo_table[offset];\n\tlen = strlen(res)+1;\n\tif (len &gt; count)\n\t\tlen = count;\n\tif (copy_to_user(buf, res, len))\n\t\terr = -EFAULT;\n\telse\n\t\terr = 0;\n\tup_read(&amp;uts_sem);\n out:\n\treturn err;\n}',
 'static ssize_t _epoll_read(oe_fd_t* epoll_, void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(epoll_);\n\n    oe_errno = 0;\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html for\n     * for more detail.\n     */\n    if (!file || count &gt; OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_read_ocall(&amp;ret, file-&gt;host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret &gt; (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}',
 'snmp_mib_find(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource-&gt;next) {\n\n    if(!snmp_oid_cmp_oid(oid, resource-&gt;oid)) {\n      return resource;\n    }\n  }\n\n  return NULL;\n}',
 'static int pb0100_start(struct sd *sd)\n{\n\tint err, packet_size, max_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct cam *cam = &amp;sd-&gt;gspca_dev.cam;\n\tu32 mode = cam-&gt;cam_mode[sd-&gt;gspca_dev.curr_mode].priv;\n\n\tintf = usb_ifnum_to_if(sd-&gt;gspca_dev.dev, sd-&gt;gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd-&gt;gspca_dev.alt);\n\tif (!alt)\n\t\treturn -ENODEV;\n\n\tif (alt-&gt;desc.bNumEndpoints &lt; 1)\n\t\treturn -ENODEV;\n\n\tpacket_size = le16_to_cpu(alt-&gt;endpoint[0].desc.wMaxPacketSize);\n\n\t/* If we don\'t have enough bandwidth use a lower framerate */\n\tmax_packet_size = sd-&gt;sensor-&gt;max_packet_size[sd-&gt;gspca_dev.curr_mode];\n\tif (packet_size &lt; max_packet_size)\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\n\telse\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(5)|BIT(3)|BIT(1));\n\n\t/* Setup sensor window */\n\tif (mode &amp; PB0100_CROP_TO_VGA) {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 30);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 20);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 240 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 320 - 1);\n\t} else {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 8);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 4);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 288 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 352 - 1);\n\t}\n\n\tif (mode &amp; PB0100_SUBSAMPLE) {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02); /* Wrong, FIXME */\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\n\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\n\t} else {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\n\t\t/* larger -&gt; slower */\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x20);\n\t}\n\n\terr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3)|BIT(1));\n\tgspca_dbg(gspca_dev, D_STREAM, "Started stream, status: %d\\n", err);\n\n\treturn (err &lt; 0) ? err : 0;\n}',
 'rend_service_intro_established(origin_circuit_t *circuit,\n                               const uint8_t *request,\n                               size_t request_len)\n{\n  rend_service_t *service;\n  rend_intro_point_t *intro;\n  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];\n  (void) request;\n  (void) request_len;\n  tor_assert(circuit-&gt;rend_data);\n  /* XXX: This is version 2 specific (only supported one for now). */\n  const char *rend_pk_digest =\n    (char *) rend_data_get_pk_digest(circuit-&gt;rend_data, NULL);\n\n  if (circuit-&gt;base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {\n    log_warn(LD_PROTOCOL,\n             "received INTRO_ESTABLISHED cell on non-intro circuit.");\n    goto err;\n  }\n  service = rend_service_get_by_pk_digest(rend_pk_digest);\n  if (!service) {\n    log_warn(LD_REND, "Unknown service on introduction circuit %u.",\n             (unsigned)circuit-&gt;base_.n_circ_id);\n    goto err;\n  }\n  /* We\'ve just successfully established a intro circuit to one of our\n   * introduction point, account for it. */\n  intro = find_intro_point(circuit);\n  if (intro == NULL) {\n    log_warn(LD_REND,\n             "Introduction circuit established without a rend_intro_point_t "\n             "object for service %s on circuit %u",\n             safe_str_client(serviceid), (unsigned)circuit-&gt;base_.n_circ_id);\n    goto err;\n  }\n  intro-&gt;circuit_established = 1;\n  /* We might not have every introduction point ready but at this point we\n   * know that the descriptor needs to be uploaded. */\n  service-&gt;desc_is_dirty = time(NULL);\n  circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);\n\n  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,\n                rend_pk_digest, REND_SERVICE_ID_LEN);\n  log_info(LD_REND,\n           "Received INTRO_ESTABLISHED cell on circuit %u for service %s",\n           (unsigned)circuit-&gt;base_.n_circ_id, serviceid);\n\n  /* Getting a valid INTRODUCE_ESTABLISHED means we\'ve successfully\n   * used the circ */\n  pathbias_mark_use_success(circuit);\n\n  return 0;\n err:\n  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);\n  return -1;\n}',
 'static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &amp;timr-&gt;it.real.timer;\n\n\tif (!timr-&gt;it_interval)\n\t\treturn;\n\n\ttimr-&gt;it_overrun += (unsigned int) hrtimer_forward(timer,\n\t\t\t\t\t\ttimer-&gt;base-&gt;get_time(),\n\t\t\t\t\t\ttimr-&gt;it_interval);\n\thrtimer_restart(timer);\n}',
 'static uint8_t check_length(uint16_t length, uint16_t offset)\n{\n\tif (length &gt; BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\n\tif (offset &gt; BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_OFFSET;\n\n\tif (length + offset &gt; BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\n\treturn 0;\n}',
 'nautilus_file_mark_desktop_file_executable (GFile              *file,\n                                            GtkWindow          *parent_window,\n                                            gboolean            interactive,\n                                            NautilusOpCallback  done_callback,\n                                            gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job-&gt;file = g_object_ref (file);\n    job-&gt;interactive = interactive;\n    job-&gt;done_callback = done_callback;\n    job-&gt;done_callback_data = done_callback_data;\n\n    task = g_task_new (NULL, NULL, mark_desktop_file_executable_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_desktop_file_executable_task_thread_func);\n    g_object_unref (task);\n}',
 'static ssize_t _epoll_write(oe_fd_t* epoll_, const void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(epoll_);\n\n    oe_errno = 0;\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html for\n     * for more detail.\n     */\n    if (!file || count &gt; OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_write_ocall(&amp;ret, file-&gt;host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret &gt; (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}',
 'static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\n\tif (!atomic_pool) {\n\t\tWARN(1, "coherent pool not initialised!\\n");\n\t\treturn NULL;\n\t}\n\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tmemset(ptr, 0, size);\n\t}\n\n\treturn ptr;\n}',
 'void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\n\tif (state-&gt;frame_state.header_obus) {\n\t\twhile (gf_list_count(state-&gt;frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state-&gt;frame_state.header_obus);\n\t\t\tif (a-&gt;obu) gf_free(a-&gt;obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\n\tif (state-&gt;frame_state.frame_obus) {\n\t\twhile (gf_list_count(state-&gt;frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state-&gt;frame_state.frame_obus);\n\t\t\tif (a-&gt;obu) gf_free(a-&gt;obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state-&gt;frame_state.frame_obus;\n\tl2 = state-&gt;frame_state.header_obus;\n\tmemset(&amp;state-&gt;frame_state, 0, sizeof(AV1StateFrame));\n\tstate-&gt;frame_state.is_first_frame = GF_TRUE;\n\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state-&gt;bs) {\n\t\t\tif (gf_bs_get_position(state-&gt;bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state-&gt;bs, &amp;state-&gt;frame_obus, &amp;size, &amp;state-&gt;frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state-&gt;bs);\n\t\t}\n\t\tstate-&gt;bs = NULL;\n\t}\n\telse {\n\t\tstate-&gt;frame_state.frame_obus = l1;\n\t\tstate-&gt;frame_state.header_obus = l2;\n\t\tif (state-&gt;bs)\n\t\t\tgf_bs_seek(state-&gt;bs, 0);\n\t}\n}',
 'acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\t/* A hint request must be the first token received. */\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &amp;supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx(0);\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &amp;sc-&gt;DER_mechTypes) &lt; 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc-&gt;internal_mech = GSS_C_NO_OID;\n\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc-&gt;firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\n\ncleanup:\n\trelease_spnego_ctx(&amp;sc);\n\tgss_release_oid_set(&amp;tmpmin, &amp;supported_mechSet);\n\n\treturn ret;\n}',
 'GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tptr-&gt;scalability_mask = gf_bs_read_u16(bs);\n\tgf_bs_read_int(bs, 2);//reserved\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i &lt; count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl;\n\t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);\n\t\tif (!ptl) return GF_OUT_OF_MEM;\n\t\tptl-&gt;general_profile_space = gf_bs_read_int(bs, 2);\n\t\tptl-&gt;general_tier_flag= gf_bs_read_int(bs, 1);\n\t\tptl-&gt;general_profile_idc = gf_bs_read_int(bs, 5);\n\t\tptl-&gt;general_profile_compatibility_flags = gf_bs_read_u32(bs);\n\t\tptl-&gt;general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);\n\t\tptl-&gt;general_level_idc = gf_bs_read_u8(bs);\n\t\tgf_list_add(ptr-&gt;profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i &lt; count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top-&gt;output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top-&gt;max_temporal_id = gf_bs_read_u8(bs);\n\t\top-&gt;layer_count = gf_bs_read_u8(bs);\n\t\tif (op-&gt;layer_count &gt; ARRAY_LENGTH(op-&gt;layers_info))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tfor (j = 0; j &lt; op-&gt;layer_count; j++) {\n\t\t\top-&gt;layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top-&gt;layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top-&gt;layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top-&gt;layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top-&gt;minPicWidth = gf_bs_read_u16(bs);\n\t\top-&gt;minPicHeight = gf_bs_read_u16(bs);\n\t\top-&gt;maxPicWidth = gf_bs_read_u16(bs);\n\t\top-&gt;maxPicHeight = gf_bs_read_u16(bs);\n\t\top-&gt;maxChromaFormat = gf_bs_read_int(bs, 2);\n\t\top-&gt;maxBitDepth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 1);//reserved\n\t\top-&gt;frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\top-&gt;bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\tif (op-&gt;frame_rate_info_flag) {\n\t\t\top-&gt;avgFrameRate = gf_bs_read_u16(bs);\n\t\t\tgf_bs_read_int(bs, 6); //reserved\n\t\t\top-&gt;constantFrameRate = gf_bs_read_int(bs, 2);\n\t\t}\n\t\tif (op-&gt;bit_rate_info_flag) {\n\t\t\top-&gt;maxBitRate = gf_bs_read_u32(bs);\n\t\t\top-&gt;avgBitRate = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_add(ptr-&gt;operating_points, op);\n\t}\n\tcount = gf_bs_read_u8(bs);\n\tfor (i = 0; i &lt; count; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\t\tdep-&gt;dependent_layerID = gf_bs_read_u8(bs);\n\t\tdep-&gt;num_layers_dependent_on = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j &lt; dep-&gt;num_layers_dependent_on; j++)\n\t\t\tdep-&gt;dependent_on_layerID[j] = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j &lt; 16; j++) {\n\t\t\tif (ptr-&gt;scalability_mask &amp; (1 &lt;&lt; j))\n\t\t\t\tdep-&gt;dimension_identifier[j] = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_add(ptr-&gt;dependency_layers, dep);\n\t}\n\n\treturn GF_OK;\n}',
 'mainloop_destroy_trigger(crm_trigger_t * source)\n{\n    source-&gt;trigger = FALSE;\n    if (source-&gt;id &gt; 0) {\n        g_source_remove(source-&gt;id);\n        source-&gt;id = 0;\n    }\n    return TRUE;\n}',
 'TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* input,\n                      TfLiteNode* node) {\n  // Map from value, to index in the unique elements vector.\n  // Note that we prefer to use map than unordered_map as it showed less\n  // increase in the binary size.\n  std::map&lt;T, int&gt; unique_values;\n  TfLiteTensor* output_indexes = GetOutput(context, node, 1);\n  std::vector&lt;T&gt; output_values;\n  I* indexes = GetTensorData&lt;I&gt;(output_indexes);\n  const T* data = GetTensorData&lt;T&gt;(input);\n  const int num_elements = NumElements(input);\n\n  for (int i = 0; i &lt; num_elements; ++i) {\n    const auto element_it = unique_values.find(data[i]);\n    if (element_it != unique_values.end()) {\n      indexes[i] = element_it-&gt;second;\n    } else {\n      const int unique_index = unique_values.size();\n      unique_values[data[i]] = unique_index;\n      indexes[i] = unique_index;\n      output_values.push_back(data[i]);\n    }\n  }\n  // Allocate output tensor.\n  TfLiteTensor* unique_output = GetOutput(context, node, 0);\n  std::unique_ptr&lt;TfLiteIntArray, void (*)(TfLiteIntArray*)&gt; shape(\n      TfLiteIntArrayCreate(NumDimensions(input)), TfLiteIntArrayFree);\n  shape-&gt;data[0] = unique_values.size();\n  TF_LITE_ENSURE_STATUS(\n      context-&gt;ResizeTensor(context, unique_output, shape.release()));\n  // Set the values in the output tensor.\n  T* output_unique_values = GetTensorData&lt;T&gt;(unique_output);\n  for (int i = 0; i &lt; output_values.size(); ++i) {\n    output_unique_values[i] = output_values[i];\n  }\n  return kTfLiteOk;\n}',
 'static void test_show_object(struct object *object,\n\t\t\t     struct strbuf *path,\n\t\t\t     const char *last, void *data)\n{\n\tstruct bitmap_test_data *tdata = data;\n\tint bitmap_pos;\n\n\tbitmap_pos = bitmap_position(object-&gt;oid.hash);\n\tif (bitmap_pos &lt; 0)\n\t\tdie("Object not in bitmap: %s\\n", oid_to_hex(&amp;object-&gt;oid));\n\n\tbitmap_set(tdata-&gt;base, bitmap_pos);\n\tdisplay_progress(tdata-&gt;prg, ++tdata-&gt;seen);\n}',
 'static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_test(&amp;ucounts-&gt;count)) {\n\t\tspin_lock_irqsave(&amp;ucounts_lock, flags);\n\t\thlist_del_init(&amp;ucounts-&gt;node);\n\t\tspin_unlock_irqrestore(&amp;ucounts_lock, flags);\n\n\t\tkfree(ucounts);\n\t}\n}',
 'char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&amp;ret, path);\n\tstrbuf_addstr(&amp;ret, name);\n\treturn strbuf_detach(&amp;ret, NULL);\n}',
 'pixFillMapHoles(PIX     *pix,\n                l_int32  nx,\n                l_int32  ny,\n                l_int32  filltype)\n{\nl_int32   w, h, y, nmiss, goodcol, i, j, found, ival, valtest;\nl_uint32  val, lastval;\nNUMA     *na;  /* indicates if there is any data in the column */\nPIX      *pixt;\n\n    PROCNAME("pixFillMapHoles");\n\n    if (!pix || pixGetDepth(pix) != 8)\n        return ERROR_INT("pix not defined or not 8 bpp", procName, 1);\n    if (pixGetColormap(pix))\n        return ERROR_INT("pix is colormapped", procName, 1);\n\n    /* ------------- Fill holes in the mapping image columns ----------- */\n    pixGetDimensions(pix, &amp;w, &amp;h, NULL);\n    na = numaCreate(0);  /* holds flag for which columns have data */\n    nmiss = 0;\n    valtest = (filltype == L_FILL_WHITE) ? 255 : 0;\n    for (j = 0; j &lt; nx; j++) {  /* do it by columns */\n        found = FALSE;\n        for (i = 0; i &lt; ny; i++) {\n            pixGetPixel(pix, j, i, &amp;val);\n            if (val != valtest) {\n                y = i;\n                found = TRUE;\n                break;\n            }\n        }\n        if (found == FALSE) {\n            numaAddNumber(na, 0);  /* no data in the column */\n            nmiss++;\n        }\n        else {\n            numaAddNumber(na, 1);  /* data in the column */\n            for (i = y - 1; i &gt;= 0; i--)  /* replicate upwards to top */\n                pixSetPixel(pix, j, i, val);\n            pixGetPixel(pix, j, 0, &amp;lastval);\n            for (i = 1; i &lt; h; i++) {  /* set going down to bottom */\n                pixGetPixel(pix, j, i, &amp;val);\n                if (val == valtest)\n                    pixSetPixel(pix, j, i, lastval);\n                else\n                    lastval = val;\n            }\n        }\n    }\n    numaAddNumber(na, 0);  /* last column */\n\n    if (nmiss == nx) {  /* no data in any column! */\n        numaDestroy(&amp;na);\n        L_WARNING("no bg found; no data in any column\\n", procName);\n        return 1;\n    }\n\n    /* ---------- Fill in missing columns by replication ----------- */\n    if (nmiss &gt; 0) {  /* replicate columns */\n        pixt = pixCopy(NULL, pix);\n            /* Find the first good column */\n        goodcol = 0;\n        for (j = 0; j &lt; w; j++) {\n            numaGetIValue(na, j, &amp;ival);\n            if (ival == 1) {\n                goodcol = j;\n                break;\n            }\n        }\n        if (goodcol &gt; 0) {  /* copy cols backward */\n            for (j = goodcol - 1; j &gt;= 0; j--) {\n                pixRasterop(pix, j, 0, 1, h, PIX_SRC, pixt, j + 1, 0);\n                pixRasterop(pixt, j, 0, 1, h, PIX_SRC, pix, j, 0);\n            }\n        }\n        for (j = goodcol + 1; j &lt; w; j++) {   /* copy cols forward */\n            numaGetIValue(na, j, &amp;ival);\n            if (ival == 0) {\n                    /* Copy the column to the left of j */\n                pixRasterop(pix, j, 0, 1, h, PIX_SRC, pixt, j - 1, 0);\n                pixRasterop(pixt, j, 0, 1, h, PIX_SRC, pix, j, 0);\n            }\n        }\n        pixDestroy(&amp;pixt);\n    }\n    if (w &gt; nx) {  /* replicate the last column */\n        for (i = 0; i &lt; h; i++) {\n            pixGetPixel(pix, w - 2, i, &amp;val);\n            pixSetPixel(pix, w - 1, i, val);\n        }\n    }\n\n    numaDestroy(&amp;na);\n    return 0;\n}',
 'TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* axis,\n                                 const TfLiteTensor* input, int num_splits) {\n  int axis_value = GetTensorData&lt;int&gt;(axis)[0];\n  if (axis_value &lt; 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  TF_LITE_ENSURE(context, axis_value &gt;= 0);\n  TF_LITE_ENSURE(context, axis_value &lt; NumDimensions(input));\n\n  const int input_size = SizeOfDimension(input, axis_value);\n  TF_LITE_ENSURE(context, num_splits != 0);\n  TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,\n                     "Not an even split");\n  const int slice_size = input_size / num_splits;\n\n  for (int i = 0; i &lt; NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input-&gt;dims);\n    output_dims-&gt;data[axis_value] = slice_size;\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &amp;output));\n    TF_LITE_ENSURE_STATUS(context-&gt;ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}',
 'int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tint family = sk-&gt;sk_family;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\tpr_debug("ping_recvmsg(sk=%p,sk-&gt;num=%u)\\n", isk, isk-&gt;inet_num);\n\n\terr = -EOPNOTSUPP;\n\tif (flags &amp; MSG_OOB)\n\t\tgoto out;\n\n\tif (flags &amp; MSG_ERRQUEUE) {\n\t\tif (family == AF_INET) {\n\t\t\treturn ip_recv_error(sk, msg, len);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (family == AF_INET6) {\n\t\t\treturn pingv6_ops.ipv6_recv_error(sk, msg, len);\n#endif\n\t\t}\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &amp;err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb-&gt;len;\n\tif (copied &gt; len) {\n\t\tmsg-&gt;msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t/* Don\'t bother checking the checksum */\n\terr = skb_copy_datagram_iovec(skb, 0, msg-&gt;msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address and add cmsg data. */\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg-&gt;msg_name;\n\n\t\tsin-&gt;sin_family = AF_INET;\n\t\tsin-&gt;sin_port = 0 /* skb-&gt;h.uh-&gt;source */;\n\t\tsin-&gt;sin_addr.s_addr = ip_hdr(skb)-&gt;saddr;\n\t\tmemset(sin-&gt;sin_zero, 0, sizeof(sin-&gt;sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\n\t\tif (isk-&gt;cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg-&gt;msg_name;\n\n\t\tsin6-&gt;sin6_family = AF_INET6;\n\t\tsin6-&gt;sin6_port = 0;\n\t\tsin6-&gt;sin6_addr = ip6-&gt;saddr;\n\t\tsin6-&gt;sin6_flowinfo = 0;\n\t\tif (np-&gt;sndflow)\n\t\t\tsin6-&gt;sin6_flowinfo = ip6_flowinfo(ip6);\n\n\t\tsin6-&gt;sin6_scope_id = ipv6_iface_scope_id(&amp;sin6-&gt;sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)-&gt;iif);\n\t\t*addr_len = sizeof(*sin6);\n\n\t\tif (inet6_sk(sk)-&gt;rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\terr = copied;\n\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tpr_debug("ping_recvmsg -&gt; %d\\n", err);\n\treturn err;\n}',
 'static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i &lt; max &amp;&amp; buf[i] != eoc) {\n\t\t// TODO: calc the expresion with the bytcode (ESIL?)\n\t\ti++;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}',
 'char *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i &lt; 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen &lt; 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD(("Received complete reply:  \\"%s\\"\\n", ret_msg));\n\t}\n\treturn(ret_msg);\n}',
 "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr &lt; 0 || syscall_nr &gt;= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr-&gt;enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data-&gt;nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr-&gt;trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data-&gt;enter_event-&gt;event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry-&gt;nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data-&gt;nb_args, entry-&gt;args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
 "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    const struct bpf_reg_state *off_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    struct bpf_sanitize_info *info,\n\t\t\t    const bool commit_window)\n{\n\tstruct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : &amp;info-&gt;aux;\n\tstruct bpf_verifier_state *vstate = env-&gt;cur_state;\n\tbool off_is_imm = tnum_is_const(off_reg-&gt;var_off);\n\tbool off_is_neg = off_reg-&gt;smin_value &lt; 0;\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn-&gt;code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\tint err;\n\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\n\t/* We already marked aux for masking from non-speculative\n\t * paths, thus we got here in the first place. We only care\n\t * to explore bad access from here.\n\t */\n\tif (vstate-&gt;speculative)\n\t\tgoto do_sim;\n\n\tif (!commit_window) {\n\t\tif (!tnum_is_const(off_reg-&gt;var_off) &amp;&amp;\n\t\t    (off_reg-&gt;smin_value &lt; 0) != (off_reg-&gt;smax_value &lt; 0))\n\t\t\treturn REASON_BOUNDS;\n\n\t\tinfo-&gt;mask_to_left = (opcode == BPF_ADD &amp;&amp;  off_is_neg) ||\n\t\t\t\t     (opcode == BPF_SUB &amp;&amp; !off_is_neg);\n\t}\n\n\terr = retrieve_ptr_limit(ptr_reg, &amp;alu_limit, info-&gt;mask_to_left);\n\tif (err &lt; 0)\n\t\treturn err;\n\n\tif (commit_window) {\n\t\t/* In commit phase we narrow the masking window based on\n\t\t * the observed pointer move after the simulated operation.\n\t\t */\n\t\talu_state = info-&gt;aux.alu_state;\n\t\talu_limit = abs(info-&gt;aux.alu_limit - alu_limit);\n\t} else {\n\t\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\t\talu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;\n\t\talu_state |= ptr_is_dst_reg ?\n\t\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\t}\n\n\terr = update_alu_sanitation_state(aux, alu_state, alu_limit);\n\tif (err &lt; 0)\n\t\treturn err;\ndo_sim:\n\t/* If we're in commit phase, we're done here given we already\n\t * pushed the truncated dst_reg into the speculative verification\n\t * stack.\n\t *\n\t * Also, when register is a known constant, we rewrite register-based\n\t * operation to immediate-based, and thus do not need masking (and as\n\t * a consequence, do not need to simulate the zero-truncation either).\n\t */\n\tif (commit_window || off_is_imm)\n\t\treturn 0;\n\n\t/* Simulate and find potential out-of-bounds access under\n\t * speculative execution from truncation as a result of\n\t * masking when off was not within expected range. If off\n\t * sits in dst, then we temporarily need to move ptr there\n\t * to simulate dst (== 0) +/-= ptr. Needed, for example,\n\t * for cases where we use K-based arithmetic in one direction\n\t * and truncated reg-based in the other in order to explore\n\t * bad access.\n\t */\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env-&gt;insn_idx + 1, env-&gt;insn_idx, true);\n\tif (!ptr_is_dst_reg &amp;&amp; ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? REASON_STACK : 0;\n}",
 'static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String&amp; /*type*/ /* = null_string */,\n                         int /*slabid*/ /* = 0 */, int /*limit*/ /* = 100 */) {\n  auto data = Native::data&lt;MemcacheData&gt;(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n\n  stats = memcached_stat(&amp;data-&gt;m_memcache, nullptr, &amp;ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n\n  int server_count = memcached_server_count(&amp;data-&gt;m_memcache);\n\n  Array return_val;\n\n  for (int server_id = 0; server_id &lt; server_count; server_id++) {\n    memcached_stat_st *stat;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&amp;data-&gt;m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    stat = stats + server_id;\n\n    Array server_stats = memcache_build_stats(&amp;data-&gt;m_memcache, stat, &amp;ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n\n    auto const port_str = folly::to&lt;std::string&gt;(port);\n    auto const key_len = strlen(hostname) + 1 + port_str.length();\n    auto key = String(key_len, ReserveString);\n    key += hostname;\n    key += ":";\n    key += port_str;\n    return_val.set(key, server_stats);\n  }\n\n  free(stats);\n  return return_val;\n}',
 'compute_O_value(std::string const&amp; user_password,\n\t\tstd::string const&amp; owner_password,\n\t\tQPDF::EncryptionData const&amp; data)\n{\n    // Algorithm 3.3 from the PDF 1.7 Reference Manual\n\n    unsigned char O_key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, O_key);\n\n    char upass[key_bytes];\n    pad_or_truncate_password_V4(user_password, upass);\n    std::string k1(reinterpret_cast&lt;char*&gt;(O_key), OU_key_bytes_V4);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(upass), key_bytes,\n\t\tO_key, data.getLengthBytes(),\n                (data.getR() &gt;= 3) ? 20 : 1, false);\n    return std::string(upass, key_bytes);\n}',
 'static size_t hash_str(const void *ptr)\n{\n    const char *str = (const char *)ptr;\n\n    size_t hash = 5381;\n    size_t c;\n\n    while((c = (size_t)*str))\n    {\n        hash = ((hash &lt;&lt; 5) + hash) + c;\n        str++;\n    }\n\n    return hash;\n}',
 'optional&lt;ARN&gt; ARN::parse(const string&amp; s, bool wildcards) {\n  static const char str_wild[] = "arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)";\n  static const regex rx_wild(str_wild,\n\t\t\t\t    sizeof(str_wild) - 1,\n\t\t\t\t    ECMAScript | optimize);\n  static const char str_no_wild[]\n    = "arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)";\n  static const regex rx_no_wild(str_no_wild,\n\t\t\t\tsizeof(str_no_wild) - 1,\n\t\t\t\tECMAScript | optimize);\n\n  smatch match;\n\n  if ((s == "*") &amp;&amp; wildcards) {\n    return ARN(Partition::wildcard, Service::wildcard, "*", "*", "*");\n  } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {\n    ceph_assert(match.size() == 6);\n\n    ARN a;\n    {\n      auto p = to_partition(match[1], wildcards);\n      if (!p)\n\treturn none;\n\n      a.partition = *p;\n    }\n    {\n      auto s = to_service(match[2], wildcards);\n      if (!s) {\n\treturn none;\n      }\n      a.service = *s;\n    }\n\n    a.region = match[3];\n    a.account = match[4];\n    a.resource = match[5];\n\n    return a;\n  }\n  return none;\n}',
 'bool HexInStream::hexStrToBin(const char* s, char** data, int* length) {\n  int l=strlen(s);\n  if ((l % 2) == 0) {\n    delete [] *data;\n    *data = 0; *length = 0;\n    if (l == 0)\n      return true;\n    *data = new char[l/2];\n    *length = l/2;\n    for(int i=0;i&lt;l;i+=2) {\n      int byte = 0;\n      if (!readHexAndShift(s[i], &amp;byte) ||\n        !readHexAndShift(s[i+1], &amp;byte))\n        goto decodeError;\n      (*data)[i/2] = byte;\n    }\n    return true;\n  }\ndecodeError:\n  delete [] *data;\n  *data = 0;\n  *length = 0;\n  return false;\n}',
 'inline bool ShapeIsVector(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* shape = GetInput(context, node, kShapeTensor);\n  return (shape != nullptr &amp;&amp; shape-&gt;dims-&gt;size == 1 &amp;&amp;\n          shape-&gt;type == kTfLiteInt32);\n}',
 "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&amp;info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info.si_code != SI_QUEUE) {\n\t\t/* We used to allow any &lt; 0 si_code */\n\t\tWARN_ON_ONCE(info.si_code &lt; 0);\n\t\treturn -EPERM;\n\t}\n\tinfo.si_signo = sig;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, &amp;info, pid);\n}",
 'struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t *entry;\n\tif (!pe || !pe-&gt;b) {\n\t\treturn 0LL;\n\t}\n\tut8 b[512] = {0};\n\tZERO_FILL (b);\n\tentry = PE_ (r_bin_pe_get_entrypoint) (pe);\n\t// option2: /x 8bff558bec83ec20\n\tif (r_buf_read_at (pe-&gt;b, entry-&gt;paddr, b, sizeof (b)) != sizeof (b)) {\n\t\tpe_printf ("Warning: Cannot read entry at 0x%08"PFMT64x"\\n", entry-&gt;paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\t/* Decode the jmp instruction, this gets the address of the \'main\'\n\t   function for PE produced by a compiler whose name someone forgot to\n\t   write down. */\n\t// this is dirty only a single byte check, can return false positives\n\tif (b[367] == 0xe8) {\n\t\tfollow_offset (entry, pe-&gt;b, b, sizeof (b), pe-&gt;big_endian, 367);\n\t\treturn entry;\n\t}\n\tsize_t i;\n\tfor (i = 0; i &lt; 512 - 16 ; i++) {\n\t\t// 5. ff 15 .. .. .. .. 50 e8 [main]\n\t\tif (!memcmp (b + i, "\\xff\\x15", 2)) {\n\t\t\tif (b[i + 6] == 0x50) {\n\t\t\t\tif (b[i + 7] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe-&gt;b, b, sizeof (b), pe-&gt;big_endian, i + 7);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}',
 'static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb-&gt;usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret &gt;= 0) {\n\t\tatusb-&gt;fw_ver_maj = buffer[0];\n\t\tatusb-&gt;fw_ver_min = buffer[1];\n\t\tatusb-&gt;fw_hw_type = buffer[2];\n\n\t\tdev_info(&amp;usb_dev-&gt;dev,\n\t\t\t "Firmware: major: %u, minor: %u, hardware type: %u\\n",\n\t\t\t atusb-&gt;fw_ver_maj, atusb-&gt;fw_ver_min, atusb-&gt;fw_hw_type);\n\t}\n\tif (atusb-&gt;fw_ver_maj == 0 &amp;&amp; atusb-&gt;fw_ver_min &lt; 2) {\n\t\tdev_info(&amp;usb_dev-&gt;dev,\n\t\t\t "Firmware version (%u.%u) predates our first public release.",\n\t\t\t atusb-&gt;fw_ver_maj, atusb-&gt;fw_ver_min);\n\t\tdev_info(&amp;usb_dev-&gt;dev, "Please update to version 0.2 or newer");\n\t}\n\n\treturn ret;\n}',
 'void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row = 0; row &lt; height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col &lt; raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 &gt;&gt; (3 - pana_bits(2));\n      if (nonz[i &amp; 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i &amp; 1] -= 0x80 &lt;&lt; sh) &lt; 0 || sh == 4)\n            pred[i &amp; 1] &amp;= ~((~0u) &lt;&lt; sh);\n          pred[i &amp; 1] += j &lt;&lt; sh;\n        }\n      }\n      else if ((nonz[i &amp; 1] = pana_bits(8)) || i &gt; 11)\n        pred[i &amp; 1] = nonz[i &amp; 1] &lt;&lt; 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col &amp; 1]) &gt; 4098 &amp;&amp; col &lt; width)\n        derror();\n    }\n  }\n}',
 'size_t FdInStream::readWithTimeoutOrCallback(void* buf, size_t len, bool wait)\n{\n  struct timeval before, after;\n  if (timing)\n    gettimeofday(&amp;before, 0);\n\n  int n;\n  while (true) {\n    do {\n      fd_set fds;\n      struct timeval tv;\n      struct timeval* tvp = &amp;tv;\n\n      if (!wait) {\n        tv.tv_sec = tv.tv_usec = 0;\n      } else if (timeoutms != -1) {\n        tv.tv_sec = timeoutms / 1000;\n        tv.tv_usec = (timeoutms % 1000) * 1000;\n      } else {\n        tvp = 0;\n      }\n\n      FD_ZERO(&amp;fds);\n      FD_SET(fd, &amp;fds);\n      n = select(fd+1, &amp;fds, 0, 0, tvp);\n    } while (n &lt; 0 &amp;&amp; errno == EINTR);\n\n    if (n &gt; 0) break;\n    if (n &lt; 0) throw SystemException("select",errno);\n    if (!wait) return 0;\n    if (!blockCallback) throw TimedOut();\n\n    blockCallback-&gt;blockCallback();\n  }\n\n  do {\n    n = ::recv(fd, (char*)buf, len, 0);\n  } while (n &lt; 0 &amp;&amp; errno == EINTR);\n\n  if (n &lt; 0) throw SystemException("read",errno);\n  if (n == 0) throw EndOfStream();\n\n  if (timing) {\n    gettimeofday(&amp;after, 0);\n    int newTimeWaited = ((after.tv_sec - before.tv_sec) * 10000 +\n                         (after.tv_usec - before.tv_usec) / 100);\n    int newKbits = n * 8 / 1000;\n\n    // limit rate to between 10kbit/s and 40Mbit/s\n\n    if (newTimeWaited &gt; newKbits*1000) newTimeWaited = newKbits*1000;\n    if (newTimeWaited &lt; newKbits/4)    newTimeWaited = newKbits/4;\n\n    timeWaitedIn100us += newTimeWaited;\n    timedKbits += newKbits;\n  }\n\n  return n;\n}',
 'static Jsi_RC DebugAddCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp-&gt;breakpointHash)\n        interp-&gt;breakpointHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    int argc = Jsi_ValueGetLength(interp, args);\n    jsi_BreakPoint *bptr, bp = {};\n    Jsi_Number vnum;\n    if (argc&gt;1 &amp;&amp; Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &amp;bp.temp) != JSI_OK) \n        return Jsi_LogError("bad boolean");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, v, &amp;vnum) == JSI_OK) {\n        bp.line = (int)vnum;\n        bp.file = interp-&gt;curFile;\n    } else {\n        const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n        const char *cp;\n        \n        if (isdigit(val[0])) {\n            if (Jsi_GetInt(interp, val, &amp;bp.line, 0) != JSI_OK) \n                return Jsi_LogError("bad number");\n            bp.file = interp-&gt;curFile;\n        } else if ((cp = Jsi_Strchr(val, \':\'))) {\n            if (Jsi_GetInt(interp, cp+1, &amp;bp.line, 0) != JSI_OK) \n                return Jsi_LogError("bad number");\n            Jsi_DString dStr = {};\n            Jsi_DSAppendLen(&amp;dStr, val, cp-val);\n            bp.file = Jsi_KeyAdd(interp, Jsi_DSValue(&amp;dStr));\n            Jsi_DSFree(&amp;dStr);\n        } else {\n            bp.func = Jsi_KeyAdd(interp, val);\n        }\n    }\n    if (bp.line&lt;=0 &amp;&amp; !bp.func) \n        return Jsi_LogError("bad number");\n    char nbuf[100];\n    bp.id = ++interp-&gt;debugOpts.breakIdx;\n    bp.enabled = 1;\n    snprintf(nbuf, sizeof(nbuf), "%d", bp.id);\n    bptr = (jsi_BreakPoint*)Jsi_Malloc(sizeof(*bptr));\n    *bptr = bp;\n    Jsi_HashSet(interp-&gt;breakpointHash, (void*)nbuf, bptr);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)bp.id);\n    return JSI_OK;\n}',
 "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im-&gt;sx;\n\tint height = im-&gt;sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\n\t/* switch off colour merging on target gd image just while we write out\n\t * content - we want to preserve the alpha data until the user chooses\n\t * what to do with the image */\n\talphaBlendingFlag = im-&gt;alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\n\tfor(y = 0; y &lt; height; y++) {\n\t\tfor(x = 0; x &lt; width; x++) {\n\t\t\t/* if it doesn't already exist, allocate a new colour,\n\t\t\t * else use existing one */\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\n\t\t\t/* set pixel colour to this colour */\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\n\tgdFree(buffer);\n\n\t/* now reset colour merge for alpha blending routines */\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}",
 'static void Sp_match(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint len;\n\tconst char *a, *b, *c, *e;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, "", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\n\tre = js_toregexp(J, -1);\n\tif (!(re-&gt;flags &amp; JS_REGEXP_G)) {\n\t\tjs_RegExp_prototype_exec(J, re, text);\n\t\treturn;\n\t}\n\n\tre-&gt;last = 0;\n\n\tjs_newarray(J);\n\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a &lt;= e) {\n\t\tif (js_regexec(re-&gt;prog, a, &amp;m, a &gt; text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\n\t\ta = c;\n\t\tif (c - b == 0)\n\t\t\t++a;\n\t}\n\n\tif (len == 0) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushnull(J);\n\t}\n}',
 'static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)-&gt;rng_make_random(tfm, dst, dlen);\n}',
 'TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteIntArray* input_dims = input-&gt;dims;\n  int input_dims_size = input_dims-&gt;size;\n  TF_LITE_ENSURE(context, input_dims_size &gt;= 1);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  // Resize the output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(input_dims_size + 1);\n  for (int i = 0; i &lt; input_dims_size; i++) {\n    output_shape-&gt;data[i] = input_dims-&gt;data[i];\n  }\n  // Last dimension in the output is the same as the last dimension in the\n  // input.\n  output_shape-&gt;data[input_dims_size] = input_dims-&gt;data[input_dims_size - 1];\n  output-&gt;type = input-&gt;type;\n  TF_LITE_ENSURE_OK(context,\n                    context-&gt;ResizeTensor(context, output, output_shape));\n\n  return kTfLiteOk;\n}',
 'static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth-&gt;alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\talgo = nla_data(nla);\n\tstrncpy(algo-&gt;alg_name, auth-&gt;alg_name, sizeof(algo-&gt;alg_name));\n\tmemcpy(algo-&gt;alg_key, auth-&gt;alg_key, (auth-&gt;alg_key_len + 7) / 8);\n\talgo-&gt;alg_key_len = auth-&gt;alg_key_len;\n\n\treturn 0;\n}',
 "void* leak_malloc(size_t bytes)\n{\n    // allocate enough space infront of the allocation to store the pointer for\n    // the alloc structure. This will making free'ing the structer really fast!\n\n    // 1. allocate enough memory and include our header\n    // 2. set the base pointer to be right after our header\n\n    size_t size = bytes + sizeof(AllocationEntry);\n    if (size &lt; bytes) { // Overflow.\n        return NULL;\n    }\n\n    void* base = dlmalloc(size);\n    if (base != NULL) {\n        pthread_mutex_lock(&amp;gAllocationsMutex);\n\n            intptr_t backtrace[BACKTRACE_SIZE];\n            size_t numEntries = get_backtrace(backtrace, BACKTRACE_SIZE);\n\n            AllocationEntry* header = (AllocationEntry*)base;\n            header-&gt;entry = record_backtrace(backtrace, numEntries, bytes);\n            header-&gt;guard = GUARD;\n\n            // now increment base to point to after our header.\n            // this should just work since our header is 8 bytes.\n            base = (AllocationEntry*)base + 1;\n\n        pthread_mutex_unlock(&amp;gAllocationsMutex);\n    }\n\n    return base;\n}",
 'void BezierOval(double w, double h, char *action)\n{\n    char *outpos = outputbuffer;\n    outpos +=\n    sprintf(outpos," %12.3f 0 m %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n",-w,-w,h*BzK,-w*BzK,h,h);\n    outpos +=\n    sprintf(outpos," %12.3f %12.3f %12.3f %12.3f %12.3f 0 c\\n",w*BzK,h,w,h*BzK,w);\n    outpos +=\n    sprintf(outpos," %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n",w,-h*BzK,w*BzK,-h,-h);\n    outpos +=\n    sprintf(outpos," %12.3f %12.3f %12.3f %12.3f %12.3f 0 c %s\\n",-w*BzK,-h,-w,-h*BzK,-w,action);\n    sendClean(outputbuffer);\n}',
 'R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree &amp;&amp; data &amp;&amp; cmp, false);\n\tbool inserted = false;\n\n\tif (tree-&gt;root == NULL) {\n\t\ttree-&gt;root = _node_new (data, NULL);\n\t\tif (tree-&gt;root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&amp;head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &amp;head; /* Grandparent &amp; parent */\n\tRRBNode *p = NULL, *q = tree-&gt;root; /* Iterator &amp; parent */\n\tint dir = 0, last = 0; /* Directions */\n\n\t_set_link (parent, q, 1);\n\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\t/* Insert a node at first null link(also set its parent link) */\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp-&gt;link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q-&gt;link[0]) &amp;&amp; IS_RED (q-&gt;link[1])) {\n\t\t\t/* Simple red violation: color flip */\n\t\t\tq-&gt;red = 1;\n\t\t\tq-&gt;link[0]-&gt;red = 0;\n\t\t\tq-&gt;link[1]-&gt;red = 0;\n\t\t}\n\n\t\tif (IS_RED (q) &amp;&amp; IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\t/* Hard red violation: rotate */\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent-&gt;link[1] == g;\n\t\t\tif (q == p-&gt;link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast = dir;\n\t\tdir = cmp (data, q-&gt;data, user) &gt;= 0;\n\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q-&gt;link[dir];\n\t}\n\n\t/* Update root(it may different due to root rotation) */\n\ttree-&gt;root = head.link[1];\n\nout_exit:\n\t/* Invariant: root is black */\n\ttree-&gt;root-&gt;red = 0;\n\ttree-&gt;root-&gt;parent = NULL;\n\tif (inserted) {\n\t\ttree-&gt;size++;\n\t}\n\n\treturn inserted;\n}',
 'obj2ast_stmt(PyObject* obj, stmt_ty* out, PyArena* arena)\n{\n    int isinstance;\n\n    PyObject *tmp = NULL;\n    int lineno;\n    int col_offset;\n\n    if (obj == Py_None) {\n        *out = NULL;\n        return 0;\n    }\n    if (lookup_attr_id(obj, &amp;PyId_lineno, &amp;tmp) &lt; 0) {\n        return 1;\n    }\n    if (tmp == NULL) {\n        PyErr_SetString(PyExc_TypeError, "required field \\"lineno\\" missing from stmt");\n        return 1;\n    }\n    else {\n        int res;\n        res = obj2ast_int(tmp, &amp;lineno, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    if (lookup_attr_id(obj, &amp;PyId_col_offset, &amp;tmp) &lt; 0) {\n        return 1;\n    }\n    if (tmp == NULL) {\n        PyErr_SetString(PyExc_TypeError, "required field \\"col_offset\\" missing from stmt");\n        return 1;\n    }\n    else {\n        int res;\n        res = obj2ast_int(tmp, &amp;col_offset, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)FunctionDef_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        identifier name;\n        arguments_ty args;\n        asdl_seq* body;\n        asdl_seq* decorator_list;\n        expr_ty returns;\n        string type_comment;\n\n        if (lookup_attr_id(obj, &amp;PyId_name, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"name\\" missing from FunctionDef");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_identifier(tmp, &amp;name, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_args, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"args\\" missing from FunctionDef");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_arguments(tmp, &amp;args, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from FunctionDef");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "FunctionDef field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "FunctionDef field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_decorator_list, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"decorator_list\\" missing from FunctionDef");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "FunctionDef field \\"decorator_list\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            decorator_list = _Ta3_asdl_seq_new(len, arena);\n            if (decorator_list == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty val;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "FunctionDef field \\"decorator_list\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(decorator_list, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_returns, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            returns = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;returns, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_type_comment, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            type_comment = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = FunctionDef(name, args, body, decorator_list, returns,\n                           type_comment, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)AsyncFunctionDef_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        identifier name;\n        arguments_ty args;\n        asdl_seq* body;\n        asdl_seq* decorator_list;\n        expr_ty returns;\n        string type_comment;\n\n        if (lookup_attr_id(obj, &amp;PyId_name, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"name\\" missing from AsyncFunctionDef");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_identifier(tmp, &amp;name, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_args, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"args\\" missing from AsyncFunctionDef");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_arguments(tmp, &amp;args, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from AsyncFunctionDef");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncFunctionDef field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncFunctionDef field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_decorator_list, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"decorator_list\\" missing from AsyncFunctionDef");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncFunctionDef field \\"decorator_list\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            decorator_list = _Ta3_asdl_seq_new(len, arena);\n            if (decorator_list == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty val;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncFunctionDef field \\"decorator_list\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(decorator_list, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_returns, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            returns = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;returns, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_type_comment, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            type_comment = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = AsyncFunctionDef(name, args, body, decorator_list, returns,\n                                type_comment, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)ClassDef_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        identifier name;\n        asdl_seq* bases;\n        asdl_seq* keywords;\n        asdl_seq* body;\n        asdl_seq* decorator_list;\n\n        if (lookup_attr_id(obj, &amp;PyId_name, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"name\\" missing from ClassDef");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_identifier(tmp, &amp;name, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_bases, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"bases\\" missing from ClassDef");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "ClassDef field \\"bases\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            bases = _Ta3_asdl_seq_new(len, arena);\n            if (bases == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty val;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \\"bases\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(bases, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_keywords, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"keywords\\" missing from ClassDef");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "ClassDef field \\"keywords\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            keywords = _Ta3_asdl_seq_new(len, arena);\n            if (keywords == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                keyword_ty val;\n                res = obj2ast_keyword(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \\"keywords\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(keywords, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from ClassDef");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "ClassDef field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_decorator_list, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"decorator_list\\" missing from ClassDef");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "ClassDef field \\"decorator_list\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            decorator_list = _Ta3_asdl_seq_new(len, arena);\n            if (decorator_list == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty val;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \\"decorator_list\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(decorator_list, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = ClassDef(name, bases, keywords, body, decorator_list, lineno,\n                        col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Return_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty value;\n\n        if (lookup_attr_id(obj, &amp;PyId_value, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            value = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;value, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = Return(value, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Delete_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* targets;\n\n        if (lookup_attr_id(obj, &amp;PyId_targets, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"targets\\" missing from Delete");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Delete field \\"targets\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            targets = _Ta3_asdl_seq_new(len, arena);\n            if (targets == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty val;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Delete field \\"targets\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(targets, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Delete(targets, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Assign_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* targets;\n        expr_ty value;\n        string type_comment;\n\n        if (lookup_attr_id(obj, &amp;PyId_targets, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"targets\\" missing from Assign");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Assign field \\"targets\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            targets = _Ta3_asdl_seq_new(len, arena);\n            if (targets == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                expr_ty val;\n                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Assign field \\"targets\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(targets, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_value, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"value\\" missing from Assign");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;value, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_type_comment, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            type_comment = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = Assign(targets, value, type_comment, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)AugAssign_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty target;\n        operator_ty op;\n        expr_ty value;\n\n        if (lookup_attr_id(obj, &amp;PyId_target, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"target\\" missing from AugAssign");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;target, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_op, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"op\\" missing from AugAssign");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_operator(tmp, &amp;op, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_value, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"value\\" missing from AugAssign");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;value, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = AugAssign(target, op, value, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)AnnAssign_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty target;\n        expr_ty annotation;\n        expr_ty value;\n        int simple;\n\n        if (lookup_attr_id(obj, &amp;PyId_target, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"target\\" missing from AnnAssign");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;target, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_annotation, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"annotation\\" missing from AnnAssign");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;annotation, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_value, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            value = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;value, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_simple, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"simple\\" missing from AnnAssign");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_int(tmp, &amp;simple, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = AnnAssign(target, annotation, value, simple, lineno, col_offset,\n                         arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)For_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty target;\n        expr_ty iter;\n        asdl_seq* body;\n        asdl_seq* orelse;\n        string type_comment;\n\n        if (lookup_attr_id(obj, &amp;PyId_target, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"target\\" missing from For");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;target, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_iter, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"iter\\" missing from For");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;iter, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from For");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "For field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "For field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_orelse, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"orelse\\" missing from For");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "For field \\"orelse\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            orelse = _Ta3_asdl_seq_new(len, arena);\n            if (orelse == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "For field \\"orelse\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(orelse, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_type_comment, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            type_comment = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = For(target, iter, body, orelse, type_comment, lineno,\n                   col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)AsyncFor_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty target;\n        expr_ty iter;\n        asdl_seq* body;\n        asdl_seq* orelse;\n        string type_comment;\n\n        if (lookup_attr_id(obj, &amp;PyId_target, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"target\\" missing from AsyncFor");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;target, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_iter, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"iter\\" missing from AsyncFor");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;iter, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from AsyncFor");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncFor field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncFor field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_orelse, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"orelse\\" missing from AsyncFor");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncFor field \\"orelse\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            orelse = _Ta3_asdl_seq_new(len, arena);\n            if (orelse == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncFor field \\"orelse\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(orelse, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_type_comment, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            type_comment = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = AsyncFor(target, iter, body, orelse, type_comment, lineno,\n                        col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)While_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty test;\n        asdl_seq* body;\n        asdl_seq* orelse;\n\n        if (lookup_attr_id(obj, &amp;PyId_test, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"test\\" missing from While");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;test, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from While");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "While field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "While field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_orelse, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"orelse\\" missing from While");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "While field \\"orelse\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            orelse = _Ta3_asdl_seq_new(len, arena);\n            if (orelse == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "While field \\"orelse\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(orelse, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = While(test, body, orelse, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)If_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty test;\n        asdl_seq* body;\n        asdl_seq* orelse;\n\n        if (lookup_attr_id(obj, &amp;PyId_test, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"test\\" missing from If");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;test, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from If");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "If field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "If field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_orelse, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"orelse\\" missing from If");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "If field \\"orelse\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            orelse = _Ta3_asdl_seq_new(len, arena);\n            if (orelse == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "If field \\"orelse\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(orelse, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = If(test, body, orelse, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)With_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* items;\n        asdl_seq* body;\n        string type_comment;\n\n        if (lookup_attr_id(obj, &amp;PyId_items, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"items\\" missing from With");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "With field \\"items\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            items = _Ta3_asdl_seq_new(len, arena);\n            if (items == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                withitem_ty val;\n                res = obj2ast_withitem(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "With field \\"items\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(items, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from With");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "With field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "With field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_type_comment, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            type_comment = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = With(items, body, type_comment, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)AsyncWith_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* items;\n        asdl_seq* body;\n        string type_comment;\n\n        if (lookup_attr_id(obj, &amp;PyId_items, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"items\\" missing from AsyncWith");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncWith field \\"items\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            items = _Ta3_asdl_seq_new(len, arena);\n            if (items == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                withitem_ty val;\n                res = obj2ast_withitem(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncWith field \\"items\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(items, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from AsyncWith");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "AsyncWith field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "AsyncWith field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_type_comment, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            type_comment = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_string(tmp, &amp;type_comment, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = AsyncWith(items, body, type_comment, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Raise_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty exc;\n        expr_ty cause;\n\n        if (lookup_attr_id(obj, &amp;PyId_exc, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            exc = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;exc, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_cause, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            cause = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;cause, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = Raise(exc, cause, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Try_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* body;\n        asdl_seq* handlers;\n        asdl_seq* orelse;\n        asdl_seq* finalbody;\n\n        if (lookup_attr_id(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from Try");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Try field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Ta3_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Try field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_handlers, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"handlers\\" missing from Try");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Try field \\"handlers\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            handlers = _Ta3_asdl_seq_new(len, arena);\n            if (handlers == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                excepthandler_ty val;\n                res = obj2ast_excepthandler(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Try field \\"handlers\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(handlers, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_orelse, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"orelse\\" missing from Try");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Try field \\"orelse\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            orelse = _Ta3_asdl_seq_new(len, arena);\n            if (orelse == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Try field \\"orelse\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(orelse, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_finalbody, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"finalbody\\" missing from Try");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Try field \\"finalbody\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            finalbody = _Ta3_asdl_seq_new(len, arena);\n            if (finalbody == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Try field \\"finalbody\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(finalbody, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Try(body, handlers, orelse, finalbody, lineno, col_offset,\n                   arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Assert_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty test;\n        expr_ty msg;\n\n        if (lookup_attr_id(obj, &amp;PyId_test, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"test\\" missing from Assert");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;test, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_msg, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            msg = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;msg, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = Assert(test, msg, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Import_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* names;\n\n        if (lookup_attr_id(obj, &amp;PyId_names, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"names\\" missing from Import");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Import field \\"names\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            names = _Ta3_asdl_seq_new(len, arena);\n            if (names == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                alias_ty val;\n                res = obj2ast_alias(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Import field \\"names\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(names, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Import(names, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)ImportFrom_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        identifier module;\n        asdl_seq* names;\n        int level;\n\n        if (lookup_attr_id(obj, &amp;PyId_module, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            module = NULL;\n        }\n        else {\n            int res;\n            res = obj2ast_identifier(tmp, &amp;module, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_names, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"names\\" missing from ImportFrom");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "ImportFrom field \\"names\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            names = _Ta3_asdl_seq_new(len, arena);\n            if (names == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                alias_ty val;\n                res = obj2ast_alias(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "ImportFrom field \\"names\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(names, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        if (lookup_attr_id(obj, &amp;PyId_level, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL || tmp == Py_None) {\n            Py_CLEAR(tmp);\n            level = 0;\n        }\n        else {\n            int res;\n            res = obj2ast_int(tmp, &amp;level, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = ImportFrom(module, names, level, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Global_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* names;\n\n        if (lookup_attr_id(obj, &amp;PyId_names, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"names\\" missing from Global");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Global field \\"names\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            names = _Ta3_asdl_seq_new(len, arena);\n            if (names == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                identifier val;\n                res = obj2ast_identifier(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Global field \\"names\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(names, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Global(names, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Nonlocal_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* names;\n\n        if (lookup_attr_id(obj, &amp;PyId_names, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"names\\" missing from Nonlocal");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Nonlocal field \\"names\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            names = _Ta3_asdl_seq_new(len, arena);\n            if (names == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                identifier val;\n                res = obj2ast_identifier(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Nonlocal field \\"names\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(names, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Nonlocal(names, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Expr_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty value;\n\n        if (lookup_attr_id(obj, &amp;PyId_value, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"value\\" missing from Expr");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;value, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = Expr(value, lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Pass_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n\n        *out = Pass(lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Break_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n\n        *out = Break(lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Continue_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n\n        *out = Continue(lineno, col_offset, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n\n    PyErr_Format(PyExc_TypeError, "expected some sort of stmt, but got %R", obj);\n    failed:\n    Py_XDECREF(tmp);\n    return 1;\n}',
 'int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n\n    PLUGIN_TRACE("[FD %i] Mandril validating URL", cs-&gt;socket);\n    if (mk_security_check_url(sr-&gt;uri) &lt; 0) {\n        PLUGIN_TRACE("[FD %i] Close connection, blocked URL", cs-&gt;socket);\n        mk_api-&gt;header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    PLUGIN_TRACE("[FD %d] Mandril validating hotlinking", cs-&gt;socket);\n    referer = mk_api-&gt;header_get(&amp;sr-&gt;headers_toc, "Referer", strlen("Referer"));\n    if (mk_security_check_hotlink(sr-&gt;uri_processed, sr-&gt;host, referer) &lt; 0) {\n        PLUGIN_TRACE("[FD %i] Close connection, deny hotlinking.", cs-&gt;socket);\n        mk_api-&gt;header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    return MK_PLUGIN_RET_NOT_ME;\n}',
 "static inline int do_exception(struct pt_regs *regs, int access,\n\t\t\t       unsigned long trans_exc_code)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long address;\n\tunsigned int flags;\n\tint fault;\n\n\tif (notify_page_fault(regs))\n\t\treturn 0;\n\n\ttsk = current;\n\tmm = tsk-&gt;mm;\n\n\t/*\n\t * Verify that the fault happened in user space, that\n\t * we are not in an interrupt and that there is a \n\t * user context.\n\t */\n\tfault = VM_FAULT_BADCONTEXT;\n\tif (unlikely(!user_space_fault(trans_exc_code) || in_atomic() || !mm))\n\t\tgoto out;\n\n\taddress = trans_exc_code &amp; __FAIL_ADDR_MASK;\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\tflags = FAULT_FLAG_ALLOW_RETRY;\n\tif (access == VM_WRITE || (trans_exc_code &amp; store_indication) == 0x400)\n\t\tflags |= FAULT_FLAG_WRITE;\nretry:\n\tdown_read(&amp;mm-&gt;mmap_sem);\n\n\tfault = VM_FAULT_BADMAP;\n\tvma = find_vma(mm, address);\n\tif (!vma)\n\t\tgoto out_up;\n\n\tif (unlikely(vma-&gt;vm_start &gt; address)) {\n\t\tif (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))\n\t\t\tgoto out_up;\n\t\tif (expand_stack(vma, address))\n\t\t\tgoto out_up;\n\t}\n\n\t/*\n\t * Ok, we have a good vm_area for this memory access, so\n\t * we can handle it..\n\t */\n\tfault = VM_FAULT_BADACCESS;\n\tif (unlikely(!(vma-&gt;vm_flags &amp; access)))\n\t\tgoto out_up;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\taddress &amp;= HPAGE_MASK;\n\t/*\n\t * If for any reason at all we couldn't handle the fault,\n\t * make sure we exit gracefully rather than endlessly redo\n\t * the fault.\n\t */\n\tfault = handle_mm_fault(mm, vma, address, flags);\n\tif (unlikely(fault &amp; VM_FAULT_ERROR))\n\t\tgoto out_up;\n\n\t/*\n\t * Major/minor page fault accounting is only done on the\n\t * initial attempt. If we go through a retry, it is extremely\n\t * likely that the page will be found in page cache at that point.\n\t */\n\tif (flags &amp; FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault &amp; VM_FAULT_MAJOR) {\n\t\t\ttsk-&gt;maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t\t      regs, address);\n\t\t} else {\n\t\t\ttsk-&gt;min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t\t      regs, address);\n\t\t}\n\t\tif (fault &amp; VM_FAULT_RETRY) {\n\t\t\t/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk\n\t\t\t * of starvation. */\n\t\t\tflags &amp;= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\t/*\n\t * The instruction that caused the program check will\n\t * be repeated. Don't signal single step via SIGTRAP.\n\t */\n\tclear_tsk_thread_flag(tsk, TIF_PER_TRAP);\n\tfault = 0;\nout_up:\n\tup_read(&amp;mm-&gt;mmap_sem);\nout:\n\treturn fault;\n}",
 'static inline void vmacache_invalidate(struct mm_struct *mm)\n{\n\tmm-&gt;vmacache_seqnum++;\n\n\t/* deal with overflows */\n\tif (unlikely(mm-&gt;vmacache_seqnum == 0))\n\t\tvmacache_flush_all(mm);\n}',
 'u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[4];\n\n\t/*\n\t *  Pick a unique starting offset for each ephemeral port search\n\t *  (saddr, daddr, dport) and 48bits of random data.\n\t */\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ keyptr-&gt;secret[10];\n\thash[3] = keyptr-&gt;secret[11];\n\n\treturn half_md4_transform(hash, keyptr-&gt;secret);\n}',
 'void big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&amp;key-&gt;payload.data[big_key_path];\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\tif (key_is_positive(key) &amp;&amp;\n\t    (size_t)key-&gt;payload.data[big_key_len] &gt; BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}',
 'accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n\n        /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n        if (server-&gt;priv-&gt;xsmp_sockets == NULL) {\n                g_debug ("GsmXsmpServer: In shutdown, rejecting new client");\n\n                *failure_reason_ret = strdup (_("Refusing new client connection because the session is currently being shut down\\n"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn-&gt;context;\n\n        g_return_val_if_fail (client != NULL, TRUE);\n\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}',
 'cleanup_pathname(struct archive_write_disk *a)\n{\n\tstruct archive_string error_string;\n\tint error_number;\n\tint rc;\n\tarchive_string_init(&amp;error_string);\n\trc = cleanup_pathname_fsobj(a-&gt;name, &amp;error_number, &amp;error_string, a-&gt;flags);\n\tif (rc != ARCHIVE_OK) {\n\t\tarchive_set_error(&amp;a-&gt;archive, error_number, "%s", error_string.s);\n\t}\n\tarchive_string_free(&amp;error_string);\n\treturn rc;\n}',
 'static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &amp;box-&gt;data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr-&gt;lutdata = 0;\n\tpclr-&gt;bpc = 0;\n\n\tif (jp2_getuint16(in, &amp;pclr-&gt;numlutents) ||\n\t  jp2_getuint8(in, &amp;pclr-&gt;numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr-&gt;numlutents * pclr-&gt;numchans;\n\tif (!(pclr-&gt;lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr-&gt;bpc = jas_alloc2(pclr-&gt;numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i &lt; pclr-&gt;numchans; ++i) {\n\t\tif (jp2_getuint8(in, &amp;pclr-&gt;bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i &lt; pclr-&gt;numlutents; ++i) {\n\t\tfor (j = 0; j &lt; pclr-&gt;numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr-&gt;bpc[j] &amp; 0x80) != 0,\n\t\t\t  (pclr-&gt;bpc[j] &amp; 0x7f) + 1, &amp;x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr-&gt;lutdata[i * pclr-&gt;numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}',
 'read_subpkt(cdk_stream_t inp, cdk_subpkt_t * r_ctx, size_t * r_nbytes)\n{\n\tbyte c, c1;\n\tsize_t size, nread, n;\n\tcdk_subpkt_t node;\n\tcdk_error_t rc;\n\n\tif (!inp || !r_nbytes)\n\t\treturn CDK_Inv_Value;\n\n\tif (DEBUG_PKT)\n\t\t_gnutls_write_log("read_subpkt:\\n");\n\n\tn = 0;\n\t*r_nbytes = 0;\n\tc = cdk_stream_getc(inp);\n\tn++;\n\tif (c == 255) {\n\t\tsize = read_32(inp);\n\t\tn += 4;\n\t} else if (c &gt;= 192 &amp;&amp; c &lt; 255) {\n\t\tc1 = cdk_stream_getc(inp);\n\t\tn++;\n\t\tif (c1 == 0)\n\t\t\treturn 0;\n\t\tsize = ((c - 192) &lt;&lt; 8) + c1 + 192;\n\t} else if (c &lt; 192)\n\t\tsize = c;\n\telse\n\t\treturn CDK_Inv_Packet;\n\n\tnode = cdk_subpkt_new(size);\n\tif (!node)\n\t\treturn CDK_Out_Of_Core;\n\tnode-&gt;size = size;\n\tnode-&gt;type = cdk_stream_getc(inp);\n\tif (DEBUG_PKT)\n\t\t_gnutls_write_log(" %d octets %d type\\n", node-&gt;size,\n\t\t\t\t  node-&gt;type);\n\tn++;\n\tnode-&gt;size--;\n\trc = stream_read(inp, node-&gt;d, node-&gt;size, &amp;nread);\n\tn += nread;\n\tif (rc) {\n\t\tcdk_subpkt_free(node);\n\t\treturn rc;\n\t}\n\t*r_nbytes = n;\n\tif (!*r_ctx)\n\t\t*r_ctx = node;\n\telse\n\t\tcdk_subpkt_add(*r_ctx, node);\n\treturn rc;\n}',
 'int main(int    argc,\n         char **argv)\n{\nl_int32       w, h;\nPIX          *pixs, *pixg, *pixim, *pixgm, *pixmi, *pix1, *pix2;\nPIX          *pixmr, *pixmg, *pixmb, *pixmri, *pixmgi, *pixmbi;\nPIXA         *pixa;\nL_REGPARAMS  *rp;\n\n    if (regTestSetup(argc, argv, &amp;rp))\n        return 1;\n\n    lept_mkdir("lept/adapt");  // REMOVE?\n\n    pixs = pixRead("wet-day.jpg");\n    pixa = pixaCreate(0);\n    pixg = pixConvertRGBToGray(pixs, 0.33, 0.34, 0.33);\n    pixaAddPix(pixa, pixs, L_INSERT);\n    pixaAddPix(pixa, pixg, L_INSERT);\n    pixGetDimensions(pixs, &amp;w, &amp;h, NULL);\n\n        /* Process in grayscale */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pixGetBackgroundGrayMap(pixg, pixim, SIZE_X, SIZE_Y,\n                            BINTHRESH, MINCOUNT, &amp;pixgm);\n    fprintf(stderr, "Time for gray adaptmap gen: %7.3f\\n", stopTimer());\n    regTestWritePixAndCheck(rp, pixgm, IFF_PNG);  /* 0 */\n    pixaAddPix(pixa, pixgm, L_INSERT);\n\n    startTimer();\n    pixmi = pixGetInvBackgroundMap(pixgm, BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, "Time for gray inv map generation: %7.3f\\n", stopTimer());\n    regTestWritePixAndCheck(rp, pixmi, IFF_PNG);  /* 1 */\n    pixaAddPix(pixa, pixmi, L_INSERT);\n\n    startTimer();\n    pix1 = pixApplyInvBackgroundGrayMap(pixg, pixmi, SIZE_X, SIZE_Y);\n    fprintf(stderr, "Time to apply gray inv map: %7.3f\\n", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 2 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 3 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&amp;pixim);\n\n        /* Process in color */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pixGetBackgroundRGBMap(pixs, pixim, NULL, SIZE_X, SIZE_Y,\n                           BINTHRESH, MINCOUNT,\n                           &amp;pixmr, &amp;pixmg, &amp;pixmb);\n    fprintf(stderr, "Time for color adaptmap gen: %7.3f\\n", stopTimer());\n    regTestWritePixAndCheck(rp, pixmr, IFF_PNG);  /* 4 */\n    regTestWritePixAndCheck(rp, pixmg, IFF_PNG);  /* 5 */\n    regTestWritePixAndCheck(rp, pixmb, IFF_PNG);  /* 6 */\n    pixaAddPix(pixa, pixmr, L_INSERT);\n    pixaAddPix(pixa, pixmg, L_INSERT);\n    pixaAddPix(pixa, pixmb, L_INSERT);\n\n    startTimer();\n    pixmri = pixGetInvBackgroundMap(pixmr, BGVAL, SMOOTH_X, SMOOTH_Y);\n    pixmgi = pixGetInvBackgroundMap(pixmg, BGVAL, SMOOTH_X, SMOOTH_Y);\n    pixmbi = pixGetInvBackgroundMap(pixmb, BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, "Time for color inv map generation: %7.3f\\n", stopTimer());\n    regTestWritePixAndCheck(rp, pixmri, IFF_PNG);  /* 7 */\n    regTestWritePixAndCheck(rp, pixmgi, IFF_PNG);  /* 8 */\n    regTestWritePixAndCheck(rp, pixmbi, IFF_PNG);  /* 9 */\n    pixaAddPix(pixa, pixmri, L_INSERT);\n    pixaAddPix(pixa, pixmgi, L_INSERT);\n    pixaAddPix(pixa, pixmbi, L_INSERT);\n\n    startTimer();\n    pix1 = pixApplyInvBackgroundRGBMap(pixs, pixmri, pixmgi, pixmbi,\n                                       SIZE_X, SIZE_Y);\n    fprintf(stderr, "Time to apply color inv maps: %7.3f\\n", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 10 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 11 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&amp;pixim);\n\n        /* Process at higher level in color */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pix1 = pixBackgroundNorm(pixs, pixim, NULL, 5, 10, BINTHRESH, 20,\n                             BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, "Time for bg normalization: %7.3f\\n", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 12 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 13 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&amp;pixim);\n\n        /* Display results */\n    pix1 = pixaDisplayTiledAndScaled(pixa, 32, 400, 4, 0, 20, 2);\n    pixWrite("/tmp/lept/adapt/results.jpg", pix1, IFF_JFIF_JPEG);\n    pixDisplayWithTitle(pix1, 100, 0, NULL, rp-&gt;display);\n    pixDestroy(&amp;pix1);\n    pixaDestroy(&amp;pixa);\n\n    return regTestCleanup(rp);\n}',
 'static int aa_read_header(AVFormatContext *s)\n{\n    int i, j, idx, largest_idx = -1;\n    uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;\n    char key[128], val[128], codec_name[64] = {0};\n    uint8_t output[24], dst[8], src[8];\n    int64_t largest_size = -1, current_size = -1, chapter_pos;\n    struct toc_entry {\n        uint32_t offset;\n        uint32_t size;\n    } TOC[MAX_TOC_ENTRIES];\n    uint32_t header_key_part[4];\n    uint8_t header_key[16] = {0};\n    AADemuxContext *c = s-&gt;priv_data;\n    AVIOContext *pb = s-&gt;pb;\n    AVStream *st;\n\n    /* parse .aa header */\n    avio_skip(pb, 4); // file size\n    avio_skip(pb, 4); // magic string\n    toc_size = avio_rb32(pb); // TOC size\n    avio_skip(pb, 4); // unidentified integer\n    if (toc_size &gt; MAX_TOC_ENTRIES)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i &lt; toc_size; i++) { // read TOC\n        avio_skip(pb, 4); // TOC entry index\n        TOC[i].offset = avio_rb32(pb); // block offset\n        TOC[i].size = avio_rb32(pb); // block size\n    }\n    avio_skip(pb, 24); // header termination block (ignored)\n    npairs = avio_rb32(pb); // read dictionary entries\n    if (npairs &gt; MAX_DICTIONARY_ENTRIES)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i &lt; npairs; i++) {\n        memset(val, 0, sizeof(val));\n        memset(key, 0, sizeof(key));\n        avio_skip(pb, 1); // unidentified integer\n        nkey = avio_rb32(pb); // key string length\n        nval = avio_rb32(pb); // value string length\n        avio_get_str(pb, nkey, key, sizeof(key));\n        avio_get_str(pb, nval, val, sizeof(val));\n        if (!strcmp(key, "codec")) {\n            av_log(s, AV_LOG_DEBUG, "Codec is &lt;%s&gt;\\n", val);\n            strncpy(codec_name, val, sizeof(codec_name) - 1);\n        } else if (!strcmp(key, "HeaderSeed")) {\n            av_log(s, AV_LOG_DEBUG, "HeaderSeed is &lt;%s&gt;\\n", val);\n            header_seed = atoi(val);\n        } else if (!strcmp(key, "HeaderKey")) { // this looks like "1234567890 1234567890 1234567890 1234567890"\n            av_log(s, AV_LOG_DEBUG, "HeaderKey is &lt;%s&gt;\\n", val);\n            sscanf(val, "%"SCNu32"%"SCNu32"%"SCNu32"%"SCNu32,\n                   &amp;header_key_part[0], &amp;header_key_part[1], &amp;header_key_part[2], &amp;header_key_part[3]);\n            for (idx = 0; idx &lt; 4; idx++) {\n                AV_WB32(&amp;header_key[idx * 4], header_key_part[idx]); // convert each part to BE!\n            }\n            av_log(s, AV_LOG_DEBUG, "Processed HeaderKey is ");\n            for (i = 0; i &lt; 16; i++)\n                av_log(s, AV_LOG_DEBUG, "%02x", header_key[i]);\n            av_log(s, AV_LOG_DEBUG, "\\n");\n        } else {\n            av_dict_set(&amp;s-&gt;metadata, key, val, 0);\n        }\n    }\n\n    /* verify fixed key */\n    if (c-&gt;aa_fixed_key_len != 16) {\n        av_log(s, AV_LOG_ERROR, "aa_fixed_key value needs to be 16 bytes!\\n");\n        return AVERROR(EINVAL);\n    }\n\n    /* verify codec */\n    if ((c-&gt;codec_second_size = get_second_size(codec_name)) == -1) {\n        av_log(s, AV_LOG_ERROR, "unknown codec &lt;%s&gt;!\\n", codec_name);\n        return AVERROR(EINVAL);\n    }\n\n    /* decryption key derivation */\n    c-&gt;tea_ctx = av_tea_alloc();\n    if (!c-&gt;tea_ctx)\n        return AVERROR(ENOMEM);\n    av_tea_init(c-&gt;tea_ctx, c-&gt;aa_fixed_key, 16);\n    output[0] = output[1] = 0; // purely for padding purposes\n    memcpy(output + 2, header_key, 16);\n    idx = 0;\n    for (i = 0; i &lt; 3; i++) { // TEA CBC with weird mixed endianness\n        AV_WB32(src, header_seed);\n        AV_WB32(src + 4, header_seed + 1);\n        header_seed += 2;\n        av_tea_crypt(c-&gt;tea_ctx, dst, src, 1, NULL, 0); // TEA ECB encrypt\n        for (j = 0; j &lt; TEA_BLOCK_SIZE &amp;&amp; idx &lt; 18; j+=1, idx+=1) {\n            output[idx] = output[idx] ^ dst[j];\n        }\n    }\n    memcpy(c-&gt;file_key, output + 2, 16); // skip first 2 bytes of output\n    av_log(s, AV_LOG_DEBUG, "File key is ");\n    for (i = 0; i &lt; 16; i++)\n        av_log(s, AV_LOG_DEBUG, "%02x", c-&gt;file_key[i]);\n    av_log(s, AV_LOG_DEBUG, "\\n");\n\n    /* decoder setup */\n    st = avformat_new_stream(s, NULL);\n    if (!st) {\n        av_freep(&amp;c-&gt;tea_ctx);\n        return AVERROR(ENOMEM);\n    }\n    st-&gt;codecpar-&gt;codec_type = AVMEDIA_TYPE_AUDIO;\n    if (!strcmp(codec_name, "mp332")) {\n        st-&gt;codecpar-&gt;codec_id = AV_CODEC_ID_MP3;\n        st-&gt;codecpar-&gt;sample_rate = 22050;\n        st-&gt;need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);\n        // encoded audio frame is MP3_FRAME_SIZE bytes (+1 with padding, unlikely)\n    } else if (!strcmp(codec_name, "acelp85")) {\n        st-&gt;codecpar-&gt;codec_id = AV_CODEC_ID_SIPR;\n        st-&gt;codecpar-&gt;block_align = 19;\n        st-&gt;codecpar-&gt;channels = 1;\n        st-&gt;codecpar-&gt;sample_rate = 8500;\n        st-&gt;codecpar-&gt;bit_rate = 8500;\n        st-&gt;need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);\n    } else if (!strcmp(codec_name, "acelp16")) {\n        st-&gt;codecpar-&gt;codec_id = AV_CODEC_ID_SIPR;\n        st-&gt;codecpar-&gt;block_align = 20;\n        st-&gt;codecpar-&gt;channels = 1;\n        st-&gt;codecpar-&gt;sample_rate = 16000;\n        st-&gt;codecpar-&gt;bit_rate = 16000;\n        st-&gt;need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);\n    }\n\n    /* determine, and jump to audio start offset */\n    for (i = 1; i &lt; toc_size; i++) { // skip the first entry!\n        current_size = TOC[i].size;\n        if (current_size &gt; largest_size) {\n            largest_idx = i;\n            largest_size = current_size;\n        }\n    }\n    start = TOC[largest_idx].offset;\n    avio_seek(pb, start, SEEK_SET);\n\n    // extract chapter positions. since all formats have constant bit rate, use it\n    // as time base in bytes/s, for easy stream position &lt;-&gt; timestamp conversion\n    st-&gt;start_time = 0;\n    c-&gt;content_start = start;\n    c-&gt;content_end = start + largest_size;\n\n    while ((chapter_pos = avio_tell(pb)) &gt;= 0 &amp;&amp; chapter_pos &lt; c-&gt;content_end) {\n        int chapter_idx = s-&gt;nb_chapters;\n        uint32_t chapter_size = avio_rb32(pb);\n        if (chapter_size == 0) break;\n        chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;\n        avio_skip(pb, 4 + chapter_size);\n        if (!avpriv_new_chapter(s, chapter_idx, st-&gt;time_base,\n            chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))\n                return AVERROR(ENOMEM);\n    }\n\n    st-&gt;duration = (largest_size - CHAPTER_HEADER_SIZE * s-&gt;nb_chapters) * TIMEPREC;\n\n    ff_update_cur_dts(s, st, 0);\n    avio_seek(pb, start, SEEK_SET);\n    c-&gt;current_chapter_size = 0;\n    c-&gt;seek_offset = 0;\n\n    return 0;\n}',
 'static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt-&gt;ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\tops-&gt;get_msr(ctxt, MSR_EFER, &amp;efer);\n\t/* inject #GP if in real mode */\n\tif (ctxt-&gt;mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/*\n\t * Not recognized on AMD in compat mode (but is recognized in legacy\n\t * mode).\n\t */\n\tif ((ctxt-&gt;mode != X86EMUL_MODE_PROT64) &amp;&amp; (efer &amp; EFER_LMA)\n\t    &amp;&amp; !vendor_intel(ctxt))\n\t\treturn emulate_ud(ctxt);\n\n\t/* sysenter/sysexit have not been tested in 64bit mode. */\n\tif (ctxt-&gt;mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tsetup_syscalls_segments(ctxt, &amp;cs, &amp;ss);\n\n\tops-&gt;get_msr(ctxt, MSR_IA32_SYSENTER_CS, &amp;msr_data);\n\tif ((msr_data &amp; 0xfffc) == 0x0)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt-&gt;eflags &amp;= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data &amp; ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tif (efer &amp; EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\n\tops-&gt;set_segment(ctxt, cs_sel, &amp;cs, 0, VCPU_SREG_CS);\n\tops-&gt;set_segment(ctxt, ss_sel, &amp;ss, 0, VCPU_SREG_SS);\n\n\tops-&gt;get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &amp;msr_data);\n\tctxt-&gt;_eip = (efer &amp; EFER_LMA) ? msr_data : (u32)msr_data;\n\n\tops-&gt;get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &amp;msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = (efer &amp; EFER_LMA) ? msr_data :\n\t\t\t\t\t\t\t      (u32)msr_data;\n\n\treturn X86EMUL_CONTINUE;\n}',
 'static int xwd_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame, AVPacket *avpkt)\n{\n    AVFrame *p = data;\n    const uint8_t *buf = avpkt-&gt;data;\n    int i, ret, buf_size = avpkt-&gt;size;\n    uint32_t version, header_size, vclass, ncolors;\n    uint32_t xoffset, be, bpp, lsize, rsize;\n    uint32_t pixformat, pixdepth, bunit, bitorder, bpad;\n    uint32_t rgb[3];\n    uint8_t *ptr;\n    GetByteContext gb;\n\n    if (buf_size &lt; XWD_HEADER_SIZE)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&amp;gb, buf, buf_size);\n    header_size = bytestream2_get_be32u(&amp;gb);\n\n    version = bytestream2_get_be32u(&amp;gb);\n    if (version != XWD_VERSION) {\n        av_log(avctx, AV_LOG_ERROR, "unsupported version\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (buf_size &lt; header_size || header_size &lt; XWD_HEADER_SIZE) {\n        av_log(avctx, AV_LOG_ERROR, "invalid header size\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    pixformat     = bytestream2_get_be32u(&amp;gb);\n    pixdepth      = bytestream2_get_be32u(&amp;gb);\n    avctx-&gt;width  = bytestream2_get_be32u(&amp;gb);\n    avctx-&gt;height = bytestream2_get_be32u(&amp;gb);\n    xoffset       = bytestream2_get_be32u(&amp;gb);\n    be            = bytestream2_get_be32u(&amp;gb);\n    bunit         = bytestream2_get_be32u(&amp;gb);\n    bitorder      = bytestream2_get_be32u(&amp;gb);\n    bpad          = bytestream2_get_be32u(&amp;gb);\n    bpp           = bytestream2_get_be32u(&amp;gb);\n    lsize         = bytestream2_get_be32u(&amp;gb);\n    vclass        = bytestream2_get_be32u(&amp;gb);\n    rgb[0]        = bytestream2_get_be32u(&amp;gb);\n    rgb[1]        = bytestream2_get_be32u(&amp;gb);\n    rgb[2]        = bytestream2_get_be32u(&amp;gb);\n    bytestream2_skipu(&amp;gb, 8);\n    ncolors       = bytestream2_get_be32u(&amp;gb);\n    bytestream2_skipu(&amp;gb, header_size - (XWD_HEADER_SIZE - 20));\n\n    av_log(avctx, AV_LOG_DEBUG,\n           "pixformat %"PRIu32", pixdepth %"PRIu32", bunit %"PRIu32", bitorder %"PRIu32", bpad %"PRIu32"\\n",\n           pixformat, pixdepth, bunit, bitorder, bpad);\n    av_log(avctx, AV_LOG_DEBUG,\n           "vclass %"PRIu32", ncolors %"PRIu32", bpp %"PRIu32", be %"PRIu32", lsize %"PRIu32", xoffset %"PRIu32"\\n",\n           vclass, ncolors, bpp, be, lsize, xoffset);\n    av_log(avctx, AV_LOG_DEBUG,\n           "red %0"PRIx32", green %0"PRIx32", blue %0"PRIx32"\\n",\n           rgb[0], rgb[1], rgb[2]);\n\n    if (pixformat &gt; XWD_Z_PIXMAP) {\n        av_log(avctx, AV_LOG_ERROR, "invalid pixmap format\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (pixdepth == 0 || pixdepth &gt; 32) {\n        av_log(avctx, AV_LOG_ERROR, "invalid pixmap depth\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (xoffset) {\n        avpriv_request_sample(avctx, "xoffset %"PRIu32"", xoffset);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (be &gt; 1) {\n        av_log(avctx, AV_LOG_ERROR, "invalid byte order\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bitorder &gt; 1) {\n        av_log(avctx, AV_LOG_ERROR, "invalid bitmap bit order\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bunit != 8 &amp;&amp; bunit != 16 &amp;&amp; bunit != 32) {\n        av_log(avctx, AV_LOG_ERROR, "invalid bitmap unit\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bpad != 8 &amp;&amp; bpad != 16 &amp;&amp; bpad != 32) {\n        av_log(avctx, AV_LOG_ERROR, "invalid bitmap scan-line pad\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bpp == 0 || bpp &gt; 32) {\n        av_log(avctx, AV_LOG_ERROR, "invalid bits per pixel\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncolors &gt; 256) {\n        av_log(avctx, AV_LOG_ERROR, "invalid number of entries in colormap\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = av_image_check_size(avctx-&gt;width, avctx-&gt;height, 0, NULL)) &lt; 0)\n        return ret;\n\n    rsize = FFALIGN(avctx-&gt;width * bpp, bpad) / 8;\n    if (lsize &lt; rsize) {\n        av_log(avctx, AV_LOG_ERROR, "invalid bytes per scan-line\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&amp;gb) &lt; ncolors * XWD_CMAP_SIZE + (uint64_t)avctx-&gt;height * lsize) {\n        av_log(avctx, AV_LOG_ERROR, "input buffer too small\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (pixformat != XWD_Z_PIXMAP) {\n        avpriv_report_missing_feature(avctx, "Pixmap format %"PRIu32, pixformat);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    avctx-&gt;pix_fmt = AV_PIX_FMT_NONE;\n    switch (vclass) {\n    case XWD_STATIC_GRAY:\n    case XWD_GRAY_SCALE:\n        if (bpp != 1 &amp;&amp; bpp != 8)\n            return AVERROR_INVALIDDATA;\n        if (pixdepth == 1) {\n            avctx-&gt;pix_fmt = AV_PIX_FMT_MONOWHITE;\n        } else if (pixdepth == 8) {\n            avctx-&gt;pix_fmt = AV_PIX_FMT_GRAY8;\n        }\n        break;\n    case XWD_STATIC_COLOR:\n    case XWD_PSEUDO_COLOR:\n        if (bpp == 8)\n            avctx-&gt;pix_fmt = AV_PIX_FMT_PAL8;\n        break;\n    case XWD_TRUE_COLOR:\n    case XWD_DIRECT_COLOR:\n        if (bpp != 16 &amp;&amp; bpp != 24 &amp;&amp; bpp != 32)\n            return AVERROR_INVALIDDATA;\n        if (bpp == 16 &amp;&amp; pixdepth == 15) {\n            if (rgb[0] == 0x7C00 &amp;&amp; rgb[1] == 0x3E0 &amp;&amp; rgb[2] == 0x1F)\n                avctx-&gt;pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE;\n            else if (rgb[0] == 0x1F &amp;&amp; rgb[1] == 0x3E0 &amp;&amp; rgb[2] == 0x7C00)\n                avctx-&gt;pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE;\n        } else if (bpp == 16 &amp;&amp; pixdepth == 16) {\n            if (rgb[0] == 0xF800 &amp;&amp; rgb[1] == 0x7E0 &amp;&amp; rgb[2] == 0x1F)\n                avctx-&gt;pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE;\n            else if (rgb[0] == 0x1F &amp;&amp; rgb[1] == 0x7E0 &amp;&amp; rgb[2] == 0xF800)\n                avctx-&gt;pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE;\n        } else if (bpp == 24) {\n            if (rgb[0] == 0xFF0000 &amp;&amp; rgb[1] == 0xFF00 &amp;&amp; rgb[2] == 0xFF)\n                avctx-&gt;pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24;\n            else if (rgb[0] == 0xFF &amp;&amp; rgb[1] == 0xFF00 &amp;&amp; rgb[2] == 0xFF0000)\n                avctx-&gt;pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24;\n        } else if (bpp == 32) {\n            if (rgb[0] == 0xFF0000 &amp;&amp; rgb[1] == 0xFF00 &amp;&amp; rgb[2] == 0xFF)\n                avctx-&gt;pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA;\n            else if (rgb[0] == 0xFF &amp;&amp; rgb[1] == 0xFF00 &amp;&amp; rgb[2] == 0xFF0000)\n                avctx-&gt;pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA;\n        }\n        bytestream2_skipu(&amp;gb, ncolors * XWD_CMAP_SIZE);\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, "invalid visual class\\n");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (avctx-&gt;pix_fmt == AV_PIX_FMT_NONE) {\n        avpriv_request_sample(avctx,\n                              "Unknown file: bpp %"PRIu32", pixdepth %"PRIu32", vclass %"PRIu32"",\n                              bpp, pixdepth, vclass);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) &lt; 0)\n        return ret;\n\n    p-&gt;key_frame = 1;\n    p-&gt;pict_type = AV_PICTURE_TYPE_I;\n\n    if (avctx-&gt;pix_fmt == AV_PIX_FMT_PAL8) {\n        uint32_t *dst = (uint32_t *)p-&gt;data[1];\n        uint8_t red, green, blue;\n\n        for (i = 0; i &lt; ncolors; i++) {\n\n            bytestream2_skipu(&amp;gb, 4); // skip colormap entry number\n            red    = bytestream2_get_byteu(&amp;gb);\n            bytestream2_skipu(&amp;gb, 1);\n            green  = bytestream2_get_byteu(&amp;gb);\n            bytestream2_skipu(&amp;gb, 1);\n            blue   = bytestream2_get_byteu(&amp;gb);\n            bytestream2_skipu(&amp;gb, 3); // skip bitmask flag and padding\n\n            dst[i] = red &lt;&lt; 16 | green &lt;&lt; 8 | blue;\n        }\n    }\n\n    ptr = p-&gt;data[0];\n    for (i = 0; i &lt; avctx-&gt;height; i++) {\n        bytestream2_get_bufferu(&amp;gb, ptr, rsize);\n        bytestream2_skipu(&amp;gb, lsize - rsize);\n        ptr += p-&gt;linesize[0];\n    }\n\n    *got_frame       = 1;\n\n    return buf_size;\n}',
 'static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx-&gt;clockid == CLOCK_REALTIME ||\n\t     ctx-&gt;clockid == CLOCK_REALTIME_ALARM) &amp;&amp;\n\t    (flags &amp; TFD_TIMER_ABSTIME) &amp;&amp; (flags &amp; TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx-&gt;might_cancel) {\n\t\t\tctx-&gt;might_cancel = true;\n\t\t\tspin_lock(&amp;cancel_lock);\n\t\t\tlist_add_rcu(&amp;ctx-&gt;clist, &amp;cancel_list);\n\t\t\tspin_unlock(&amp;cancel_lock);\n\t\t}\n\t} else if (ctx-&gt;might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}',
 'tcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     const struct xt_action_param *par,\n\t\t     unsigned int family,\n\t\t     unsigned int tcphoff,\n\t\t     unsigned int minlen)\n{\n\tconst struct xt_tcpmss_info *info = par-&gt;targinfo;\n\tstruct tcphdr *tcph;\n\tint len, tcp_hdrlen;\n\tunsigned int i;\n\t__be16 oldval;\n\tu16 newmss;\n\tu8 *opt;\n\n\t/* This is a fragment, no TCP header is available */\n\tif (par-&gt;fragoff != 0)\n\t\treturn 0;\n\n\tif (!skb_make_writable(skb, skb-&gt;len))\n\t\treturn -1;\n\n\tlen = skb-&gt;len - tcphoff;\n\tif (len &lt; (int)sizeof(struct tcphdr))\n\t\treturn -1;\n\n\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\ttcp_hdrlen = tcph-&gt;doff * 4;\n\n\tif (len &lt; tcp_hdrlen || tcp_hdrlen &lt; sizeof(struct tcphdr))\n\t\treturn -1;\n\n\tif (info-&gt;mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tstruct net *net = xt_net(par);\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t\tunsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);\n\n\t\tif (min_mtu &lt;= minlen) {\n\t\t\tnet_err_ratelimited("unknown or invalid path-MTU (%u)\\n",\n\t\t\t\t\t    min_mtu);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmss = min_mtu - minlen;\n\t} else\n\t\tnewmss = info-&gt;mss;\n\n\topt = (u_int8_t *)tcph;\n\tfor (i = sizeof(struct tcphdr); i &lt;= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {\n\t\tif (opt[i] == TCPOPT_MSS &amp;&amp; opt[i+1] == TCPOLEN_MSS) {\n\t\t\tu_int16_t oldmss;\n\n\t\t\toldmss = (opt[i+2] &lt;&lt; 8) | opt[i+3];\n\n\t\t\t/* Never increase MSS, even when setting it, as\n\t\t\t * doing so results in problems for hosts that rely\n\t\t\t * on MSS being set correctly.\n\t\t\t */\n\t\t\tif (oldmss &lt;= newmss)\n\t\t\t\treturn 0;\n\n\t\t\topt[i+2] = (newmss &amp; 0xff00) &gt;&gt; 8;\n\t\t\topt[i+3] = newmss &amp; 0x00ff;\n\n\t\t\tinet_proto_csum_replace2(&amp;tcph-&gt;check, skb,\n\t\t\t\t\t\t htons(oldmss), htons(newmss),\n\t\t\t\t\t\t false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* There is data after the header so the option can\'t be added\n\t * without moving it, and doing so may make the SYN packet\n\t * itself too large. Accept the packet unmodified instead.\n\t */\n\tif (len &gt; tcp_hdrlen)\n\t\treturn 0;\n\n\t/* tcph-&gt;doff has 4 bits, do not wrap it to 0 */\n\tif (tcp_hdrlen &gt;= 15 * 4)\n\t\treturn 0;\n\n\t/*\n\t * MSS Option not found ?! add it..\n\t */\n\tif (skb_tailroom(skb) &lt; TCPOLEN_MSS) {\n\t\tif (pskb_expand_head(skb, 0,\n\t\t\t\t     TCPOLEN_MSS - skb_tailroom(skb),\n\t\t\t\t     GFP_ATOMIC))\n\t\t\treturn -1;\n\t\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\t}\n\n\tskb_put(skb, TCPOLEN_MSS);\n\n\t/*\n\t * IPv4: RFC 1122 states "If an MSS option is not received at\n\t * connection setup, TCP MUST assume a default send MSS of 536".\n\t * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum\n\t * length IPv6 header of 60, ergo the default MSS value is 1220\n\t * Since no MSS was provided, we must use the default values\n\t */\n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\tnewmss = min(newmss, (u16)536);\n\telse\n\t\tnewmss = min(newmss, (u16)1220);\n\n\topt = (u_int8_t *)tcph + sizeof(struct tcphdr);\n\tmemmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));\n\n\tinet_proto_csum_replace2(&amp;tcph-&gt;check, skb,\n\t\t\t\t htons(len), htons(len + TCPOLEN_MSS), true);\n\topt[0] = TCPOPT_MSS;\n\topt[1] = TCPOLEN_MSS;\n\topt[2] = (newmss &amp; 0xff00) &gt;&gt; 8;\n\topt[3] = newmss &amp; 0x00ff;\n\n\tinet_proto_csum_replace4(&amp;tcph-&gt;check, skb, 0, *((__be32 *)opt), false);\n\n\toldval = ((__be16 *)tcph)[6];\n\ttcph-&gt;doff += TCPOLEN_MSS/4;\n\tinet_proto_csum_replace2(&amp;tcph-&gt;check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn TCPOLEN_MSS;\n}',
 '\tPong(const std::string&amp; cookie, const std::string&amp; server = "")\n\t\t: ClientProtocol::Message("PONG", ServerInstance-&gt;Config-&gt;GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance-&gt;Config-&gt;GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}',
 'TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* inputs;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputsTensor, &amp;inputs));\n  const TfLiteTensor* sequence_length;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kSequenceLengthTensor,\n                                          &amp;sequence_length));\n  const CTCBeamSearchDecoderParams* option =\n      reinterpret_cast&lt;CTCBeamSearchDecoderParams*&gt;(node-&gt;user_data);\n\n  const int max_time = SizeOfDimension(inputs, 0);\n  const int batch_size = SizeOfDimension(inputs, 1);\n  const int num_classes = SizeOfDimension(inputs, 2);\n\n  const int beam_width = option-&gt;beam_width;\n  const int top_paths = option-&gt;top_paths;\n  const bool merge_repeated = option-&gt;merge_repeated;\n\n  // Validate sequence length is less or equal than max time.\n  for (int i = 0; i &lt; batch_size; ++i) {\n    TF_LITE_ENSURE(context,\n                   max_time &gt;= GetTensorData&lt;int32_t&gt;(sequence_length)[i]);\n  }\n\n  // The following logic is implemented like\n  // tensorflow/core/kernels/ctc_decoder_ops.cc\n  std::vector&lt;optimized_ops::TTypes&lt;float&gt;::UnalignedConstMatrix&gt; input_list_t;\n\n  for (std::size_t t = 0; t &lt; max_time; ++t) {\n    input_list_t.emplace_back(\n        GetTensorData&lt;float&gt;(inputs) + t * batch_size * num_classes, batch_size,\n        num_classes);\n  }\n\n  ::tflite::experimental::ctc::CTCBeamSearchDecoder&lt;&gt;::DefaultBeamScorer\n      beam_scorer;\n  ::tflite::experimental::ctc::CTCBeamSearchDecoder&lt;&gt; beam_search(\n      num_classes, beam_width, &amp;beam_scorer, 1 /* batch_size */,\n      merge_repeated);\n\n  // Allocate temporary memory for holding chip operation data.\n  float* input_chip_t_data =\n      static_cast&lt;float*&gt;(malloc(num_classes * sizeof(float)));\n  Eigen::array&lt;Eigen::DenseIndex, 1&gt; dims;\n  dims[0] = num_classes;\n  optimized_ops::TTypes&lt;float&gt;::Flat input_chip_t(input_chip_t_data, dims);\n\n  std::vector&lt;std::vector&lt;std::vector&lt;int&gt;&gt;&gt; best_paths(batch_size);\n  std::vector&lt;float&gt; log_probs;\n\n  TfLiteTensor* log_probabilities;\n  TF_LITE_ENSURE_OK(\n      context, GetOutputSafe(context, node, 3 * top_paths, &amp;log_probabilities));\n  float* log_probabilities_output = GetTensorData&lt;float&gt;(log_probabilities);\n\n  // Assumption: the blank index is num_classes - 1\n  for (int b = 0; b &lt; batch_size; ++b) {\n    auto&amp; best_paths_b = best_paths[b];\n    best_paths_b.resize(top_paths);\n    for (int t = 0; t &lt; GetTensorData&lt;int32_t&gt;(sequence_length)[b]; ++t) {\n      input_chip_t = input_list_t[t].chip(b, 0);\n      auto input_bi =\n          Eigen::Map&lt;const Eigen::ArrayXf&gt;(input_chip_t.data(), num_classes);\n      beam_search.Step(input_bi);\n    }\n    TF_LITE_ENSURE(context, beam_search.TopPaths(top_paths, &amp;best_paths_b,\n                                                 &amp;log_probs, merge_repeated));\n    beam_search.Reset();\n\n    // Fill in log_probabilities output.\n    for (int bp = 0; bp &lt; top_paths; ++bp) {\n      log_probabilities_output[b * top_paths + bp] = log_probs[bp];\n    }\n  }\n\n  free(input_chip_t_data);\n  return StoreAllDecodedSequences(context, best_paths, node, top_paths);\n}',
 'int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\n{\n  struct Client* acptr;\n  int first = 0;\n  char realhost[HOSTLEN + 3];\n  char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));\n\n  if (!CapActive(cptr, CAP_SASL))\n    return 0;\n\n  if (parc &lt; 2) /* have enough parameters? */\n    return need_more_params(cptr, "AUTHENTICATE");\n\n  if (strlen(parv[1]) &gt; 400)\n    return send_reply(cptr, ERR_SASLTOOLONG);\n\n  if (IsSASLComplete(cptr))\n    return send_reply(cptr, ERR_SASLALREADY);\n\n  /* Look up the target server */\n  if (!(acptr = cli_saslagent(cptr))) {\n    if (strcmp(feature_str(FEAT_SASL_SERVER), "*"))\n      acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));\n    else\n      acptr = NULL;\n  }\n\n  if (!acptr &amp;&amp; strcmp(feature_str(FEAT_SASL_SERVER), "*"))\n    return send_reply(cptr, ERR_SASLFAIL, ": service unavailable");\n\n  /* If it\'s to us, do nothing; otherwise, forward the query */\n  if (acptr &amp;&amp; IsMe(acptr))\n    return 0;\n\n  /* Generate an SASL session cookie if not already generated */\n  if (!cli_saslcookie(cptr)) {\n    do {\n      cli_saslcookie(cptr) = ircrandom() &amp; 0x7fffffff;\n    } while (!cli_saslcookie(cptr));\n    first = 1;\n  }\n\n  if (strchr(hoststr, \':\') != NULL)\n    ircd_snprintf(0, realhost, sizeof(realhost), "[%s]", hoststr);\n  else\n    ircd_strncpy(realhost, hoststr, sizeof(realhost));\n\n  if (acptr) {\n    if (first) {\n      if (*parv[1] == \':\' || strchr(parv[1], \' \'))\n\t\treturn exit_client(cptr, sptr, sptr, "Malformed AUTHENTICATE");\n      if (!EmptyString(cli_sslclifp(cptr)))\n        sendcmdto_one(&amp;me, CMD_SASL, acptr, "%C %C!%u.%u S %s :%s", acptr, &amp;me,\n                      cli_fd(cptr), cli_saslcookie(cptr),\n                      parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_one(&amp;me, CMD_SASL, acptr, "%C %C!%u.%u S :%s", acptr, &amp;me,\n                      cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_one(&amp;me, CMD_SASL, acptr, "%C %C!%u.%u H :%s@%s:%s", acptr, &amp;me,\n                      cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                      realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_one(&amp;me, CMD_SASL, acptr, "%C %C!%u.%u C :%s", acptr, &amp;me,\n                    cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  } else {\n    if (first) {\n      if (*parv[1] == \':\' || strchr(parv[1], \' \'))\n        return exit_client(cptr, sptr, sptr, "Malformed AUTHENTICATE");\n      if (!EmptyString(cli_sslclifp(cptr)))\n        sendcmdto_serv_butone(&amp;me, CMD_SASL, cptr, "* %C!%u.%u S %s :%s", &amp;me,\n                              cli_fd(cptr), cli_saslcookie(cptr),\n                              parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_serv_butone(&amp;me, CMD_SASL, cptr, "* %C!%u.%u S :%s", &amp;me,\n                              cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_serv_butone(&amp;me, CMD_SASL, cptr, "* %C!%u.%u H :%s@%s:%s", &amp;me,\n                              cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                              realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_serv_butone(&amp;me, CMD_SASL, cptr, "* %C!%u.%u C :%s", &amp;me,\n                            cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  }\n\n  if (!t_active(&amp;cli_sasltimeout(cptr)))\n    timer_add(timer_init(&amp;cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,\n              TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));\n\n  return 0;\n}',
 'CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire_clear(data); /* shut off timers */\n\n  m = data-&gt;multi;\n  if(m)\n    /* This handle is still part of a multi handle, take care of this first\n       and detach this handle from there. */\n    curl_multi_remove_handle(data-&gt;multi, data);\n\n  if(data-&gt;multi_easy) {\n    /* when curl_easy_perform() is used, it creates its own multi handle to\n       use and this is the one */\n    curl_multi_cleanup(data-&gt;multi_easy);\n    data-&gt;multi_easy = NULL;\n  }\n\n  /* Destroy the timeout list that is held in the easy handle. It is\n     /normally/ done by curl_multi_remove_handle() but this is "just in\n     case" */\n  Curl_llist_destroy(&amp;data-&gt;state.timeoutlist, NULL);\n\n  data-&gt;magic = 0; /* force a clear AFTER the possibly enforced removal from\n                      the multi handle, since that function uses the magic\n                      field! */\n\n  if(data-&gt;state.rangestringalloc)\n    free(data-&gt;state.range);\n\n  /* freed here just in case DONE wasn\'t called */\n  Curl_free_request_state(data);\n\n  /* Close down all open SSL info and sessions */\n  Curl_ssl_close_all(data);\n  Curl_safefree(data-&gt;state.first_host);\n  Curl_safefree(data-&gt;state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  /* Cleanup possible redirect junk */\n  free(data-&gt;req.newurl);\n  data-&gt;req.newurl = NULL;\n\n  if(data-&gt;change.referer_alloc) {\n    Curl_safefree(data-&gt;change.referer);\n    data-&gt;change.referer_alloc = FALSE;\n  }\n  data-&gt;change.referer = NULL;\n\n  Curl_up_free(data);\n  Curl_safefree(data-&gt;state.buffer);\n  Curl_safefree(data-&gt;state.headerbuff);\n  Curl_safefree(data-&gt;state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data-&gt;info.contenttype);\n  Curl_safefree(data-&gt;info.wouldredirect);\n\n  /* this destroys the channel and we cannot use it anymore after this */\n  Curl_resolver_cleanup(data-&gt;state.resolver);\n\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n\n  /* No longer a dirty share, if it exists */\n  if(data-&gt;share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data-&gt;share-&gt;dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  /* destruct wildcard structures if it is needed */\n  Curl_wildcard_dtor(&amp;data-&gt;wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}',
 "static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,\n\t\tstruct vm_area_struct *vma, struct page *check_page)\n{\n\tstruct mm_struct *mm = vma-&gt;vm_mm;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tpte_t pteval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tunsigned long address;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tunsigned long end;\n\tint ret = SWAP_AGAIN;\n\tint locked_vma = 0;\n\n\taddress = (vma-&gt;vm_start + cursor) &amp; CLUSTER_MASK;\n\tend = address + CLUSTER_SIZE;\n\tif (address &lt; vma-&gt;vm_start)\n\t\taddress = vma-&gt;vm_start;\n\tif (end &gt; vma-&gt;vm_end)\n\t\tend = vma-&gt;vm_end;\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd)\n\t\treturn ret;\n\n\tmmun_start = address;\n\tmmun_end   = end;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,\n\t * keep the sem while scanning the cluster for mlocking pages.\n\t */\n\tif (down_read_trylock(&amp;vma-&gt;vm_mm-&gt;mmap_sem)) {\n\t\tlocked_vma = (vma-&gt;vm_flags &amp; VM_LOCKED);\n\t\tif (!locked_vma)\n\t\t\tup_read(&amp;vma-&gt;vm_mm-&gt;mmap_sem); /* don't need it */\n\t}\n\n\tpte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);\n\n\t/* Update high watermark before we lower rss */\n\tupdate_hiwater_rss(mm);\n\n\tfor (; address &lt; end; pte++, address += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, address, *pte);\n\t\tBUG_ON(!page || PageAnon(page));\n\n\t\tif (locked_vma) {\n\t\t\tif (page == check_page) {\n\t\t\t\t/* we know we have check_page locked */\n\t\t\t\tmlock_vma_page(page);\n\t\t\t\tret = SWAP_MLOCK;\n\t\t\t} else if (trylock_page(page)) {\n\t\t\t\t/*\n\t\t\t\t * If we can lock the page, perform mlock.\n\t\t\t\t * Otherwise leave the page alone, it will be\n\t\t\t\t * eventually encountered again later.\n\t\t\t\t */\n\t\t\t\tmlock_vma_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t\tcontinue;\t/* don't unmap */\n\t\t}\n\n\t\tif (ptep_clear_flush_young_notify(vma, address, pte))\n\t\t\tcontinue;\n\n\t\t/* Nuke the page table entry. */\n\t\tflush_cache_page(vma, address, pte_pfn(*pte));\n\t\tpteval = ptep_clear_flush(vma, address, pte);\n\n\t\t/* If nonlinear, store the file page offset in the pte. */\n\t\tif (page-&gt;index != linear_page_index(vma, address)) {\n\t\t\tpte_t ptfile = pgoff_to_pte(page-&gt;index);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tpte_file_mksoft_dirty(ptfile);\n\t\t\tset_pte_at(mm, address, pte, ptfile);\n\t\t}\n\n\t\t/* Move the dirty bit to the physical page now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tset_page_dirty(page);\n\n\t\tpage_remove_rmap(page);\n\t\tpage_cache_release(page);\n\t\tdec_mm_counter(mm, MM_FILEPAGES);\n\t\t(*mapcount)--;\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\tif (locked_vma)\n\t\tup_read(&amp;vma-&gt;vm_mm-&gt;mmap_sem);\n\treturn ret;\n}",
 'void RunOneAveragePoolTest(const PoolParams&amp; params,\n                           const RuntimeShape&amp; input_shape,\n                           const int8* input_data,\n                           const RuntimeShape&amp; output_shape) {\n  const int buffer_size = output_shape.FlatSize();\n  std::vector&lt;int8&gt; optimized_averagePool_output(buffer_size);\n  std::vector&lt;int8&gt; reference_averagePool_output(buffer_size);\n\n  bool reference_success = reference_integer_ops::AveragePool(\n      params, input_shape, input_data, output_shape,\n      reference_averagePool_output.data());\n  bool optimized_success = optimized_integer_ops::AveragePool(\n      params, input_shape, input_data, output_shape,\n      optimized_averagePool_output.data());\n  EXPECT_TRUE(reference_success);\n  EXPECT_TRUE(optimized_success);\n\n  for (int i = 0; i &lt; buffer_size; i++) {\n    EXPECT_TRUE(reference_averagePool_output[i] ==\n                optimized_averagePool_output[i]);\n  }\n}',
 "GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_ChunkOffsetBox *stco;\n\tGF_SampleToChunkBox *stsc;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\tu32 i, k, *newOff, new_chunk_idx=0;\n\tu64 *newLarge;\n\ts32 insert_idx = -1;\n\n\tstbl = mdia-&gt;information-&gt;sampleTable;\n\tstsc = stbl-&gt;SampleToChunk;\n\n//\tif (stsc-&gt;w_lastSampleNumber + 1 &lt; sampleNumber ) return GF_BAD_PARAM;\n\tif (!nb_pack_samples)\n\t\tnb_pack_samples = 1;\n\n\tif (!stsc-&gt;nb_entries || (stsc-&gt;nb_entries + 2 &gt;= stsc-&gt;alloc_size)) {\n\t\tif (!stsc-&gt;alloc_size) stsc-&gt;alloc_size = 1;\n\t\tALLOC_INC(stsc-&gt;alloc_size);\n\t\tstsc-&gt;entries = gf_realloc(stsc-&gt;entries, sizeof(GF_StscEntry)*stsc-&gt;alloc_size);\n\t\tif (!stsc-&gt;entries) return GF_OUT_OF_MEM;\n\t\tmemset(&amp;stsc-&gt;entries[stsc-&gt;nb_entries], 0, sizeof(GF_StscEntry)*(stsc-&gt;alloc_size-stsc-&gt;nb_entries) );\n\t}\n\tif (sampleNumber == stsc-&gt;w_lastSampleNumber + 1) {\n\t\tent = &amp;stsc-&gt;entries[stsc-&gt;nb_entries];\n\t\tstsc-&gt;w_lastChunkNumber ++;\n\t\tent-&gt;firstChunk = stsc-&gt;w_lastChunkNumber;\n\t\tif (stsc-&gt;nb_entries) stsc-&gt;entries[stsc-&gt;nb_entries-1].nextChunk = stsc-&gt;w_lastChunkNumber;\n\n\t\tnew_chunk_idx = stsc-&gt;w_lastChunkNumber;\n\t\tstsc-&gt;w_lastSampleNumber = sampleNumber + nb_pack_samples-1;\n\t\tstsc-&gt;nb_entries += 1;\n\t} else {\n\t\tu32 cur_samp = 1;\n\t\tu32 samples_in_next_entry = 0;\n\t\tu32 next_entry_first_chunk = 1;\n\t\tfor (i=0; i&lt;stsc-&gt;nb_entries; i++) {\n\t\t\tu32 nb_chunks = 1;\n\t\t\tent = &amp;stsc-&gt;entries[i];\n\t\t\tif (i+1&lt;stsc-&gt;nb_entries) nb_chunks = stsc-&gt;entries[i+1].firstChunk - ent-&gt;firstChunk;\n\t\t\tfor (k=0; k&lt;nb_chunks; k++) {\n\t\t\t\tif ((cur_samp &lt;= sampleNumber) &amp;&amp; (ent-&gt;samplesPerChunk + cur_samp &gt; sampleNumber)) {\n\t\t\t\t\tinsert_idx = i;\n\t\t\t\t\t//stsc entry has samples before inserted sample, split\n\t\t\t\t\tif (sampleNumber&gt;cur_samp) {\n\t\t\t\t\t\tsamples_in_next_entry = ent-&gt;samplesPerChunk - (sampleNumber-cur_samp);\n\t\t\t\t\t\tent-&gt;samplesPerChunk = sampleNumber-cur_samp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_samp += ent-&gt;samplesPerChunk;\n\t\t\t\tnext_entry_first_chunk++;\n\t\t\t}\n\t\t\tif (insert_idx&gt;=0) break;\n\t\t}\n\t\t//we need to split the entry\n\t\tif (samples_in_next_entry) {\n\t\t\tmemmove(&amp;stsc-&gt;entries[insert_idx+3], &amp;stsc-&gt;entries[insert_idx+1], sizeof(GF_StscEntry)*(stsc-&gt;nb_entries - insert_idx - 1));\n\t\t\t//copy over original entry\n\t\t\tent = &amp;stsc-&gt;entries[insert_idx];\n\t\t\tstsc-&gt;entries[insert_idx+2] = *ent;\n\t\t\tstsc-&gt;entries[insert_idx+2].samplesPerChunk = samples_in_next_entry;\n\t\t\tstsc-&gt;entries[insert_idx+2].firstChunk = next_entry_first_chunk + 1;\n\n\t\t\t//setup new entry\n\t\t\tent = &amp;stsc-&gt;entries[insert_idx+1];\n\t\t\tent-&gt;firstChunk = next_entry_first_chunk;\n\n\t\t\tstsc-&gt;nb_entries += 2;\n\t\t} else {\n\t\t\tif (insert_idx&lt;0) {\n\t\t\t\tent = &amp;stsc-&gt;entries[stsc-&gt;nb_entries];\n\t\t\t\tinsert_idx = stsc-&gt;nb_entries;\n\t\t\t} else {\n\t\t\t\tmemmove(&amp;stsc-&gt;entries[insert_idx+1], &amp;stsc-&gt;entries[insert_idx], sizeof(GF_StscEntry)*(stsc-&gt;nb_entries+1-insert_idx));\n\t\t\t\tent = &amp;stsc-&gt;entries[insert_idx+1];\n\t\t\t}\n\n\t\t\tent-&gt;firstChunk = next_entry_first_chunk;\n\t\t\tstsc-&gt;nb_entries += 1;\n\t\t}\n\t\tnew_chunk_idx = next_entry_first_chunk;\n\t}\n\tent-&gt;isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0;\n\tent-&gt;sampleDescriptionIndex = StreamDescIndex;\n\tent-&gt;samplesPerChunk = nb_pack_samples;\n\tent-&gt;nextChunk = ent-&gt;firstChunk+1;\n\n\t//OK, now if we've inserted a chunk, update the sample to chunk info...\n\tif (sampleNumber + nb_pack_samples - 1 == stsc-&gt;w_lastSampleNumber) {\n\t\tif (stsc-&gt;nb_entries)\n\t\t\tstsc-&gt;entries[stsc-&gt;nb_entries-1].nextChunk = ent-&gt;firstChunk;\n\n\t\tstbl-&gt;SampleToChunk-&gt;currentIndex = stsc-&gt;nb_entries-1;\n\t\tstbl-&gt;SampleToChunk-&gt;firstSampleInCurrentChunk = sampleNumber;\n\t\t//write - edit mode: sample number = chunk number\n\t\tstbl-&gt;SampleToChunk-&gt;currentChunk = stsc-&gt;w_lastChunkNumber;\n\t\tstbl-&gt;SampleToChunk-&gt;ghostNumber = 1;\n\t} else {\n\t\t/*offset remaining entries*/\n\t\tfor (i = insert_idx+1; i&lt;stsc-&gt;nb_entries+1; i++) {\n\t\t\tstsc-&gt;entries[i].firstChunk++;\n\t\t\tif (i+1&lt;stsc-&gt;nb_entries)\n\t\t\t\tstsc-&gt;entries[i-1].nextChunk = stsc-&gt;entries[i].firstChunk;\n\t\t}\n\t}\n\n\t//add the offset to the chunk...\n\t//and we change our offset\n\tif (stbl-&gt;ChunkOffset-&gt;type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl-&gt;ChunkOffset;\n\t\t//if the new offset is a large one, we have to rewrite our table entry by entry (32-&gt;64 bit conv)...\n\t\tif (offset &gt; 0xFFFFFFFF) {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&amp;stbl-&gt;child_boxes, GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64-&gt;nb_entries = stco-&gt;nb_entries + 1;\n\t\t\tco64-&gt;alloc_size = co64-&gt;nb_entries;\n\t\t\tco64-&gt;offsets = (u64*)gf_malloc(sizeof(u64) * co64-&gt;nb_entries);\n\t\t\tif (!co64-&gt;offsets) return GF_OUT_OF_MEM;\n\t\t\tk = 0;\n\t\t\tfor (i=0; i&lt;stco-&gt;nb_entries; i++) {\n\t\t\t\tif (i + 1 == new_chunk_idx) {\n\t\t\t\t\tco64-&gt;offsets[i] = offset;\n\t\t\t\t\tk = 1;\n\t\t\t\t}\n\t\t\t\tco64-&gt;offsets[i+k] = (u64) stco-&gt;offsets[i];\n\t\t\t}\n\t\t\tif (!k) co64-&gt;offsets[co64-&gt;nb_entries - 1] = offset;\n\t\t\tgf_isom_box_del_parent(&amp;stbl-&gt;child_boxes, stbl-&gt;ChunkOffset);\n\t\t\tstbl-&gt;ChunkOffset = (GF_Box *) co64;\n\t\t} else {\n\t\t\t//no, we can use this one.\n\t\t\tif (new_chunk_idx &gt; stco-&gt;nb_entries) {\n\t\t\t\tif (!stco-&gt;alloc_size) stco-&gt;alloc_size = stco-&gt;nb_entries;\n\t\t\t\tif (stco-&gt;nb_entries == stco-&gt;alloc_size) {\n\t\t\t\t\tALLOC_INC(stco-&gt;alloc_size);\n\t\t\t\t\tstco-&gt;offsets = (u32*)gf_realloc(stco-&gt;offsets, sizeof(u32) * stco-&gt;alloc_size);\n\t\t\t\t\tif (!stco-&gt;offsets) return GF_OUT_OF_MEM;\n\t\t\t\t\tmemset(&amp;stco-&gt;offsets[stco-&gt;nb_entries], 0, sizeof(u32) * (stco-&gt;alloc_size-stco-&gt;nb_entries) );\n\t\t\t\t}\n\t\t\t\tstco-&gt;offsets[stco-&gt;nb_entries] = (u32) offset;\n\t\t\t\tstco-&gt;nb_entries += 1;\n\t\t\t} else {\n\t\t\t\t//nope. we're inserting\n\t\t\t\tnewOff = (u32*)gf_malloc(sizeof(u32) * (stco-&gt;nb_entries + 1));\n\t\t\t\tif (!newOff) return GF_OUT_OF_MEM;\n\t\t\t\tk=0;\n\t\t\t\tfor (i=0; i&lt;stco-&gt;nb_entries; i++) {\n\t\t\t\t\tif (i+1 == new_chunk_idx) {\n\t\t\t\t\t\tnewOff[i] = (u32) offset;\n\t\t\t\t\t\tk=1;\n\t\t\t\t\t}\n\t\t\t\t\tnewOff[i+k] = stco-&gt;offsets[i];\n\t\t\t\t}\n\t\t\t\tgf_free(stco-&gt;offsets);\n\t\t\t\tstco-&gt;offsets = newOff;\n\t\t\t\tstco-&gt;nb_entries ++;\n\t\t\t\tstco-&gt;alloc_size = stco-&gt;nb_entries;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t//use large offset...\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl-&gt;ChunkOffset;\n\t\tif (sampleNumber &gt; co64-&gt;nb_entries) {\n\t\t\tif (!co64-&gt;alloc_size) co64-&gt;alloc_size = co64-&gt;nb_entries;\n\t\t\tif (co64-&gt;nb_entries == co64-&gt;alloc_size) {\n\t\t\t\tALLOC_INC(co64-&gt;alloc_size);\n\t\t\t\tco64-&gt;offsets = (u64*)gf_realloc(co64-&gt;offsets, sizeof(u64) * co64-&gt;alloc_size);\n\t\t\t\tif (!co64-&gt;offsets) return GF_OUT_OF_MEM;\n\t\t\t\tmemset(&amp;co64-&gt;offsets[co64-&gt;nb_entries], 0, sizeof(u64) * (co64-&gt;alloc_size - co64-&gt;nb_entries) );\n\t\t\t}\n\t\t\tco64-&gt;offsets[co64-&gt;nb_entries] = offset;\n\t\t\tco64-&gt;nb_entries += 1;\n\t\t} else {\n\t\t\t//nope. we're inserting\n\t\t\tnewLarge = (u64*)gf_malloc(sizeof(u64) * (co64-&gt;nb_entries + 1));\n\t\t\tif (!newLarge) return GF_OUT_OF_MEM;\n\t\t\tk=0;\n\t\t\tfor (i=0; i&lt;co64-&gt;nb_entries; i++) {\n\t\t\t\tif (i+1 == new_chunk_idx) {\n\t\t\t\t\tnewLarge[i] = offset;\n\t\t\t\t\tk=1;\n\t\t\t\t}\n\t\t\t\tnewLarge[i+k] = co64-&gt;offsets[i];\n\t\t\t}\n\t\t\tgf_free(co64-&gt;offsets);\n\t\t\tco64-&gt;offsets = newLarge;\n\t\t\tco64-&gt;nb_entries++;\n\t\t\tco64-&gt;alloc_size++;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}",
 'int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\n\tdp-&gt;dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len &lt; sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin-&gt;sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin-&gt;sin_addr.s_addr;\n\tif (inet-&gt;opt != NULL &amp;&amp; inet-&gt;opt-&gt;srr) {\n\t\tif (daddr == 0)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet-&gt;opt-&gt;faddr;\n\t}\n\n\torig_sport = inet-&gt;inet_sport;\n\torig_dport = usin-&gt;sin_port;\n\trt = ip_route_connect(&amp;fl4, nexthop, inet-&gt;inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,\n\t\t\t      IPPROTO_DCCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (inet-&gt;opt == NULL || !inet-&gt;opt-&gt;srr)\n\t\tdaddr = rt-&gt;rt_dst;\n\n\tif (inet-&gt;inet_saddr == 0)\n\t\tinet-&gt;inet_saddr = rt-&gt;rt_src;\n\tinet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr;\n\n\tinet-&gt;inet_dport = usin-&gt;sin_port;\n\tinet-&gt;inet_daddr = daddr;\n\n\tinet_csk(sk)-&gt;icsk_ext_hdr_len = 0;\n\tif (inet-&gt;opt != NULL)\n\t\tinet_csk(sk)-&gt;icsk_ext_hdr_len = inet-&gt;opt-&gt;optlen;\n\t/*\n\t * Socket identity is still unknown (sport may be zero).\n\t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet_hash_connect(&amp;dccp_death_row, sk);\n\tif (err != 0)\n\t\tgoto failure;\n\n\trt = ip_route_newports(&amp;fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet-&gt;inet_sport, inet-&gt;inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t/* OK, now commit destination to socket.  */\n\tsk_setup_caps(sk, &amp;rt-&gt;dst);\n\n\tdp-&gt;dccps_iss = secure_dccp_sequence_number(inet-&gt;inet_saddr,\n\t\t\t\t\t\t    inet-&gt;inet_daddr,\n\t\t\t\t\t\t    inet-&gt;inet_sport,\n\t\t\t\t\t\t    inet-&gt;inet_dport);\n\tinet-&gt;inet_id = dp-&gt;dccps_iss ^ jiffies;\n\n\terr = dccp_connect(sk);\n\trt = NULL;\n\tif (err != 0)\n\t\tgoto failure;\nout:\n\treturn err;\nfailure:\n\t/*\n\t * This unhashes the socket and releases the local port, if necessary.\n\t */\n\tdccp_set_state(sk, DCCP_CLOSED);\n\tip_rt_put(rt);\n\tsk-&gt;sk_route_caps = 0;\n\tinet-&gt;inet_dport = 0;\n\tgoto out;\n}',
 'static void parse_cfg(int flags, int argc, const char **argv, cfg_t *cfg) {\n  int i;\n  memset(cfg, 0, sizeof(cfg_t));\n  cfg-&gt;debug_file = stderr;\n\n  for (i = 0; i &lt; argc; i++) {\n    if (strncmp(argv[i], "max_devices=", 12) == 0)\n      sscanf(argv[i], "max_devices=%u", &amp;cfg-&gt;max_devs);\n    if (strcmp(argv[i], "manual") == 0)\n      cfg-&gt;manual = 1;\n    if (strcmp(argv[i], "debug") == 0)\n      cfg-&gt;debug = 1;\n    if (strcmp(argv[i], "nouserok") == 0)\n      cfg-&gt;nouserok = 1;\n    if (strcmp(argv[i], "openasuser") == 0)\n      cfg-&gt;openasuser = 1;\n    if (strcmp(argv[i], "alwaysok") == 0)\n      cfg-&gt;alwaysok = 1;\n    if (strcmp(argv[i], "interactive") == 0)\n      cfg-&gt;interactive = 1;\n    if (strcmp(argv[i], "cue") == 0)\n      cfg-&gt;cue = 1;\n    if (strcmp(argv[i], "nodetect") == 0)\n      cfg-&gt;nodetect = 1;\n    if (strncmp(argv[i], "authfile=", 9) == 0)\n      cfg-&gt;auth_file = argv[i] + 9;\n    if (strncmp(argv[i], "authpending_file=", 17) == 0)\n      cfg-&gt;authpending_file = argv[i] + 17;\n    if (strncmp(argv[i], "origin=", 7) == 0)\n      cfg-&gt;origin = argv[i] + 7;\n    if (strncmp(argv[i], "appid=", 6) == 0)\n      cfg-&gt;appid = argv[i] + 6;\n    if (strncmp(argv[i], "prompt=", 7) == 0)\n      cfg-&gt;prompt = argv[i] + 7;\n    if (strncmp (argv[i], "debug_file=", 11) == 0) {\n      const char *filename = argv[i] + 11;\n      if(strncmp (filename, "stdout", 6) == 0) {\n        cfg-&gt;debug_file = stdout;\n      }\n      else if(strncmp (filename, "stderr", 6) == 0) {\n        cfg-&gt;debug_file = stderr;\n      }\n      else if( strncmp (filename, "syslog", 6) == 0) {\n        cfg-&gt;debug_file = (FILE *)-1;\n      }\n      else {\n        struct stat st;\n        FILE *file;\n        if(lstat(filename, &amp;st) == 0) {\n          if(S_ISREG(st.st_mode)) {\n            file = fopen(filename, "a");\n            if(file != NULL) {\n              cfg-&gt;debug_file = file;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (cfg-&gt;debug) {\n    D(cfg-&gt;debug_file, "called.");\n    D(cfg-&gt;debug_file, "flags %d argc %d", flags, argc);\n    for (i = 0; i &lt; argc; i++) {\n      D(cfg-&gt;debug_file, "argv[%d]=%s", i, argv[i]);\n    }\n    D(cfg-&gt;debug_file, "max_devices=%d", cfg-&gt;max_devs);\n    D(cfg-&gt;debug_file, "debug=%d", cfg-&gt;debug);\n    D(cfg-&gt;debug_file, "interactive=%d", cfg-&gt;interactive);\n    D(cfg-&gt;debug_file, "cue=%d", cfg-&gt;cue);\n    D(cfg-&gt;debug_file, "nodetect=%d", cfg-&gt;nodetect);\n    D(cfg-&gt;debug_file, "manual=%d", cfg-&gt;manual);\n    D(cfg-&gt;debug_file, "nouserok=%d", cfg-&gt;nouserok);\n    D(cfg-&gt;debug_file, "openasuser=%d", cfg-&gt;openasuser);\n    D(cfg-&gt;debug_file, "alwaysok=%d", cfg-&gt;alwaysok);\n    D(cfg-&gt;debug_file, "authfile=%s", cfg-&gt;auth_file ? cfg-&gt;auth_file : "(null)");\n    D(cfg-&gt;debug_file, "authpending_file=%s", cfg-&gt;authpending_file ? cfg-&gt;authpending_file : "(null)");\n    D(cfg-&gt;debug_file, "origin=%s", cfg-&gt;origin ? cfg-&gt;origin : "(null)");\n    D(cfg-&gt;debug_file, "appid=%s", cfg-&gt;appid ? cfg-&gt;appid : "(null)");\n    D(cfg-&gt;debug_file, "prompt=%s", cfg-&gt;prompt ? cfg-&gt;prompt : "(null)");\n  }\n}',
 'uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return NULL;\n\n\tuint32_t *MP4buffer = NULL;\n\tif (index &lt; mp4-&gt;indexcount &amp;&amp; mp4-&gt;mediafp)\n\t{\n\t\tMP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4-&gt;metasizes[index]);\n\n\t\tif (MP4buffer)\n\t\t{\n\t\t\tLONGSEEK(mp4-&gt;mediafp, mp4-&gt;metaoffsets[index], SEEK_SET);\n\t\t\tfread(MP4buffer, 1, mp4-&gt;metasizes[index], mp4-&gt;mediafp);\n\t\t\treturn MP4buffer;\n\t\t}\n\t}\n\treturn NULL;\n}',
 '  static void Launch(OpKernelContext* context, const Tensor&amp; in_x,\n                     const Tensor&amp; in_y, bool adjoint, bool lower,\n                     const MatMulBCast&amp; bcast, Tensor* out) {\n    // Number of banded matrix triangular solves i.e. size of the batch.\n    const int64 batch_size = bcast.output_batch_size();\n    const int64 cost_per_unit =\n        in_x.dim_size(1) * in_x.dim_size(2) * in_y.dim_size(2);\n    auto worker_threads = *(context-&gt;device()-&gt;tensorflow_cpu_worker_threads());\n\n    using Matrix =\n        Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;;\n    using ConstMatrixMap = Eigen::Map&lt;const Matrix&gt;;\n    using RealScalar = typename Eigen::NumTraits&lt;Scalar&gt;::Real;\n    // Check diagonal before doing any solves. This is the first row in the\n    // lower case and else is the last row.\n    auto matrix = ConstMatrixMap(in_x.flat&lt;Scalar&gt;().data(), in_x.dim_size(1),\n                                 in_x.dim_size(2));\n    RealScalar min_abs_pivot;\n    if (lower) {\n      min_abs_pivot = matrix.row(0).cwiseAbs().minCoeff();\n    } else {\n      min_abs_pivot = matrix.row(in_x.dim_size(1) - 1).cwiseAbs().minCoeff();\n    }\n    OP_REQUIRES(context, min_abs_pivot &gt; RealScalar(0),\n                errors::InvalidArgument("Input matrix is not invertible."));\n\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          cost_per_unit,\n          [&amp;in_x, &amp;in_y, adjoint, lower, &amp;bcast, out](int start, int limit) {\n            SequentialBandedTriangularSolveKernel&lt;Scalar&gt;::Run(\n                in_x, in_y, lower, adjoint, bcast, out, start, limit);\n          });\n  }',
 '  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant&amp; out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      // Unsupported, malformed, or trailing garbage. Release entire stack.\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }',
 'pci_emul_alloc_resource(uint64_t *baseptr, uint64_t limit, uint64_t size,\n\t\t\tuint64_t *addr)\n{\n\tuint64_t base;\n\n\tassert((size &amp; (size - 1)) == 0);\t/* must be a power of 2 */\n\n\tbase = roundup2(*baseptr, size);\n\n\tif (base + size &lt;= limit) {\n\t\t*addr = base;\n\t\t*baseptr = base + size;\n\t\treturn 0;\n\t} else\n\t\treturn -1;\n}',
 'static int __mkroute_input(struct sk_buff *skb,\n\t\t\t   const struct fib_result *res,\n\t\t\t   struct in_device *in_dev,\n\t\t\t   __be32 daddr, __be32 saddr, u32 tos)\n{\n\tstruct fib_nh_exception *fnhe;\n\tstruct rtable *rth;\n\tint err;\n\tstruct in_device *out_dev;\n\tunsigned int flags = 0;\n\tbool do_cache;\n\tu32 itag = 0;\n\n\t/* get a working reference to the output device */\n\tout_dev = __in_dev_get_rcu(FIB_RES_DEV(*res));\n\tif (out_dev == NULL) {\n\t\tnet_crit_ratelimited("Bug in ip_route_input_slow(). Please report.\\n");\n\t\treturn -EINVAL;\n\t}\n\n\terr = fib_validate_source(skb, saddr, daddr, tos, FIB_RES_OIF(*res),\n\t\t\t\t  in_dev-&gt;dev, in_dev, &amp;itag);\n\tif (err &lt; 0) {\n\t\tip_handle_martian_source(in_dev-&gt;dev, in_dev, skb, daddr,\n\t\t\t\t\t saddr);\n\n\t\tgoto cleanup;\n\t}\n\n\tdo_cache = res-&gt;fi &amp;&amp; !itag;\n\tif (out_dev == in_dev &amp;&amp; err &amp;&amp; IN_DEV_TX_REDIRECTS(out_dev) &amp;&amp;\n\t    skb-&gt;protocol == htons(ETH_P_IP) &amp;&amp;\n\t    (IN_DEV_SHARED_MEDIA(out_dev) ||\n\t     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))\n\t\tIPCB(skb)-&gt;flags |= IPSKB_DOREDIRECT;\n\n\tif (skb-&gt;protocol != htons(ETH_P_IP)) {\n\t\t/* Not IP (i.e. ARP). Do not create route, if it is\n\t\t * invalid for proxy arp. DNAT routes are always valid.\n\t\t *\n\t\t * Proxy arp feature have been extended to allow, ARP\n\t\t * replies back to the same interface, to support\n\t\t * Private VLAN switch technologies. See arp.c.\n\t\t */\n\t\tif (out_dev == in_dev &amp;&amp;\n\t\t    IN_DEV_PROXY_ARP_PVLAN(in_dev) == 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tfnhe = find_exception(&amp;FIB_RES_NH(*res), daddr);\n\tif (do_cache) {\n\t\tif (fnhe != NULL)\n\t\t\trth = rcu_dereference(fnhe-&gt;fnhe_rth_input);\n\t\telse\n\t\t\trth = rcu_dereference(FIB_RES_NH(*res).nh_rth_input);\n\n\t\tif (rt_cache_valid(rth)) {\n\t\t\tskb_dst_set_noref(skb, &amp;rth-&gt;dst);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trth = rt_dst_alloc(out_dev-&gt;dev,\n\t\t\t   IN_DEV_CONF_GET(in_dev, NOPOLICY),\n\t\t\t   IN_DEV_CONF_GET(out_dev, NOXFRM), do_cache);\n\tif (!rth) {\n\t\terr = -ENOBUFS;\n\t\tgoto cleanup;\n\t}\n\n\trth-&gt;rt_genid = rt_genid_ipv4(dev_net(rth-&gt;dst.dev));\n\trth-&gt;rt_flags = flags;\n\trth-&gt;rt_type = res-&gt;type;\n\trth-&gt;rt_is_input = 1;\n\trth-&gt;rt_iif \t= 0;\n\trth-&gt;rt_pmtu\t= 0;\n\trth-&gt;rt_gateway\t= 0;\n\trth-&gt;rt_uses_gateway = 0;\n\tINIT_LIST_HEAD(&amp;rth-&gt;rt_uncached);\n\tRT_CACHE_STAT_INC(in_slow_tot);\n\n\trth-&gt;dst.input = ip_forward;\n\trth-&gt;dst.output = ip_output;\n\n\trt_set_nexthop(rth, daddr, res, fnhe, res-&gt;fi, res-&gt;type, itag);\n\tskb_dst_set(skb, &amp;rth-&gt;dst);\nout:\n\terr = 0;\n cleanup:\n\treturn err;\n}',
 'void fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)\n{\n\tstruct in_device *in_dev = ifa-&gt;ifa_dev;\n\tstruct net_device *dev = in_dev-&gt;dev;\n\tstruct in_ifaddr *ifa1;\n\tstruct in_ifaddr *prim = ifa, *prim1 = NULL;\n\t__be32 brd = ifa-&gt;ifa_address | ~ifa-&gt;ifa_mask;\n\t__be32 any = ifa-&gt;ifa_address &amp; ifa-&gt;ifa_mask;\n#define LOCAL_OK\t1\n#define BRD_OK\t\t2\n#define BRD0_OK\t\t4\n#define BRD1_OK\t\t8\n\tunsigned int ok = 0;\n\tint subnet = 0;\t\t/* Primary network */\n\tint gone = 1;\t\t/* Address is missing */\n\tint same_prefsrc = 0;\t/* Another primary with same IP */\n\n\tif (ifa-&gt;ifa_flags &amp; IFA_F_SECONDARY) {\n\t\tprim = inet_ifa_byprefix(in_dev, any, ifa-&gt;ifa_mask);\n\t\tif (!prim) {\n\t\t\tpr_warn("%s: bug: prim == NULL\\n", __func__);\n\t\t\treturn;\n\t\t}\n\t\tif (iprim &amp;&amp; iprim != prim) {\n\t\t\tpr_warn("%s: bug: iprim != prim\\n", __func__);\n\t\t\treturn;\n\t\t}\n\t} else if (!ipv4_is_zeronet(any) &amp;&amp;\n\t\t   (any != ifa-&gt;ifa_local || ifa-&gt;ifa_prefixlen &lt; 32)) {\n\t\tif (!(ifa-&gt;ifa_flags &amp; IFA_F_NOPREFIXROUTE))\n\t\t\tfib_magic(RTM_DELROUTE,\n\t\t\t\t  dev-&gt;flags &amp; IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\n\t\t\t\t  any, ifa-&gt;ifa_prefixlen, prim);\n\t\tsubnet = 1;\n\t}\n\n\tif (in_dev-&gt;dead)\n\t\tgoto no_promotions;\n\n\t/* Deletion is more complicated than add.\n\t * We should take care of not to delete too much :-)\n\t *\n\t * Scan address list to be sure that addresses are really gone.\n\t */\n\n\tfor (ifa1 = in_dev-&gt;ifa_list; ifa1; ifa1 = ifa1-&gt;ifa_next) {\n\t\tif (ifa1 == ifa) {\n\t\t\t/* promotion, keep the IP */\n\t\t\tgone = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Ignore IFAs from our subnet */\n\t\tif (iprim &amp;&amp; ifa1-&gt;ifa_mask == iprim-&gt;ifa_mask &amp;&amp;\n\t\t    inet_ifa_match(ifa1-&gt;ifa_address, iprim))\n\t\t\tcontinue;\n\n\t\t/* Ignore ifa1 if it uses different primary IP (prefsrc) */\n\t\tif (ifa1-&gt;ifa_flags &amp; IFA_F_SECONDARY) {\n\t\t\t/* Another address from our subnet? */\n\t\t\tif (ifa1-&gt;ifa_mask == prim-&gt;ifa_mask &amp;&amp;\n\t\t\t    inet_ifa_match(ifa1-&gt;ifa_address, prim))\n\t\t\t\tprim1 = prim;\n\t\t\telse {\n\t\t\t\t/* We reached the secondaries, so\n\t\t\t\t * same_prefsrc should be determined.\n\t\t\t\t */\n\t\t\t\tif (!same_prefsrc)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Search new prim1 if ifa1 is not\n\t\t\t\t * using the current prim1\n\t\t\t\t */\n\t\t\t\tif (!prim1 ||\n\t\t\t\t    ifa1-&gt;ifa_mask != prim1-&gt;ifa_mask ||\n\t\t\t\t    !inet_ifa_match(ifa1-&gt;ifa_address, prim1))\n\t\t\t\t\tprim1 = inet_ifa_byprefix(in_dev,\n\t\t\t\t\t\t\tifa1-&gt;ifa_address,\n\t\t\t\t\t\t\tifa1-&gt;ifa_mask);\n\t\t\t\tif (!prim1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (prim1-&gt;ifa_local != prim-&gt;ifa_local)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (prim-&gt;ifa_local != ifa1-&gt;ifa_local)\n\t\t\t\tcontinue;\n\t\t\tprim1 = ifa1;\n\t\t\tif (prim != prim1)\n\t\t\t\tsame_prefsrc = 1;\n\t\t}\n\t\tif (ifa-&gt;ifa_local == ifa1-&gt;ifa_local)\n\t\t\tok |= LOCAL_OK;\n\t\tif (ifa-&gt;ifa_broadcast == ifa1-&gt;ifa_broadcast)\n\t\t\tok |= BRD_OK;\n\t\tif (brd == ifa1-&gt;ifa_broadcast)\n\t\t\tok |= BRD1_OK;\n\t\tif (any == ifa1-&gt;ifa_broadcast)\n\t\t\tok |= BRD0_OK;\n\t\t/* primary has network specific broadcasts */\n\t\tif (prim1 == ifa1 &amp;&amp; ifa1-&gt;ifa_prefixlen &lt; 31) {\n\t\t\t__be32 brd1 = ifa1-&gt;ifa_address | ~ifa1-&gt;ifa_mask;\n\t\t\t__be32 any1 = ifa1-&gt;ifa_address &amp; ifa1-&gt;ifa_mask;\n\n\t\t\tif (!ipv4_is_zeronet(any1)) {\n\t\t\t\tif (ifa-&gt;ifa_broadcast == brd1 ||\n\t\t\t\t    ifa-&gt;ifa_broadcast == any1)\n\t\t\t\t\tok |= BRD_OK;\n\t\t\t\tif (brd == brd1 || brd == any1)\n\t\t\t\t\tok |= BRD1_OK;\n\t\t\t\tif (any == brd1 || any == any1)\n\t\t\t\t\tok |= BRD0_OK;\n\t\t\t}\n\t\t}\n\t}\n\nno_promotions:\n\tif (!(ok &amp; BRD_OK))\n\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, ifa-&gt;ifa_broadcast, 32, prim);\n\tif (subnet &amp;&amp; ifa-&gt;ifa_prefixlen &lt; 31) {\n\t\tif (!(ok &amp; BRD1_OK))\n\t\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, brd, 32, prim);\n\t\tif (!(ok &amp; BRD0_OK))\n\t\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, any, 32, prim);\n\t}\n\tif (!(ok &amp; LOCAL_OK)) {\n\t\tunsigned int addr_type;\n\n\t\tfib_magic(RTM_DELROUTE, RTN_LOCAL, ifa-&gt;ifa_local, 32, prim);\n\n\t\t/* Check, that this local address finally disappeared. */\n\t\taddr_type = inet_addr_type_dev_table(dev_net(dev), dev,\n\t\t\t\t\t\t     ifa-&gt;ifa_local);\n\t\tif (gone &amp;&amp; addr_type != RTN_LOCAL) {\n\t\t\t/* And the last, but not the least thing.\n\t\t\t * We must flush stray FIB entries.\n\t\t\t *\n\t\t\t * First of all, we scan fib_info list searching\n\t\t\t * for stray nexthop entries, then ignite fib_flush.\n\t\t\t */\n\t\t\tif (fib_sync_down_addr(dev_net(dev), ifa-&gt;ifa_local))\n\t\t\t\tfib_flush(dev_net(dev));\n\t\t}\n\t}\n#undef LOCAL_OK\n#undef BRD_OK\n#undef BRD0_OK\n#undef BRD1_OK\n}',
 'static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &amp;ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  int n = 0;  /* number of results */\n  defaultoptions(&amp;h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &amp;fmt);\n    pos += gettoalign(pos, &amp;h, opt, size);\n    luaL_argcheck(L, pos+size &lt;= ld, 2, "data string too short");\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, "too many results");\n    switch (opt) {\n      case \'b\': case \'B\': case \'h\': case \'H\':\n      case \'l\': case \'L\': case \'T\': case \'i\':  case \'I\': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case \'x\': {\n        break;\n      }\n      case \'f\': {\n        float f;\n        memcpy(&amp;f, data+pos, size);\n        correctbytes((char *)&amp;f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case \'d\': {\n        double d;\n        memcpy(&amp;d, data+pos, size);\n        correctbytes((char *)&amp;d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case \'c\': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, "format \'c0\' needs a previous size");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size &lt;= ld &amp;&amp; pos &lt;= ld - size,\n                           2, "data string too short");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case \'s\': {\n        const char *e = (const char *)memchr(data+pos, \'\\0\', ld - pos);\n        if (e == NULL)\n          luaL_error(L, "unfinished string in data");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &amp;fmt, &amp;h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  /* next position */\n  return n + 1;\n}',
 'int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}',
 'static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tint fault, sig, code;\n\tunsigned long vm_flags = VM_READ | VM_WRITE | VM_EXEC;\n\tunsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\n\n\ttsk = current;\n\tmm  = tsk-&gt;mm;\n\n\t/* Enable interrupts if they were enabled in the parent context. */\n\tif (interrupts_enabled(regs))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * If we\'re in an interrupt or have no user context, we must not take\n\t * the fault.\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\tif (user_mode(regs))\n\t\tmm_flags |= FAULT_FLAG_USER;\n\n\tif (esr &amp; ESR_LNX_EXEC) {\n\t\tvm_flags = VM_EXEC;\n\t} else if ((esr &amp; ESR_EL1_WRITE) &amp;&amp; !(esr &amp; ESR_EL1_CM)) {\n\t\tvm_flags = VM_WRITE;\n\t\tmm_flags |= FAULT_FLAG_WRITE;\n\t}\n\n\t/*\n\t * As per x86, we may deadlock here. However, since the kernel only\n\t * validly references user space from well defined areas of the code,\n\t * we can bug out early if this is from code which shouldn\'t.\n\t */\n\tif (!down_read_trylock(&amp;mm-&gt;mmap_sem)) {\n\t\tif (!user_mode(regs) &amp;&amp; !search_exception_tables(regs-&gt;pc))\n\t\t\tgoto no_context;\nretry:\n\t\tdown_read(&amp;mm-&gt;mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in which\n\t\t * case, we\'ll have missed the might_sleep() from down_read().\n\t\t */\n\t\tmight_sleep();\n#ifdef CONFIG_DEBUG_VM\n\t\tif (!user_mode(regs) &amp;&amp; !search_exception_tables(regs-&gt;pc))\n\t\t\tgoto no_context;\n#endif\n\t}\n\n\tfault = __do_page_fault(mm, addr, mm_flags, vm_flags, tsk);\n\n\t/*\n\t * If we need to retry but a fatal signal is pending, handle the\n\t * signal first. We do not need to release the mmap_sem because it\n\t * would already be released in __lock_page_or_retry in mm/filemap.c.\n\t */\n\tif ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current))\n\t\treturn 0;\n\n\t/*\n\t * Major/minor page fault accounting is only done on the initial\n\t * attempt. If we go through a retry, it is extremely likely that the\n\t * page will be found in page cache at that point.\n\t */\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, addr);\n\tif (mm_flags &amp; FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault &amp; VM_FAULT_MAJOR) {\n\t\t\ttsk-&gt;maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs,\n\t\t\t\t      addr);\n\t\t} else {\n\t\t\ttsk-&gt;min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs,\n\t\t\t\t      addr);\n\t\t}\n\t\tif (fault &amp; VM_FAULT_RETRY) {\n\t\t\t/*\n\t\t\t * Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk of\n\t\t\t * starvation.\n\t\t\t */\n\t\t\tmm_flags &amp;= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tup_read(&amp;mm-&gt;mmap_sem);\n\n\t/*\n\t * Handle the "normal" case first - VM_FAULT_MAJOR / VM_FAULT_MINOR\n\t */\n\tif (likely(!(fault &amp; (VM_FAULT_ERROR | VM_FAULT_BADMAP |\n\t\t\t      VM_FAULT_BADACCESS))))\n\t\treturn 0;\n\n\t/*\n\t * If we are in kernel mode at this point, we have no context to\n\t * handle this fault with.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\n\tif (fault &amp; VM_FAULT_OOM) {\n\t\t/*\n\t\t * We ran out of memory, call the OOM killer, and return to\n\t\t * userspace (which will retry the fault, or kill us if we got\n\t\t * oom-killed).\n\t\t */\n\t\tpagefault_out_of_memory();\n\t\treturn 0;\n\t}\n\n\tif (fault &amp; VM_FAULT_SIGBUS) {\n\t\t/*\n\t\t * We had some memory, but were unable to successfully fix up\n\t\t * this page fault.\n\t\t */\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRERR;\n\t} else {\n\t\t/*\n\t\t * Something tried to access memory that isn\'t in our memory\n\t\t * map.\n\t\t */\n\t\tsig = SIGSEGV;\n\t\tcode = fault == VM_FAULT_BADACCESS ?\n\t\t\tSEGV_ACCERR : SEGV_MAPERR;\n\t}\n\n\t__do_user_fault(tsk, addr, esr, sig, code, regs);\n\treturn 0;\n\nno_context:\n\t__do_kernel_fault(mm, addr, esr, regs);\n\treturn 0;\n}',
 'test_make_inputs (xd3_stream *stream, xoff_t *ss_out, xoff_t *ts_out)\n{\n  usize_t ts = (mt_random (&amp;static_mtrand) % TEST_FILE_MEAN) +\n    TEST_FILE_MEAN / 2;\n  usize_t ss = (mt_random (&amp;static_mtrand) % TEST_FILE_MEAN) +\n    TEST_FILE_MEAN / 2;\n  uint8_t *buf = (uint8_t*) malloc (ts + ss), *sbuf = buf, *tbuf = buf + ss;\n  usize_t sadd = 0, sadd_max = (usize_t)(ss * TEST_ADD_RATIO);\n  FILE  *tf = NULL, *sf = NULL;\n  usize_t i, j;\n  int ret;\n\n  if (buf == NULL) { return ENOMEM; }\n\n  if ((tf = fopen (TEST_TARGET_FILE, "w")) == NULL ||\n      (ss_out != NULL &amp;&amp; (sf = fopen (TEST_SOURCE_FILE, "w")) == NULL))\n    {\n      stream-&gt;msg = "write failed";\n      ret = get_errno ();\n      goto failure;\n    }\n\n  if (ss_out != NULL)\n    {\n      for (i = 0; i &lt; ss; )\n\t{\n\t  sbuf[i++] = (uint8_t) mt_random (&amp;static_mtrand);\n\t}\n    }\n\n  /* Then modify the data to produce copies, everything not copied is\n   * an add.  The following logic produces the TEST_ADD_RATIO.  The\n   * variable SADD contains the number of adds so far, which should\n   * not exceed SADD_MAX. */\n\n  /* XPR(NT "ss = %u ts = %u\\n", ss, ts); */\n  for (i = 0; i &lt; ts; )\n    {\n      usize_t left = ts - i;\n      usize_t next = mt_exp_rand ((uint32_t) TEST_ADD_MEAN,\n\t\t\t\t  (uint32_t) TEST_ADD_MAX);\n      usize_t add_left = sadd_max - sadd;\n      double add_prob = (left == 0) ? 0 : (add_left / (double) left);\n      int do_copy;\n\n      next = min (left, next);\n      do_copy = (next &gt; add_left ||\n\t\t (mt_random (&amp;static_mtrand) / \\\n\t\t  (double)USIZE_T_MAX) &gt;= add_prob);\n\n      if (ss_out == NULL)\n\t{\n\t  do_copy &amp;= (i &gt; 0);\n\t}\n      else\n\t{\n\t  do_copy &amp;= (ss - next) &gt; 0;\n\t}\n\n      if (do_copy)\n\t{\n\t  /* Copy */\n\t  size_t offset = mt_random (&amp;static_mtrand) % ((ss_out == NULL) ?\n\t\t\t\t\t\t\ti :\n\t\t\t\t\t\t\t(ss - next));\n\t  /* XPR(NT "[%u] copy %u at %u ", i, next, offset); */\n\n\t  for (j = 0; j &lt; next; j += 1)\n\t    {\n\t      char c = ((ss_out == NULL) ? tbuf : sbuf)[offset + j];\n\t      /* XPR(NT "%x%x", (c &gt;&gt; 4) &amp; 0xf, c &amp; 0xf); */\n\t      tbuf[i++] = c;\n\t    }\n\t  /* XPR(NT "\\n"); */\n\t}\n      else\n\t{\n\t  /* Add */\n\t  /* XPR(NT "[%u] add %u ", i, next); */\n\t  for (j = 0; j &lt; next; j += 1)\n\t    {\n\t      char c = (char) mt_random (&amp;static_mtrand);\n\t      /* XPR(NT "%x%x", (c &gt;&gt; 4) &amp; 0xf, c &amp; 0xf); */\n\t      tbuf[i++] = c;\n\t    }\n\t  /* XPR(NT "\\n"); */\n\t  sadd += next;\n\t}\n    }\n\n  /* XPR(NT "sadd = %u max = %u\\n", sadd, sadd_max); */\n\n  if ((fwrite (tbuf, 1, ts, tf) != ts) ||\n      (ss_out != NULL &amp;&amp; (fwrite (sbuf, 1, ss, sf) != ss)))\n    {\n      stream-&gt;msg = "write failed";\n      ret = get_errno ();\n      goto failure;\n    }\n\n  if ((ret = fclose (tf)) || (ss_out != NULL &amp;&amp; (ret = fclose (sf))))\n    {\n      stream-&gt;msg = "close failed";\n      ret = get_errno ();\n      goto failure;\n    }\n\n  if (ts_out) { (*ts_out) = ts; }\n  if (ss_out) { (*ss_out) = ss; }\n\n failure:\n  free (buf);\n  return ret;\n}',
 'TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,\n                                       TfLiteNode* node) {\n  OpData* data = reinterpret_cast&lt;OpData*&gt;(node-&gt;user_data);\n\n  // Make sure that the input is in uint8_t with at least 1 data entry.\n  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);\n  if (input-&gt;type != kTfLiteUInt8) return kTfLiteError;\n  if (NumElements(input-&gt;dims) == 0) return kTfLiteError;\n\n  // Allocate a temporary buffer with the same size of input for sorting.\n  TF_LITE_ENSURE_STATUS(context-&gt;RequestScratchBufferInArena(\n      context, sizeof(uint8_t) * NumElements(input-&gt;dims),\n      &amp;data-&gt;sorting_buffer));\n  // We can interleave scratch / persistent buffer allocation.\n  data-&gt;invoke_count = reinterpret_cast&lt;int*&gt;(\n      context-&gt;AllocatePersistentBuffer(context, sizeof(int)));\n  *data-&gt;invoke_count = 0;\n\n  return kTfLiteOk;\n}',
 'size_t ZlibInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n{\n  if (itemSize &gt; bufSize)\n    throw Exception("ZlibInStream overrun: max itemSize exceeded");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while ((size_t)(end - ptr) &lt; itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n\n  if (itemSize * nItems &gt; (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}',
 '  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    // Create a new SparseTensorSliceDatasetOp::Dataset, insert it in\n    // the step container, and return it as the output.\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx-&gt;input("indices", &amp;indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx-&gt;input("values", &amp;values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx-&gt;input("dense_shape", &amp;dense_shape));\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices-&gt;shape()),\n                errors::InvalidArgument("Input indices must be a matrix. Got: ",\n                                        indices-&gt;shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values-&gt;shape()),\n                errors::InvalidArgument("Input values must be a vector. Got: ",\n                                        values-&gt;shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape-&gt;shape()),\n                errors::InvalidArgument("Input shape must be a vector. Got: ",\n                                        dense_shape-&gt;shape().DebugString()));\n    OP_REQUIRES(\n        ctx, values-&gt;shape().dim_size(0) == indices-&gt;shape().dim_size(0),\n        errors::InvalidArgument(\n            "Number of values must match first dimension of indices. ", "Got ",\n            values-&gt;shape().dim_size(0),\n            " values, indices shape: ", indices-&gt;shape().DebugString()));\n    OP_REQUIRES(\n        ctx, dense_shape-&gt;shape().dim_size(0) == indices-&gt;shape().dim_size(1),\n        errors::InvalidArgument(\n            "Number of dimensions must match second dimension of indices. ",\n            "Got ", dense_shape-&gt;shape().dim_size(0),\n            " dimensions, indices shape: ", indices-&gt;shape().DebugString()));\n    OP_REQUIRES(ctx, dense_shape-&gt;NumElements() &gt; 0,\n                errors::InvalidArgument(\n                    "The shape argument requires at least one element."));\n\n    // We currently ensure that `sparse_tensor` is ordered in the\n    // batch dimension.\n    // TODO(mrry): Investigate ways to avoid this unconditional check\n    // if we can be sure that the sparse tensor was produced in an\n    // appropriate order (e.g. by `tf.parse_example()` or a Dataset\n    // that batches elements into rows of a SparseTensor).\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i &lt; indices-&gt;dim_size(0); ++i) {\n      int64_t next_batch_index = indices-&gt;matrix&lt;int64_t&gt;()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index &gt;= previous_batch_index,\n          errors::Unimplemented("The SparseTensor must be ordered in the batch "\n                                "dimension; handling arbitrarily ordered input "\n                                "is not currently supported."));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector&lt;int64_t, 8&gt; std_order(dense_shape-&gt;NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape-&gt;vec&lt;int64_t&gt;()),\n                 std_order, &amp;tensor));\n    *output = new Dataset&lt;T&gt;(ctx, std::move(tensor));\n  }',
 'static EjsObj *http_info(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)\n{\n    EjsObj  *obj;\n    char    *key, *next, *value;\n\n    if (hp-&gt;conn &amp;&amp; hp-&gt;conn-&gt;sock) {\n        obj = ejsCreateEmptyPot(ejs);\n        for (key = stok(mprGetSocketState(hp-&gt;conn-&gt;sock), ",", &amp;next); key; key = stok(NULL, ",", &amp;next)) {\n            stok(key, "=", &amp;value);\n            ejsSetPropertyByName(ejs, obj, EN(key), ejsCreateStringFromAsc(ejs, value));\n        }\n        return obj;\n    }\n    return ESV(null);\n}',
 'static int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n}',
 'mark_desktop_file_executable_task_done (GObject      *source_object,\n                                        GAsyncResult *res,\n                                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n\n    g_object_unref (job-&gt;file);\n\n    if (job-&gt;done_callback)\n    {\n        job-&gt;done_callback (!job_aborted ((CommonJob *) job),\n                            job-&gt;done_callback_data);\n    }\n\n    finalize_common ((CommonJob *) job);\n}',
 'static CYTHON_INLINE PyObject* __Pyx_decode_c_string(\n         const char* cstring, Py_ssize_t start, Py_ssize_t stop,\n         const char* encoding, const char* errors,\n         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {\n    Py_ssize_t length;\n    if (unlikely((start &lt; 0) | (stop &lt; 0))) {\n        size_t slen = strlen(cstring);\n        if (unlikely(slen &gt; (size_t) PY_SSIZE_T_MAX)) {\n            PyErr_SetString(PyExc_OverflowError,\n                            "c-string too long to convert to Python");\n            return NULL;\n        }\n        length = (Py_ssize_t) slen;\n        if (start &lt; 0) {\n            start += length;\n            if (start &lt; 0)\n                start = 0;\n        }\n        if (stop &lt; 0)\n            stop += length;\n    }\n    if (unlikely(stop &lt;= start))\n        return PyUnicode_FromUnicode(NULL, 0);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {\n        return PyUnicode_Decode(cstring, length, encoding, errors);\n    }\n}',
 'int i2400m_op_rfkill_sw_toggle(struct wimax_dev *wimax_dev,\n\t\t\t       enum wimax_rf_state state)\n{\n\tint result;\n\tstruct i2400m *i2400m = wimax_dev_to_i2400m(wimax_dev);\n\tstruct device *dev = i2400m_dev(i2400m);\n\tstruct sk_buff *ack_skb;\n\tstruct {\n\t\tstruct i2400m_l3l4_hdr hdr;\n\t\tstruct i2400m_tlv_rf_operation sw_rf;\n\t} __packed *cmd;\n\tchar strerr[32];\n\n\td_fnstart(4, dev, "(wimax_dev %p state %d)\\n", wimax_dev, state);\n\n\tresult = -ENOMEM;\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\tgoto error_alloc;\n\tcmd-&gt;hdr.type = cpu_to_le16(I2400M_MT_CMD_RF_CONTROL);\n\tcmd-&gt;hdr.length = sizeof(cmd-&gt;sw_rf);\n\tcmd-&gt;hdr.version = cpu_to_le16(I2400M_L3L4_VERSION);\n\tcmd-&gt;sw_rf.hdr.type = cpu_to_le16(I2400M_TLV_RF_OPERATION);\n\tcmd-&gt;sw_rf.hdr.length = cpu_to_le16(sizeof(cmd-&gt;sw_rf.status));\n\tswitch (state) {\n\tcase WIMAX_RF_OFF:\t/* RFKILL ON, radio OFF */\n\t\tcmd-&gt;sw_rf.status = cpu_to_le32(2);\n\t\tbreak;\n\tcase WIMAX_RF_ON:\t/* RFKILL OFF, radio ON */\n\t\tcmd-&gt;sw_rf.status = cpu_to_le32(1);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tack_skb = i2400m_msg_to_dev(i2400m, cmd, sizeof(*cmd));\n\tresult = PTR_ERR(ack_skb);\n\tif (IS_ERR(ack_skb)) {\n\t\tdev_err(dev, "Failed to issue \'RF Control\' command: %d\\n",\n\t\t\tresult);\n\t\tgoto error_msg_to_dev;\n\t}\n\tresult = i2400m_msg_check_status(wimax_msg_data(ack_skb),\n\t\t\t\t\t strerr, sizeof(strerr));\n\tif (result &lt; 0) {\n\t\tdev_err(dev, "\'RF Control\' (0x%04x) command failed: %d - %s\\n",\n\t\t\tI2400M_MT_CMD_RF_CONTROL, result, strerr);\n\t\tgoto error_cmd;\n\t}\n\n\t/* Now we wait for the state to change to RADIO_OFF or RADIO_ON */\n\tresult = wait_event_timeout(\n\t\ti2400m-&gt;state_wq, i2400m_radio_is(i2400m, state),\n\t\t5 * HZ);\n\tif (result == 0)\n\t\tresult = -ETIMEDOUT;\n\tif (result &lt; 0)\n\t\tdev_err(dev, "Error waiting for device to toggle RF state: "\n\t\t\t"%d\\n", result);\n\tresult = 0;\nerror_cmd:\n\tkfree(cmd);\n\tkfree_skb(ack_skb);\nerror_msg_to_dev:\nerror_alloc:\n\td_fnend(4, dev, "(wimax_dev %p state %d) = %d\\n",\n\t\twimax_dev, state, result);\n\treturn result;\n}',
 'print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n\n   ND_TCHECK2(data[0],length);\n\n   switch(attr_code)\n   {\n      case TUNNEL_PASS:\n           if (length &lt; 3)\n           {\n              ND_PRINT((ndo, "%s", tstr));\n              return;\n           }\n           if (*data &amp;&amp; (*data &lt;=0x1F) )\n              ND_PRINT((ndo, "Tag[%u] ", *data));\n           else\n              ND_PRINT((ndo, "Tag[Unused] "));\n           data++;\n           length--;\n           ND_PRINT((ndo, "Salt %u ", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n           if (*data &lt;= 0x1F)\n           {\n              if (length &lt; 1)\n              {\n                 ND_PRINT((ndo, "%s", tstr));\n                 return;\n              }\n              if (*data)\n                ND_PRINT((ndo, "Tag[%u] ", *data));\n              else\n                ND_PRINT((ndo, "Tag[Unused] "));\n              data++;\n              length--;\n           }\n        break;\n      case EGRESS_VLAN_NAME:\n           ND_PRINT((ndo, "%s (0x%02x) ",\n                  tok2str(rfc4675_tagged,"Unknown tag",*data),\n                  *data));\n           data++;\n           length--;\n        break;\n   }\n\n   for (i=0; *data &amp;&amp; i &lt; length ; i++, data++)\n       ND_PRINT((ndo, "%c", (*data &lt; 32 || *data &gt; 126) ? \'.\' : *data));\n\n   return;\n\n   trunc:\n      ND_PRINT((ndo, "%s", tstr));\n}',
 'static void mspack_fmap_free(void *mem)\n{\n    if(mem) {\n        free(mem);\n        mem = NULL;\n    }\n    return;\n}',
 'static pyc_object *get_object(RBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\tut8 code = get_ut8 (buffer, &amp;error);\n\tut8 flag = code &amp; FLAG_REF;\n\tRListIter *ref_idx = NULL;\n\tut8 type = code &amp; ~FLAG_REF;\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\n\tif (flag) {\n\t\tret = get_none_object ();\n\t\tif (!ret) {\n\t\t\treturn NULL;\n\t\t}\n\t\tref_idx = r_list_append (refs, ret);\n\t\tif (!ref_idx) {\n\t\t\tfree_object (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase TYPE_NULL:\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase TYPE_TRUE:\n\t\tfree_object (ret);\n\t\treturn get_true_object ();\n\tcase TYPE_FALSE:\n\t\tfree_object (ret);\n\t\treturn get_false_object ();\n\tcase TYPE_NONE:\n\t\tfree_object (ret);\n\t\treturn get_none_object ();\n\tcase TYPE_REF:\n\t\tfree_object (ret);\n\t\treturn get_ref_object (buffer);\n\tcase TYPE_SMALL_TUPLE:\n\t\tret = get_small_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\t\tret = get_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRING:\n\t\tret = get_string_object (buffer);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret-&gt;type = TYPE_CODE_v0;\n\t\t}\n\t\tbreak;\n\tcase TYPE_CODE_v1:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret-&gt;type = TYPE_CODE_v1;\n\t\t}\n\t\tbreak;\n\tcase TYPE_INT:\n\t\tret = get_int_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII_INTERNED:\n\t\tret = get_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII:\n\t\tret = get_short_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII:\n\t\tret = get_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tret = get_short_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_INT64:\n\t\tret = get_int64_object (buffer);\n\t\tbreak;\n\tcase TYPE_INTERNED:\n\t\tret = get_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRINGREF:\n\t\tret = get_stringref_object (buffer);\n\t\tbreak;\n\tcase TYPE_FLOAT:\n\t\tret = get_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_BINARY_FLOAT:\n\t\tret = get_binary_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_COMPLEX:\n\t\tret = get_complex_object (buffer); // behaviour depends on Python version\n\t\tbreak;\n\tcase TYPE_BINARY_COMPLEX:\n\t\tret = get_binary_complex_object (buffer);\n\t\tbreak;\n\tcase TYPE_LIST:\n\t\tret = get_list_object (buffer);\n\t\tbreak;\n\tcase TYPE_LONG:\n\t\tret = get_long_object (buffer);\n\t\tbreak;\n\tcase TYPE_UNICODE:\n\t\tret = get_unicode_object (buffer);\n\t\tbreak;\n\tcase TYPE_DICT:\n\t\tret = get_dict_object (buffer);\n\t\tbreak;\n\tcase TYPE_FROZENSET:\n\tcase TYPE_SET:\n\t\tret = get_set_object (buffer);\n\t\tbreak;\n\tcase TYPE_STOPITER:\n\tcase TYPE_ELLIPSIS:\n\t\tret = R_NEW0 (pyc_object);\n\t\tbreak;\n\tcase TYPE_UNKNOWN:\n\t\teprintf ("Get not implemented for type 0x%x\\n", type);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase 0:\n\t\t// nop\n\t\tbreak;\n\tdefault:\n\t\teprintf ("Undefined type in get_object (0x%x)\\n", type);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\t}\n\n\tif (flag &amp;&amp; ref_idx) {\n\t\tfree_object (ref_idx-&gt;data);\n\t\tref_idx-&gt;data = copy_object (ret);\n\t}\n\treturn ret;\n}',
 "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\t/*\n\t\t * Want to mark the page and the radix tree as dirty, and\n\t\t * redo the accounting that clear_page_dirty_for_io undid,\n\t\t * but we can't use set_page_dirty because that function\n\t\t * is actually a signal that all of the page has become dirty.\n\t\t * Whereas only part of our page may be dirty.\n\t\t */\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}",
 'static void setup_private_mount(const char *snap_name)\n{\n\tchar tmpdir[MAX_BUF] = { 0 };\n\n\t// Create a 0700 base directory, this is the base dir that is\n\t// protected from other users.\n\t//\n\t// Under that basedir, we put a 1777 /tmp dir that is then bind\n\t// mounted for the applications to use\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), "/tmp/snap.%s_XXXXXX", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie("cannot create temporary directory essential for private /tmp");\n\t}\n\t// now we create a 1777 /tmp inside our private dir\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), "%s/tmp", d);\n\tfree(d);\n\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie("cannot create temporary directory for private /tmp");\n\t}\n\tumask(old_mask);\n\n\t// chdir to \'/\' since the mount won\'t apply to the current directory\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie("cannot get current working directory");\n\tif (chdir("/") != 0)\n\t\tdie("cannot change directory to \'/\'");\n\n\t// MS_BIND is there from linux 2.4\n\tsc_do_mount(tmpdir, "/tmp", NULL, MS_BIND, NULL);\n\t// MS_PRIVATE needs linux &gt; 2.6.11\n\tsc_do_mount("none", "/tmp", NULL, MS_PRIVATE, NULL);\n\t// do the chown after the bind mount to avoid potential shenanigans\n\tif (chown("/tmp/", 0, 0) &lt; 0) {\n\t\tdie("cannot change ownership of /tmp");\n\t}\n\t// chdir to original directory\n\tif (chdir(pwd) != 0)\n\t\tdie("cannot change current working directory to the original directory");\n\tfree(pwd);\n}',
 'struct error_obj run_pam_auth(const char *username, char *password) {\n    // PAM frees pam_response for us.\n    struct pam_response *reply = malloc(sizeof(struct pam_response));\n    if (reply == NULL) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = "malloc";\n        ret_val.error_msg = "Out of memory";\n        return ret_val;\n    }\n    reply-&gt;resp = password;\n    reply-&gt;resp_retcode = 0;\n\n    const struct pam_conv local_conv = { conv_func, reply };\n    pam_handle_t *local_auth = NULL;\n    int status = pam_start("maddy", username, &amp;local_conv, &amp;local_auth);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = "pam_start";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = "pam_authenticate";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = "pam_acct_mgmt";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_end(local_auth, status);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = "pam_end";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    struct error_obj ret_val;\n    ret_val.status = 0;\n    ret_val.func_name = NULL;\n    ret_val.error_msg = NULL;\n    return ret_val;\n}',
 'upnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &amp;address) &lt;= 0) {\n\t\tsyslog(LOG_ERR, "inet_aton(%s) FAILED", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, "redirection permission check failed for "\n\t\t                 "%hu-&gt;%s:%hu %s", eport, iaddr, iport, protocol);\n\t\treturn -3;\n\t}\n\n\tif (desc == NULL)\n\t\tdesc = "";\t/* assume empty description */\n\n\t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n\t * - 2.2.20.PortMappingDescription :\n\t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           ≠           ≠         Failure\n\t *     =         =           ≠           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           ≠         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = \'\\0\';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &amp;iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &amp;timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &amp;&amp;\n\t\t   ((rhost == NULL &amp;&amp; rhost_old[0]==\'\\0\') ||\n\t\t    (rhost &amp;&amp; (strcmp(rhost, "*") == 0) &amp;&amp; rhost_old[0]==\'\\0\') ||\n\t\t    (rhost &amp;&amp; (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, "updating existing port mapping %hu %s (rhost \'%s\') =&gt; %s:%hu",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration &gt; 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, "port %hu %s (rhost \'%s\') already redirected to %s:%hu",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) &gt; 0) {\n\t\tsyslog(LOG_INFO, "port %hu protocol %s already in use",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration &gt; 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, "redirecting port %hu to %s:%hu protocol %s for: %s",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}',
 'xmalloc (size_t num, size_t size)\n{\n    size_t res;\n    if (check_mul_overflow(num, size, &amp;res))\n        abort();\n\n    void *ptr = malloc (res);\n    if (!ptr\n        &amp;&amp; (size != 0))         /* some libc don\'t like size == 0 */\n    {\n        perror ("xmalloc: Memory allocation failure");\n        abort();\n    }\n    return ptr;\n}',
 'static void __udf_read_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode-&gt;i_sb);\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\nreread:\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb-&gt;s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode-&gt;i_sb, &amp;iinfo-&gt;i_location, 0, &amp;ident);\n\tif (!bh) {\n\t\tudf_err(inode-&gt;i_sb, "(ino %ld) failed !bh\\n", inode-&gt;i_ino);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tif (ident != TAG_IDENT_FE &amp;&amp; ident != TAG_IDENT_EFE &amp;&amp;\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode-&gt;i_sb, "(ino %ld) failed ident=%d\\n",\n\t\t\tinode-&gt;i_ino, ident);\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tfe = (struct fileEntry *)bh-&gt;b_data;\n\tefe = (struct extendedFileEntry *)bh-&gt;b_data;\n\n\tif (fe-&gt;icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode-&gt;i_sb, &amp;iinfo-&gt;i_location, 1,\n\t\t\t\t\t&amp;ident);\n\t\tif (ident == TAG_IDENT_IE &amp;&amp; ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh-&gt;b_data;\n\t\t\tloc = lelb_to_cpu(ie-&gt;indirectICB.extLocation);\n\n\t\t\tif (ie-&gt;indirectICB.extLength) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&amp;iinfo-&gt;i_location, &amp;loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections &gt; UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode-&gt;i_sb,\n\t\t\t\t\t\t"too many ICBs in ICB hierarchy"\n\t\t\t\t\t\t" (max %d supported)\\n",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tmake_bad_inode(inode);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe-&gt;icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode-&gt;i_sb, "unsupported strategy type: %d\\n",\n\t\t\tle16_to_cpu(fe-&gt;icbTag.strategyType));\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (fe-&gt;icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo-&gt;i_strat4096 = 0;\n\telse /* if (fe-&gt;icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo-&gt;i_strat4096 = 1;\n\n\tiinfo-&gt;i_alloc_type = le16_to_cpu(fe-&gt;icbTag.flags) &amp;\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo-&gt;i_unique = 0;\n\tiinfo-&gt;i_lenEAttr = 0;\n\tiinfo-&gt;i_lenExtents = 0;\n\tiinfo-&gt;i_lenAlloc = 0;\n\tiinfo-&gt;i_next_alloc_block = 0;\n\tiinfo-&gt;i_next_alloc_goal = 0;\n\tif (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo-&gt;i_efe = 1;\n\t\tiinfo-&gt;i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo-&gt;i_ext.i_data,\n\t\t       bh-&gt;b_data + sizeof(struct extendedFileEntry),\n\t\t       inode-&gt;i_sb-&gt;s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t} else if (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo-&gt;i_efe = 0;\n\t\tiinfo-&gt;i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -\n\t\t\t\t\t\tsizeof(struct fileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo-&gt;i_ext.i_data,\n\t\t       bh-&gt;b_data + sizeof(struct fileEntry),\n\t\t       inode-&gt;i_sb-&gt;s_blocksize - sizeof(struct fileEntry));\n\t} else if (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo-&gt;i_efe = 0;\n\t\tiinfo-&gt;i_use = 1;\n\t\tiinfo-&gt;i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh-&gt;b_data)-&gt;\n\t\t\t\t lengthAllocDescs);\n\t\tif (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo-&gt;i_ext.i_data,\n\t\t       bh-&gt;b_data + sizeof(struct unallocSpaceEntry),\n\t\t       inode-&gt;i_sb-&gt;s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\treturn;\n\t}\n\n\tread_lock(&amp;sbi-&gt;s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe-&gt;uid));\n\tif (!uid_valid(inode-&gt;i_uid) ||\n\t    UDF_QUERY_FLAG(inode-&gt;i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode-&gt;i_sb, UDF_FLAG_UID_SET))\n\t\tinode-&gt;i_uid = UDF_SB(inode-&gt;i_sb)-&gt;s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe-&gt;gid));\n\tif (!gid_valid(inode-&gt;i_gid) ||\n\t    UDF_QUERY_FLAG(inode-&gt;i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode-&gt;i_sb, UDF_FLAG_GID_SET))\n\t\tinode-&gt;i_gid = UDF_SB(inode-&gt;i_sb)-&gt;s_gid;\n\n\tif (fe-&gt;icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &amp;&amp;\n\t\t\tsbi-&gt;s_fmode != UDF_INVALID_MODE)\n\t\tinode-&gt;i_mode = sbi-&gt;s_fmode;\n\telse if (fe-&gt;icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &amp;&amp;\n\t\t\tsbi-&gt;s_dmode != UDF_INVALID_MODE)\n\t\tinode-&gt;i_mode = sbi-&gt;s_dmode;\n\telse\n\t\tinode-&gt;i_mode = udf_convert_permissions(fe);\n\tinode-&gt;i_mode &amp;= ~sbi-&gt;s_umask;\n\tread_unlock(&amp;sbi-&gt;s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe-&gt;fileLinkCount);\n\tif (!link_count)\n\t\tlink_count = 1;\n\tset_nlink(inode, link_count);\n\n\tinode-&gt;i_size = le64_to_cpu(fe-&gt;informationLength);\n\tiinfo-&gt;i_lenExtents = inode-&gt;i_size;\n\n\tif (iinfo-&gt;i_efe == 0) {\n\t\tinode-&gt;i_blocks = le64_to_cpu(fe-&gt;logicalBlocksRecorded) &lt;&lt;\n\t\t\t(inode-&gt;i_sb-&gt;s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_atime, fe-&gt;accessTime))\n\t\t\tinode-&gt;i_atime = sbi-&gt;s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_mtime,\n\t\t\t\t\t    fe-&gt;modificationTime))\n\t\t\tinode-&gt;i_mtime = sbi-&gt;s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_ctime, fe-&gt;attrTime))\n\t\t\tinode-&gt;i_ctime = sbi-&gt;s_record_time;\n\n\t\tiinfo-&gt;i_unique = le64_to_cpu(fe-&gt;uniqueID);\n\t\tiinfo-&gt;i_lenEAttr = le32_to_cpu(fe-&gt;lengthExtendedAttr);\n\t\tiinfo-&gt;i_lenAlloc = le32_to_cpu(fe-&gt;lengthAllocDescs);\n\t\tiinfo-&gt;i_checkpoint = le32_to_cpu(fe-&gt;checkpoint);\n\t} else {\n\t\tinode-&gt;i_blocks = le64_to_cpu(efe-&gt;logicalBlocksRecorded) &lt;&lt;\n\t\t    (inode-&gt;i_sb-&gt;s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_atime, efe-&gt;accessTime))\n\t\t\tinode-&gt;i_atime = sbi-&gt;s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_mtime,\n\t\t\t\t\t    efe-&gt;modificationTime))\n\t\t\tinode-&gt;i_mtime = sbi-&gt;s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&amp;iinfo-&gt;i_crtime, efe-&gt;createTime))\n\t\t\tiinfo-&gt;i_crtime = sbi-&gt;s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&amp;inode-&gt;i_ctime, efe-&gt;attrTime))\n\t\t\tinode-&gt;i_ctime = sbi-&gt;s_record_time;\n\n\t\tiinfo-&gt;i_unique = le64_to_cpu(efe-&gt;uniqueID);\n\t\tiinfo-&gt;i_lenEAttr = le32_to_cpu(efe-&gt;lengthExtendedAttr);\n\t\tiinfo-&gt;i_lenAlloc = le32_to_cpu(efe-&gt;lengthAllocDescs);\n\t\tiinfo-&gt;i_checkpoint = le32_to_cpu(efe-&gt;checkpoint);\n\t}\n\n\tswitch (fe-&gt;icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode-&gt;i_op = &amp;udf_dir_inode_operations;\n\t\tinode-&gt;i_fop = &amp;udf_dir_operations;\n\t\tinode-&gt;i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo-&gt;i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode-&gt;i_data.a_ops = &amp;udf_adinicb_aops;\n\t\telse\n\t\t\tinode-&gt;i_data.a_ops = &amp;udf_aops;\n\t\tinode-&gt;i_op = &amp;udf_file_inode_operations;\n\t\tinode-&gt;i_fop = &amp;udf_file_operations;\n\t\tinode-&gt;i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode-&gt;i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode-&gt;i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode-&gt;i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode-&gt;i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode-&gt;i_data.a_ops = &amp;udf_symlink_aops;\n\t\tinode-&gt;i_op = &amp;udf_symlink_inode_operations;\n\t\tinode-&gt;i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug("METADATA FILE-----\\n");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug("METADATA MIRROR FILE-----\\n");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug("METADATA BITMAP FILE-----\\n");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode-&gt;i_sb, "(ino %ld) failed unknown file type=%d\\n",\n\t\t\tinode-&gt;i_ino, fe-&gt;icbTag.fileType);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (S_ISCHR(inode-&gt;i_mode) || S_ISBLK(inode-&gt;i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode-&gt;i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea-&gt;majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea-&gt;minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tmake_bad_inode(inode);\n\t}\n\tbrelse(bh);\n}',
 'gimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n  GimpImage           *image;\n  GimpImage           *loaded_image;\n  GimpPlugInProcedure *proc;\n  gchar               *filename;\n  GFile               *file;\n\n  /* Create the image */\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n\n  /* Assert valid state */\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n\n  /* Write to file */\n  filename = g_build_filename (g_get_tmp_dir (), "gimp-test.xcf", NULL);\n  file = g_file_new_for_path (filename);\n  g_free (filename);\n\n  proc = gimp_plug_in_manager_file_procedure_find (image-&gt;gimp-&gt;plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL /*error*/);\n  file_save (gimp,\n             image,\n             NULL /*progress*/,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE /*change_saved_state*/,\n             FALSE /*export_backward*/,\n             FALSE /*export_forward*/,\n             NULL /*error*/);\n\n  /* Load from file */\n  loaded_image = gimp_test_load_image (image-&gt;gimp, file);\n\n  /* Assert on the loaded file. If success, it means that there is no\n   * significant information loss when we wrote the image to a file\n   * and loaded it again\n   */\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}',
 'tgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       const char *server_name,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b-&gt;kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&amp;rep, 0, sizeof(rep));\n    memset(&amp;et, 0, sizeof(et));\n    memset(&amp;ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt-&gt;authtime;\n    _kdc_fix_time(&amp;b-&gt;till);\n    et.endtime = min(tgt-&gt;endtime, *b-&gt;till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &amp;et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn\'t ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn\'t marked as allowing this\n       5) we don\'t globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config-&gt;trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config-&gt;trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config-&gt;trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &amp;&amp;\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &amp;tgt-&gt;transited, &amp;et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server-&gt;entry.principal),\n\t\t\t\t krb5_principal_get_realm(context, krbtgt-&gt;entry.principal));\n    if(ret)\n\tgoto out;\n\n    copy_Realm(&amp;server_principal-&gt;realm, &amp;rep.ticket.realm);\n    _krb5_principal2principalname(&amp;rep.ticket.sname, server_principal);\n    copy_Realm(&amp;tgt_name-&gt;realm, &amp;rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&amp;rep.cname);\n    else */\n\n    copy_PrincipalName(&amp;tgt_name-&gt;name, &amp;rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client &amp;&amp; client-&gt;entry.max_life)\n\t    life = min(life, *client-&gt;entry.max_life);\n\tif(server-&gt;entry.max_life)\n\t    life = min(life, *server-&gt;entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok &amp;&amp; tgt-&gt;flags.renewable &amp;&amp;\n       et.renew_till == NULL &amp;&amp; et.endtime &lt; *b-&gt;till &amp;&amp;\n       tgt-&gt;renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b-&gt;till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client &amp;&amp; client-&gt;entry.max_renew)\n\t    renew = min(renew, *client-&gt;entry.max_renew);\n\tif(server-&gt;entry.max_renew)\n\t    renew = min(renew, *server-&gt;entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt-&gt;renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till &amp;&amp; et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt-&gt;flags.pre_authent;\n    et.flags.hw_authent  = tgt-&gt;flags.hw_authent;\n    et.flags.anonymous   = tgt-&gt;flags.anonymous;\n    et.flags.ok_as_delegate = server-&gt;entry.flags.ok_as_delegate;\n\n    if(rspac-&gt;length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it\'s signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &amp;et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, "malloc: out of memory");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i &lt; auth_data-&gt;len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &amp;auth_data-&gt;val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, "malloc: out of memory");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data-&gt;len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&amp;ad-&gt;val[ad-&gt;len - 1]);\n\t\tad-&gt;len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &amp;et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name-&gt;realm;\n    et.cname = tgt_name-&gt;name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b-&gt;nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, "TGS-REQ", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don\'t sign cross realm tickets, they can\'t be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&amp;ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &amp;et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data-&gt;len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey-&gt;keytype) != 0\n\t&amp;&amp; _kdc_is_weak_exception(server-&gt;entry.principal, serverkey-&gt;keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey-&gt;keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don\'t want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &amp;rep, &amp;et, &amp;ek, serverkey-&gt;keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey-&gt;keytype);\n\nout:\n    free_TGS_REP(&amp;rep);\n    free_TransitedEncoding(&amp;et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&amp;ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&amp;et.key);\n    return ret;\n}',
 'static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn crypto_rng_alg(tfm)-&gt;seedsize;\n}',
 'int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb-&gt;dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\n\t/* Jumbo payload inhibits frag. header */\n\tif (ipv6_hdr(skb)-&gt;payload_len == 0) {\n\t\tpr_debug("payload len = 0\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tif (find_prev_fhdr(skb, &amp;prevhdr, &amp;nhoff, &amp;fhoff) &lt; 0)\n\t\treturn -EINVAL;\n\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\n\tfq = fq_find(net, fhdr-&gt;identification, user, &amp;hdr-&gt;saddr, &amp;hdr-&gt;daddr,\n\t\t     skb-&gt;dev ? skb-&gt;dev-&gt;ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug("Can\'t find and can\'t create new queue\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_bh(&amp;fq-&gt;q.lock);\n\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) &lt; 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* after queue has assumed skb ownership, only 0 or -EINPROGRESS\n\t * must be returned.\n\t */\n\tret = -EINPROGRESS;\n\tif (fq-&gt;q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &amp;&amp;\n\t    fq-&gt;q.meat == fq-&gt;q.len &amp;&amp;\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\n\nout_unlock:\n\tspin_unlock_bh(&amp;fq-&gt;q.lock);\n\tinet_frag_put(&amp;fq-&gt;q, &amp;nf_frags);\n\treturn ret;\n}',
 'MONGO_EXPORT int bson_buffer_size( const bson *b ) {\n    return (b-&gt;cur - b-&gt;data + 1);\n}',
 'int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) &lt; 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields-&gt;Len); /* Len (2 bytes) */\n\tStream_Read_UINT16(s, fields-&gt;MaxLen); /* MaxLen (2 bytes) */\n\tStream_Read_UINT32(s, fields-&gt;BufferOffset); /* BufferOffset (4 bytes) */\n\treturn 1;\n}',
 'ast_for_async_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* async_funcdef: \'async\' funcdef */\n    REQ(n, async_funcdef);\n    REQ(CHILD(n, 0), NAME);\n    assert(strcmp(STR(CHILD(n, 0)), "async") == 0);\n    REQ(CHILD(n, 1), funcdef);\n\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                true /* is_async */);\n}',
 '  void Compute(OpKernelContext* context) override {\n    const Tensor&amp; diagonal = context-&gt;input(0);\n\n    // MatrixDiag and MatrixDiagV2 both use this OpKernel. MatrixDiag only has\n    // one input, so we have to check the number of inputs before reading\n    // additional parameters in MatrixDiagV2.\n    int32 lower_diag_index = 0;\n    int32 upper_diag_index = 0;\n    int32 num_rows = -1;\n    int32 num_cols = -1;\n    T padding_value(0);\n\n    // MatrixDiagOpV2-specific.\n    if (context-&gt;num_inputs() &gt; kNumV1Inputs) {\n      auto&amp; diag_index = context-&gt;input(1);\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(diag_index.shape()) ||\n                      TensorShapeUtils::IsVector(diag_index.shape()),\n                  errors::InvalidArgument(\n                      "diag_index must be a scalar or vector, received shape: ",\n                      diag_index.shape().DebugString()));\n      lower_diag_index = diag_index.flat&lt;int32&gt;()(0);\n      upper_diag_index = lower_diag_index;\n      if (TensorShapeUtils::IsVector(diag_index.shape())) {\n        auto diag_index_size = diag_index.dim_size(0);\n        OP_REQUIRES(\n            context, 0 &lt; diag_index_size &amp;&amp; diag_index_size &lt;= 2,\n            errors::InvalidArgument(\n                "diag_index must have only one or two elements, received ",\n                diag_index_size, " elements."));\n        if (diag_index_size &gt; 1) {\n          upper_diag_index = diag_index.flat&lt;int32&gt;()(1);\n        }\n      }\n      num_rows = context-&gt;input(2).flat&lt;int32&gt;()(0);\n      num_cols = context-&gt;input(3).flat&lt;int32&gt;()(0);\n      padding_value = context-&gt;input(4).flat&lt;T&gt;()(0);\n    }\n\n    // Size validations.\n    const TensorShape&amp; diagonal_shape = diagonal.shape();\n    const int diag_rank = diagonal_shape.dims();\n    const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;\n    OP_REQUIRES(context, TensorShapeUtils::IsVectorOrHigher(diagonal_shape),\n                errors::InvalidArgument(\n                    "diagonal must be at least 1-dim, received shape: ",\n                    diagonal.shape().DebugString()));\n    OP_REQUIRES(\n        context, lower_diag_index &lt;= upper_diag_index,\n        errors::InvalidArgument(\n            "lower_diag_index must not be larger than upper_diag_index: ",\n            lower_diag_index, " &gt; ", upper_diag_index));\n    OP_REQUIRES(context,\n                lower_diag_index == upper_diag_index ||\n                    diagonal_shape.dim_size(diag_rank - 2) == num_diags,\n                errors::InvalidArgument(\n                    "The number of diagonals provided in the input does not "\n                    "match the lower_diag_index and upper_diag_index range."));\n\n    const Eigen::Index max_diag_len = diagonal_shape.dim_size(diag_rank - 1);\n    const int32 min_num_rows = max_diag_len - std::min(upper_diag_index, 0);\n    const int32 min_num_cols = max_diag_len + std::max(lower_diag_index, 0);\n    OP_REQUIRES(context, num_rows == -1 || num_rows &gt;= min_num_rows,\n                errors::InvalidArgument("The number of rows is too small."));\n    OP_REQUIRES(context, num_cols == -1 || num_cols &gt;= min_num_cols,\n                errors::InvalidArgument("The number of columns is too small."));\n\n    // If both num_rows and num_cols are unknown, assume that output is square.\n    // Otherwise, use smallest possible values.\n    if (num_rows == -1 &amp;&amp; num_cols == -1) {\n      num_rows = std::max(min_num_rows, min_num_cols);\n      num_cols = num_rows;\n    } else if (num_rows == -1) {\n      num_rows = min_num_rows;\n    } else if (num_cols == -1) {\n      num_cols = min_num_cols;\n    }\n    OP_REQUIRES(context, num_rows == min_num_rows || num_cols == min_num_cols,\n                errors::InvalidArgument(\n                    "The number of rows or columns is not consistent with "\n                    "the specified d_lower, d_upper, and diagonal."));\n\n    TensorShape output_shape = diagonal_shape;\n    if (num_diags == 1) {  // Output has rank `rank+1`.\n      output_shape.set_dim(diag_rank - 1, num_rows);\n      output_shape.AddDim(num_cols);\n    } else {  // Output has rank `rank`.\n      output_shape.set_dim(diag_rank - 2, num_rows);\n      output_shape.set_dim(diag_rank - 1, num_cols);\n    }\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context-&gt;allocate_output(0, output_shape, &amp;output));\n    auto output_reshaped = output-&gt;flat_inner_dims&lt;T, 3&gt;();\n    auto diag_reshaped = diagonal.flat&lt;T&gt;();\n    functor::MatrixDiag&lt;Device, T&gt;::Compute(\n        context, context-&gt;eigen_device&lt;Device&gt;(), diag_reshaped,\n        output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,\n        padding_value, left_align_superdiagonal_, left_align_subdiagonal_);\n  }',
 'void SetLineWidth(double w) {\n    outpos +=\n    sprintf(outpos," %12.3f w",w);\n}',
 'struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\n\trt = lookup(net, net-&gt;ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt-&gt;dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net-&gt;ipv6.ip6_null_entry;\n\t\tif (!(flags &amp; RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&amp;rt-&gt;dst);\n\t}\n\n\treturn &amp;rt-&gt;dst;\n}',
 '  static NAN_METHOD(New) {\n    MarkPopErrorOnReturn mark_pop_error_on_return;\n\n    if (!Buffer::HasInstance(info[0]))\n      return Nan::ThrowTypeError("Missing/Invalid keys");\n\n    ChaChaPolyDecipher* obj = new ChaChaPolyDecipher();\n    ErrorType r = obj-&gt;init(\n      reinterpret_cast&lt;unsigned char*&gt;(Buffer::Data(info[0])),\n      Buffer::Length(info[0])\n    );\n    if (r != kErrNone) {\n      delete obj;\n      switch (r) {\n        case kErrBadKeyLen:\n          return Nan::ThrowError("Invalid keys length");\n        case kErrBadIVLen:\n          return Nan::ThrowError("Invalid IV length");\n        case kErrOpenSSL: {\n          char msg_buf[128] = {0};\n          ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));\n          return Nan::ThrowError(msg_buf);\n        }\n        default:\n          return Nan::ThrowError("Unknown init failure");\n      }\n    }\n\n    obj-&gt;Wrap(info.This());\n    info.GetReturnValue().Set(info.This());\n  }',
 'static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  VALUE rb_schema;\n  VALUE errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n   schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, "Could not parse document");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, "@errors", errors);\n\n  return rb_schema;\n}',
 'compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node-&gt;type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn-&gt;lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len &lt; 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)-&gt;push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)-&gt;jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      int cond_len, then_len, jump_len;\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node-&gt;te.Then;\n      Node* Else = node-&gt;te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len &lt; 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len &lt; 0) return then_len;\n      }\n      else\n        then_len = 0;\n\n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;\n      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)-&gt;push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        int else_len = compile_length_tree(Else, reg);\n        r = add_op(reg, OP_JUMP);\n        if (r != 0) return r;\n        COP(reg)-&gt;jump.addr = else_len + SIZE_INC_OP;\n\n        r = compile_tree(Else, reg, env);\n      }\n    }\n    break;\n  }\n\n  return r;\n}',
 'main(int argc, char **argv)\n{\n\tconst char *safepath = SAFE_PATH;\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tchar myname[_PW_NAME_LEN + 1];\n\tstruct passwd *original_pw, *target_pw;\n\tstruct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar *login_style = NULL;\n\tchar **envp;\n\n\t#ifndef linux\n\tsetprogname("doas");\n\t#endif\n\n\t#ifndef linux\n\tclosefrom(STDERR_FILENO + 1);\n\t#endif\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, "a:C:nsu:")) != -1) {\n/*\twhile ((ch = getopt(argc, argv, "a:C:Lnsu:")) != -1) { */\n\t\tswitch (ch) {\n\t\tcase \'a\':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n\t\tcase \'C\':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n/*\t\tcase \'L\':\n\t\t\ti = open("/dev/tty", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i != -1);\n*/\n\t\tcase \'u\':\n\t\t\tif (parseuid(optarg, &amp;target) != 0)\n\t\t\t\terrx(1, "unknown user");\n\t\t\tbreak;\n\t\tcase \'n\':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase \'s\':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag &amp;&amp; !argc) || (sflag &amp;&amp; argc))\n\t\tusage();\n\n\toriginal_pw = getpwuid(uid);\n\tif (! original_pw)\n\t\terr(1, "getpwuid failed");\n\tif (strlcpy(myname, original_pw-&gt;pw_name, sizeof(myname)) &gt;= sizeof(myname))\n\t\terrx(1, "pw_name too long");\n\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, "can\'t get groups");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv("SHELL");\n\t\tif (sh == NULL || *sh == \'\\0\') {\n\t\t\tshargv[0] = strdup(original_pw-&gt;pw_shell);\n\t\t\tif (shargv[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, "not installed setuid");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i &lt; argc; i++) {\n\t\tif (strlcat(cmdline, " ", sizeof(cmdline)) &gt;= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) &gt;= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &amp;rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    "failed command for %s: %s", myname, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n\tif (!(rule-&gt;options &amp; NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, "Authorization required");\n\n#if defined(USE_BSD_AUTH) \n\t\tauthuser(myname, login_style, rule-&gt;options &amp; PERSIST);\n#elif defined(USE_PAM)\n#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, "%s: %s", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx("%s: %s", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;\n\t\tint pam_err;\n\n/* #ifndef linux */\n\t\tint temp_stdin;\n\n\t\t/* openpam_ttyconv checks if stdin is a terminal and\n\t\t * if it is then does not bother to open /dev/tty.\n\t\t * The result is that PAM writes the password prompt\n\t\t * directly to stdout.  In scenarios where stdin is a\n\t\t * terminal, but stdout is redirected to a file\n\t\t * e.g. by running doas ls &amp;&gt; ls.out interactively,\n\t\t * the password prompt gets written to ls.out as well.\n\t\t * By closing stdin first we forces PAM to read/write\n\t\t * to/from the terminal directly.  We restore stdin\n\t\t * after authenticating. */\n\t\ttemp_stdin = dup(STDIN_FILENO);\n\t\tif (temp_stdin == -1)\n\t\t\terr(1, "dup");\n\t\tclose(STDIN_FILENO);\n/* #else */\n\t\t/* force password prompt to display on stderr, not stdout */\n\t\tint temp_stdout = dup(1);\n\t\tif (temp_stdout == -1)\n\t\t\terr(1, "dup");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, "dup2");\n/* #endif */\n\n\t\tpam_err = pam_start("doas", myname, &amp;pamc, &amp;pamh);\n\t\tif (pam_err != PAM_SUCCESS) {\n\t\t\tif (pamh != NULL)\n\t\t\t\tPAM_END("pam_start");\n\t\t\tsyslog(LOG_ERR, "pam_start failed: %s",\n\t\t\t    pam_strerror(pamh, pam_err));\n\t\t\terrx(EXIT_FAILURE, "pam_start failed");\n\t\t}\n\n\t\tswitch (pam_err = pam_authenticate(pamh, PAM_SILENT)) {\n\t\tcase PAM_SUCCESS:\n\t\t\tswitch (pam_err = pam_acct_mgmt(pamh, PAM_SILENT)) {\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t\t\tpam_err = pam_chauthtok(pamh,\n\t\t\t\t    PAM_SILENT|PAM_CHANGE_EXPIRED_AUTHTOK);\n\t\t\t\tif (pam_err != PAM_SUCCESS)\n\t\t\t\t\tPAM_END("pam_chauthtok");\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_AUTH_ERR:\n\t\t\tcase PAM_USER_UNKNOWN:\n\t\t\tcase PAM_MAXTRIES:\n\t\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t\t    "failed auth for %s", myname);\n                                errx(EXIT_FAILURE, "second authentication failed");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END("pam_acct_mgmt");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PAM_AUTH_ERR:\n\t\tcase PAM_USER_UNKNOWN:\n\t\tcase PAM_MAXTRIES:\n\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t    "failed auth for %s", myname);\n                        errx(EXIT_FAILURE, "authentication failed");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END("pam_authenticate");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(pamh, pam_err);\n\n#ifndef linux\n\t\t/* Re-establish stdin */\n\t\tif (dup2(temp_stdin, STDIN_FILENO) == -1)\n\t\t\terr(1, "dup2");\n\t\tclose(temp_stdin);\n#else \n\t\t/* Re-establish stdout */\n\t\tclose(1);\n\t\tif (dup2(temp_stdout, 1) == -1)\n\t\t\terr(1, "dup2");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /*\n\tif (pledge("stdio rpath getpw exec id", NULL) == -1)\n\t\terr(1, "pledge");\n        */\n\ttarget_pw = getpwuid(target);\n\tif (! target_pw)\n\t\terrx(1, "no passwd entry for target");\n\n#if defined(HAVE_LOGIN_CAP_H)\n\tif (setusercontext(NULL, target_pw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, "failed to set user context for target");\n#else\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresgid(target_pw-&gt;pw_gid, target_pw-&gt;pw_gid, target_pw-&gt;pw_gid) == -1)\n\t\terr(1, "setresgid");\n\t#else\n\tif (setregid(target_pw-&gt;pw_gid, target_pw-&gt;pw_gid) == -1)\n\t\terr(1, "setregid");\n\t#endif\n\tif (initgroups(target_pw-&gt;pw_name, target_pw-&gt;pw_gid) == -1)\n\t\terr(1, "initgroups");\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresuid(target, target, target) == -1)\n\t\terr(1, "setresuid");\n\t#else\n\tif (setreuid(target, target) == -1)\n\t\terr(1, "setreuid");\n\t#endif\n#endif\n        /*\n\tif (pledge("stdio rpath exec", NULL) == -1)\n\t\terr(1, "pledge");\n        */\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = "(failed)";\n\telse\n\t\tcwd = cwdpath;\n\n\t/*\n        if (pledge("stdio exec", NULL) == -1)\n\t\terr(1, "pledge");\n        */\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, "%s ran command %s as %s from %s",\n\t    myname, cmdline, target_pw-&gt;pw_name, cwd);\n\n\tenvp = prepenv(rule, original_pw, target_pw);\n\n\tif (rule-&gt;cmd) {\n\t\tif (setenv("PATH", safepath, 1) == -1)\n\t\t\terr(1, "failed to set PATH \'%s\'", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, "%s: command not found", cmd);\n\terr(1, "%s", cmd);\n}',
 'int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode-&gt;i_sb;\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn 0;\n\n\tmutex_lock(&amp;EXT4_SB(sb)-&gt;s_orphan_lock);\n\tif (!list_empty(&amp;EXT4_I(inode)-&gt;i_orphan))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode) ||\n\t\t  S_ISLNK(inode-&gt;i_mode)) || inode-&gt;i_nlink == 0);\n\n\tBUFFER_TRACE(EXT4_SB(sb)-&gt;s_sbh, "get_write_access");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)-&gt;s_sbh);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ext4_reserve_inode_write(handle, inode, &amp;iloc);\n\tif (err)\n\t\tgoto out_unlock;\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (NEXT_ORPHAN(inode) &amp;&amp; NEXT_ORPHAN(inode) &lt;=\n\t\t(le32_to_cpu(EXT4_SB(sb)-&gt;s_es-&gt;s_inodes_count)))\n\t\t\tgoto mem_insert;\n\n\t/* Insert this inode at the head of the on-disk orphan list... */\n\tNEXT_ORPHAN(inode) = le32_to_cpu(EXT4_SB(sb)-&gt;s_es-&gt;s_last_orphan);\n\tEXT4_SB(sb)-&gt;s_es-&gt;s_last_orphan = cpu_to_le32(inode-&gt;i_ino);\n\terr = ext4_handle_dirty_super(handle, sb);\n\trc = ext4_mark_iloc_dirty(handle, inode, &amp;iloc);\n\tif (!err)\n\t\terr = rc;\n\n\t/* Only add to the head of the in-memory list if all the\n\t * previous operations succeeded.  If the orphan_add is going to\n\t * fail (possibly taking the journal offline), we can\'t risk\n\t * leaving the inode on the orphan list: stray orphan-list\n\t * entries can cause panics at unmount time.\n\t *\n\t * This is safe: on error we\'re going to ignore the orphan list\n\t * anyway on the next recovery. */\nmem_insert:\n\tif (!err)\n\t\tlist_add(&amp;EXT4_I(inode)-&gt;i_orphan, &amp;EXT4_SB(sb)-&gt;s_orphan);\n\n\tjbd_debug(4, "superblock will point to %lu\\n", inode-&gt;i_ino);\n\tjbd_debug(4, "orphan inode %lu will point to %d\\n",\n\t\t\tinode-&gt;i_ino, NEXT_ORPHAN(inode));\nout_unlock:\n\tmutex_unlock(&amp;EXT4_SB(sb)-&gt;s_orphan_lock);\n\text4_std_error(inode-&gt;i_sb, err);\n\treturn err;\n}',
 'static int http_proxy_open(URLContext *h, const char *uri, int flags)\n{\n    HTTPContext *s = h-&gt;priv_data;\n    char hostname[1024], hoststr[1024];\n    char auth[1024], pathbuf[1024], *path;\n    char lower_url[100];\n    int port, ret = 0, attempts = 0;\n    HTTPAuthType cur_auth_type;\n    char *authstr;\n    int new_loc;\n\n    if( s-&gt;seekable == 1 )\n        h-&gt;is_streamed = 0;\n    else\n        h-&gt;is_streamed = 1;\n\n    av_url_split(NULL, 0, auth, sizeof(auth), hostname, sizeof(hostname), &amp;port,\n                 pathbuf, sizeof(pathbuf), uri);\n    ff_url_join(hoststr, sizeof(hoststr), NULL, NULL, hostname, port, NULL);\n    path = pathbuf;\n    if (*path == \'/\')\n        path++;\n\n    ff_url_join(lower_url, sizeof(lower_url), "tcp", NULL, hostname, port,\n                NULL);\nredo:\n    ret = ffurl_open_whitelist(&amp;s-&gt;hd, lower_url, AVIO_FLAG_READ_WRITE,\n                               &amp;h-&gt;interrupt_callback, NULL,\n                               h-&gt;protocol_whitelist, h-&gt;protocol_blacklist, h);\n    if (ret &lt; 0)\n        return ret;\n\n    authstr = ff_http_auth_create_response(&amp;s-&gt;proxy_auth_state, auth,\n                                           path, "CONNECT");\n    snprintf(s-&gt;buffer, sizeof(s-&gt;buffer),\n             "CONNECT %s HTTP/1.1\\r\\n"\n             "Host: %s\\r\\n"\n             "Connection: close\\r\\n"\n             "%s%s"\n             "\\r\\n",\n             path,\n             hoststr,\n             authstr ? "Proxy-" : "", authstr ? authstr : "");\n    av_freep(&amp;authstr);\n\n    if ((ret = ffurl_write(s-&gt;hd, s-&gt;buffer, strlen(s-&gt;buffer))) &lt; 0)\n        goto fail;\n\n    s-&gt;buf_ptr    = s-&gt;buffer;\n    s-&gt;buf_end    = s-&gt;buffer;\n    s-&gt;line_count = 0;\n    s-&gt;filesize   = UINT64_MAX;\n    cur_auth_type = s-&gt;proxy_auth_state.auth_type;\n\n    /* Note: This uses buffering, potentially reading more than the\n     * HTTP header. If tunneling a protocol where the server starts\n     * the conversation, we might buffer part of that here, too.\n     * Reading that requires using the proper ffurl_read() function\n     * on this URLContext, not using the fd directly (as the tls\n     * protocol does). This shouldn\'t be an issue for tls though,\n     * since the client starts the conversation there, so there\n     * is no extra data that we might buffer up here.\n     */\n    ret = http_read_header(h, &amp;new_loc);\n    if (ret &lt; 0)\n        goto fail;\n\n    attempts++;\n    if (s-&gt;http_code == 407 &amp;&amp;\n        (cur_auth_type == HTTP_AUTH_NONE || s-&gt;proxy_auth_state.stale) &amp;&amp;\n        s-&gt;proxy_auth_state.auth_type != HTTP_AUTH_NONE &amp;&amp; attempts &lt; 2) {\n        ffurl_closep(&amp;s-&gt;hd);\n        goto redo;\n    }\n\n    if (s-&gt;http_code &lt; 400)\n        return 0;\n    ret = ff_http_averror(s-&gt;http_code, AVERROR(EIO));\n\nfail:\n    http_proxy_close(h);\n    return ret;\n}',
 'struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags-&gt;rqs[tag];\n\t/* mq_ctx of flush rq is always cloned from the corresponding req */\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq-&gt;q, rq-&gt;mq_ctx);\n\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\n\treturn fq-&gt;flush_rq;\n}',
 'void * gdImageGifPtr (gdImagePtr im, int *size)\n{\n  void *rv;\n  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (!_gdImageGifCtx(im, out)) {\n\t\trv = gdDPExtractData(out, size);\n\t} else {\n\t\trv = NULL;\n\t}\n  out-&gt;gd_free (out);\n  return rv;\n}',
 "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key-&gt;type-&gt;read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&amp;key-&gt;sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key-&gt;type-&gt;read(key, buffer, buflen);\n\t\tup_read(&amp;key-&gt;sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
 'pimv2_print(netdissect_options *ndo,\n            register const u_char *bp, register u_int len, const u_char *bp2)\n{\n\tregister const u_char *ep;\n\tregister const struct pim *pim = (const struct pim *)bp;\n\tint advance;\n\tenum checksum_status cksum_status;\n\n\tep = (const u_char *)ndo-&gt;ndo_snapend;\n\tif (bp &gt;= ep)\n\t\treturn;\n\tif (ep &gt; bp + len)\n\t\tep = bp + len;\n\tND_TCHECK(pim-&gt;pim_rsv);\n\tpimv2_addr_len = pim-&gt;pim_rsv;\n\tif (pimv2_addr_len != 0)\n\t\tND_PRINT((ndo, ", RFC2117-encoding"));\n\n\tND_PRINT((ndo, ", cksum 0x%04x ", EXTRACT_16BITS(&amp;pim-&gt;pim_cksum)));\n\tif (EXTRACT_16BITS(&amp;pim-&gt;pim_cksum) == 0) {\n\t\tND_PRINT((ndo, "(unverified)"));\n\t} else {\n\t\tif (PIM_TYPE(pim-&gt;pim_typever) == PIMV2_TYPE_REGISTER) {\n\t\t\t/*\n\t\t\t * The checksum only covers the packet header,\n\t\t\t * not the encapsulated packet.\n\t\t\t */\n\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, 8);\n\t\t\tif (cksum_status == INCORRECT) {\n\t\t\t\t/*\n\t\t\t\t * To quote RFC 4601, "For interoperability\n\t\t\t\t * reasons, a message carrying a checksum\n\t\t\t\t * calculated over the entire PIM Register\n\t\t\t\t * message should also be accepted."\n\t\t\t\t */\n\t\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, len);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The checksum covers the entire packet.\n\t\t\t */\n\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, len);\n\t\t}\n\t\tswitch (cksum_status) {\n\n\t\tcase CORRECT:\n\t\t\tND_PRINT((ndo, "(correct)"));\n\t\t\tbreak;\n\n\t\tcase INCORRECT:\n\t\t\tND_PRINT((ndo, "(incorrect)"));\n\t\t\tbreak;\n\n\t\tcase UNVERIFIED:\n\t\t\tND_PRINT((ndo, "(unverified)"));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (PIM_TYPE(pim-&gt;pim_typever)) {\n\tcase PIMV2_TYPE_HELLO:\n\t    {\n\t\tuint16_t otype, olen;\n\t\tbp += 4;\n\t\twhile (bp &lt; ep) {\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\totype = EXTRACT_16BITS(&amp;bp[0]);\n\t\t\tolen = EXTRACT_16BITS(&amp;bp[2]);\n\t\t\tND_TCHECK2(bp[0], 4 + olen);\n\t\t\tND_PRINT((ndo, "\\n\\t  %s Option (%u), length %u, Value: ",\n\t\t\t          tok2str(pimv2_hello_option_values, "Unknown", otype),\n\t\t\t          otype,\n\t\t\t          olen));\n\t\t\tbp += 4;\n\n\t\t\tswitch (otype) {\n\t\t\tcase PIMV2_HELLO_OPTION_HOLDTIME:\n\t\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_LANPRUNEDELAY:\n\t\t\t\tif (olen != 4) {\n\t\t\t\t\tND_PRINT((ndo, "ERROR: Option Length != 4 Bytes (%u)", olen));\n\t\t\t\t} else {\n\t\t\t\t\tchar t_bit;\n\t\t\t\t\tuint16_t lan_delay, override_interval;\n\t\t\t\t\tlan_delay = EXTRACT_16BITS(bp);\n\t\t\t\t\toverride_interval = EXTRACT_16BITS(bp+2);\n\t\t\t\t\tt_bit = (lan_delay &amp; 0x8000)? 1 : 0;\n\t\t\t\t\tlan_delay &amp;= ~0x8000;\n\t\t\t\t\tND_PRINT((ndo, "\\n\\t    T-bit=%d, LAN delay %dms, Override interval %dms",\n\t\t\t\t\tt_bit, lan_delay, override_interval));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_DR_PRIORITY_OLD:\n\t\t\tcase PIMV2_HELLO_OPTION_DR_PRIORITY:\n\t\t\t\tswitch (olen) {\n\t\t\t\tcase 0:\n\t\t\t\t\tND_PRINT((ndo, "Bi-Directional Capability (Old)"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tND_PRINT((ndo, "%u", EXTRACT_32BITS(bp)));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, "ERROR: Option Length != 4 Bytes (%u)", olen));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_GENID:\n\t\t\t\tND_PRINT((ndo, "0x%08x", EXTRACT_32BITS(bp)));\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_REFRESH_CAP:\n\t\t\t\tND_PRINT((ndo, "v%d", *bp));\n\t\t\t\tif (*(bp+1) != 0) {\n\t\t\t\t\tND_PRINT((ndo, ", interval "));\n\t\t\t\t\tunsigned_relts_print(ndo, *(bp+1));\n\t\t\t\t}\n\t\t\t\tif (EXTRACT_16BITS(bp+2) != 0) {\n\t\t\t\t\tND_PRINT((ndo, " ?0x%04x?", EXTRACT_16BITS(bp+2)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase  PIMV2_HELLO_OPTION_BIDIR_CAP:\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_ADDRESS_LIST_OLD:\n\t\t\tcase PIMV2_HELLO_OPTION_ADDRESS_LIST:\n\t\t\t\tif (ndo-&gt;ndo_vflag &gt; 1) {\n\t\t\t\t\tconst u_char *ptr = bp;\n\t\t\t\t\twhile (ptr &lt; (bp+olen)) {\n\t\t\t\t\t\tND_PRINT((ndo, "\\n\\t    "));\n\t\t\t\t\t\tadvance = pimv2_addr_print(ndo, ptr, pimv2_unicast, 0);\n\t\t\t\t\t\tif (advance &lt; 0) {\n\t\t\t\t\t\t\tND_PRINT((ndo, "..."));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tptr += advance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ndo-&gt;ndo_vflag &lt;= 1)\n\t\t\t\t\tprint_unknown_data(ndo, bp, "\\n\\t    ", olen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* do we want to see an additionally hexdump ? */\n\t\t\tif (ndo-&gt;ndo_vflag&gt; 1)\n\t\t\t\tprint_unknown_data(ndo, bp, "\\n\\t    ", olen);\n\t\t\tbp += olen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tcase PIMV2_TYPE_REGISTER:\n\t{\n\t\tconst struct ip *ip;\n\n\t\tND_TCHECK2(*(bp + 4), PIMV2_REGISTER_FLAG_LEN);\n\n\t\tND_PRINT((ndo, ", Flags [ %s ]\\n\\t",\n\t\t          tok2str(pimv2_register_flag_values,\n\t\t          "none",\n\t\t          EXTRACT_32BITS(bp+4))));\n\n\t\tbp += 8; len -= 8;\n\t\t/* encapsulated multicast packet */\n\t\tip = (const struct ip *)bp;\n\t\tswitch (IP_V(ip)) {\n                case 0: /* Null header */\n\t\t\tND_PRINT((ndo, "IP-Null-header %s &gt; %s",\n\t\t\t          ipaddr_string(ndo, &amp;ip-&gt;ip_src),\n\t\t\t          ipaddr_string(ndo, &amp;ip-&gt;ip_dst)));\n\t\t\tbreak;\n\n\t\tcase 4:\t/* IPv4 */\n\t\t\tip_print(ndo, bp, len);\n\t\t\tbreak;\n\n\t\tcase 6:\t/* IPv6 */\n\t\t\tip6_print(ndo, bp, len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tND_PRINT((ndo, "IP ver %d", IP_V(ip)));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PIMV2_TYPE_REGISTER_STOP:\n\t\tbp += 4; len -= 4;\n\t\tif (bp &gt;= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, " group="));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) &lt; 0) {\n\t\t\tND_PRINT((ndo, "..."));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp &gt;= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, " source="));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) &lt; 0) {\n\t\t\tND_PRINT((ndo, "..."));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tbreak;\n\n\tcase PIMV2_TYPE_JOIN_PRUNE:\n\tcase PIMV2_TYPE_GRAFT:\n\tcase PIMV2_TYPE_GRAFT_ACK:\n\n\n        /*\n         * 0                   1                   2                   3\n         *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |PIM Ver| Type  | Addr length   |           Checksum            |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |             Unicast-Upstream Neighbor Address                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |  Reserved     | Num groups    |          Holdtime             |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |            Encoded-Multicast Group Address-1                  |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |   Number of Joined  Sources   |   Number of Pruned Sources    |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Joined Source Address-1                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                             .                                 |\n         *  |                             .                                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Joined Source Address-n                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Pruned Source Address-1                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                             .                                 |\n         *  |                             .                                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Pruned Source Address-n                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                           .                                   |\n         *  |                           .                                   |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                Encoded-Multicast Group Address-n              |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         */\n\n\t    {\n\t\tuint8_t ngroup;\n\t\tuint16_t holdtime;\n\t\tuint16_t njoin;\n\t\tuint16_t nprune;\n\t\tint i, j;\n\n\t\tbp += 4; len -= 4;\n\t\tif (PIM_TYPE(pim-&gt;pim_typever) != 7) {\t/*not for Graft-ACK*/\n\t\t\tif (bp &gt;= ep)\n\t\t\t\tbreak;\n\t\t\tND_PRINT((ndo, ", upstream-neighbor: "));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) &lt; 0) {\n\t\t\t\tND_PRINT((ndo, "..."));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp += advance; len -= advance;\n\t\t}\n\t\tif (bp + 4 &gt; ep)\n\t\t\tbreak;\n\t\tngroup = bp[1];\n\t\tholdtime = EXTRACT_16BITS(&amp;bp[2]);\n\t\tND_PRINT((ndo, "\\n\\t  %u group(s)", ngroup));\n\t\tif (PIM_TYPE(pim-&gt;pim_typever) != 7) {\t/*not for Graft-ACK*/\n\t\t\tND_PRINT((ndo, ", holdtime: "));\n\t\t\tif (holdtime == 0xffff)\n\t\t\t\tND_PRINT((ndo, "infinite"));\n\t\t\telse\n\t\t\t\tunsigned_relts_print(ndo, holdtime);\n\t\t}\n\t\tbp += 4; len -= 4;\n\t\tfor (i = 0; i &lt; ngroup; i++) {\n\t\t\tif (bp &gt;= ep)\n\t\t\t\tgoto jp_done;\n\t\t\tND_PRINT((ndo, "\\n\\t    group #%u: ", i+1));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) &lt; 0) {\n\t\t\t\tND_PRINT((ndo, "...)"));\n\t\t\t\tgoto jp_done;\n\t\t\t}\n\t\t\tbp += advance; len -= advance;\n\t\t\tif (bp + 4 &gt; ep) {\n\t\t\t\tND_PRINT((ndo, "...)"));\n\t\t\t\tgoto jp_done;\n\t\t\t}\n\t\t\tnjoin = EXTRACT_16BITS(&amp;bp[0]);\n\t\t\tnprune = EXTRACT_16BITS(&amp;bp[2]);\n\t\t\tND_PRINT((ndo, ", joined sources: %u, pruned sources: %u", njoin, nprune));\n\t\t\tbp += 4; len -= 4;\n\t\t\tfor (j = 0; j &lt; njoin; j++) {\n\t\t\t\tND_PRINT((ndo, "\\n\\t      joined source #%u: ", j+1));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_source, 0)) &lt; 0) {\n\t\t\t\t\tND_PRINT((ndo, "...)"));\n\t\t\t\t\tgoto jp_done;\n\t\t\t\t}\n\t\t\t\tbp += advance; len -= advance;\n\t\t\t}\n\t\t\tfor (j = 0; j &lt; nprune; j++) {\n\t\t\t\tND_PRINT((ndo, "\\n\\t      pruned source #%u: ", j+1));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_source, 0)) &lt; 0) {\n\t\t\t\t\tND_PRINT((ndo, "...)"));\n\t\t\t\t\tgoto jp_done;\n\t\t\t\t}\n\t\t\t\tbp += advance; len -= advance;\n\t\t\t}\n\t\t}\n\tjp_done:\n\t\tbreak;\n\t    }\n\n\tcase PIMV2_TYPE_BOOTSTRAP:\n\t{\n\t\tint i, j, frpcnt;\n\t\tbp += 4;\n\n\t\t/* Fragment Tag, Hash Mask len, and BSR-priority */\n\t\tif (bp + sizeof(uint16_t) &gt;= ep) break;\n\t\tND_PRINT((ndo, " tag=%x", EXTRACT_16BITS(bp)));\n\t\tbp += sizeof(uint16_t);\n\t\tif (bp &gt;= ep) break;\n\t\tND_PRINT((ndo, " hashmlen=%d", bp[0]));\n\t\tif (bp + 1 &gt;= ep) break;\n\t\tND_PRINT((ndo, " BSRprio=%d", bp[1]));\n\t\tbp += 2;\n\n\t\t/* Encoded-Unicast-BSR-Address */\n\t\tif (bp &gt;= ep) break;\n\t\tND_PRINT((ndo, " BSR="));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) &lt; 0) {\n\t\t\tND_PRINT((ndo, "..."));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\n\t\tfor (i = 0; bp &lt; ep; i++) {\n\t\t\t/* Encoded-Group Address */\n\t\t\tND_PRINT((ndo, " (group%d: ", i));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0))\n\t\t\t    &lt; 0) {\n\t\t\t\tND_PRINT((ndo, "...)"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tbp += advance;\n\n\t\t\t/* RP-Count, Frag RP-Cnt, and rsvd */\n\t\t\tif (bp &gt;= ep) {\n\t\t\t\tND_PRINT((ndo, "...)"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tND_PRINT((ndo, " RPcnt=%d", bp[0]));\n\t\t\tif (bp + 1 &gt;= ep) {\n\t\t\t\tND_PRINT((ndo, "...)"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tND_PRINT((ndo, " FRPcnt=%d", frpcnt = bp[1]));\n\t\t\tbp += 4;\n\n\t\t\tfor (j = 0; j &lt; frpcnt &amp;&amp; bp &lt; ep; j++) {\n\t\t\t\t/* each RP info */\n\t\t\t\tND_PRINT((ndo, " RP%d=", j));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp,\n\t\t\t\t\t\t\t\tpimv2_unicast,\n\t\t\t\t\t\t\t\t0)) &lt; 0) {\n\t\t\t\t\tND_PRINT((ndo, "...)"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tbp += advance;\n\n\t\t\t\tif (bp + 1 &gt;= ep) {\n\t\t\t\t\tND_PRINT((ndo, "...)"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, ",holdtime="));\n\t\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\t\t\tif (bp + 2 &gt;= ep) {\n\t\t\t\t\tND_PRINT((ndo, "...)"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, ",prio=%d", bp[2]));\n\t\t\t\tbp += 4;\n\t\t\t}\n\t\t\tND_PRINT((ndo, ")"));\n\t\t}\n\t   bs_done:\n\t\tbreak;\n\t}\n\tcase PIMV2_TYPE_ASSERT:\n\t\tbp += 4; len -= 4;\n\t\tif (bp &gt;= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, " group="));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) &lt; 0) {\n\t\t\tND_PRINT((ndo, "..."));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp &gt;= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, " src="));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) &lt; 0) {\n\t\t\tND_PRINT((ndo, "..."));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp + 8 &gt; ep)\n\t\t\tbreak;\n\t\tif (bp[0] &amp; 0x80)\n\t\t\tND_PRINT((ndo, " RPT"));\n\t\tND_PRINT((ndo, " pref=%u", EXTRACT_32BITS(&amp;bp[0]) &amp; 0x7fffffff));\n\t\tND_PRINT((ndo, " metric=%u", EXTRACT_32BITS(&amp;bp[4])));\n\t\tbreak;\n\n\tcase PIMV2_TYPE_CANDIDATE_RP:\n\t{\n\t\tint i, pfxcnt;\n\t\tbp += 4;\n\n\t\t/* Prefix-Cnt, Priority, and Holdtime */\n\t\tif (bp &gt;= ep) break;\n\t\tND_PRINT((ndo, " prefix-cnt=%d", bp[0]));\n\t\tpfxcnt = bp[0];\n\t\tif (bp + 1 &gt;= ep) break;\n\t\tND_PRINT((ndo, " prio=%d", bp[1]));\n\t\tif (bp + 3 &gt;= ep) break;\n\t\tND_PRINT((ndo, " holdtime="));\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&amp;bp[2]));\n\t\tbp += 4;\n\n\t\t/* Encoded-Unicast-RP-Address */\n\t\tif (bp &gt;= ep) break;\n\t\tND_PRINT((ndo, " RP="));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) &lt; 0) {\n\t\t\tND_PRINT((ndo, "..."));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\n\t\t/* Encoded-Group Addresses */\n\t\tfor (i = 0; i &lt; pfxcnt &amp;&amp; bp &lt; ep; i++) {\n\t\t\tND_PRINT((ndo, " Group%d=", i));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0))\n\t\t\t    &lt; 0) {\n\t\t\t\tND_PRINT((ndo, "..."));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp += advance;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PIMV2_TYPE_PRUNE_REFRESH:\n\t\tND_PRINT((ndo, " src="));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) &lt; 0) {\n\t\t\tND_PRINT((ndo, "..."));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_PRINT((ndo, " grp="));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) &lt; 0) {\n\t\t\tND_PRINT((ndo, "..."));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_PRINT((ndo, " forwarder="));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) &lt; 0) {\n\t\t\tND_PRINT((ndo, "..."));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_TCHECK2(bp[0], 2);\n\t\tND_PRINT((ndo, " TUNR "));\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\tbreak;\n\n\n\t default:\n\t\tND_PRINT((ndo, " [type %d]", PIM_TYPE(pim-&gt;pim_typever)));\n\t\tbreak;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, "[|pim]"));\n}',
 'TEST(DenseOpticalFlow_DIS, InvalidImgSize_CoarsestLevelLessThanZero)\n{\n    cv::Ptr&lt;cv::DISOpticalFlow&gt; of = cv::DISOpticalFlow::create();\n    const int mat_size = 10;\n\n    cv::Mat x(mat_size, mat_size, CV_8UC1, 42);\n    cv::Mat y(mat_size, mat_size, CV_8UC1, 42);\n    cv::Mat flow;\n\n    ASSERT_THROW(of-&gt;calc(x, y, flow), cv::Exception);\n}',
 'service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (table &amp;&amp;\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &amp;parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table-&gt;serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger-&gt;eventURL) {\n\t\t\t\tif (parse_uri(finger-&gt;eventURL,\n\t\t\t\t\t    strlen(finger-&gt;eventURL),\n\t\t\t\t\t    &amp;parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&amp;parsed_url.pathquery,\n\t\t\t\t\t\t    &amp;parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger-&gt;next;\n\t\t}\n\t}\n\n\treturn NULL;\n}',
 'obj2ast_mod(PyObject* obj, mod_ty* out, PyArena* arena)\n{\n    int isinstance;\n\n    PyObject *tmp = NULL;\n\n    if (obj == Py_None) {\n        *out = NULL;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Module_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* body;\n\n        if (_PyObject_LookupAttrId(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from Module");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Module field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Py_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Module field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Module(body, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Interactive_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* body;\n\n        if (_PyObject_LookupAttrId(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from Interactive");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Interactive field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Py_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Interactive field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Interactive(body, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Expression_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        expr_ty body;\n\n        if (_PyObject_LookupAttrId(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from Expression");\n            return 1;\n        }\n        else {\n            int res;\n            res = obj2ast_expr(tmp, &amp;body, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        }\n        *out = Expression(body, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)Suite_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        asdl_seq* body;\n\n        if (_PyObject_LookupAttrId(obj, &amp;PyId_body, &amp;tmp) &lt; 0) {\n            return 1;\n        }\n        if (tmp == NULL) {\n            PyErr_SetString(PyExc_TypeError, "required field \\"body\\" missing from Suite");\n            return 1;\n        }\n        else {\n            int res;\n            Py_ssize_t len;\n            Py_ssize_t i;\n            if (!PyList_Check(tmp)) {\n                PyErr_Format(PyExc_TypeError, "Suite field \\"body\\" must be a list, not a %.200s", tmp-&gt;ob_type-&gt;tp_name);\n                goto failed;\n            }\n            len = PyList_GET_SIZE(tmp);\n            body = _Py_asdl_seq_new(len, arena);\n            if (body == NULL) goto failed;\n            for (i = 0; i &lt; len; i++) {\n                stmt_ty val;\n                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &amp;val, arena);\n                if (res != 0) goto failed;\n                if (len != PyList_GET_SIZE(tmp)) {\n                    PyErr_SetString(PyExc_RuntimeError, "Suite field \\"body\\" changed size during iteration");\n                    goto failed;\n                }\n                asdl_seq_SET(body, i, val);\n            }\n            Py_CLEAR(tmp);\n        }\n        *out = Suite(body, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n\n    PyErr_Format(PyExc_TypeError, "expected some sort of mod, but got %R", obj);\n    failed:\n    Py_XDECREF(tmp);\n    return 1;\n}',
 "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_sample_name(file-&gt;mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval&gt;=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}",
 'void test_parser(void) {\n\ttest_parser_param(0);\n}',
 'GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts&gt;1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &amp;et, &amp;sd, &amp;mt, &amp;em);\n\t\tif ((nbEdts&gt;2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[rtp hinter] Cannot hint track whith EditList\\n"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions &amp; co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there\'s only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) &gt; 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd &amp;&amp; esd-&gt;decoderConfig) {\n\t\t\t\tstreamType = esd-&gt;decoderConfig-&gt;streamType;\n\t\t\t\tcodecid = esd-&gt;decoderConfig-&gt;objectTypeIndication;\n\t\t\t\tif (esd-&gt;URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&amp;&amp; esd-&gt;decoderConfig-&gt;decoderSpecificInfo &amp;&amp; esd-&gt;decoderConfig-&gt;decoderSpecificInfo-&gt;data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        &amp;&amp; ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd-&gt;decoderConfig-&gt;decoderSpecificInfo-&gt;data, esd-&gt;decoderConfig-&gt;decoderSpecificInfo-&gt;dataLength, &amp;a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags &amp; GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = "AAC";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = "CELP";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) &amp;&amp; ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp &amp;&amp; (samp-&gt;dataLength&gt;3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp-&gt;data[0], (u8)samp-&gt;data[1], (u8)samp-&gt;data[2], (u8)samp-&gt;data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &amp;sample_rate, &amp;nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&amp;samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) &amp;&amp; (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) &amp;&amp; ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) &amp;&amp; esd-&gt;decoderConfig-&gt;decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd-&gt;decoderConfig-&gt;decoderSpecificInfo-&gt;data, esd-&gt;decoderConfig-&gt;decoderSpecificInfo-&gt;dataLength, &amp;dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid&gt;=GF_CODECID_MPEG2_SIMPLE) &amp;&amp; (codecid&lt;=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that\'s another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &amp;= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc &amp;&amp; !svcc &amp;&amp; !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* "90 kHz clock rate MUST be used"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc-&gt;nal_unit_size : svcc ? svcc-&gt;nal_unit_size : mvcc-&gt;nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* "90 kHz clock rate MUST be used"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc-&gt;nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &amp;nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp &amp;&amp; (samp-&gt;dataLength&gt;3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp-&gt;data[0], (u8)samp-&gt;data[1], (u8)samp-&gt;data[2], (u8)samp-&gt;data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &amp;required_rate, &amp;nb_ch, &amp;bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&amp;samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &amp;url, &amp;urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping &amp;&amp; (flags &amp; GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID &amp;&amp; (flags &amp; GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp-&gt;file = file;\n\ttmp-&gt;TrackNum = TrackNum;\n\ttmp-&gt;avc_nalu_size = avc_nalu_size;\n\ttmp-&gt;nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp-&gt;has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &amp;MinSize, &amp;MaxSize, &amp;avgTS, &amp;maxDTSDelta, &amp;const_dur, &amp;bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags &amp; GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags &amp; GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp-&gt;has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&amp;my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength&gt;16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &amp;use_sel_enc, &amp;IV_length, &amp;KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp-&gt;OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp-&gt;rtp_p = gf_rtp_builder_new(hintType, &amp;my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp-&gt;rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp-&gt;rtp_p-&gt;slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp-&gt;TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp-&gt;HintID = tmp-&gt;TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp-&gt;HintID)) tmp-&gt;HintID++;\n\n\ttmp-&gt;HintTrack = gf_isom_new_track(file, tmp-&gt;HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp-&gt;HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp-&gt;HintTrack, -1, -1, 0, &amp;descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp-&gt;HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp-&gt;rtp_p-&gt;slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\t*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &amp;my_sl);\n\t\tif (*e) {\n\t\t\tgf_hinter_track_del(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp-&gt;bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don\'t copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp-&gt;HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp-&gt;HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp-&gt;HintTrack, InterleaveGroupPriority);\n\n#if 0\n#endif\n\t*e = GF_OK;\n\treturn tmp;\n}',
 'static Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) {\n\tVar* var = calloc (1, sizeof (*var));\n\tif (!var) {\n\t\tpe_printf ("Warning: calloc (Var)\\n");\n\t\treturn NULL;\n\t}\n\tif ((var-&gt;wLength = r_buf_read_le16_at (pe-&gt;b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf ("Warning: read (Var wLength)\\n");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (var-&gt;wLength);\n\tif ((var-&gt;wValueLength = r_buf_read_le16_at (pe-&gt;b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf ("Warning: read (Var wValueLength)\\n");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (var-&gt;wValueLength);\n\tif ((var-&gt;wType = r_buf_read_le16_at (pe-&gt;b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf ("Warning: read (Var wType)\\n");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (var-&gt;wType);\n\tif (var-&gt;wType != 0 &amp;&amp; var-&gt;wType != 1) {\n\t\tpe_printf ("Warning: check (Var wType)\\n");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\n\tvar-&gt;szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  //L"Translation"\n\tif (!var-&gt;szKey) {\n\t\tpe_printf ("Warning: malloc (Var szKey)\\n");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (pe-&gt;b, *curAddr, (ut8*) var-&gt;szKey, TRANSLATION_UTF_16_LEN) &lt; 1) {\n\t\tpe_printf ("Warning: read (Var szKey)\\n");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += TRANSLATION_UTF_16_LEN;\n\tif (memcmp (var-&gt;szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {\n\t\tpe_printf ("Warning: check (Var szKey)\\n");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\talign32 (*curAddr);\n\tvar-&gt;numOfValues = var-&gt;wValueLength / 4;\n\tif (!var-&gt;numOfValues) {\n\t\tpe_printf ("Warning: check (Var numOfValues)\\n");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tvar-&gt;Value = (ut32*) malloc (var-&gt;wValueLength);\n\tif (!var-&gt;Value) {\n\t\tpe_printf ("Warning: malloc (Var Value)\\n");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (pe-&gt;b, *curAddr, (ut8*) var-&gt;Value, var-&gt;wValueLength) != var-&gt;wValueLength) {\n\t\tpe_printf ("Warning: read (Var Value)\\n");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += var-&gt;wValueLength;\n\treturn var;\n}',
 "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\n\tfor (p = path; p; p = p-&gt;up) {\n\t\tif (p-&gt;elem_len)\n\t\t\tlen += p-&gt;elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p-&gt;up) {\n\t\tif (p-&gt;elem_len) {\n\t\t\tm -= p-&gt;elem_len + 1;\n\t\t\tmemcpy(m, p-&gt;elem, p-&gt;elem_len);\n\t\t\tm[p-&gt;elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}",
 'static void nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tUINT16 i;\n\tBYTE* rle;\n\tUINT32 planeSize;\n\tUINT32 originalSize;\n\trle = context-&gt;Planes;\n\n\tfor (i = 0; i &lt; 4; i++)\n\t{\n\t\toriginalSize = context-&gt;OrgByteCount[i];\n\t\tplaneSize = context-&gt;PlaneByteCount[i];\n\n\t\tif (planeSize == 0)\n\t\t\tFillMemory(context-&gt;priv-&gt;PlaneBuffers[i], originalSize, 0xFF);\n\t\telse if (planeSize &lt; originalSize)\n\t\t\tnsc_rle_decode(rle, context-&gt;priv-&gt;PlaneBuffers[i], originalSize);\n\t\telse\n\t\t\tCopyMemory(context-&gt;priv-&gt;PlaneBuffers[i], rle, originalSize);\n\n\t\trle += planeSize;\n\t}\n}',
 'int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n\t/* Init keys */\n\tinit_keys(&amp;key_size, cipher_key, cmac_key, iv);\n\n\t/* Init periph */\n\tat91_aes_init();\n\n\t/* Check signature if required */\n\tif (is_signed) {\n\t\t/* Compute the CMAC */\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\t/* Check the CMAC */\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\t/* Decrypt the whole file */\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\t/* Reset periph */\n\tat91_aes_cleanup();\n\n\t/* Reset keys */\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\n\treturn rc;\n}',
 'void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tspin_lock(&amp;unix_gc_lock);\n\t\tBUG_ON(list_empty(&amp;u-&gt;link));\n\n\t\tif (atomic_long_dec_and_test(&amp;u-&gt;inflight))\n\t\t\tlist_del_init(&amp;u-&gt;link);\n\t\tunix_tot_inflight--;\n\t\tspin_unlock(&amp;unix_gc_lock);\n\t}\n}',
 'image_load_bmp(image_t *img,\t/* I - Image to load into */\n               FILE    *fp,\t/* I - File to read from */\n\t       int     gray,\t/* I - Grayscale image? */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  int\t\tinfo_size,\t/* Size of info header */\n\t\tdepth,\t\t/* Depth of image (bits) */\n\t\tcompression,\t/* Type of compression */\n\t\tcolors_used,\t/* Number of colors used */\n\t\tx, y,\t\t/* Looping vars */\n\t\tcolor,\t\t/* Color of RLE pixel */\n\t\tcount,\t\t/* Number of times to repeat */\n\t\ttemp,\t\t/* Temporary color */\n\t\talign;\t\t/* Alignment bytes */\n  uchar\t\tbit,\t\t/* Bit in image */\n\t\tbyte;\t\t/* Byte in image */\n  uchar\t\t*ptr;\t\t/* Pointer into pixels */\n  uchar\t\tcolormap[256][4];/* Colormap */\n\n\n  // Get the header...\n  getc(fp);\t\t\t/* Skip "BM" sync chars */\n  getc(fp);\n  read_dword(fp);\t\t/* Skip size */\n  read_word(fp);\t\t/* Skip reserved stuff */\n  read_word(fp);\n  read_dword(fp);\n\n  // Then the bitmap information...\n  info_size        = (int)read_dword(fp);\n  img-&gt;width       = read_long(fp);\n  img-&gt;height      = read_long(fp);\n  read_word(fp);\n  depth            = read_word(fp);\n  compression      = (int)read_dword(fp);\n  read_dword(fp);\n  read_long(fp);\n  read_long(fp);\n  colors_used      = (int)read_dword(fp);\n  read_dword(fp);\n\n  if (img-&gt;width &lt;= 0 || img-&gt;width &gt; 8192 || img-&gt;height &lt;= 0 || img-&gt;height &gt; 8192)\n    return (-1);\n\n  if (info_size &gt; 40)\n    for (info_size -= 40; info_size &gt; 0; info_size --)\n      getc(fp);\n\n  // Get colormap...\n  if (colors_used == 0 &amp;&amp; depth &lt;= 8)\n    colors_used = 1 &lt;&lt; depth;\n\n  fread(colormap, (size_t)colors_used, 4, fp);\n\n  // Setup image and buffers...\n  img-&gt;depth = gray ? 1 : 3;\n\n  // If this image is indexed and we are writing an encrypted PDF file, bump the use count so\n  // we create an image object (Acrobat 6 bug workaround)\n  if (depth &lt;= 8 &amp;&amp; Encryption)\n    img-&gt;use ++;\n\n  // Return now if we only need the dimensions...\n  if (!load_data)\n    return (0);\n\n  img-&gt;pixels = (uchar *)malloc((size_t)(img-&gt;width * img-&gt;height * img-&gt;depth));\n  if (img-&gt;pixels == NULL)\n    return (-1);\n\n  if (gray &amp;&amp; depth &lt;= 8)\n  {\n    // Convert colormap to grayscale...\n    for (color = colors_used - 1; color &gt;= 0; color --)\n      colormap[color][0] = (colormap[color][2] * 31 +\n                            colormap[color][1] * 61 +\n                            colormap[color][0] * 8) / 100;\n  }\n\n  // Read the image data...\n  color = 0;\n  count = 0;\n  align = 0;\n  byte  = 0;\n  temp  = 0;\n\n  for (y = img-&gt;height - 1; y &gt;= 0; y --)\n  {\n    ptr = img-&gt;pixels + y * img-&gt;width * img-&gt;depth;\n\n    switch (depth)\n    {\n      case 1 : /* Bitmap */\n          for (x = img-&gt;width, bit = 128; x &gt; 0; x --)\n\t  {\n\t    if (bit == 128)\n\t      byte = (uchar)getc(fp);\n\n\t    if (byte &amp; bit)\n\t    {\n\t      if (!gray)\n\t      {\n\t\t*ptr++ = colormap[1][2];\n\t\t*ptr++ = colormap[1][1];\n              }\n\n\t      *ptr++ = colormap[1][0];\n\t    }\n\t    else\n\t    {\n\t      if (!gray)\n\t      {\n\t\t*ptr++ = colormap[0][2];\n\t\t*ptr++ = colormap[0][1];\n\t      }\n\n\t      *ptr++ = colormap[0][0];\n\t    }\n\n\t    if (bit &gt; 1)\n\t      bit &gt;&gt;= 1;\n\t    else\n\t      bit = 128;\n\t  }\n\n         /*\n\t  * Read remaining bytes to align to 32 bits...\n\t  */\n\n\t  for (temp = (img-&gt;width + 7) / 8; temp &amp; 3; temp ++)\n\t    getc(fp);\n          break;\n\n      case 4 : /* 16-color */\n          for (x = img-&gt;width, bit = 0xf0; x &gt; 0; x --)\n\t  {\n\t   /*\n\t    * Get a new count as needed...\n\t    */\n\n            if (compression != BI_RLE4 &amp;&amp; count == 0)\n\t    {\n\t      count = 2;\n\t      color = -1;\n            }\n\n\t    if (count == 0)\n\t    {\n\t      while (align &gt; 0)\n\t      {\n\t        align --;\n\t\tgetc(fp);\n              }\n\n\t      if ((count = getc(fp)) == 0)\n\t      {\n\t\tif ((count = getc(fp)) == 0)\n\t\t{\n\t\t /*\n\t\t  * End of line...\n\t\t  */\n\n                  x ++;\n\t\t  continue;\n\t\t}\n\t\telse if (count == 1)\n\t\t{\n\t\t /*\n\t\t  * End of image...\n\t\t  */\n\n\t\t  break;\n\t\t}\n\t\telse if (count == 2)\n\t\t{\n\t\t /*\n\t\t  * Delta...\n\t\t  */\n\n\t\t  count = getc(fp) * getc(fp) * img-&gt;width;\n\t\t  color = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t /*\n\t\t  * Absolute...\n\t\t  */\n\n\t\t  color = -1;\n\t\t  align = ((4 - (count &amp; 3)) / 2) &amp; 1;\n\t\t}\n\t      }\n\t      else\n\t        color = getc(fp);\n            }\n\n           /*\n\t    * Get a new color as needed...\n\t    */\n\n\t    count --;\n\n            if (bit == 0xf0)\n\t    {\n              if (color &lt; 0)\n\t\ttemp = getc(fp) &amp; 255;\n\t      else\n\t\ttemp = color;\n\n             /*\n\t      * Copy the color value...\n\t      */\n\n              if (!gray)\n\t      {\n\t\t*ptr++ = colormap[temp &gt;&gt; 4][2];\n\t\t*ptr++ = colormap[temp &gt;&gt; 4][1];\n              }\n\n\t      *ptr++ = colormap[temp &gt;&gt; 4][0];\n\t      bit    = 0x0f;\n            }\n\t    else\n\t    {\n             /*\n\t      * Copy the color value...\n\t      */\n\n\t      if (!gray)\n\t      {\n\t        *ptr++ = colormap[temp &amp; 15][2];\n\t        *ptr++ = colormap[temp &amp; 15][1];\n\t      }\n\n\t      *ptr++ = colormap[temp &amp; 15][0];\n\t      bit    = 0xf0;\n\t    }\n\t  }\n          break;\n\n      case 8 : /* 256-color */\n          for (x = img-&gt;width; x &gt; 0; x --)\n\t  {\n\t   /*\n\t    * Get a new count as needed...\n\t    */\n\n            if (compression != BI_RLE8)\n\t    {\n\t      count = 1;\n\t      color = -1;\n            }\n\n\t    if (count == 0)\n\t    {\n\t      while (align &gt; 0)\n\t      {\n\t        align --;\n\t\tgetc(fp);\n              }\n\n\t      if ((count = getc(fp)) == 0)\n\t      {\n\t\tif ((count = getc(fp)) == 0)\n\t\t{\n\t\t /*\n\t\t  * End of line...\n\t\t  */\n\n                  x ++;\n\t\t  continue;\n\t\t}\n\t\telse if (count == 1)\n\t\t{\n\t\t /*\n\t\t  * End of image...\n\t\t  */\n\n\t\t  break;\n\t\t}\n\t\telse if (count == 2)\n\t\t{\n\t\t /*\n\t\t  * Delta...\n\t\t  */\n\n\t\t  count = getc(fp) * getc(fp) * img-&gt;width;\n\t\t  color = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t /*\n\t\t  * Absolute...\n\t\t  */\n\n\t\t  color = -1;\n\t\t  align = (2 - (count &amp; 1)) &amp; 1;\n\t\t}\n\t      }\n\t      else\n\t        color = getc(fp);\n            }\n\n           /*\n\t    * Get a new color as needed...\n\t    */\n\n            if (color &lt; 0)\n\t      temp = getc(fp);\n\t    else\n\t      temp = color;\n\n            count --;\n\n           /*\n\t    * Copy the color value...\n\t    */\n\n            if (!gray)\n\t    {\n\t      *ptr++ = colormap[temp][2];\n\t      *ptr++ = colormap[temp][1];\n\t    }\n\n\t    *ptr++ = colormap[temp][0];\n\t  }\n          break;\n\n      case 24 : /* 24-bit RGB */\n          if (gray)\n\t  {\n            for (x = img-&gt;width; x &gt; 0; x --)\n\t    {\n\t      temp = getc(fp) * 8;\n\t      temp += getc(fp) * 61;\n\t      temp += getc(fp) * 31;\n\t      *ptr++ = (uchar)(temp / 100);\n\t    }\n\t  }\n\t  else\n\t  {\n            for (x = img-&gt;width; x &gt; 0; x --, ptr += 3)\n\t    {\n\t      ptr[2] = (uchar)getc(fp);\n\t      ptr[1] = (uchar)getc(fp);\n\t      ptr[0] = (uchar)getc(fp);\n\t    }\n          }\n\n         /*\n\t  * Read remaining bytes to align to 32 bits...\n\t  */\n\n\t  for (temp = img-&gt;width * 3; temp &amp; 3; temp ++)\n\t    getc(fp);\n          break;\n    }\n  }\n\n  return (0);\n}',
 'int crypto_scrypt(const uint8_t* password, size_t pwlen, const uint8_t* salt,\n                  size_t saltlen, uint64_t N, uint32_t r, uint32_t p,\n                  uint8_t* buf, size_t buflen) {\n  return crypto_pwhash_scryptsalsa208sha256_ll(password, pwlen, salt, saltlen,\n                                               N, r, p, buf, buflen);\n}',
 'int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga-&gt;bits / 8);\n\tint image_block_size = (tga-&gt;width * tga-&gt;height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga-&gt;width, tga-&gt;height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga-&gt;width * tga-&gt;height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga-&gt;imagetype != TGA_TYPE_RGB &amp;&amp; tga-&gt;imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga-&gt;bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga-&gt;bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga-&gt;imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error("gd-tga: premature end of image data\\n");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret &lt; image_block_size) {\n\t\t\ttga-&gt;bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error("gd-tga: premature end of image data\\n");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size &lt;= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret &lt; rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret &lt; image_block_size ) {\n\t\t\t\n\t\t\tif ((decompression_buffer[buffer_caret] &amp; TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] &amp; ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) &gt; image_block_size\n\t\t\t\t\t\t|| buffer_caret + pixel_block_size &gt; rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i &lt; encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga-&gt;bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) &gt; image_block_size\n\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) &gt; rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga-&gt;bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}',
 'std::string RestAuthHandler::generateJwt(std::string const&amp; username) const {\n  AuthenticationFeature* af = AuthenticationFeature::instance();\n  TRI_ASSERT(af != nullptr);\n  return fuerte::jwt::generateUserToken(\n      af-&gt;tokenCache().jwtSecret(), \n      username, \n      std::chrono::seconds(uint64_t(af-&gt;sessionTimeout())));\n}',
 "start_input_bmp(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  U_CHAR bmpfileheader[14];\n  U_CHAR bmpinfoheader[64];\n\n#define GET_2B(array, offset) \\\n  ((unsigned short)UCH(array[offset]) + \\\n   (((unsigned short)UCH(array[offset + 1])) &lt;&lt; 8))\n#define GET_4B(array, offset) \\\n  ((unsigned int)UCH(array[offset]) + \\\n   (((unsigned int)UCH(array[offset + 1])) &lt;&lt; 8) + \\\n   (((unsigned int)UCH(array[offset + 2])) &lt;&lt; 16) + \\\n   (((unsigned int)UCH(array[offset + 3])) &lt;&lt; 24))\n\n  unsigned int bfOffBits;\n  unsigned int headerSize;\n  int biWidth;\n  int biHeight;\n  unsigned short biPlanes;\n  unsigned int biCompression;\n  int biXPelsPerMeter, biYPelsPerMeter;\n  unsigned int biClrUsed = 0;\n  int mapentrysize = 0;         /* 0 indicates no colormap */\n  int bPad;\n  JDIMENSION row_width = 0;\n\n  /* Read and verify the bitmap file header */\n  if (!ReadOK(source-&gt;pub.input_file, bmpfileheader, 14))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  if (GET_2B(bmpfileheader, 0) != 0x4D42) /* 'BM' */\n    ERREXIT(cinfo, JERR_BMP_NOT);\n  bfOffBits = GET_4B(bmpfileheader, 10);\n  /* We ignore the remaining fileheader fields */\n\n  /* The infoheader might be 12 bytes (OS/2 1.x), 40 bytes (Windows),\n   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.\n   */\n  if (!ReadOK(source-&gt;pub.input_file, bmpinfoheader, 4))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  headerSize = GET_4B(bmpinfoheader, 0);\n  if (headerSize &lt; 12 || headerSize &gt; 64)\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n  if (!ReadOK(source-&gt;pub.input_file, bmpinfoheader + 4, headerSize - 4))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n\n  switch (headerSize) {\n  case 12:\n    /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */\n    biWidth = (int)GET_2B(bmpinfoheader, 4);\n    biHeight = (int)GET_2B(bmpinfoheader, 6);\n    biPlanes = GET_2B(bmpinfoheader, 8);\n    source-&gt;bits_per_pixel = (int)GET_2B(bmpinfoheader, 10);\n\n    switch (source-&gt;bits_per_pixel) {\n    case 8:                     /* colormapped image */\n      mapentrysize = 3;         /* OS/2 uses RGBTRIPLE colormap */\n      TRACEMS2(cinfo, 1, JTRC_BMP_OS2_MAPPED, biWidth, biHeight);\n      break;\n    case 24:                    /* RGB image */\n      TRACEMS2(cinfo, 1, JTRC_BMP_OS2, biWidth, biHeight);\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n      break;\n    }\n    break;\n  case 40:\n  case 64:\n    /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */\n    /* or OS/2 2.x header, which has additional fields that we ignore */\n    biWidth = (int)GET_4B(bmpinfoheader, 4);\n    biHeight = (int)GET_4B(bmpinfoheader, 8);\n    biPlanes = GET_2B(bmpinfoheader, 12);\n    source-&gt;bits_per_pixel = (int)GET_2B(bmpinfoheader, 14);\n    biCompression = GET_4B(bmpinfoheader, 16);\n    biXPelsPerMeter = (int)GET_4B(bmpinfoheader, 24);\n    biYPelsPerMeter = (int)GET_4B(bmpinfoheader, 28);\n    biClrUsed = GET_4B(bmpinfoheader, 32);\n    /* biSizeImage, biClrImportant fields are ignored */\n\n    switch (source-&gt;bits_per_pixel) {\n    case 8:                     /* colormapped image */\n      mapentrysize = 4;         /* Windows uses RGBQUAD colormap */\n      TRACEMS2(cinfo, 1, JTRC_BMP_MAPPED, biWidth, biHeight);\n      break;\n    case 24:                    /* RGB image */\n      TRACEMS2(cinfo, 1, JTRC_BMP, biWidth, biHeight);\n      break;\n    case 32:                    /* RGB image + Alpha channel */\n      TRACEMS2(cinfo, 1, JTRC_BMP, biWidth, biHeight);\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n      break;\n    }\n    if (biCompression != 0)\n      ERREXIT(cinfo, JERR_BMP_COMPRESSED);\n\n    if (biXPelsPerMeter &gt; 0 &amp;&amp; biYPelsPerMeter &gt; 0) {\n      /* Set JFIF density parameters from the BMP data */\n      cinfo-&gt;X_density = (UINT16)(biXPelsPerMeter / 100); /* 100 cm per meter */\n      cinfo-&gt;Y_density = (UINT16)(biYPelsPerMeter / 100);\n      cinfo-&gt;density_unit = 2;  /* dots/cm */\n    }\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n    return;\n  }\n\n  if (biWidth &lt;= 0 || biHeight &lt;= 0)\n    ERREXIT(cinfo, JERR_BMP_EMPTY);\n  if (biPlanes != 1)\n    ERREXIT(cinfo, JERR_BMP_BADPLANES);\n\n  /* Compute distance to bitmap data --- will adjust for colormap below */\n  bPad = bfOffBits - (headerSize + 14);\n\n  /* Read the colormap, if any */\n  if (mapentrysize &gt; 0) {\n    if (biClrUsed &lt;= 0)\n      biClrUsed = 256;          /* assume it's 256 */\n    else if (biClrUsed &gt; 256)\n      ERREXIT(cinfo, JERR_BMP_BADCMAP);\n    /* Allocate space to store the colormap */\n    source-&gt;colormap = (*cinfo-&gt;mem-&gt;alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)biClrUsed, (JDIMENSION)3);\n    /* and read it from the file */\n    read_colormap(source, (int)biClrUsed, mapentrysize);\n    /* account for size of colormap */\n    bPad -= biClrUsed * mapentrysize;\n  }\n\n  /* Skip any remaining pad bytes */\n  if (bPad &lt; 0)                 /* incorrect bfOffBits value? */\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n  while (--bPad &gt;= 0) {\n    (void)read_byte(source);\n  }\n\n  /* Compute row width in file, including padding to 4-byte boundary */\n  switch (source-&gt;bits_per_pixel) {\n  case 8:\n    if (cinfo-&gt;in_color_space == JCS_UNKNOWN)\n      cinfo-&gt;in_color_space = JCS_EXT_RGB;\n    if (IsExtRGB(cinfo-&gt;in_color_space))\n      cinfo-&gt;input_components = rgb_pixelsize[cinfo-&gt;in_color_space];\n    else if (cinfo-&gt;in_color_space == JCS_GRAYSCALE)\n      cinfo-&gt;input_components = 1;\n    else if (cinfo-&gt;in_color_space == JCS_CMYK)\n      cinfo-&gt;input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)biWidth;\n    break;\n  case 24:\n    if (cinfo-&gt;in_color_space == JCS_UNKNOWN)\n      cinfo-&gt;in_color_space = JCS_EXT_BGR;\n    if (IsExtRGB(cinfo-&gt;in_color_space))\n      cinfo-&gt;input_components = rgb_pixelsize[cinfo-&gt;in_color_space];\n    else if (cinfo-&gt;in_color_space == JCS_CMYK)\n      cinfo-&gt;input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)(biWidth * 3);\n    break;\n  case 32:\n    if (cinfo-&gt;in_color_space == JCS_UNKNOWN)\n      cinfo-&gt;in_color_space = JCS_EXT_BGRA;\n    if (IsExtRGB(cinfo-&gt;in_color_space))\n      cinfo-&gt;input_components = rgb_pixelsize[cinfo-&gt;in_color_space];\n    else if (cinfo-&gt;in_color_space == JCS_CMYK)\n      cinfo-&gt;input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)(biWidth * 4);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n  }\n  while ((row_width &amp; 3) != 0) row_width++;\n  source-&gt;row_width = row_width;\n\n  if (source-&gt;use_inversion_array) {\n    /* Allocate space for inversion array, prepare for preload pass */\n    source-&gt;whole_image = (*cinfo-&gt;mem-&gt;request_virt_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n       row_width, (JDIMENSION)biHeight, (JDIMENSION)1);\n    source-&gt;pub.get_pixel_rows = preload_image;\n    if (cinfo-&gt;progress != NULL) {\n      cd_progress_ptr progress = (cd_progress_ptr)cinfo-&gt;progress;\n      progress-&gt;total_extra_passes++; /* count file input as separate pass */\n    }\n  } else {\n    source-&gt;iobuffer = (U_CHAR *)\n      (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE, row_width);\n    switch (source-&gt;bits_per_pixel) {\n    case 8:\n      source-&gt;pub.get_pixel_rows = get_8bit_row;\n      break;\n    case 24:\n      source-&gt;pub.get_pixel_rows = get_24bit_row;\n      break;\n    case 32:\n      source-&gt;pub.get_pixel_rows = get_32bit_row;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n    }\n  }\n\n  /* Ensure that biWidth * cinfo-&gt;input_components doesn't exceed the maximum\n     value of the JDIMENSION type.  This is only a danger with BMP files, since\n     their width and height fields are 32-bit integers. */\n  if ((unsigned long long)biWidth *\n      (unsigned long long)cinfo-&gt;input_components &gt; 0xFFFFFFFFULL)\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n  /* Allocate one-row buffer for returned data */\n  source-&gt;pub.buffer = (*cinfo-&gt;mem-&gt;alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE,\n     (JDIMENSION)(biWidth * cinfo-&gt;input_components), (JDIMENSION)1);\n  source-&gt;pub.buffer_height = 1;\n\n  cinfo-&gt;data_precision = 8;\n  cinfo-&gt;image_width = (JDIMENSION)biWidth;\n  cinfo-&gt;image_height = (JDIMENSION)biHeight;\n}",
 'static int http_connect(URLContext *h, const char *path, const char *local_path,\n                        const char *hoststr, const char *auth,\n                        const char *proxyauth, int *new_location)\n{\n    HTTPContext *s = h-&gt;priv_data;\n    int post, err;\n    char headers[HTTP_HEADERS_SIZE] = "";\n    char *authstr = NULL, *proxyauthstr = NULL;\n    int64_t off = s-&gt;off;\n    int len = 0;\n    const char *method;\n    int send_expect_100 = 0;\n\n    /* send http header */\n    post = h-&gt;flags &amp; AVIO_FLAG_WRITE;\n\n    if (s-&gt;post_data) {\n        /* force POST method and disable chunked encoding when\n         * custom HTTP post data is set */\n        post            = 1;\n        s-&gt;chunked_post = 0;\n    }\n\n    if (s-&gt;method)\n        method = s-&gt;method;\n    else\n        method = post ? "POST" : "GET";\n\n    authstr      = ff_http_auth_create_response(&amp;s-&gt;auth_state, auth,\n                                                local_path, method);\n    proxyauthstr = ff_http_auth_create_response(&amp;s-&gt;proxy_auth_state, proxyauth,\n                                                local_path, method);\n    if (post &amp;&amp; !s-&gt;post_data) {\n        send_expect_100 = s-&gt;send_expect_100;\n        /* The user has supplied authentication but we don\'t know the auth type,\n         * send Expect: 100-continue to get the 401 response including the\n         * WWW-Authenticate header, or an 100 continue if no auth actually\n         * is needed. */\n        if (auth &amp;&amp; *auth &amp;&amp;\n            s-&gt;auth_state.auth_type == HTTP_AUTH_NONE &amp;&amp;\n            s-&gt;http_code != 401)\n            send_expect_100 = 1;\n    }\n\n#if FF_API_HTTP_USER_AGENT\n    if (strcmp(s-&gt;user_agent_deprecated, DEFAULT_USER_AGENT)) {\n        av_log(s, AV_LOG_WARNING, "the user-agent option is deprecated, please use user_agent option\\n");\n        s-&gt;user_agent = av_strdup(s-&gt;user_agent_deprecated);\n    }\n#endif\n    /* set default headers if needed */\n    if (!has_header(s-&gt;headers, "\\r\\nUser-Agent: "))\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           "User-Agent: %s\\r\\n", s-&gt;user_agent);\n    if (!has_header(s-&gt;headers, "\\r\\nAccept: "))\n        len += av_strlcpy(headers + len, "Accept: */*\\r\\n",\n                          sizeof(headers) - len);\n    // Note: we send this on purpose even when s-&gt;off is 0 when we\'re probing,\n    // since it allows us to detect more reliably if a (non-conforming)\n    // server supports seeking by analysing the reply headers.\n    if (!has_header(s-&gt;headers, "\\r\\nRange: ") &amp;&amp; !post &amp;&amp; (s-&gt;off &gt; 0 || s-&gt;end_off || s-&gt;seekable == -1)) {\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           "Range: bytes=%"PRId64"-", s-&gt;off);\n        if (s-&gt;end_off)\n            len += av_strlcatf(headers + len, sizeof(headers) - len,\n                               "%"PRId64, s-&gt;end_off - 1);\n        len += av_strlcpy(headers + len, "\\r\\n",\n                          sizeof(headers) - len);\n    }\n    if (send_expect_100 &amp;&amp; !has_header(s-&gt;headers, "\\r\\nExpect: "))\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           "Expect: 100-continue\\r\\n");\n\n    if (!has_header(s-&gt;headers, "\\r\\nConnection: ")) {\n        if (s-&gt;multiple_requests)\n            len += av_strlcpy(headers + len, "Connection: keep-alive\\r\\n",\n                              sizeof(headers) - len);\n        else\n            len += av_strlcpy(headers + len, "Connection: close\\r\\n",\n                              sizeof(headers) - len);\n    }\n\n    if (!has_header(s-&gt;headers, "\\r\\nHost: "))\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           "Host: %s\\r\\n", hoststr);\n    if (!has_header(s-&gt;headers, "\\r\\nContent-Length: ") &amp;&amp; s-&gt;post_data)\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           "Content-Length: %d\\r\\n", s-&gt;post_datalen);\n\n    if (!has_header(s-&gt;headers, "\\r\\nContent-Type: ") &amp;&amp; s-&gt;content_type)\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           "Content-Type: %s\\r\\n", s-&gt;content_type);\n    if (!has_header(s-&gt;headers, "\\r\\nCookie: ") &amp;&amp; s-&gt;cookies) {\n        char *cookies = NULL;\n        if (!get_cookies(s, &amp;cookies, path, hoststr) &amp;&amp; cookies) {\n            len += av_strlcatf(headers + len, sizeof(headers) - len,\n                               "Cookie: %s\\r\\n", cookies);\n            av_free(cookies);\n        }\n    }\n    if (!has_header(s-&gt;headers, "\\r\\nIcy-MetaData: ") &amp;&amp; s-&gt;icy)\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           "Icy-MetaData: %d\\r\\n", 1);\n\n    /* now add in custom headers */\n    if (s-&gt;headers)\n        av_strlcpy(headers + len, s-&gt;headers, sizeof(headers) - len);\n\n    snprintf(s-&gt;buffer, sizeof(s-&gt;buffer),\n             "%s %s HTTP/1.1\\r\\n"\n             "%s"\n             "%s"\n             "%s"\n             "%s%s"\n             "\\r\\n",\n             method,\n             path,\n             post &amp;&amp; s-&gt;chunked_post ? "Transfer-Encoding: chunked\\r\\n" : "",\n             headers,\n             authstr ? authstr : "",\n             proxyauthstr ? "Proxy-" : "", proxyauthstr ? proxyauthstr : "");\n\n    av_log(h, AV_LOG_DEBUG, "request: %s\\n", s-&gt;buffer);\n\n    if ((err = ffurl_write(s-&gt;hd, s-&gt;buffer, strlen(s-&gt;buffer))) &lt; 0)\n        goto done;\n\n    if (s-&gt;post_data)\n        if ((err = ffurl_write(s-&gt;hd, s-&gt;post_data, s-&gt;post_datalen)) &lt; 0)\n            goto done;\n\n    /* init input buffer */\n    s-&gt;buf_ptr          = s-&gt;buffer;\n    s-&gt;buf_end          = s-&gt;buffer;\n    s-&gt;line_count       = 0;\n    s-&gt;off              = 0;\n    s-&gt;icy_data_read    = 0;\n    s-&gt;filesize         = -1;\n    s-&gt;willclose        = 0;\n    s-&gt;end_chunked_post = 0;\n    s-&gt;end_header       = 0;\n    if (post &amp;&amp; !s-&gt;post_data &amp;&amp; !send_expect_100) {\n        /* Pretend that it did work. We didn\'t read any header yet, since\n         * we\'ve still to send the POST data, but the code calling this\n         * function will check http_code after we return. */\n        s-&gt;http_code = 200;\n        err = 0;\n        goto done;\n    }\n\n    /* wait for header */\n    err = http_read_header(h, new_location);\n    if (err &lt; 0)\n        goto done;\n\n    if (*new_location)\n        s-&gt;off = off;\n\n    err = (off == s-&gt;off) ? 0 : -1;\ndone:\n    av_freep(&amp;authstr);\n    av_freep(&amp;proxyauthstr);\n    return err;\n}',
 'static int callback_static_file_uncompressed (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  size_t length;\n  FILE * f;\n  char * file_requested, * file_path, * url_dup_save;\n  const char * content_type;\n  int ret = U_CALLBACK_CONTINUE;\n\n  if (user_data != NULL &amp;&amp; ((struct _u_compressed_inmemory_website_config *)user_data)-&gt;files_path != NULL) {\n    file_requested = o_strdup(request-&gt;http_url);\n    url_dup_save = file_requested;\n\n    file_requested += o_strlen(((struct _u_compressed_inmemory_website_config *)user_data)-&gt;url_prefix);\n    while (file_requested[0] == \'/\') {\n      file_requested++;\n    }\n\n    if (strchr(file_requested, \'#\') != NULL) {\n      *strchr(file_requested, \'#\') = \'\\0\';\n    }\n\n    if (strchr(file_requested, \'?\') != NULL) {\n      *strchr(file_requested, \'?\') = \'\\0\';\n    }\n\n    if (file_requested == NULL || o_strnullempty(file_requested) || 0 == o_strcmp("/", file_requested)) {\n      o_free(url_dup_save);\n      url_dup_save = file_requested = o_strdup("index.html");\n    }\n\n    file_path = msprintf("%s/%s", ((struct _u_compressed_inmemory_website_config *)user_data)-&gt;files_path, file_requested);\n\n    f = fopen (file_path, "rb");\n    if (f) {\n      fseek (f, 0, SEEK_END);\n      length = ftell (f);\n      fseek (f, 0, SEEK_SET);\n\n      content_type = u_map_get_case(&amp;((struct _u_compressed_inmemory_website_config *)user_data)-&gt;mime_types, get_filename_ext(file_requested));\n      if (content_type == NULL) {\n        content_type = u_map_get(&amp;((struct _u_compressed_inmemory_website_config *)user_data)-&gt;mime_types, "*");\n        y_log_message(Y_LOG_LEVEL_WARNING, "Static File Server - Unknown mime type for extension %s", get_filename_ext(file_requested));\n      }\n      u_map_put(response-&gt;map_header, "Content-Type", content_type);\n      u_map_copy_into(response-&gt;map_header, &amp;((struct _u_compressed_inmemory_website_config *)user_data)-&gt;map_header);\n\n      if (ulfius_set_stream_response(response, 200, callback_static_file_uncompressed_stream, callback_static_file_uncompressed_stream_free, length, CHUNK, f) != U_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, "Static File Server - Error ulfius_set_stream_response");\n      }\n    } else {\n      if (((struct _u_compressed_inmemory_website_config *)user_data)-&gt;redirect_on_404 == NULL) {\n        ret = U_CALLBACK_IGNORE;\n      } else {\n        ulfius_add_header_to_response(response, "Location", ((struct _u_compressed_inmemory_website_config *)user_data)-&gt;redirect_on_404);\n        response-&gt;status = 302;\n      }\n    }\n    o_free(file_path);\n    o_free(url_dup_save);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, "Static File Server - Error, user_data is NULL or inconsistent");\n    ret = U_CALLBACK_ERROR;\n  }\n  return ret;\n}',
 'void cJSON_AddItemToArray( cJSON *array, cJSON *item )\n{\n\tcJSON *c = array-&gt;child;\n\tif ( ! item )\n\t\treturn;\n\tif ( ! c ) {\n\t\tarray-&gt;child = item;\n\t} else {\n\t\twhile ( c &amp;&amp; c-&gt;next )\n\t\t\tc = c-&gt;next;\n\t\tsuffix_object( c, item );\n\t}\n}',
 'void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = "`\\"\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = \'"\';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s &amp;&amp; dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen &lt; 2)\n        break;\n      dlen -= 2;\n      *pt++ = \'\\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = \'"\';\n  *pt = \'\\0\';\n}',
 'int TLSOutStream::overrun(int itemSize, int nItems)\n{\n  if (itemSize &gt; bufSize)\n    throw Exception("TLSOutStream overrun: max itemSize exceeded");\n\n  flush();\n\n  if (itemSize * nItems &gt; end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}',
 'void SPECTRA::run( Session* session, const std::string&amp; argument ){\n\n  /* The argument should consist of 2 comma separated values:\n     1) resolution\n     2) tile number\n     3) pixel index in x direction\n     4) pixel index in y direction\n  */\n\n  if( session-&gt;loglevel &gt;= 3 ) (*session-&gt;logfile) &lt;&lt; "SPECTRA handler reached" &lt;&lt; endl;\n\n  int resolution, tile, x, y;\n\n\n  // Time this command\n  if( session-&gt;loglevel &gt;= 2 ) command_timer.start();\n\n\n  // Parse the argument list\n  string arg = argument;\n  int delimitter = arg.find( "," );\n  resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( "," );\n  tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( "," );\n  x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( "," );\n  y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session-&gt;loglevel &gt;= 5 ){ \n    (*session-&gt;logfile) &lt;&lt; "SPECTRA :: resolution: " &lt;&lt; resolution\n\t\t\t&lt;&lt; ", tile: " &lt;&lt; tile\n\t\t\t&lt;&lt; ", x: " &lt;&lt; x\n\t\t\t&lt;&lt; ", y: " &lt;&lt; y &lt;&lt; endl;\n  }\n\n  // Make sure our x,y coordinates are within the tile dimensions\n  if( x &lt; 0 || x &gt;= (int)(*session-&gt;image)-&gt;getTileWidth() ||\n      y &lt; 0 || y &gt;= (int)(*session-&gt;image)-&gt;getTileHeight() ){\n    throw invalid_argument( "SPECTRA :: Error: x,y coordinates outside of tile boundaries" );\n  }\n  \n\n  TileManager tilemanager( session-&gt;tileCache, *session-&gt;image, session-&gt;watermark, session-&gt;jpeg, session-&gt;logfile, session-&gt;loglevel );\n\n  // Use our horizontal views function to get a list of available spectral images\n  list &lt;int&gt; views = (*session-&gt;image)-&gt;getHorizontalViewsList();\n  list &lt;int&gt; :: const_iterator i;\n\n  // Our list of spectral reflectance values for the requested point\n  list &lt;float&gt; spectrum;\n\n\n#ifndef DEBUG\n  // Output our HTTP header\n  stringstream header;\n  header &lt;&lt; session-&gt;response-&gt;createHTTPHeader( "xml", (*session-&gt;image)-&gt;getTimestamp() );\n  session-&gt;out-&gt;putStr( (const char*) header.str().c_str(), header.tellp() );\n  session-&gt;out-&gt;flush();\n#endif\n\n  session-&gt;out-&gt;putS( "&lt;?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?&gt;\\n" );\n  session-&gt;out-&gt;putS( "&lt;spectra&gt;\\n" );\n  session-&gt;out-&gt;flush();\n\n  for( i = views.begin(); i != views.end(); i++ ){\n\n    int n = *i;\n\n    RawTile rawtile = tilemanager.getTile( resolution, tile, n, session-&gt;view-&gt;yangle, session-&gt;view-&gt;getLayers(), UNCOMPRESSED );\n\n    // Make sure our x,y coordinates are within the tile dimensions\n    if( x &gt;= (int)rawtile.width || y &gt;= (int)rawtile.height ){\n      if( session-&gt;loglevel &gt;= 1 ){\n\t(*session-&gt;logfile) &lt;&lt; "SPECTRA :: Error: x,y coordinates outside of tile boundaries" &lt;&lt; endl;\n      }\n      break;\n    }\n\n\n    unsigned int tw = (*session-&gt;image)-&gt;getTileWidth();\n    unsigned int index = y*tw + x;\n\n    void *ptr;\n    float reflectance = 0.0;\n\n    if( session-&gt;loglevel &gt;= 5 ) (*session-&gt;logfile) &lt;&lt; "SPECTRA :: " &lt;&lt; rawtile.bpc &lt;&lt; " bits per channel data" &lt;&lt; endl;\n\n    // Handle depending on bit depth\n    if( rawtile.bpc == 8 ){\n      ptr = (unsigned char*) (rawtile.data);\n      reflectance = static_cast&lt;float&gt;((float)((unsigned char*)ptr)[index]) / 255.0;\n    }\n    else if( rawtile.bpc == 16 ){\n      ptr = (unsigned short*) (rawtile.data);\n      reflectance = static_cast&lt;float&gt;((float)((unsigned short*)ptr)[index]) / 65535.0;\n    }\n    else if( rawtile.bpc == 32 ){\n      if( rawtile.sampleType == FIXEDPOINT ) {\n        ptr = (unsigned int*) rawtile.data;\n        reflectance = static_cast&lt;float&gt;((float)((unsigned int*)ptr)[index]);\n      }\n      else {\n        ptr = (float*) rawtile.data;\n        reflectance = static_cast&lt;float&gt;((float)((float*)ptr)[index]);\n      }\n    }\n\n    spectrum.push_front( reflectance );\n\n    string metadata = (*session-&gt;image)-&gt;getMetadata( "subject" );\n\n    char tmp[1024];\n    snprintf( tmp, 1024, "\\t&lt;point&gt;\\n\\t\\t&lt;wavelength&gt;%d&lt;/wavelength&gt;\\n\\t\\t&lt;reflectance&gt;%f&lt;/reflectance&gt;\\n\\t&lt;/point&gt;\\n", n, reflectance );\n    session-&gt;out-&gt;putS( tmp );\n    session-&gt;out-&gt;flush();\n\n    if( session-&gt;loglevel &gt;= 3 ) (*session-&gt;logfile) &lt;&lt; "SPECTRA :: Band: " &lt;&lt; n &lt;&lt; ", reflectance: " &lt;&lt; reflectance &lt;&lt; endl;\n  }\n\n\n  session-&gt;out-&gt;putS( "&lt;/spectra&gt;" );\n\n  if( session-&gt;out-&gt;flush() == -1 ) {\n    if( session-&gt;loglevel &gt;= 1 ){\n      *(session-&gt;logfile) &lt;&lt; "SPECTRA :: Error flushing XML" &lt;&lt; endl;\n    }\n  }\n\n\n  // Inform our response object that we have sent something to the client\n  session-&gt;response-&gt;setImageSent();\n\n  // Total SPECTRA response time\n  if( session-&gt;loglevel &gt;= 2 ){\n    *(session-&gt;logfile) &lt;&lt; "SPECTRA :: Total command time " &lt;&lt; command_timer.getTime() &lt;&lt; " microseconds" &lt;&lt; endl;\n  }\n\n}',
 'cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n\n    if (NamedColorList == NULL) return FALSE;\n\n    if (NamedColorList -&gt;nColors + 1 &gt; NamedColorList -&gt;Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n\n    for (i=0; i &lt; NamedColorList -&gt;ColorantCount; i++)\n        NamedColorList -&gt;List[NamedColorList -&gt;nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];\n\n    for (i=0; i &lt; 3; i++)\n        NamedColorList -&gt;List[NamedColorList -&gt;nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];\n\n    if (Name != NULL) {\n\n        strncpy(NamedColorList -&gt;List[NamedColorList -&gt;nColors].Name, Name,\n                    sizeof(NamedColorList -&gt;List[NamedColorList -&gt;nColors].Name));\n\n        NamedColorList -&gt;List[NamedColorList -&gt;nColors].Name[cmsMAX_PATH-1] = 0;\n\n    }\n    else\n        NamedColorList -&gt;List[NamedColorList -&gt;nColors].Name[0] = 0;\n\n\n    NamedColorList -&gt;nColors++;\n    return TRUE;\n}',
 'CAMLprim value caml_alloc_dummy(value size)\n{\n  mlsize_t wosize = Int_val(size);\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}',
 'u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i &lt; 4; i++)\n\t\tsecret[i] = net_secret[i] + (__force u32) daddr[i];\n\tsecret[4] = net_secret[4] + (__force u32)dport;\n\tfor (i = 5; i &lt; MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\n\tmd5_transform(hash, secret);\n\n\treturn hash[0];\n}',
 'const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n\n  MessageWriter input;\n  input.Push&lt;int&gt;(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast&lt;const char *&gt;(src), src_size});\n  input.Push(size);\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &amp;input, &amp;output);\n  CheckStatusAndParamCount(status, output, "enc_untrusted_inet_ntop", 2);\n\n  auto result = output.next();\n  int klinux_errno = output.next&lt;int&gt;();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n\n  memcpy(\n      dst, result.data(),\n      std::min({static_cast&lt;size_t&gt;(size), static_cast&lt;size_t&gt;(result.size()),\n                static_cast&lt;size_t&gt;(INET6_ADDRSTRLEN)}));\n  return dst;\n}',
 'static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *new_root_item;\n\tstruct btrfs_root *tree_root = fs_info-&gt;tree_root;\n\tstruct btrfs_root *root = pending-&gt;root;\n\tstruct btrfs_root *parent_root;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct inode *parent_inode;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct dentry *parent;\n\tstruct dentry *dentry;\n\tstruct extent_buffer *tmp;\n\tstruct extent_buffer *old;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tint ret;\n\tu64 to_reserve = 0;\n\tu64 index = 0;\n\tu64 objectid;\n\tu64 root_flags;\n\tuuid_le new_uuid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = pending-&gt;error = -ENOMEM;\n\t\tgoto path_alloc_fail;\n\t}\n\n\tnew_root_item = kmalloc(sizeof(*new_root_item), GFP_NOFS);\n\tif (!new_root_item) {\n\t\tret = pending-&gt;error = -ENOMEM;\n\t\tgoto root_item_alloc_fail;\n\t}\n\n\tret = btrfs_find_free_objectid(tree_root, &amp;objectid);\n\tif (ret) {\n\t\tpending-&gt;error = ret;\n\t\tgoto no_free_objectid;\n\t}\n\n\tbtrfs_reloc_pre_snapshot(trans, pending, &amp;to_reserve);\n\n\tif (to_reserve &gt; 0) {\n\t\tret = btrfs_block_rsv_add(root, &amp;pending-&gt;block_rsv,\n\t\t\t\t\t  to_reserve,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\tif (ret) {\n\t\t\tpending-&gt;error = ret;\n\t\t\tgoto no_free_objectid;\n\t\t}\n\t}\n\n\tret = btrfs_qgroup_inherit(trans, fs_info, root-&gt;root_key.objectid,\n\t\t\t\t   objectid, pending-&gt;inherit);\n\tif (ret) {\n\t\tpending-&gt;error = ret;\n\t\tgoto no_free_objectid;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\trsv = trans-&gt;block_rsv;\n\ttrans-&gt;block_rsv = &amp;pending-&gt;block_rsv;\n\n\tdentry = pending-&gt;dentry;\n\tparent = dget_parent(dentry);\n\tparent_inode = parent-&gt;d_inode;\n\tparent_root = BTRFS_I(parent_inode)-&gt;root;\n\trecord_root_in_trans(trans, parent_root);\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(parent_inode, &amp;index);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\t/* check if there is a file/dir which has the same name. */\n\tdir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\n\t\t\t\t\t btrfs_ino(parent_inode),\n\t\t\t\t\t dentry-&gt;d_name.name,\n\t\t\t\t\t dentry-&gt;d_name.len, 0);\n\tif (dir_item != NULL &amp;&amp; !IS_ERR(dir_item)) {\n\t\tpending-&gt;error = -EEXIST;\n\t\tgoto fail;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pull in the delayed directory update\n\t * and the delayed inode item\n\t * otherwise we corrupt the FS during\n\t * snapshot\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\t/* Transaction aborted */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\trecord_root_in_trans(trans, root);\n\tbtrfs_set_root_last_snapshot(&amp;root-&gt;root_item, trans-&gt;transid);\n\tmemcpy(new_root_item, &amp;root-&gt;root_item, sizeof(*new_root_item));\n\tbtrfs_check_and_init_root_item(new_root_item);\n\n\troot_flags = btrfs_root_flags(new_root_item);\n\tif (pending-&gt;readonly)\n\t\troot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\n\telse\n\t\troot_flags &amp;= ~BTRFS_ROOT_SUBVOL_RDONLY;\n\tbtrfs_set_root_flags(new_root_item, root_flags);\n\n\tbtrfs_set_root_generation_v2(new_root_item,\n\t\t\ttrans-&gt;transid);\n\tuuid_le_gen(&amp;new_uuid);\n\tmemcpy(new_root_item-&gt;uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tmemcpy(new_root_item-&gt;parent_uuid, root-&gt;root_item.uuid,\n\t\t\tBTRFS_UUID_SIZE);\n\tnew_root_item-&gt;otime.sec = cpu_to_le64(cur_time.tv_sec);\n\tnew_root_item-&gt;otime.nsec = cpu_to_le32(cur_time.tv_nsec);\n\tbtrfs_set_root_otransid(new_root_item, trans-&gt;transid);\n\tmemset(&amp;new_root_item-&gt;stime, 0, sizeof(new_root_item-&gt;stime));\n\tmemset(&amp;new_root_item-&gt;rtime, 0, sizeof(new_root_item-&gt;rtime));\n\tbtrfs_set_root_stransid(new_root_item, 0);\n\tbtrfs_set_root_rtransid(new_root_item, 0);\n\n\told = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, old, NULL, 0, &amp;old);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(old);\n\t\tfree_extent_buffer(old);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_set_lock_blocking(old);\n\n\tret = btrfs_copy_root(trans, root, old, &amp;tmp, objectid);\n\t/* clean up in any case */\n\tbtrfs_tree_unlock(old);\n\tfree_extent_buffer(old);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/* see comments in should_cow_block() */\n\troot-&gt;force_cow = 1;\n\tsmp_wmb();\n\n\tbtrfs_set_root_node(new_root_item, tmp);\n\t/* record when the snapshot was created in key.offset */\n\tkey.offset = trans-&gt;transid;\n\tret = btrfs_insert_root(trans, tree_root, &amp;key, new_root_item);\n\tbtrfs_tree_unlock(tmp);\n\tfree_extent_buffer(tmp);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert root back/forward references\n\t */\n\tret = btrfs_add_root_ref(trans, tree_root, objectid,\n\t\t\t\t parent_root-&gt;root_key.objectid,\n\t\t\t\t btrfs_ino(parent_inode), index,\n\t\t\t\t dentry-&gt;d_name.name, dentry-&gt;d_name.len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tkey.offset = (u64)-1;\n\tpending-&gt;snap = btrfs_read_fs_root_no_name(root-&gt;fs_info, &amp;key);\n\tif (IS_ERR(pending-&gt;snap)) {\n\t\tret = PTR_ERR(pending-&gt;snap);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_reloc_post_snapshot(trans, pending);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, parent_root,\n\t\t\t\t    dentry-&gt;d_name.name, dentry-&gt;d_name.len,\n\t\t\t\t    parent_inode, &amp;key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\t/* We have check then name at the beginning, so it is impossible. */\n\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode-&gt;i_size +\n\t\t\t\t\t dentry-&gt;d_name.len * 2);\n\tparent_inode-&gt;i_mtime = parent_inode-&gt;i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\nfail:\n\tdput(parent);\n\ttrans-&gt;block_rsv = rsv;\nno_free_objectid:\n\tkfree(new_root_item);\nroot_item_alloc_fail:\n\tbtrfs_free_path(path);\npath_alloc_fail:\n\tbtrfs_block_rsv_release(root, &amp;pending-&gt;block_rsv, (u64)-1);\n\treturn ret;\n}',
 'void TestSocketLineReader::init()\n{\n    m_packets.clear();\n    m_server = new Server(this);\n\n    QVERIFY2(m_server-&gt;listen(QHostAddress::LocalHost, 8694), "Failed to create local tcp server");\n\n    m_timer.setInterval(4000);//For second is more enough to send some data via local socket\n    m_timer.setSingleShot(true);\n    connect(&amp;m_timer, &amp;QTimer::timeout, &amp;m_loop, &amp;QEventLoop::quit);\n\n    m_conn = new QSslSocket(this);\n    m_conn-&gt;connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &amp;QAbstractSocket::connected, &amp;m_loop, &amp;QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n\n    QVERIFY2(m_conn-&gt;isOpen(), "Could not connect to local tcp server");\n}',
 'void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tBUG_ON(client != handle-&gt;client);\n\n\tmutex_lock(&amp;client-&gt;lock);\n\tion_free_nolock(client, handle);\n\tmutex_unlock(&amp;client-&gt;lock);\n}',
 'bool StringSanMatcher::match(const GENERAL_NAME* general_name) const {\n  if (general_name-&gt;type != general_name_type_) {\n    return false;\n  }\n  // For DNS SAN, if the StringMatcher type is exact, we have to follow DNS matching semantics.\n  const std::string san = Utility::generalNameAsString(general_name);\n  return general_name-&gt;type == GEN_DNS &amp;&amp;\n                 matcher_.matcher().match_pattern_case() ==\n                     envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n             ? Utility::dnsNameMatch(matcher_.matcher().exact(), absl::string_view(san))\n             : matcher_.match(san);\n}',
 'static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink-&gt;dst-&gt;priv;\n\n    AVFrame *frame = ff_get_video_buffer(inlink-&gt;dst-&gt;outputs[0],\n                                         w + (s-&gt;w - s-&gt;in_w),\n                                         h + (s-&gt;h - s-&gt;in_h));\n    int plane;\n\n    if (!frame)\n        return NULL;\n\n    frame-&gt;width  = w;\n    frame-&gt;height = h;\n\n    for (plane = 0; plane &lt; 4 &amp;&amp; frame-&gt;data[plane] &amp;&amp; frame-&gt;linesize[plane]; plane++) {\n        int hsub = s-&gt;draw.hsub[plane];\n        int vsub = s-&gt;draw.vsub[plane];\n        frame-&gt;data[plane] += (s-&gt;x &gt;&gt; hsub) * s-&gt;draw.pixelstep[plane] +\n                              (s-&gt;y &gt;&gt; vsub) * frame-&gt;linesize[plane];\n    }\n\n    return frame;\n}',
 'static int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tuint\talen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc != 5)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * I2C chip address\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * I2C data address within the chip.  This can be 1 or\n\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t */\n\tdevaddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen &gt; 3)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Length is the number of objects, not number of bytes.\n\t */\n\tlength = hextoul(argv[3], NULL);\n\n\t/*\n\t * memaddr is the address where to store things in memory\n\t */\n\tmemaddr = (u_char *)hextoul(argv[4], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &amp;dev);\n\tif (!ret &amp;&amp; alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, devaddr, memaddr, length);\n#else\n\tret = i2c_read(chip, devaddr, alen, memaddr, length);\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\treturn 0;\n}',
 'static PyObject* patch(PyObject* self, PyObject* args)\n{\n    char *origData, *newData, *diffBlock, *extraBlock, *diffPtr, *extraPtr;\n    Py_ssize_t origDataLength, newDataLength, diffBlockLength, extraBlockLength;\n    PyObject *controlTuples, *tuple, *results;\n    off_t oldpos, newpos, x, y, z;\n    int i, j, numTuples;\n\n    if (!PyArg_ParseTuple(args, "s#nO!s#s#",\n                          &amp;origData, &amp;origDataLength, &amp;newDataLength,\n                          &amp;PyList_Type, &amp;controlTuples,\n                          &amp;diffBlock, &amp;diffBlockLength,\n                          &amp;extraBlock, &amp;extraBlockLength))\n        return NULL;\n\n    /* allocate the memory for the new data */\n    newData = PyMem_Malloc(newDataLength + 1);\n    if (!newData)\n        return PyErr_NoMemory();\n\n    oldpos = 0;\n    newpos = 0;\n    diffPtr = diffBlock;\n    extraPtr = extraBlock;\n    numTuples = PyList_GET_SIZE(controlTuples);\n    for (i = 0; i &lt; numTuples; i++) {\n        tuple = PyList_GET_ITEM(controlTuples, i);\n        if (!PyTuple_Check(tuple)) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, "expecting tuple");\n            return NULL;\n        }\n        if (PyTuple_GET_SIZE(tuple) != 3) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, "expecting tuple of size 3");\n            return NULL;\n        }\n        x = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 0));\n        y = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 1));\n        z = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 2));\n        if (newpos + x &gt; newDataLength ||\n                diffPtr + x &gt; diffBlock + diffBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, "corrupt patch (overflow)");\n            return NULL;\n        }\n        memcpy(newData + newpos, diffPtr, x);\n        diffPtr += x;\n        for (j = 0; j &lt; x; j++)\n            if ((oldpos + j &gt;= 0) &amp;&amp; (oldpos + j &lt; origDataLength))\n                newData[newpos + j] += origData[oldpos + j];\n        newpos += x;\n        oldpos += x;\n        if (newpos + y &gt; newDataLength ||\n                extraPtr + y &gt; extraBlock + extraBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, "corrupt patch (overflow)");\n            return NULL;\n        }\n        memcpy(newData + newpos, extraPtr, y);\n        extraPtr += y;\n        newpos += y;\n        oldpos += z;\n    }\n\n    /* confirm that a valid patch was applied */\n    if (newpos != newDataLength ||\n            diffPtr != diffBlock + diffBlockLength ||\n            extraPtr != extraBlock + extraBlockLength) {\n        PyMem_Free(newData);\n        PyErr_SetString(PyExc_ValueError, "corrupt patch (underflow)");\n        return NULL;\n    }\n\n    results = PyBytes_FromStringAndSize(newData, newDataLength);\n    PyMem_Free(newData);\n    return results;\n}',
 'dhcpv4_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint8_t type, optlen;\n\n    i = 0;\n    while (i &lt; length) {\n        if (i + 2 &gt; length)\n            return -1;\n        tlv = cp + i;\n        type = (uint8_t)tlv[0];\n        optlen = (uint8_t)tlv[1];\n        value = tlv + 2;\n\n        ND_PRINT((ndo, "\\n"));\n        for (t = indent; t &gt; 0; t--)\n            ND_PRINT((ndo, "\\t"));\n\n        ND_PRINT((ndo, "%s", tok2str(dh4opt_str, "Unknown", type)));\n        ND_PRINT((ndo," (%u)", optlen + 2 ));\n        if (i + 2 + optlen &gt; length)\n            return -1;\n\n        switch (type) {\n        case DH4OPT_DNS_SERVERS:\n        case DH4OPT_NTP_SERVERS: {\n            if (optlen &lt; 4 || optlen % 4 != 0) {\n                return -1;\n            }\n            for (t = 0; t &lt; optlen; t += 4)\n                ND_PRINT((ndo, " %s", ipaddr_string(ndo, value + t)));\n        }\n            break;\n        case DH4OPT_DOMAIN_SEARCH: {\n            const u_char *tp = value;\n            while (tp &lt; value + optlen) {\n                ND_PRINT((ndo, " "));\n                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                    return -1;\n            }\n        }\n            break;\n        }\n\n        i += 2 + optlen;\n    }\n    return 0;\n}',
 'inline static bool jas_safe_size_mul3(size_t a, size_t b, size_t c,\n  size_t *result)\n{\n\tsize_t tmp;\n\tif (!jas_safe_size_mul(a, b, &amp;tmp) ||\n\t  !jas_safe_size_mul(tmp, c, &amp;tmp)) {\n\t\treturn false;\n\t}\n\tif (result) {\n\t\t*result = tmp;\n\t}\n\treturn true;\n}',
 'TEST_F(QuantizedConv2DTest, Small) {\n  const int stride = 1;\n  TF_ASSERT_OK(NodeDefBuilder("quantized_conv_op", "QuantizedConv2D")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr("out_type", DataTypeToEnum&lt;qint32&gt;::v())\n                   .Attr("strides", {1, stride, stride, 1})\n                   .Attr("padding", "SAME")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n\n  const int depth = 1;\n  const int image_width = 4;\n  const int image_height = 3;\n  const int image_batch_count = 1;\n  // The image data should always be able to represent zero, to allow a fast\n  // implementation of border padding, so we set the min value to 0.\n  const float image_min = 0.0f;\n  const float image_max = 12.0f;\n  // The image matrix is:\n  // |  1 |  2 |  3 |  4 |\n  // |  5 |  6 |  7 |  8 |\n  // |  9 | 10 | 11 | 12 |\n  Tensor image_float(DT_FLOAT,\n                     {image_batch_count, image_height, image_width, depth});\n  test::FillValues&lt;float&gt;(&amp;image_float,\n                          {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});\n  Tensor image_quantized =\n      FloatTensorToQuantized&lt;quint8&gt;(image_float, image_min, image_max);\n\n  // The filter matrix is:\n  // | 1 | 4 | 7 |\n  // | 2 | 5 | 8 |\n  // | 3 | 6 | 9 |\n  const int filter_size = 3;\n  const int filter_count = 1;\n  const float filter_min = 1.0f;\n  const float filter_max = 9.0f;\n  Tensor filter_float(DT_FLOAT,\n                      {filter_size, filter_size, depth, filter_count});\n  test::FillValues&lt;float&gt;(&amp;filter_float, {1, 4, 7, 2, 5, 8, 3, 6, 9});\n  Tensor filter_quantized =\n      FloatTensorToQuantized&lt;quint8&gt;(filter_float, filter_min, filter_max);\n\n  AddInputFromArray&lt;quint8&gt;(image_quantized.shape(),\n                            image_quantized.flat&lt;quint8&gt;());\n  AddInputFromArray&lt;quint8&gt;(filter_quantized.shape(),\n                            filter_quantized.flat&lt;quint8&gt;());\n  AddInputFromArray&lt;float&gt;(TensorShape({1}), {image_min});\n  AddInputFromArray&lt;float&gt;(TensorShape({1}), {image_max});\n  AddInputFromArray&lt;float&gt;(TensorShape({1}), {filter_min});\n  AddInputFromArray&lt;float&gt;(TensorShape({1}), {filter_max});\n  TF_ASSERT_OK(RunOpKernel());\n\n  // We\'re sliding the 3x3 filter across the 3x4 image, with accesses outside\n  // the input set to zero because we\'re using the \'SAME\' padding mode.\n  // The calculations behind the expected output are:\n  // (1*0)+(4*0)+(7*0)+(2*0)+(5*1)+(8*2)+(3*0)+(6*5)+(9*6)=105\n  // (1*0)+(4*0)+(7*0)+(2*1)+(5*2)+(8*3)+(3*5)+(6*6)+(9*7)=150\n  // (1*0)+(4*0)+(7*0)+(2*2)+(5*3)+(8*4)+(3*6)+(6*7)+(9*8)=183\n  // (1*0)+(4*0)+(7*0)+(2*3)+(5*4)+(8*0)+(3*7)+(6*8)+(9*0)=95\n  // (1*0)+(4*1)+(7*2)+(2*0)+(5*5)+(8*6)+(3*0)+(6*9)+(9*10)=235\n  // (1*1)+(4*2)+(7*3)+(2*5)+(5*6)+(8*7)+(3*9)+(6*10)+(9*11)=312\n  // (1*2)+(4*3)+(7*4)+(2*6)+(5*7)+(8*8)+(3*10)+(6*11)+(9*12)=357\n  // (1*3)+(4*4)+(7*0)+(2*7)+(5*8)+(8*0)+(3*11)+(6*12)+(9*0)=178\n  // (1*0)+(4*5)+(7*6)+(2*0)+(5*9)+(8*10)+(3*0)+(6*0)+(9*0)=187\n  // (1*5)+(4*6)+(7*7)+(2*9)+(5*10)+(8*11)+(3*0)+(6*0)+(9*0)=234\n  // (1*6)+(4*7)+(7*8)+(2*10)+(5*11)+(8*12)+(3*0)+(6*0)+(9*0)=261\n  // (1*7)+(4*11)+(7*0)+(2*8)+(5*12)+(8*0)+(3*0)+(6*0)+(9*0)=121\n  // This means we should end up with this matrix:\n  // |  105  |  150  |  183  |   95  |\n  // |  235  |  312  |  357  |  178  |\n  // |  187  |  234  |  261  |  121  |\n  const int expected_width = image_width;\n  const int expected_height = image_height * filter_count;\n  Tensor expected_float(\n      DT_FLOAT, TensorShape({image_batch_count, expected_height, expected_width,\n                             filter_count}));\n  test::FillValues&lt;float&gt;(&amp;expected_float, {105, 150, 183, 95, 235, 312, 357,\n                                            178, 187, 234, 261, 121});\n  const Tensor&amp; output_quantized = *GetOutput(0);\n  const float output_min = GetOutput(1)-&gt;flat&lt;float&gt;()(0);\n  const float output_max = GetOutput(2)-&gt;flat&lt;float&gt;()(0);\n  Tensor output_float =\n      QuantizedTensorToFloat&lt;qint32&gt;(output_quantized, output_min, output_max);\n  test::ExpectTensorNear&lt;float&gt;(expected_float, output_float, 1.0);\n}',
 "static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd-&gt;byte_length;\n    unsigned char *byteptr = wpmd-&gt;data;\n\n    wpc-&gt;version_five = 1;      // just having this block signals version 5.0\n\n    wpc-&gt;file_format = wpc-&gt;config.qmode = wpc-&gt;channel_layout = 0;\n\n    if (wpc-&gt;channel_reordering) {\n        free (wpc-&gt;channel_reordering);\n        wpc-&gt;channel_reordering = NULL;\n    }\n\n    // if there's any data, the first two bytes are file_format and qmode flags\n\n    if (bytecnt &gt;= 2) {\n        wpc-&gt;file_format = *byteptr++;\n        wpc-&gt;config.qmode = (wpc-&gt;config.qmode &amp; ~0xff) | *byteptr++;\n        bytecnt -= 2;\n\n        // another byte indicates a channel layout\n\n        if (bytecnt) {\n            int nchans, i;\n\n            wpc-&gt;channel_layout = (int32_t) *byteptr++ &lt;&lt; 16;\n            bytecnt--;\n\n            // another byte means we have a channel count for the layout and maybe a reordering\n\n            if (bytecnt) {\n                wpc-&gt;channel_layout += nchans = *byteptr++;\n                bytecnt--;\n\n                // any more means there's a reordering string\n\n                if (bytecnt) {\n                    if (bytecnt &gt; nchans)\n                        return FALSE;\n\n                    wpc-&gt;channel_reordering = malloc (nchans);\n\n                    // note that redundant reordering info is not stored, so we fill in the rest\n\n                    if (wpc-&gt;channel_reordering) {\n                        for (i = 0; i &lt; nchans; ++i)\n                            if (bytecnt) {\n                                wpc-&gt;channel_reordering [i] = *byteptr++;\n\n                                if (wpc-&gt;channel_reordering [i] &gt;= nchans)  // make sure index is in range\n                                    wpc-&gt;channel_reordering [i] = 0;\n\n                                bytecnt--;\n                            }\n                            else\n                                wpc-&gt;channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc-&gt;channel_layout += wpc-&gt;config.num_channels;\n        }\n    }\n\n    return TRUE;\n}",
 'void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}',
 'HandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client-&gt;serverPort==-1)\n    client-&gt;vncRec-&gt;readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&amp;msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&amp;msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i &lt; msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &amp;xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&amp;msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i &lt; msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&amp;rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client-&gt;HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client-&gt;KeyboardLedStateEnabled = 1;\n          if (client-&gt;HandleKeyboardLedState!=NULL)\n              client-&gt;HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client-&gt;CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient-&gt;width = rect.r.w;\n\tclient-&gt;height = rect.r.h;\n\tclient-&gt;updateRect.x = client-&gt;updateRect.y = 0;\n\tclient-&gt;updateRect.w = client-&gt;width;\n\tclient-&gt;updateRect.h = client-&gt;height;\n\tif (!client-&gt;MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog("Got new framebuffer size: %dx%d\\n", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&amp;client-&gt;supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog("client2server supported messages (bit flags)\\n");\n          for (loop=0;loop&lt;32;loop+=8)\n            rfbClientLog("%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n", loop,\n                client-&gt;supportedMessages.client2server[loop],   client-&gt;supportedMessages.client2server[loop+1],\n                client-&gt;supportedMessages.client2server[loop+2], client-&gt;supportedMessages.client2server[loop+3],\n                client-&gt;supportedMessages.client2server[loop+4], client-&gt;supportedMessages.client2server[loop+5],\n                client-&gt;supportedMessages.client2server[loop+6], client-&gt;supportedMessages.client2server[loop+7]);\n\n          rfbClientLog("server2client supported messages (bit flags)\\n");\n          for (loop=0;loop&lt;32;loop+=8)\n            rfbClientLog("%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n", loop,\n                client-&gt;supportedMessages.server2client[loop],   client-&gt;supportedMessages.server2client[loop+1],\n                client-&gt;supportedMessages.server2client[loop+2], client-&gt;supportedMessages.server2client[loop+3],\n                client-&gt;supportedMessages.server2client[loop+4], client-&gt;supportedMessages.server2client[loop+5],\n                client-&gt;supportedMessages.server2client[loop+6], client-&gt;supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog("Connected to Server \\"%s\\"\\n", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w &gt; client-&gt;width) ||\n\t    (rect.r.y + rect.r.h &gt; client-&gt;height))\n\t    {\n\t      rfbClientLog("Rect too large: %dx%d at (%d, %d)\\n",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) &amp;&amp; \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog("Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client-&gt;SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client-&gt;format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead &amp;&amp; h &gt; 0) {\n\t  if (linesToRead &gt; h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client-&gt;buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client-&gt;GotBitmap(client, (uint8_t *)client-&gt;buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&amp;cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   "cursor lock area" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient-&gt;SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client-&gt;GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client-&gt;format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client-&gt;format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client-&gt;format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client-&gt;format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client-&gt;format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client-&gt;format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client-&gt;si.format.greenMax &gt; 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client-&gt;format.redMax &lt;&lt; client-&gt;format.redShift) |\n              (client-&gt;format.greenMax &lt;&lt; client-&gt;format.greenShift) |\n              (client-&gt;format.blueMax &lt;&lt; client-&gt;format.blueShift);\n          if ((client-&gt;format.bigEndian &amp;&amp; (maxColor &amp; 0xff) == 0) ||\n              (!client-&gt;format.bigEndian &amp;&amp; (maxColor &amp; 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client-&gt;format.bigEndian &amp;&amp; (maxColor &amp; 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client-&gt;format.bigEndian &amp;&amp; (maxColor &amp; 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client-&gt;format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client-&gt;format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient-&gt;appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client-&gt;format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client-&gt;si.format.greenMax &gt; 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client-&gt;format.redMax&lt;&lt;client-&gt;format.redShift)|\n\t\t(client-&gt;format.greenMax&lt;&lt;client-&gt;format.greenShift)|\n\t\t(client-&gt;format.blueMax&lt;&lt;client-&gt;format.blueShift);\n\t  if ((client-&gt;format.bigEndian &amp;&amp; (maxColor&amp;0xff)==0) ||\n\t      (!client-&gt;format.bigEndian &amp;&amp; (maxColor&amp;0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client-&gt;format.bigEndian &amp;&amp; (maxColor&amp;0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client-&gt;format.bigEndian &amp;&amp; (maxColor&amp;0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled &amp;&amp; e; e = e-&gt;next)\n\t     if(e-&gt;handleEncoding &amp;&amp; e-&gt;handleEncoding(client, &amp;rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog("Unknown rect encoding %d\\n",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard "soft cursor locks". */\n      client-&gt;SoftCursorUnlockScreen(client);\n\n      client-&gt;GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client-&gt;FinishedFrameBufferUpdate)\n      client-&gt;FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client-&gt;Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&amp;msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length &gt; 1&lt;&lt;20) {\n\t    rfbClientErr("Ignoring too big cut text length sent by server: %u B &gt; 1 MB\\n", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc(msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client-&gt;GotXCutText)\n      client-&gt;GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&amp;msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog("Received TextChat Open\\n");\n          if (client-&gt;HandleTextChat!=NULL)\n              client-&gt;HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog("Received TextChat Close\\n");\n         if (client-&gt;HandleTextChat!=NULL)\n              client-&gt;HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog("Received TextChat Finished\\n");\n         if (client-&gt;HandleTextChat!=NULL)\n              client-&gt;HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate &lt;just in case&gt; */\n          buffer[msg.tc.length]=0;\n          rfbClientLog("Received TextChat \\"%s\\"\\n", buffer);\n          if (client-&gt;HandleTextChat!=NULL)\n              client-&gt;HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&amp;msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client-&gt;HandleXvpMsg)\n      client-&gt;HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&amp;msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client-&gt;width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client-&gt;height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client-&gt;updateRect.x = client-&gt;updateRect.y = 0;\n    client-&gt;updateRect.w = client-&gt;width;\n    client-&gt;updateRect.h = client-&gt;height;\n    if (!client-&gt;MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client-&gt;width, client-&gt;height, FALSE);\n    rfbClientLog("Got new framebuffer size: %dx%d\\n", client-&gt;width, client-&gt;height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&amp;msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client-&gt;width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client-&gt;height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client-&gt;updateRect.x = client-&gt;updateRect.y = 0;\n    client-&gt;updateRect.w = client-&gt;width;\n    client-&gt;updateRect.h = client-&gt;height;\n    if (!client-&gt;MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client-&gt;width, client-&gt;height, FALSE);\n    rfbClientLog("Got new framebuffer size: %dx%d\\n", client-&gt;width, client-&gt;height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled &amp;&amp; e; e = e-&gt;next)\n\tif(e-&gt;handleMessage &amp;&amp; e-&gt;handleMessage(client, &amp;msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog("Unknown message type %d from VNC server\\n",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}',
 'get_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n    krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;\n    size_t i, j;\n    char buf[DN_BUF_LEN];\n    unsigned int bufsize = sizeof(buf);\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    /* Get the subject name (in rfc2253 format). */\n    X509_NAME_oneline_ex(X509_get_subject_name(cert), buf, &amp;bufsize,\n                         XN_FLAG_SEP_COMMA_PLUS);\n    md-&gt;subject_dn = strdup(buf);\n    if (md-&gt;subject_dn == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Get the issuer name (in rfc2253 format). */\n    X509_NAME_oneline_ex(X509_get_issuer_name(cert), buf, &amp;bufsize,\n                         XN_FLAG_SEP_COMMA_PLUS);\n    md-&gt;issuer_dn = strdup(buf);\n    if (md-&gt;issuer_dn == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Get the SAN data. */\n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &amp;pkinit_sans, &amp;upn_sans, NULL);\n    if (ret)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md-&gt;sans = calloc((size_t)j+1, sizeof(*md-&gt;sans));\n        if (md-&gt;sans == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md-&gt;sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md-&gt;sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md-&gt;sans[j] = NULL;\n    } else\n        md-&gt;sans = NULL;\n\n    /* Get the KU and EKU data. */\n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &amp;md-&gt;ku_bits,\n                                         &amp;md-&gt;eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}',
 'setup_secureChannel(void) {\n    TestingPolicy(&amp;dummyPolicy, dummyCertificate, &amp;fCalled, &amp;keySizes);\n    UA_SecureChannel_init(&amp;testChannel, &amp;UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&amp;testChannel, &amp;dummyPolicy, &amp;dummyCertificate);\n\n    testingConnection =\n        createDummyConnection(UA_ConnectionConfig_default.sendBufferSize, &amp;sentData);\n    UA_Connection_attachSecureChannel(&amp;testingConnection, &amp;testChannel);\n    testChannel.connection = &amp;testingConnection;\n\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}',
 'Result ZipFile::uncompressEntry (int index, const File&amp; targetDirectory, bool shouldOverwriteFiles)\r\n{\r\n    auto* zei = entries.getUnchecked (index);\r\n\r\n   #if JUCE_WINDOWS\r\n    auto entryPath = zei-&gt;entry.filename;\r\n   #else\r\n    auto entryPath = zei-&gt;entry.filename.replaceCharacter (\'\\\\\', \'/\');\r\n   #endif\r\n\r\n    if (entryPath.isEmpty())\r\n        return Result::ok();\r\n\r\n    auto targetFile = targetDirectory.getChildFile (entryPath);\r\n\r\n    if (entryPath.endsWithChar (\'/\') || entryPath.endsWithChar (\'\\\\\'))\r\n        return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n\r\n    std::unique_ptr&lt;InputStream&gt; in (createStreamForEntry (index));\r\n\r\n    if (in == nullptr)\r\n        return Result::fail ("Failed to open the zip file for reading");\r\n\r\n    if (targetFile.exists())\r\n    {\r\n        if (! shouldOverwriteFiles)\r\n            return Result::ok();\r\n\r\n        if (! targetFile.deleteFile())\r\n            return Result::fail ("Failed to write to target file: " + targetFile.getFullPathName());\r\n    }\r\n\r\n    if (! targetFile.getParentDirectory().createDirectory())\r\n        return Result::fail ("Failed to create target folder: " + targetFile.getParentDirectory().getFullPathName());\r\n\r\n    if (zei-&gt;entry.isSymbolicLink)\r\n    {\r\n        String originalFilePath (in-&gt;readEntireStreamAsString()\r\n                                    .replaceCharacter (L\'/\', File::getSeparatorChar()));\r\n\r\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\r\n            return Result::fail ("Failed to create symbolic link: " + originalFilePath);\r\n    }\r\n    else\r\n    {\r\n        FileOutputStream out (targetFile);\r\n\r\n        if (out.failedToOpen())\r\n            return Result::fail ("Failed to write to target file: " + targetFile.getFullPathName());\r\n\r\n        out &lt;&lt; *in;\r\n    }\r\n\r\n    targetFile.setCreationTime (zei-&gt;entry.fileTime);\r\n    targetFile.setLastModificationTime (zei-&gt;entry.fileTime);\r\n    targetFile.setLastAccessTime (zei-&gt;entry.fileTime);\r\n\r\n    return Result::ok();\r\n}\r',
 'static void suboption(struct Curl_easy *data)\n{\n  struct curl_slist *v;\n  unsigned char temp[2048];\n  ssize_t bytes_written;\n  size_t len;\n  int err;\n  char varname[128] = "";\n  char varval[128] = "";\n  struct TELNET *tn = data-&gt;req.p.telnet;\n  struct connectdata *conn = data-&gt;conn;\n\n  printsub(data, \'&lt;\', (unsigned char *)tn-&gt;subbuffer, CURL_SB_LEN(tn) + 2);\n  switch(CURL_SB_GET(tn)) {\n    case CURL_TELOPT_TTYPE:\n      len = strlen(tn-&gt;subopt_ttype) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                "%c%c%c%c%s%c%c", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE,\n                CURL_TELQUAL_IS, tn-&gt;subopt_ttype, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn-&gt;sock[FIRSTSOCKET], temp, len);\n      if(bytes_written &lt; 0) {\n        err = SOCKERRNO;\n        failf(data,"Sending data failed (%d)",err);\n      }\n      printsub(data, \'&gt;\', &amp;temp[2], len-2);\n      break;\n    case CURL_TELOPT_XDISPLOC:\n      len = strlen(tn-&gt;subopt_xdisploc) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                "%c%c%c%c%s%c%c", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC,\n                CURL_TELQUAL_IS, tn-&gt;subopt_xdisploc, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn-&gt;sock[FIRSTSOCKET], temp, len);\n      if(bytes_written &lt; 0) {\n        err = SOCKERRNO;\n        failf(data,"Sending data failed (%d)",err);\n      }\n      printsub(data, \'&gt;\', &amp;temp[2], len-2);\n      break;\n    case CURL_TELOPT_NEW_ENVIRON:\n      msnprintf((char *)temp, sizeof(temp),\n                "%c%c%c%c", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON,\n                CURL_TELQUAL_IS);\n      len = 4;\n\n      for(v = tn-&gt;telnet_vars; v; v = v-&gt;next) {\n        size_t tmplen = (strlen(v-&gt;data) + 1);\n        /* Add the variable only if it fits */\n        if(len + tmplen &lt; (int)sizeof(temp)-6) {\n          if(sscanf(v-&gt;data, "%127[^,],%127s", varname, varval)) {\n            msnprintf((char *)&amp;temp[len], sizeof(temp) - len,\n                      "%c%s%c%s", CURL_NEW_ENV_VAR, varname,\n                      CURL_NEW_ENV_VALUE, varval);\n            len += tmplen;\n          }\n        }\n      }\n      msnprintf((char *)&amp;temp[len], sizeof(temp) - len,\n                "%c%c", CURL_IAC, CURL_SE);\n      len += 2;\n      bytes_written = swrite(conn-&gt;sock[FIRSTSOCKET], temp, len);\n      if(bytes_written &lt; 0) {\n        err = SOCKERRNO;\n        failf(data,"Sending data failed (%d)",err);\n      }\n      printsub(data, \'&gt;\', &amp;temp[2], len-2);\n      break;\n  }\n  return;\n}',
 "static BOOL region16_simplify_bands(REGION16* region)\n{\n\t/** Simplify consecutive bands that touch and have the same items\n\t *\n\t *  ====================          ====================\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |\t   ====&gt;    | 1 |  |  2  |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================          ====================\n\t *\n\t */\n\tRECTANGLE_16* band1, *band2, *endPtr, *endBand, *tmp;\n\tint nbRects, finalNbRects;\n\tint bandItems, toMove;\n\tfinalNbRects = nbRects = region16_n_rects(region);\n\n\tif (nbRects &lt; 2)\n\t\treturn TRUE;\n\n\tband1 = region16_rects_noconst(region);\n\tendPtr = band1 + nbRects;\n\n\tdo\n\t{\n\t\tband2 = next_band(band1, endPtr, &amp;bandItems);\n\n\t\tif (band2 == endPtr)\n\t\t\tbreak;\n\n\t\tif ((band1-&gt;bottom == band2-&gt;top) &amp;&amp; band_match(band1, band2, endPtr))\n\t\t{\n\t\t\t/* adjust the bottom of band1 items */\n\t\t\ttmp = band1;\n\n\t\t\twhile (tmp &lt; band2)\n\t\t\t{\n\t\t\t\ttmp-&gt;bottom = band2-&gt;bottom;\n\t\t\t\ttmp++;\n\t\t\t}\n\n\t\t\t/* override band2, we don't move band1 pointer as the band after band2\n\t\t\t * may be merged too */\n\t\t\tendBand = band2 + bandItems;\n\t\t\ttoMove = (endPtr - endBand) * sizeof(RECTANGLE_16);\n\n\t\t\tif (toMove)\n\t\t\t\tMoveMemory(band2, endBand, toMove);\n\n\t\t\tfinalNbRects -= bandItems;\n\t\t\tendPtr -= bandItems;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tband1 = band2;\n\t\t}\n\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tREGION16_DATA* data;\n\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tdata = realloc(region-&gt;data, allocSize);\n\t\tif (!data)\n\t\t\tfree(region-&gt;data);\n\t\tregion-&gt;data = data;\n\n\t\tif (!region-&gt;data)\n\t\t{\n\t\t\tregion-&gt;data = &amp;empty_region;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tregion-&gt;data-&gt;nbRects = finalNbRects;\n\t\tregion-&gt;data-&gt;size = allocSize;\n\t}\n\n\treturn TRUE;\n}",
 'spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\n\treturn (ret);\n}',
 'TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* axis,\n                                 const TfLiteTensor* input, int num_splits) {\n  int axis_value = GetTensorData&lt;int&gt;(axis)[0];\n  if (axis_value &lt; 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  TF_LITE_ENSURE(context, axis_value &gt;= 0);\n  TF_LITE_ENSURE(context, axis_value &lt; NumDimensions(input));\n\n  const int input_size = SizeOfDimension(input, axis_value);\n  TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,\n                     "Not an even split");\n  const int slice_size = input_size / num_splits;\n\n  for (int i = 0; i &lt; NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input-&gt;dims);\n    output_dims-&gt;data[axis_value] = slice_size;\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &amp;output));\n    TF_LITE_ENSURE_STATUS(context-&gt;ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}',
 '  void Compute(OpKernelContext* context) override {\n    const Tensor&amp; images = context-&gt;input(0);\n    const Tensor&amp; boxes = context-&gt;input(1);\n    const int64 depth = images.dim_size(3);\n\n    OP_REQUIRES(context, images.dims() == 4,\n                errors::InvalidArgument("The rank of the images should be 4"));\n    OP_REQUIRES(\n        context, boxes.dims() == 3,\n        errors::InvalidArgument("The rank of the boxes tensor should be 3"));\n    OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0),\n                errors::InvalidArgument("The batch sizes should be the same"));\n\n    OP_REQUIRES(\n        context, depth == 4 || depth == 1 || depth == 3,\n        errors::InvalidArgument("Channel depth should be either 1 (GRY), "\n                                "3 (RGB), or 4 (RGBA)"));\n\n    const int64 batch_size = images.dim_size(0);\n    const int64 height = images.dim_size(1);\n    const int64 width = images.dim_size(2);\n    std::vector&lt;std::vector&lt;float&gt;&gt; color_table;\n    if (context-&gt;num_inputs() == 3) {\n      const Tensor&amp; colors_tensor = context-&gt;input(2);\n      OP_REQUIRES(context, colors_tensor.shape().dims() == 2,\n                  errors::InvalidArgument("colors must be a 2-D matrix",\n                                          colors_tensor.shape().DebugString()));\n      OP_REQUIRES(context, colors_tensor.shape().dim_size(1) &gt;= depth,\n                  errors::InvalidArgument("colors must have equal or more ",\n                                          "channels than the image provided: ",\n                                          colors_tensor.shape().DebugString()));\n      if (colors_tensor.NumElements() != 0) {\n        color_table.clear();\n\n        auto colors = colors_tensor.matrix&lt;float&gt;();\n        for (int64 i = 0; i &lt; colors.dimension(0); i++) {\n          std::vector&lt;float&gt; color_value(4);\n          for (int64 j = 0; j &lt; 4; j++) {\n            color_value[j] = colors(i, j);\n          }\n          color_table.emplace_back(color_value);\n        }\n      }\n    }\n    if (color_table.empty()) {\n      color_table = DefaultColorTable(depth);\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(\n        context,\n        context-&gt;allocate_output(\n            0, TensorShape({batch_size, height, width, depth}), &amp;output));\n\n    output-&gt;tensor&lt;T, 4&gt;() = images.tensor&lt;T, 4&gt;();\n    auto canvas = output-&gt;tensor&lt;T, 4&gt;();\n\n    for (int64 b = 0; b &lt; batch_size; ++b) {\n      const int64 num_boxes = boxes.dim_size(1);\n      const auto tboxes = boxes.tensor&lt;T, 3&gt;();\n      for (int64 bb = 0; bb &lt; num_boxes; ++bb) {\n        int64 color_index = bb % color_table.size();\n        const int64 min_box_row =\n            static_cast&lt;float&gt;(tboxes(b, bb, 0)) * (height - 1);\n        const int64 min_box_row_clamp = std::max&lt;int64&gt;(min_box_row, int64{0});\n        const int64 max_box_row =\n            static_cast&lt;float&gt;(tboxes(b, bb, 2)) * (height - 1);\n        const int64 max_box_row_clamp =\n            std::min&lt;int64&gt;(max_box_row, height - 1);\n        const int64 min_box_col =\n            static_cast&lt;float&gt;(tboxes(b, bb, 1)) * (width - 1);\n        const int64 min_box_col_clamp = std::max&lt;int64&gt;(min_box_col, int64{0});\n        const int64 max_box_col =\n            static_cast&lt;float&gt;(tboxes(b, bb, 3)) * (width - 1);\n        const int64 max_box_col_clamp = std::min&lt;int64&gt;(max_box_col, width - 1);\n\n        if (min_box_row &gt; max_box_row || min_box_col &gt; max_box_col) {\n          LOG(WARNING) &lt;&lt; "Bounding box (" &lt;&lt; min_box_row &lt;&lt; "," &lt;&lt; min_box_col\n                       &lt;&lt; "," &lt;&lt; max_box_row &lt;&lt; "," &lt;&lt; max_box_col\n                       &lt;&lt; ") is inverted and will not be drawn.";\n          continue;\n        }\n        if (min_box_row &gt;= height || max_box_row &lt; 0 || min_box_col &gt;= width ||\n            max_box_col &lt; 0) {\n          LOG(WARNING) &lt;&lt; "Bounding box (" &lt;&lt; min_box_row &lt;&lt; "," &lt;&lt; min_box_col\n                       &lt;&lt; "," &lt;&lt; max_box_row &lt;&lt; "," &lt;&lt; max_box_col\n                       &lt;&lt; ") is completely outside the image"\n                       &lt;&lt; " and will not be drawn.";\n          continue;\n        }\n\n        // At this point, {min,max}_box_{row,col}_clamp are inside the\n        // image.\n        CHECK_GE(min_box_row_clamp, 0);\n        CHECK_GE(max_box_row_clamp, 0);\n        CHECK_LT(min_box_row_clamp, height);\n        CHECK_LT(max_box_row_clamp, height);\n        CHECK_GE(min_box_col_clamp, 0);\n        CHECK_GE(max_box_col_clamp, 0);\n        CHECK_LT(min_box_col_clamp, width);\n        CHECK_LT(max_box_col_clamp, width);\n\n        // At this point, the min_box_row and min_box_col are either\n        // in the image or above/left of it, and max_box_row and\n        // max_box_col are either in the image or below/right or it.\n        CHECK_LT(min_box_row, height);\n        CHECK_GE(max_box_row, 0);\n        CHECK_LT(min_box_col, width);\n        CHECK_GE(max_box_col, 0);\n\n        // Draw top line.\n        if (min_box_row &gt;= 0) {\n          for (int64 j = min_box_col_clamp; j &lt;= max_box_col_clamp; ++j)\n            for (int64 c = 0; c &lt; depth; c++) {\n              canvas(b, min_box_row, j, c) =\n                  static_cast&lt;T&gt;(color_table[color_index][c]);\n            }\n        }\n        // Draw bottom line.\n        if (max_box_row &lt; height) {\n          for (int64 j = min_box_col_clamp; j &lt;= max_box_col_clamp; ++j)\n            for (int64 c = 0; c &lt; depth; c++) {\n              canvas(b, max_box_row, j, c) =\n                  static_cast&lt;T&gt;(color_table[color_index][c]);\n            }\n        }\n        // Draw left line.\n        if (min_box_col &gt;= 0) {\n          for (int64 i = min_box_row_clamp; i &lt;= max_box_row_clamp; ++i)\n            for (int64 c = 0; c &lt; depth; c++) {\n              canvas(b, i, min_box_col, c) =\n                  static_cast&lt;T&gt;(color_table[color_index][c]);\n            }\n        }\n        // Draw right line.\n        if (max_box_col &lt; width) {\n          for (int64 i = min_box_row_clamp; i &lt;= max_box_row_clamp; ++i)\n            for (int64 c = 0; c &lt; depth; c++) {\n              canvas(b, i, max_box_col, c) =\n                  static_cast&lt;T&gt;(color_table[color_index][c]);\n            }\n        }\n      }\n    }\n  }',
 'char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("", cl, NULL);\n\n    /*\n       We later alloc length+1, which might wrap around on 32-bit systems if length equals\n       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n       will safely be allocated since this check will never trigger and malloc() can digest length+1\n       without problems as length is a uint32_t.\n    */\n    if(length == SIZE_MAX) {\n\trfbErr("rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n\n    if (length&gt;0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) &lt;= 0) {\n                if (n != 0)\n                    rfbLogPerror("rfbProcessFileTransferReadBuffer: read");\n                rfbCloseClient(cl);\n                /* NOTE: don\'t forget to free(buffer) if you return early! */\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            /* Null Terminate */\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}',
 'void ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo)\n{\n  FILE *stream = stdout;\n  const char *ptr = writeinfo;\n  char *stringp = NULL;\n  long longinfo;\n  double doubleinfo;\n\n  while(ptr &amp;&amp; *ptr) {\n    if(\'%\' == *ptr &amp;&amp; ptr[1]) {\n      if(\'%\' == ptr[1]) {\n        /* an escaped %-letter */\n        fputc(\'%\', stream);\n        ptr += 2;\n      }\n      else {\n        /* this is meant as a variable to output */\n        char *end;\n        char keepit;\n        int i;\n        if(\'{\' == ptr[1]) {\n          bool match = FALSE;\n          end = strchr(ptr, \'}\');\n          ptr += 2; /* pass the % and the { */\n          if(!end) {\n            fputs("%{", stream);\n            continue;\n          }\n          keepit = *end;\n          *end = 0; /* zero terminate */\n          for(i = 0; replacements[i].name; i++) {\n            if(curl_strequal(ptr, replacements[i].name)) {\n              match = TRUE;\n              switch(replacements[i].id) {\n              case VAR_EFFECTIVE_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &amp;stringp))\n                   &amp;&amp; stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_HTTP_CODE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;longinfo))\n                  fprintf(stream, "%03ld", longinfo);\n                break;\n              case VAR_HTTP_CODE_PROXY:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE,\n                                     &amp;longinfo))\n                  fprintf(stream, "%03ld", longinfo);\n                break;\n              case VAR_HEADER_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &amp;longinfo))\n                  fprintf(stream, "%ld", longinfo);\n                break;\n              case VAR_REQUEST_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE, &amp;longinfo))\n                  fprintf(stream, "%ld", longinfo);\n                break;\n              case VAR_NUM_CONNECTS:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &amp;longinfo))\n                  fprintf(stream, "%ld", longinfo);\n                break;\n              case VAR_REDIRECT_COUNT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &amp;longinfo))\n                  fprintf(stream, "%ld", longinfo);\n                break;\n              case VAR_REDIRECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME,\n                                     &amp;doubleinfo))\n                  fprintf(stream, "%.6f", doubleinfo);\n                break;\n              case VAR_TOTAL_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &amp;doubleinfo))\n                  fprintf(stream, "%.6f", doubleinfo);\n                break;\n              case VAR_NAMELOOKUP_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME,\n                                     &amp;doubleinfo))\n                  fprintf(stream, "%.6f", doubleinfo);\n                break;\n              case VAR_CONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &amp;doubleinfo))\n                  fprintf(stream, "%.6f", doubleinfo);\n                break;\n              case VAR_APPCONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME,\n                                     &amp;doubleinfo))\n                  fprintf(stream, "%.6f", doubleinfo);\n                break;\n              case VAR_PRETRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME,\n                                     &amp;doubleinfo))\n                  fprintf(stream, "%.6f", doubleinfo);\n                break;\n              case VAR_STARTTRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME,\n                                     &amp;doubleinfo))\n                  fprintf(stream, "%.6f", doubleinfo);\n                break;\n              case VAR_SIZE_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &amp;doubleinfo))\n                  fprintf(stream, "%.0f", doubleinfo);\n                break;\n              case VAR_SIZE_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD,\n                                     &amp;doubleinfo))\n                  fprintf(stream, "%.0f", doubleinfo);\n                break;\n              case VAR_SPEED_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD,\n                                     &amp;doubleinfo))\n                  fprintf(stream, "%.3f", doubleinfo);\n                break;\n              case VAR_SPEED_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &amp;doubleinfo))\n                  fprintf(stream, "%.3f", doubleinfo);\n                break;\n              case VAR_CONTENT_TYPE:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &amp;stringp))\n                   &amp;&amp; stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_FTP_ENTRY_PATH:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &amp;stringp))\n                   &amp;&amp; stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_REDIRECT_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &amp;stringp))\n                   &amp;&amp; stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT,\n                                     &amp;longinfo))\n                  fprintf(stream, "%ld", longinfo);\n                break;\n              case VAR_PROXY_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PROXY_SSL_VERIFYRESULT,\n                                     &amp;longinfo))\n                  fprintf(stream, "%ld", longinfo);\n                break;\n              case VAR_EFFECTIVE_FILENAME:\n                if(outs-&gt;filename)\n                  fprintf(stream, "%s", outs-&gt;filename);\n                break;\n              case VAR_PRIMARY_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP,\n                                     &amp;stringp))\n                  fprintf(stream, "%s", stringp);\n                break;\n              case VAR_PRIMARY_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT,\n                                     &amp;longinfo))\n                  fprintf(stream, "%ld", longinfo);\n                break;\n              case VAR_LOCAL_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_IP,\n                                     &amp;stringp))\n                  fprintf(stream, "%s", stringp);\n                break;\n              case VAR_LOCAL_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT,\n                                     &amp;longinfo))\n                  fprintf(stream, "%ld", longinfo);\n                break;\n              case VAR_HTTP_VERSION:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_VERSION,\n                                     &amp;longinfo)) {\n                  const char *version = "0";\n                  switch(longinfo) {\n                  case CURL_HTTP_VERSION_1_0:\n                    version = "1.0";\n                    break;\n                  case CURL_HTTP_VERSION_1_1:\n                    version = "1.1";\n                    break;\n                  case CURL_HTTP_VERSION_2_0:\n                    version = "2";\n                    break;\n                  }\n\n                  fprintf(stream, version);\n                }\n                break;\n              case VAR_SCHEME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SCHEME,\n                                     &amp;stringp))\n                  fprintf(stream, "%s", stringp);\n                break;\n              default:\n                break;\n              }\n              break;\n            }\n          }\n          if(!match) {\n            fprintf(stderr, "curl: unknown --write-out variable: \'%s\'\\n", ptr);\n          }\n          ptr = end + 1; /* pass the end */\n          *end = keepit;\n        }\n        else {\n          /* illegal syntax, then just output the characters that are used */\n          fputc(\'%\', stream);\n          fputc(ptr[1], stream);\n          ptr += 2;\n        }\n      }\n    }\n    else if(\'\\\\\' == *ptr) {\n      switch(ptr[1]) {\n      case \'r\':\n        fputc(\'\\r\', stream);\n        break;\n      case \'n\':\n        fputc(\'\\n\', stream);\n        break;\n      case \'t\':\n        fputc(\'\\t\', stream);\n        break;\n      default:\n        /* unknown, just output this */\n        fputc(*ptr, stream);\n        fputc(ptr[1], stream);\n        break;\n      }\n      ptr += 2;\n    }\n    else {\n      fputc(*ptr, stream);\n      ptr++;\n    }\n  }\n\n}',
 "SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,\n\t\tunsigned long, nbytes, int __user *, start, void __user *, arg)\n{\n\tunsigned long w;\n\tstruct percpu_struct *cpu;\n\n\tswitch (op) {\n\tcase GSI_IEEE_FP_CONTROL:\n\t\t/* Return current software fp control &amp; status bits.  */\n\t\t/* Note that DU doesn't verify available space here.  */\n\n \t\tw = current_thread_info()-&gt;ieee_state &amp; IEEE_SW_MASK;\n \t\tw = swcr_update_status(w, rdfpcr());\n\t\tif (put_user(w, (unsigned long __user *) buffer))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase GSI_IEEE_STATE_AT_SIGNAL:\n\t\t/*\n\t\t * Not sure anybody will ever use this weird stuff.  These\n\t\t * ops can be used (under OSF/1) to set the fpcr that should\n\t\t * be used when a signal handler starts executing.\n\t\t */\n\t\tbreak;\n\n \tcase GSI_UACPROC:\n\t\tif (nbytes &lt; sizeof(unsigned int))\n\t\t\treturn -EINVAL;\n \t\tw = (current_thread_info()-&gt;flags &gt;&gt; UAC_SHIFT) &amp; UAC_BITMASK;\n \t\tif (put_user(w, (unsigned int __user *)buffer))\n \t\t\treturn -EFAULT;\n \t\treturn 1;\n\n\tcase GSI_PROC_TYPE:\n\t\tif (nbytes &lt; sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tcpu = (struct percpu_struct*)\n\t\t  ((char*)hwrpb + hwrpb-&gt;processor_offset);\n\t\tw = cpu-&gt;type;\n\t\tif (put_user(w, (unsigned long  __user*)buffer))\n\t\t\treturn -EFAULT;\n\t\treturn 1;\n\n\tcase GSI_GET_HWRPB:\n\t\tif (nbytes &gt; sizeof(*hwrpb))\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(buffer, hwrpb, nbytes) != 0)\n\t\t\treturn -EFAULT;\n\t\treturn 1;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}",
 '_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error("Unable to retrieve stanza name for Carbon");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, "private") == 0) {\n        log_info("Carbon received with private element.");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, "received") != 0) &amp;&amp; (g_strcmp0(name, "sent") != 0)) {\n        log_warning("Carbon received with unrecognised stanza name: %s", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning("Carbon received with no forwarded element");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning("Carbon received with no message element");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning("Carbon received with no message.");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n    Jid *my_jid = jid_create(connection_get_fulljid());\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid-&gt;barejid, jid_to-&gt;barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from-&gt;barejid, jid_from-&gt;resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to-&gt;barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}',
 'GF_Err ilst_item_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there\'s a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&amp;a, bs);\n\n\t\tif (!e &amp;&amp; ptr-&gt;size &lt; a-&gt;size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n", gf_4cc_to_str(ptr-&gt;type), ptr-&gt;size, a-&gt;size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\n\t\tISOM_DECREASE_SIZE(ptr, a-&gt;size);\n\n\t\tif (a &amp;&amp; ptr-&gt;data) gf_isom_box_del_parent(&amp;ptr-&gt;child_boxes, (GF_Box *) ptr-&gt;data);\n\n\t\t/* otherwise a-&gt;data will always overflow */\n\t\tif (a &amp;&amp; a-&gt;size &gt; 4 &amp;&amp; a-&gt;type != GF_ISOM_BOX_TYPE_VOID) {\n\t\t\tptr-&gt;data = (GF_DataBox *)a;\n\t\t\tif (!ptr-&gt;child_boxes) ptr-&gt;child_boxes = gf_list_new();\n\t\t\tgf_list_add(ptr-&gt;child_boxes, ptr-&gt;data);\n\t\t} else {\n\t\t\tptr-&gt;data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tu64 pos = gf_bs_get_position(bs);\n\t\tu64 prev_size = s-&gt;size;\n\t\t/*try parsing as generic box list*/\n\t\te = gf_isom_box_array_read(s, bs, NULL);\n\t\tif (e==GF_OK) return GF_OK;\n\t\t//reset content and retry - this deletes ptr-&gt;data !!\n\t\tgf_isom_box_array_del(s-&gt;child_boxes);\n\t\ts-&gt;child_boxes=NULL;\n\t\tgf_bs_seek(bs, pos);\n\t\ts-&gt;size = prev_size;\n\n\t\tptr-&gt;data = (GF_DataBox *)gf_isom_box_new_parent(&amp;ptr-&gt;child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t//nope, check qt-style\n\t\tptr-&gt;data-&gt;qt_style = GF_TRUE;\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr-&gt;data-&gt;dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\n\t\tptr-&gt;data-&gt;data = (char *) gf_malloc(sizeof(char)*(ptr-&gt;data-&gt;dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr-&gt;data-&gt;data, ptr-&gt;data-&gt;dataSize);\n\t\tptr-&gt;data-&gt;data[ptr-&gt;data-&gt;dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr-&gt;data-&gt;dataSize);\n\t}\n\treturn GF_OK;\n}',
 'delete_buff_tail(buffheader_T *buf, int slen)\n{\n    int len = (int)STRLEN(buf-&gt;bh_curr-&gt;b_str);\n\n    if (len &gt;= slen)\n    {\n\tbuf-&gt;bh_curr-&gt;b_str[len - slen] = NUL;\n\tbuf-&gt;bh_space += slen;\n    }\n}',
 'TIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldInfo info[], size_t n)\n{\n\tstatic const char module[] = "TIFFReadCustomDirectory";\n\n\tTIFFDirectory* td = &amp;tif-&gt;tif_dir;\n\tTIFFDirEntry *dp, *dir = NULL;\n\tconst TIFFFieldInfo* fip;\n\tsize_t fix;\n\tuint16 i, dircount;\n\n\t_TIFFSetupFieldInfo(tif, info, n);\n\n\tdircount = TIFFFetchDirectory(tif, diroff, &amp;dir, NULL);\n\tif (!dircount) {\n\t\tTIFFErrorExt(tif-&gt;tif_clientdata, module,\n\t\t\t"%s: Failed to read custom directory at offset %u",\n\t\t\t     tif-&gt;tif_name, diroff);\n\t\treturn 0;\n\t}\n\n\tTIFFFreeDirectory(tif);\n        _TIFFmemset(&amp;tif-&gt;tif_dir, 0, sizeof(TIFFDirectory));\n\n\tfix = 0;\n\tfor (dp = dir, i = dircount; i &gt; 0; i--, dp++) {\n\t\tif (tif-&gt;tif_flags &amp; TIFF_SWAB) {\n\t\t\tTIFFSwabArrayOfShort(&amp;dp-&gt;tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&amp;dp-&gt;tdir_count, 2);\n\t\t}\n\n\t\tif (fix &gt;= tif-&gt;tif_nfields || dp-&gt;tdir_tag == IGNORE)\n\t\t\tcontinue;\n\n\t\twhile (fix &lt; tif-&gt;tif_nfields &amp;&amp;\n\t\t       tif-&gt;tif_fieldinfo[fix]-&gt;field_tag &lt; dp-&gt;tdir_tag)\n\t\t\tfix++;\n\n\t\tif (fix &gt;= tif-&gt;tif_nfields ||\n\t\t    tif-&gt;tif_fieldinfo[fix]-&gt;field_tag != dp-&gt;tdir_tag) {\n\n\t\t\tTIFFWarningExt(tif-&gt;tif_clientdata, module,\n                        "%s: unknown field with tag %d (0x%x) encountered",\n\t\t\t\t    tif-&gt;tif_name, dp-&gt;tdir_tag, dp-&gt;tdir_tag);\n\t\t\tif (!_TIFFMergeFieldInfo(tif,\n\t\t\t\t\t\t _TIFFCreateAnonFieldInfo(tif,\n\t\t\t\t\t\t dp-&gt;tdir_tag,\n\t\t\t\t\t\t (TIFFDataType) dp-&gt;tdir_type),\n\t\t\t\t\t\t 1))\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif-&gt;tif_clientdata, module,\n\t\t\t"Registering anonymous field with tag %d (0x%x) failed",\n\t\t\t\t\t\tdp-&gt;tdir_tag, dp-&gt;tdir_tag);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\n\t\t\tfix = 0;\n\t\t\twhile (fix &lt; tif-&gt;tif_nfields &amp;&amp;\n\t\t\t       tif-&gt;tif_fieldinfo[fix]-&gt;field_tag &lt; dp-&gt;tdir_tag)\n\t\t\t\tfix++;\n\t\t}\n\t\t/*\n\t\t * Null out old tags that we ignore.\n\t\t */\n\t\tif (tif-&gt;tif_fieldinfo[fix]-&gt;field_bit == FIELD_IGNORE) {\n\tignore:\n\t\t\tdp-&gt;tdir_tag = IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\t\tfip = tif-&gt;tif_fieldinfo[fix];\n\t\twhile (dp-&gt;tdir_type != (unsigned short) fip-&gt;field_type\n                       &amp;&amp; fix &lt; tif-&gt;tif_nfields) {\n\t\t\tif (fip-&gt;field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n            ++fix; fip = (fix &gt;= tif-&gt;tif_nfields) ? 0 : tif-&gt;tif_fieldinfo[++fix];\n\t\t\tif (fix &gt;= tif-&gt;tif_nfields ||\n\t\t\t    fip-&gt;field_tag != dp-&gt;tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif-&gt;tif_clientdata, module,\n\t\t\t"%s: wrong data type %d for \\"%s\\"; tag ignored",\n\t\t\t\t\t    tif-&gt;tif_name, dp-&gt;tdir_type,\n\t\t\t\t\t    tif-&gt;tif_fieldinfo[fix-1]-&gt;field_name);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Check count if known in advance.\n\t\t */\n\t\tif (fip-&gt;field_readcount != TIFF_VARIABLE\n\t\t    &amp;&amp; fip-&gt;field_readcount != TIFF_VARIABLE2) {\n\t\t\tuint32 expected = (fip-&gt;field_readcount == TIFF_SPP) ?\n\t\t\t    (uint32) td-&gt;td_samplesperpixel :\n\t\t\t    (uint32) fip-&gt;field_readcount;\n\t\t\tif (!CheckDirCount(tif, dp, expected))\n\t\t\t\tgoto ignore;\n\t\t}\n\n\t\t/*\n\t\t * EXIF tags which need to be specifically processed.\n\t\t */\n\t\tswitch (dp-&gt;tdir_tag) {\n\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n\t\t\t\t(void) TIFFFetchSubjectDistance(tif, dp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t(void) TIFFFetchNormalTag(tif, dp);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}',
 'static cchar *getVxCPU(cchar *arch)\n{\n    char   *cpu, *family;\n\n    family = stok(sclone(arch), ":", &amp;cpu);\n    if (!cpu || *cpu == \'\\0\') {\n        if (smatch(family, "i386")) {\n            cpu = "I80386";\n        } else if (smatch(family, "i486")) {\n            cpu = "I80486";\n        } else if (smatch(family, "x86") | sends(family, "86")) {\n            cpu = "PENTIUM";\n        } else if (scaselessmatch(family, "mips")) {\n            cpu = "MIPS32";\n        } else if (scaselessmatch(family, "arm")) {\n            cpu = "ARM7TDMI";\n        } else if (scaselessmatch(family, "ppc")) {\n            cpu = "PPC";\n        } else {\n            cpu = (char*) arch;\n        }\n    }\n    return supper(cpu);\n}',
 'static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt-&gt;ops-&gt;cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt-&gt;ops;\n\n\tif (ctxt-&gt;mode == X86EMUL_MODE_PROT64)\n\t\tops-&gt;get_segment(ctxt, &amp;old_cs, &amp;old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\n\trc = emulate_pop(ctxt, &amp;eip, ctxt-&gt;op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &amp;cs, ctxt-&gt;op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\t/* Outer-privilege level return is not implemented */\n\tif (ctxt-&gt;mode &gt;= X86EMUL_MODE_PROT16 &amp;&amp; (cs &amp; 3) &gt; cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, 0, false,\n\t\t\t\t       &amp;new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, new_desc.l);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(!ctxt-&gt;mode != X86EMUL_MODE_PROT64);\n\t\tops-&gt;set_segment(ctxt, old_cs, &amp;old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}',
 'iperf_on_connect(struct iperf_test *test)\n{\n    time_t now_secs;\n    const char* rfc1123_fmt = "%a, %d %b %Y %H:%M:%S GMT";\n    char now_str[100];\n    char ipr[INET6_ADDRSTRLEN];\n    int port;\n    struct sockaddr_storage sa;\n    struct sockaddr_in *sa_inP;\n    struct sockaddr_in6 *sa_in6P;\n    socklen_t len;\n    int opt;\n\n    now_secs = time((time_t*) 0);\n    (void) strftime(now_str, sizeof(now_str), rfc1123_fmt, gmtime(&amp;now_secs));\n    if (test-&gt;json_output)\n\tcJSON_AddItemToObject(test-&gt;json_start, "timestamp", iperf_json_printf("time: %s  timesecs: %d", now_str, (int64_t) now_secs));\n    else if (test-&gt;verbose)\n\tiprintf(test, report_time, now_str);\n\n    if (test-&gt;role == \'c\') {\n\tif (test-&gt;json_output)\n\t    cJSON_AddItemToObject(test-&gt;json_start, "connecting_to", iperf_json_printf("host: %s  port: %d", test-&gt;server_hostname, (int64_t) test-&gt;server_port));\n\telse {\n\t    iprintf(test, report_connecting, test-&gt;server_hostname, test-&gt;server_port);\n\t    if (test-&gt;reverse)\n\t\tiprintf(test, report_reverse, test-&gt;server_hostname);\n\t}\n    } else {\n        len = sizeof(sa);\n        getpeername(test-&gt;ctrl_sck, (struct sockaddr *) &amp;sa, &amp;len);\n        if (getsockdomain(test-&gt;ctrl_sck) == AF_INET) {\n\t    sa_inP = (struct sockaddr_in *) &amp;sa;\n            inet_ntop(AF_INET, &amp;sa_inP-&gt;sin_addr, ipr, sizeof(ipr));\n\t    port = ntohs(sa_inP-&gt;sin_port);\n        } else {\n\t    sa_in6P = (struct sockaddr_in6 *) &amp;sa;\n            inet_ntop(AF_INET6, &amp;sa_in6P-&gt;sin6_addr, ipr, sizeof(ipr));\n\t    port = ntohs(sa_in6P-&gt;sin6_port);\n        }\n\tmapped_v4_to_regular_v4(ipr);\n\tif (test-&gt;json_output)\n\t    cJSON_AddItemToObject(test-&gt;json_start, "accepted_connection", iperf_json_printf("host: %s  port: %d", ipr, (int64_t) port));\n\telse\n\t    iprintf(test, report_accepted, ipr, port);\n    }\n    if (test-&gt;json_output) {\n\tcJSON_AddStringToObject(test-&gt;json_start, "cookie", test-&gt;cookie);\n        if (test-&gt;protocol-&gt;id == SOCK_STREAM) {\n\t    if (test-&gt;settings-&gt;mss)\n\t\tcJSON_AddIntToObject(test-&gt;json_start, "tcp_mss", test-&gt;settings-&gt;mss);\n\t    else {\n\t\tlen = sizeof(opt);\n\t\tgetsockopt(test-&gt;ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &amp;opt, &amp;len);\n\t\tcJSON_AddIntToObject(test-&gt;json_start, "tcp_mss_default", opt);\n\t    }\n\t}\n    } else if (test-&gt;verbose) {\n        iprintf(test, report_cookie, test-&gt;cookie);\n        if (test-&gt;protocol-&gt;id == SOCK_STREAM) {\n            if (test-&gt;settings-&gt;mss)\n                iprintf(test, "      TCP MSS: %d\\n", test-&gt;settings-&gt;mss);\n            else {\n                len = sizeof(opt);\n                getsockopt(test-&gt;ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &amp;opt, &amp;len);\n                iprintf(test, "      TCP MSS: %d (default)\\n", opt);\n            }\n        }\n\n    }\n}',
 'RemoteFsDevice::Details RemoteDevicePropertiesWidget::details()\n{\n    int t=type-&gt;itemData(type-&gt;currentIndex()).toInt();\n    RemoteFsDevice::Details det;\n\n    det.name=name-&gt;text().trimmed();\n    switch (t) {\n    case Type_SshFs: {\n        det.url.setHost(sshHost-&gt;text().trimmed());\n        det.url.setUserName(sshUser-&gt;text().trimmed());\n        det.url.setPath(sshFolder-&gt;text().trimmed());\n        det.url.setPort(sshPort-&gt;value());\n        det.url.setScheme(RemoteFsDevice::constSshfsProtocol);\n        det.extraOptions=sshExtra-&gt;text().trimmed();\n        break;\n    }\n    case Type_File: {\n        QString path=fileFolder-&gt;text().trimmed();\n        if (path.isEmpty()) {\n            path="/";\n        }\n        det.url.setPath(path);\n        det.url.setScheme(RemoteFsDevice::constFileProtocol);\n        break;\n    }\n    case Type_Samba:\n        det.url.setHost(smbHost-&gt;text().trimmed());\n        det.url.setUserName(smbUser-&gt;text().trimmed());\n        det.url.setPath(smbShare-&gt;text().trimmed());\n        det.url.setPort(smbPort-&gt;value());\n        det.url.setScheme(RemoteFsDevice::constSambaProtocol);\n        det.url.setPassword(smbPassword-&gt;text().trimmed());\n        if (!smbDomain-&gt;text().trimmed().isEmpty()) {\n            QUrlQuery q;\n            q.addQueryItem(RemoteFsDevice::constDomainQuery, smbDomain-&gt;text().trimmed());\n            det.url.setQuery(q);\n        }\n        break;\n    case Type_SambaAvahi:\n        det.url.setUserName(smbAvahiUser-&gt;text().trimmed());\n        det.url.setPath(smbAvahiShare-&gt;text().trimmed());\n        det.url.setPort(0);\n        det.url.setScheme(RemoteFsDevice::constSambaAvahiProtocol);\n        det.url.setPassword(smbAvahiPassword-&gt;text().trimmed());\n        if (!smbDomain-&gt;text().trimmed().isEmpty() || !smbAvahiName-&gt;text().trimmed().isEmpty()) {\n            QUrlQuery q;\n            if (!smbDomain-&gt;text().trimmed().isEmpty()) {\n                q.addQueryItem(RemoteFsDevice::constDomainQuery, smbAvahiDomain-&gt;text().trimmed());\n            }\n            if (!smbAvahiName-&gt;text().trimmed().isEmpty()) {\n                det.serviceName=smbAvahiName-&gt;text().trimmed();\n                q.addQueryItem(RemoteFsDevice::constServiceNameQuery, det.serviceName);\n            }\n            det.url.setQuery(q);\n        }\n        break;\n    }\n    return det;\n}',
 'Jsi_RC jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line, Jsi_OpCodes *argCodes, bool isParse)\n{\n    Jsi_RC rc = JSI_OK;\n    if (interp-&gt;typeCheck.all==0) {\n        if (!argCodes ? (interp-&gt;typeCheck.run==0) : (interp-&gt;typeCheck.parse==0))\n            return JSI_OK;\n    }\n\n    Jsi_CmdSpec *spec = func-&gt;cmdSpec;\n    Jsi_ScopeStrs *ss = func-&gt;argnames;\n    if (ss==NULL &amp;&amp; spec == NULL)\n        return JSI_OK;\n    int i, minArgs, maxArgs, mis = 0, varargs = 0;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    if (func-&gt;type == FC_BUILDIN) {\n        varargs =  (spec-&gt;maxArgs&lt;0);\n        maxArgs = spec-&gt;maxArgs + func-&gt;callflags.bits.addargs;\n        minArgs = spec-&gt;minArgs + func-&gt;callflags.bits.addargs;\n    } else {\n        varargs = ss-&gt;varargs;\n        minArgs = (ss-&gt;firstDef&gt;0 ? ss-&gt;firstDef-1 : ss-&gt;count);\n        maxArgs = ss-&gt;count;\n        mis = (argc != ss-&gt;count);\n        if (func-&gt;retType == 0 &amp;&amp; ss &amp;&amp; ss-&gt;typeCnt == 0 &amp;&amp; interp-&gt;typeCheck.all==0)\n            return JSI_OK;\n    }\n    if (varargs) {\n        if (argc &gt;= minArgs)\n            return JSI_OK;\n        mis = (argc&lt;minArgs);\n    } else \n        mis = (argc&lt;minArgs || argc&gt;maxArgs);\n    if (mis) {\n        if (varargs)\n            snprintf(nbuf, sizeof(nbuf), "%d or more", minArgs);\n        else if (maxArgs &gt; minArgs)\n            snprintf(nbuf, sizeof(nbuf), "%d-%d", minArgs, maxArgs);\n        else\n            snprintf(nbuf, sizeof(nbuf), "%d", maxArgs);\n        if (line)\n            interp-&gt;parseLine = line;\n        if (interp-&gt;typeCheck.error)\n            rc = JSI_ERROR;\n        Jsi_DString dStr = {};\n        Jsi_FuncObjToString(interp, func, &amp;dStr, 2);\n        if (isParse)\n            Jsi_LogWarn("got %d args, expected %s, calling %s", argc, nbuf, Jsi_DSValue(&amp;dStr));\n        else\n            rc = Jsi_LogType("got %d args, expected %s, calling %s", argc, nbuf, Jsi_DSValue(&amp;dStr));\n        jsi_TypeMismatch(interp);\n        Jsi_DSFree(&amp;dStr);\n        if (line)\n            interp-&gt;parseLine = NULL;\n        return rc;\n    }\n    if (argCodes &amp;&amp; argCodes-&gt;code_len&gt;=argc) {\n        int cl = argCodes-&gt;code_len;\n        int aind=argc-1;\n        for (i=cl-1; rc == JSI_OK &amp;&amp; i&gt;=0 &amp;&amp; aind&gt;=0; i--,aind--) {\n            Jsi_ttype atyp = JSI_TT_ANY;\n            switch (argCodes-&gt;codes[i].op) {\n                case OP_PUSHSTR: atyp=JSI_TT_STRING; break;\n                case OP_PUSHNUM: atyp=JSI_TT_NUMBER; break;\n                case OP_PUSHBOO: atyp=JSI_TT_BOOLEAN; break;\n                case OP_PUSHFUN: atyp=JSI_TT_FUNCTION; break;\n                case OP_PUSHTHS: atyp=JSI_TT_OBJECT; break;\n                case OP_PUSHREG: atyp=JSI_TT_REGEXP; break;\n                case OP_PUSHUND: atyp=JSI_TT_VOID; break;\n                case OP_PUSHNULL: atyp=JSI_TT_NULL; break;\n                case OP_PUSHARG: atyp=JSI_TT_ARRAY; break;\n                case OP_SUBSCRIPT: i++; break;\n                case OP_ARRAY: atyp=JSI_TT_ARRAY; i=jsiPopArgs(argCodes, i); break;\n                case OP_OBJECT: atyp=JSI_TT_OBJECT; i=jsiPopArgs(argCodes, i); break;\n                default: break;\n            }\n            if (atyp == JSI_TT_ANY) continue;\n            rc = jsi_StaticArgTypeCheck(interp, atyp, "for argument", name, aind+1, func, line);  \n        }\n    }\n    return rc;\n}',
 'Error HeifContext::interpret_heif_file()\n{\n  m_all_images.clear();\n  m_top_level_images.clear();\n  m_primary_image.reset();\n\n\n  // --- reference all non-hidden images\n\n  std::vector&lt;heif_item_id&gt; image_IDs = m_heif_file-&gt;get_item_IDs();\n\n  bool primary_is_grid = false;\n  for (heif_item_id id : image_IDs) {\n    auto infe_box = m_heif_file-&gt;get_infe_box(id);\n    if (!infe_box) {\n      // TODO(farindk): Should we return an error instead of skipping the invalid id?\n      continue;\n    }\n\n    if (item_type_is_image(infe_box-&gt;get_item_type())) {\n      auto image = std::make_shared&lt;Image&gt;(this, id);\n      m_all_images.insert(std::make_pair(id, image));\n\n      if (!infe_box-&gt;is_hidden_item()) {\n        if (id==m_heif_file-&gt;get_primary_image_ID()) {\n          image-&gt;set_primary(true);\n          m_primary_image = image;\n          primary_is_grid = infe_box-&gt;get_item_type() == "grid";\n        }\n\n        m_top_level_images.push_back(image);\n      }\n    }\n  }\n\n\n  if (!m_primary_image) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Nonexisting_item_referenced,\n                 "\'pitm\' box references a non-existing image");\n  }\n\n\n  // --- remove thumbnails from top-level images and assign to their respective image\n\n  auto iref_box = m_heif_file-&gt;get_iref_box();\n  if (iref_box) {\n    // m_top_level_images.clear();\n\n    for (auto&amp; pair : m_all_images) {\n      auto&amp; image = pair.second;\n\n      std::vector&lt;Box_iref::Reference&gt; references = iref_box-&gt;get_references_from(image-&gt;get_id());\n\n      for (const Box_iref::Reference&amp; ref : references) {\n        uint32_t type = ref.header.get_short_type();\n\n        if (type==fourcc("thmb")) {\n          // --- this is a thumbnail image, attach to the main image\n\n          std::vector&lt;heif_item_id&gt; refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         "Too many thumbnail references");\n          }\n\n          image-&gt;set_is_thumbnail_of(refs[0]);\n\n          auto master_iter = m_all_images.find(refs[0]);\n          if (master_iter == m_all_images.end()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         "Thumbnail references a non-existing image");\n          }\n\n          if (master_iter-&gt;second-&gt;is_thumbnail()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         "Thumbnail references another thumbnail");\n          }\n\n          if (image.get() == master_iter-&gt;second.get()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         "Recursive thumbnail image detected");\n          }\n          master_iter-&gt;second-&gt;add_thumbnail(image);\n\n          remove_top_level_image(image);\n        }\n        else if (type==fourcc("auxl")) {\n\n          // --- this is an auxiliary image\n          //     check whether it is an alpha channel and attach to the main image if yes\n\n          std::vector&lt;Box_ipco::Property&gt; properties;\n          Error err = m_heif_file-&gt;get_properties(image-&gt;get_id(), properties);\n          if (err) {\n            return err;\n          }\n\n          std::shared_ptr&lt;Box_auxC&gt; auxC_property;\n          for (const auto&amp; property : properties) {\n            auto auxC = std::dynamic_pointer_cast&lt;Box_auxC&gt;(property.property);\n            if (auxC) {\n              auxC_property = auxC;\n            }\n          }\n\n          if (!auxC_property) {\n            std::stringstream sstr;\n            sstr &lt;&lt; "No auxC property for image " &lt;&lt; image-&gt;get_id();\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Auxiliary_image_type_unspecified,\n                         sstr.str());\n          }\n\n          std::vector&lt;heif_item_id&gt; refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         "Too many auxiliary image references");\n          }\n\n\n          // alpha channel\n\n          if (auxC_property-&gt;get_aux_type() == "urn:mpeg:avc:2015:auxid:1" ||\n              auxC_property-&gt;get_aux_type() == "urn:mpeg:hevc:2015:auxid:1") {\n            image-&gt;set_is_alpha_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (master_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           "Non-existing alpha image referenced");\n            }\n            if (image.get() == master_iter-&gt;second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           "Recursive alpha image detected");\n            }\n            master_iter-&gt;second-&gt;set_alpha_channel(image);\n          }\n\n\n          // depth channel\n\n          if (auxC_property-&gt;get_aux_type() == "urn:mpeg:hevc:2015:auxid:2") {\n            image-&gt;set_is_depth_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter-&gt;second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           "Recursive depth image detected");\n            }\n            master_iter-&gt;second-&gt;set_depth_channel(image);\n\n            auto subtypes = auxC_property-&gt;get_subtypes();\n\n            std::vector&lt;std::shared_ptr&lt;SEIMessage&gt;&gt; sei_messages;\n            Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);\n\n            for (auto&amp; msg : sei_messages) {\n              auto depth_msg = std::dynamic_pointer_cast&lt;SEIMessage_depth_representation_info&gt;(msg);\n              if (depth_msg) {\n                image-&gt;set_depth_representation_info(*depth_msg);\n              }\n            }\n          }\n\n          remove_top_level_image(image);\n        }\n        else {\n          // \'image\' is a normal image, keep it as a top-level image\n        }\n      }\n    }\n  }\n\n\n  // --- check that HEVC images have an hvcC property\n\n  for (auto&amp; pair : m_all_images) {\n    auto&amp; image = pair.second;\n\n    std::shared_ptr&lt;Box_infe&gt; infe = m_heif_file-&gt;get_infe_box(image-&gt;get_id());\n    if (infe-&gt;get_item_type() == "hvc1") {\n\n      auto ipma = m_heif_file-&gt;get_ipma_box();\n      auto ipco = m_heif_file-&gt;get_ipco_box();\n\n      if (!ipco-&gt;get_property_for_item_ID(image-&gt;get_id(), ipma, fourcc("hvcC"))) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_No_hvcC_box,\n                     "No hvcC property in hvc1 type image");\n      }\n    }\n  }\n\n\n  // --- read through properties for each image and extract image resolutions\n\n  for (auto&amp; pair : m_all_images) {\n    auto&amp; image = pair.second;\n\n    std::vector&lt;Box_ipco::Property&gt; properties;\n\n    Error err = m_heif_file-&gt;get_properties(pair.first, properties);\n    if (err) {\n      return err;\n    }\n\n    bool ispe_read = false;\n    bool primary_colr_set = false;\n    for (const auto&amp; prop : properties) {\n      auto ispe = std::dynamic_pointer_cast&lt;Box_ispe&gt;(prop.property);\n      if (ispe) {\n        uint32_t width = ispe-&gt;get_width();\n        uint32_t height = ispe-&gt;get_height();\n\n\n        // --- check whether the image size is "too large"\n\n        if (width  &gt;= static_cast&lt;uint32_t&gt;(MAX_IMAGE_WIDTH) ||\n            height &gt;= static_cast&lt;uint32_t&gt;(MAX_IMAGE_HEIGHT)) {\n          std::stringstream sstr;\n          sstr &lt;&lt; "Image size " &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; " exceeds the maximum image size "\n               &lt;&lt; MAX_IMAGE_WIDTH &lt;&lt; "x" &lt;&lt; MAX_IMAGE_HEIGHT &lt;&lt; "\\n";\n\n          return Error(heif_error_Memory_allocation_error,\n                       heif_suberror_Security_limit_exceeded,\n                       sstr.str());\n        }\n\n        image-&gt;set_resolution(width, height);\n        image-&gt;set_ispe_resolution(width, height);\n        ispe_read = true;\n      }\n\n      if (ispe_read) {\n        auto clap = std::dynamic_pointer_cast&lt;Box_clap&gt;(prop.property);\n        if (clap) {\n          image-&gt;set_resolution( clap-&gt;get_width_rounded(),\n                                 clap-&gt;get_height_rounded() );\n        }\n\n        auto irot = std::dynamic_pointer_cast&lt;Box_irot&gt;(prop.property);\n        if (irot) {\n          if (irot-&gt;get_rotation()==90 ||\n              irot-&gt;get_rotation()==270) {\n            // swap width and height\n            image-&gt;set_resolution( image-&gt;get_height(),\n                                   image-&gt;get_width() );\n          }\n        }\n      }\n\n      auto colr = std::dynamic_pointer_cast&lt;Box_colr&gt;(prop.property);\n      if (colr) {\n        auto profile = colr-&gt;get_color_profile();\n\n        image-&gt;set_color_profile(profile);\n\n        // if this is a grid item we assign the first one\'s color profile\n        // to the main image which is supposed to be a grid\n\n        // TODO: this condition is not correct. It would also classify a secondary image as a \'grid item\'.\n        // We have to set the grid-image color profile in another way...\n        const bool is_grid_item = !image-&gt;is_primary() &amp;&amp; !image-&gt;is_alpha_channel() &amp;&amp; !image-&gt;is_depth_channel();\n\n        if (primary_is_grid &amp;&amp;\n            !primary_colr_set &amp;&amp;\n            is_grid_item) {\n          m_primary_image-&gt;set_color_profile(profile);\n          primary_colr_set = true;\n        }\n      }\n    }\n  }\n\n\n  // --- read metadata and assign to image\n\n  for (heif_item_id id : image_IDs) {\n    std::string item_type    = m_heif_file-&gt;get_item_type(id);\n    std::string content_type = m_heif_file-&gt;get_content_type(id);\n    if (item_type == "Exif" ||\n        (item_type=="mime" &amp;&amp; content_type=="application/rdf+xml")) {\n      std::shared_ptr&lt;ImageMetadata&gt; metadata = std::make_shared&lt;ImageMetadata&gt;();\n      metadata-&gt;item_id = id;\n      metadata-&gt;item_type = item_type;\n      metadata-&gt;content_type = content_type;\n\n      Error err = m_heif_file-&gt;get_compressed_image_data(id, &amp;(metadata-&gt;m_data));\n      if (err) {\n        return err;\n      }\n\n      //std::cerr.write((const char*)data.data(), data.size());\n\n\n      // --- assign metadata to the image\n\n      if (iref_box) {\n        std::vector&lt;Box_iref::Reference&gt; references = iref_box-&gt;get_references_from(id);\n        for (const auto&amp; ref : references) {\n          if (ref.header.get_short_type() == fourcc("cdsc")) {\n            std::vector&lt;uint32_t&gt; refs = ref.to_item_ID;\n            if (refs.size() != 1) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Unspecified,\n                           "Exif data not correctly assigned to image");\n            }\n\n            uint32_t exif_image_id = refs[0];\n            auto img_iter = m_all_images.find(exif_image_id);\n            if (img_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           "Exif data assigned to non-existing image");\n            }\n\n            img_iter-&gt;second-&gt;add_metadata(metadata);\n          }\n        }\n      }\n    }\n  }\n\n  return Error::Ok;\n}',
 'static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\n\tif (tfm-&gt;__crt_alg-&gt;cra_type == &amp;crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\n\tif (tfm-&gt;__crt_alg-&gt;cra_type == &amp;crypto_ablkcipher_type ||\n\t    tfm-&gt;__crt_alg-&gt;cra_type == &amp;crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\n\tskcipher-&gt;setkey = skcipher_setkey;\n\tskcipher-&gt;encrypt = alg-&gt;encrypt;\n\tskcipher-&gt;decrypt = alg-&gt;decrypt;\n\tskcipher-&gt;ivsize = alg-&gt;ivsize;\n\tskcipher-&gt;keysize = alg-&gt;max_keysize;\n\n\tif (alg-&gt;exit)\n\t\tskcipher-&gt;base.exit = crypto_skcipher_exit_tfm;\n\n\tif (alg-&gt;init)\n\t\treturn alg-&gt;init(skcipher);\n\n\treturn 0;\n}',
 'int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tstruct ip_options_rcu *inet_opt;\n\tint err;\n\n\t/* Route is OK, nothing to do. */\n\tif (rt)\n\t\treturn 0;\n\n\t/* Reroute. */\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet-&gt;inet_opt);\n\tdaddr = inet-&gt;inet_daddr;\n\tif (inet_opt &amp;&amp; inet_opt-&gt;opt.srr)\n\t\tdaddr = inet_opt-&gt;opt.faddr;\n\trcu_read_unlock();\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet-&gt;inet_saddr,\n\t\t\t\t   inet-&gt;inet_dport, inet-&gt;inet_sport,\n\t\t\t\t   sk-&gt;sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk-&gt;sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &amp;rt-&gt;dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\n\t\t/* Routing failed... */\n\t\tsk-&gt;sk_route_caps = 0;\n\t\t/*\n\t\t * Other protocols have to map its equivalent state to TCP_SYN_SENT.\n\t\t * DCCP maps its DCCP_REQUESTING state to TCP_SYN_SENT. -acme\n\t\t */\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk-&gt;sk_state != TCP_SYN_SENT ||\n\t\t    (sk-&gt;sk_userlocks &amp; SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk-&gt;sk_err_soft = -err;\n\t}\n\n\treturn err;\n}',
 '  void Compute(OpKernelContext* context) override {\n    const Tensor&amp; input = context-&gt;input(0);\n    const TensorShape&amp; input_shape = input.shape();\n    const int32_t input_dims = input_shape.dims();\n\n    const Tensor&amp; segment_id = context-&gt;input(1);\n    const TensorShape&amp; segment_id_shape = segment_id.shape();\n    const int32_t segment_dims = segment_id_shape.dims();\n\n    const Tensor&amp; num_segments_tensor = context-&gt;input(2);\n    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,\n                errors::InvalidArgument("Number of segments cannot be empty."));\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsScalar(num_segments_tensor.shape()),\n                errors::InvalidArgument("Number of segments must be a scalar"));\n    auto num_segments = num_segments_tensor.scalar&lt;NUM_SEGMENTS_TYPE&gt;()();\n\n    OP_REQUIRES(\n        context, num_segments &gt;= 0,\n        errors::InvalidArgument(\n            "Number of segments must be non-negative but got ", num_segments));\n    OP_REQUIRES(context, segment_dims != 0,\n                errors::InvalidArgument("Segment_id cannot have rank 0"));\n\n    OP_REQUIRES(\n        context, segment_dims &lt;= input_dims,\n        errors::OutOfRange("Invalid segment_id rank ", segment_dims,\n                           " for input with ", input_dims, " dimension(s)"));\n    for (auto i = 0; i &lt; segment_dims; i++) {\n      OP_REQUIRES(\n          context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),\n          errors::InvalidArgument(\n              "Segment dimension is ", segment_id_shape.dim_size(i),\n              " while input dimension is ", input_dims, " in rank ", i));\n    }\n\n    // Making output tensor.\n    Tensor* output_tensor = nullptr;\n    TensorShape output_shape =\n        GetOutputShape(input_shape, segment_id_shape, num_segments);\n    OP_REQUIRES_OK(context, context-&gt;allocate_output("output", output_shape,\n                                                     &amp;output_tensor));\n\n    // Preparating flat tensors.\n    auto output_flat = output_tensor-&gt;flat&lt;tstring&gt;();\n    auto flat_segment_id = segment_id.flat&lt;INDICES_TYPE&gt;();\n    auto flat_input = input.flat&lt;tstring&gt;();\n\n    for (int i = 0; i &lt; flat_segment_id.size(); i++) {\n      OP_REQUIRES(\n          context,\n          ((flat_segment_id(i) &lt; num_segments) &amp;&amp; (flat_segment_id(i) &gt;= 0)),\n          errors::InvalidArgument(\n              "segment_ids are not allowed to exceed num_segments or"\n              " to have negative values."));\n    }\n\n    int64_t big_stride;\n    int64_t small_stride;\n    std::tie(big_stride, small_stride) =\n        GetStrides&lt;INDICES_TYPE&gt;(input_shape, segment_id_shape);\n    auto relative_offset_set =\n        GetFlattenedRelativeOffsets&lt;INDICES_TYPE&gt;(small_stride, big_stride);\n    for (auto start_offset = 0; start_offset &lt; big_stride; start_offset++) {\n      for (auto i = 0; i &lt; relative_offset_set.size(); i++) {\n        auto output_index = start_offset + flat_segment_id(i) * big_stride;\n        auto offset = start_offset + relative_offset_set[i];\n        if (output_flat(output_index).length() != 0)\n          output_flat(output_index).append(separator_.c_str());\n        output_flat(output_index).append(flat_input(offset));\n      }\n    }\n  }',
 'int main(int argc, char *argv[])\n{\n\tint32_t ret = GPMF_OK;\n\tGPMF_stream metadata_stream, *ms = &amp;metadata_stream;\n\tdouble metadatalength;\n\tuint32_t *payload = NULL; //buffer to store GPMF samples from the MP4.\n\n\n\t// get file return data\n\tif (argc != 2)\n\t{\n\t\tprintf("usage: %s &lt;file_with_GPMF&gt;\\n", argv[0]);\n\t\treturn -1;\n\t}\n\n\tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n//\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4\'s udta \n\n\tmetadatalength = GetDuration(mp4);\n\n\tif (metadatalength &gt; 0.0)\n\t{\n\t\tuint32_t index, payloads = GetNumberPayloads(mp4);\n//\t\tprintf("found %.2fs of metadata, from %d payloads, within %s\\n", metadatalength, payloads, argv[1]);\n\n#if 1\n\t\tif (payloads == 1) // Printf the contents of the single payload\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4,0);\n\t\t\tpayload = GetPayload(mp4, payload, 0);\n\t\t\tif(payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n\t\t\t// Output (printf) all the contained GPMF data within this payload\n\t\t\tret = GPMF_Validate(ms, GPMF_RECURSE_LEVELS); // optional\n\t\t\tif (GPMF_OK != ret)\n\t\t\t{\n\t\t\t\tprintf("Invalid Structure\\n");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tGPMF_ResetState(ms);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPrintGPMF(ms);  // printf current GPMF KLV\n\t\t\t} while (GPMF_OK == GPMF_Next(ms, GPMF_RECURSE_LEVELS));\n\t\t\tGPMF_ResetState(ms);\n\t\t\tprintf("\\n");\n\n\t\t}\n#endif\n\n\n\t\tfor (index = 0; index &lt; payloads; index++)\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n\t\t\tfloat in = 0.0, out = 0.0; //times\n\t\t\tpayload = GetPayload(mp4, payload, index);\n\t\t\tif (payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GetPayloadTime(mp4, index, &amp;in, &amp;out);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n#if 1\t\t// Find all the available Streams and the data carrying FourCC\n\t\t\tif (index == 0) // show first payload \n\t\t\t{\n\t\t\t\tret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);\n\t\t\t\twhile (GPMF_OK == ret)\n\t\t\t\t{\n\t\t\t\t\tret = GPMF_SeekToSamples(ms);\n\t\t\t\t\tif (GPMF_OK == ret) //find the last FOURCC within the stream\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t key = GPMF_Key(ms);\n\t\t\t\t\t\tGPMF_SampleType type = GPMF_Type(ms);\n\t\t\t\t\t\tuint32_t elements = GPMF_ElementsInStruct(ms);\n\t\t\t\t\t\t//uint32_t samples = GPMF_Repeat(ms);\n\t\t\t\t\t\tuint32_t samples = GPMF_PayloadSampleCount(ms);\n\n\t\t\t\t\t\tif (samples)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf("  STRM of %c%c%c%c ", PRINTF_4CC(key));\n\n\t\t\t\t\t\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGPMF_stream find_stream;\n\t\t\t\t\t\t\t\tGPMF_CopyState(ms, &amp;find_stream);\n\n\t\t\t\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&amp;find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tchar tmp[64];\n\t\t\t\t\t\t\t\t\tchar *data = (char *)GPMF_RawData(&amp;find_stream);\n\t\t\t\t\t\t\t\t\tint size = GPMF_RawDataSize(&amp;find_stream);\n\n\t\t\t\t\t\t\t\t\tif (size &lt; sizeof(tmp))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmemcpy(tmp, data, size);\n\t\t\t\t\t\t\t\t\t\ttmp[size] = 0;\n\t\t\t\t\t\t\t\t\t\tprintf("of type %s ", tmp);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf("of type %c ", type);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprintf("with %d sample%s ", samples, samples &gt; 1 ? "s" : "");\n\n\t\t\t\t\t\t\tif (elements &gt; 1)\n\t\t\t\t\t\t\t\tprintf("-- %d elements per sample", elements);\n\n\t\t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ret == GPMF_ERROR_BAD_STRUCTURE) // some payload element was corrupt, skip to the next valid GPMF KLV at the previous level.\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = GPMF_Next(ms, GPMF_CURRENT_LEVEL); // this will be the next stream if any more are present.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tGPMF_ResetState(ms);\n\t\t\t\tprintf("\\n");\n\t\t\t}\n#endif \n\n\n\n\n#if 1\t\t// Find GPS values and return scaled doubles. \n\t\t\tif (index == 0) // show first payload \n\t\t\t{\n\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, STR2FOURCC("GPS5"), GPMF_RECURSE_LEVELS) || //GoPro Hero5/6/7 GPS\n\t\t\t\t\tGPMF_OK == GPMF_FindNext(ms, STR2FOURCC("GPRI"), GPMF_RECURSE_LEVELS))   //GoPro Karma GPS\n\t\t\t\t{\n\t\t\t\t\tuint32_t key = GPMF_Key(ms);\n\t\t\t\t\tuint32_t samples = GPMF_Repeat(ms);\n\t\t\t\t\tuint32_t elements = GPMF_ElementsInStruct(ms);\n\t\t\t\t\tuint32_t buffersize = samples * elements * sizeof(double);\n\t\t\t\t\tGPMF_stream find_stream;\n\t\t\t\t\tdouble *ptr, *tmpbuffer = malloc(buffersize);\n\t\t\t\t\tchar units[10][6] = { "" };\n\t\t\t\t\tuint32_t unit_samples = 1;\n\n\t\t\t\t\tprintf("MP4 Payload time %.3f to %.3f seconds\\n", in, out);\n\n\t\t\t\t\tif (tmpbuffer &amp;&amp; samples)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t i, j;\n\n\t\t\t\t\t\t//Search for any units to display\n\t\t\t\t\t\tGPMF_CopyState(ms, &amp;find_stream);\n\t\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&amp;find_stream, GPMF_KEY_SI_UNITS, GPMF_CURRENT_LEVEL) ||\n\t\t\t\t\t\t\tGPMF_OK == GPMF_FindPrev(&amp;find_stream, GPMF_KEY_UNITS, GPMF_CURRENT_LEVEL))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar *data = (char *)GPMF_RawData(&amp;find_stream);\n\t\t\t\t\t\t\tint ssize = GPMF_StructSize(&amp;find_stream);\n\t\t\t\t\t\t\tunit_samples = GPMF_Repeat(&amp;find_stream);\n\n\t\t\t\t\t\t\tfor (i = 0; i &lt; unit_samples; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemcpy(units[i], data, ssize);\n\t\t\t\t\t\t\t\tunits[i][ssize] = 0;\n\t\t\t\t\t\t\t\tdata += ssize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//GPMF_FormattedData(ms, tmpbuffer, buffersize, 0, samples); // Output data in LittleEnd, but no scale\n\t\t\t\t\t\tGPMF_ScaledData(ms, tmpbuffer, buffersize, 0, samples, GPMF_TYPE_DOUBLE);  //Output scaled data as floats\n\n\t\t\t\t\t\tptr = tmpbuffer;\n\t\t\t\t\t\tfor (i = 0; i &lt; samples; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf("%c%c%c%c ", PRINTF_4CC(key));\n\t\t\t\t\t\t\tfor (j = 0; j &lt; elements; j++)\n\t\t\t\t\t\t\t\tprintf("%.3f%s, ", *ptr++, units[j%unit_samples]);\n\n\t\t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(tmpbuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tGPMF_ResetState(ms);\n\t\t\t\tprintf("\\n");\n\t\t\t}\n#endif \n\t\t}\n\n#if 1\n\t\t// Find all the available Streams and compute they sample rates\n\t\twhile (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream\n\t\t\t{\n\t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);\n\t\t\t\tprintf("%c%c%c%c sampling rate = %f Hz\\n", PRINTF_4CC(fourcc), rate);\n\t\t\t}\n\t\t}\n#endif\n\n\n\tcleanup:\n\t\tif (payload) FreePayload(payload); payload = NULL;\n\t\tCloseSource(mp4);\n\t}\n\n\treturn ret;\n}',
 'bool_t enc624j600IrqHandler(NetInterface *interface)\n{\n   bool_t flag;\n   uint16_t status;\n\n   //This flag will be set if a higher priority task must be woken\n   flag = FALSE;\n\n   //Clear the INTIE bit, immediately after an interrupt event\n   enc624j600ClearBit(interface, ENC624J600_EIE, ENC624J600_EIE_INTIE);\n\n   //Read interrupt status register\n   status = enc624j600ReadReg(interface, ENC624J600_EIR);\n\n   //Link status change?\n   if((status &amp; ENC624J600_EIR_LINKIF) != 0)\n   {\n      //Disable LINKIE interrupt\n      enc624j600ClearBit(interface, ENC624J600_EIE, ENC624J600_EIE_LINKIE);\n\n      //Set event flag\n      interface-&gt;nicEvent = TRUE;\n      //Notify the TCP/IP stack of the event\n      flag |= osSetEventFromIsr(&amp;netEvent);\n   }\n\n   //Packet received?\n   if((status &amp; ENC624J600_EIR_PKTIF) != 0)\n   {\n      //Disable PKTIE interrupt\n      enc624j600ClearBit(interface, ENC624J600_EIE, ENC624J600_EIE_PKTIE);\n\n      //Set event flag\n      interface-&gt;nicEvent = TRUE;\n      //Notify the TCP/IP stack of the event\n      flag |= osSetEventFromIsr(&amp;netEvent);\n   }\n\n   //Packet transmission complete?\n   if((status &amp; (ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF)) != 0)\n   {\n      //Clear interrupt flags\n      enc624j600ClearBit(interface, ENC624J600_EIR, ENC624J600_EIR_TXIF |\n         ENC624J600_EIR_TXABTIF);\n\n      //Notify the TCP/IP stack that the transmitter is ready to send\n      flag |= osSetEventFromIsr(&amp;interface-&gt;nicTxEvent);\n   }\n\n   //Once the interrupt has been serviced, the INTIE bit\n   //is set again to re-enable interrupts\n   enc624j600SetBit(interface, ENC624J600_EIE, ENC624J600_EIE_INTIE);\n\n   //A higher priority task must be woken?\n   return flag;\n}',
 'ast_for_atom(struct compiling *c, const node *n)\n{\n    /* atom: \'(\' [yield_expr|testlist_comp] \')\' | \'[\' [listmaker] \']\'\n       | \'{\' [dictmaker] \'}\' | \'`\' testlist \'`\' | NAME | NUMBER | STRING+\n    */\n    node *ch = CHILD(n, 0);\n\n    switch (TYPE(ch)) {\n    case NAME: {\n        /* All names start in Load context, but may later be\n           changed. */\n        PyObject *name = NEW_IDENTIFIER(ch);\n        if (!name)\n            return NULL;\n        return Name(name, Load, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n    }\n    case STRING: {\n        PyObject *kind, *str = parsestrplus(c, n);\n        const char *raw, *s = STR(CHILD(n, 0));\n        int quote = Py_CHARMASK(*s);\n        /* currently Python allows up to 2 string modifiers */\n        char *ch, s_kind[3] = {0, 0, 0};\n        ch = s_kind;\n        raw = s;\n        while (*raw &amp;&amp; *raw != \'\\\'\' &amp;&amp; *raw != \'"\') {\n            *ch++ = *raw++;\n        }\n        kind = PyUnicode_FromString(s_kind);\n        if (!kind) {\n            return NULL;\n        }\n        if (!str) {\n#ifdef Py_USING_UNICODE\n            if (PyErr_ExceptionMatches(PyExc_UnicodeError)){\n                PyObject *type, *value, *tback, *errstr;\n                PyErr_Fetch(&amp;type, &amp;value, &amp;tback);\n                errstr = PyObject_Str(value);\n                if (errstr) {\n                    char *s = "";\n                    char buf[128];\n                    s = _PyUnicode_AsString(errstr);\n                    PyOS_snprintf(buf, sizeof(buf), "(unicode error) %s", s);\n                    ast_error(n, buf);\n                    Py_DECREF(errstr);\n                } else {\n                    ast_error(n, "(unicode error) unknown error");\n                }\n                Py_DECREF(type);\n                Py_DECREF(value);\n                Py_XDECREF(tback);\n            }\n#endif\n            return NULL;\n        }\n        PyArena_AddPyObject(c-&gt;c_arena, str);\n        return Str(str, kind, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n    }\n    case NUMBER: {\n        PyObject *pynum = parsenumber(c, STR(ch));\n        if (!pynum)\n            return NULL;\n\n        PyArena_AddPyObject(c-&gt;c_arena, pynum);\n        return Num(pynum, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n    }\n    case LPAR: /* some parenthesized expressions */\n        ch = CHILD(n, 1);\n\n        if (TYPE(ch) == RPAR)\n            return Tuple(NULL, Load, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n\n        if (TYPE(ch) == yield_expr)\n            return ast_for_expr(c, ch);\n\n        return ast_for_testlist_comp(c, ch);\n    case LSQB: /* list (or list comprehension) */\n        ch = CHILD(n, 1);\n\n        if (TYPE(ch) == RSQB)\n            return List(NULL, Load, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n\n        REQ(ch, listmaker);\n        if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {\n            asdl_seq *elts = seq_for_testlist(c, ch);\n            if (!elts)\n                return NULL;\n\n            return List(elts, Load, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n        }\n        else\n            return ast_for_listcomp(c, ch);\n    case LBRACE: {\n        /* dictorsetmaker:\n         *    (test \':\' test (comp_for | (\',\' test \':\' test)* [\',\'])) |\n         *    (test (comp_for | (\',\' test)* [\',\']))\n         */\n        int i, size;\n        asdl_seq *keys, *values;\n\n        ch = CHILD(n, 1);\n        if (TYPE(ch) == RBRACE) {\n            /* it\'s an empty dict */\n            return Dict(NULL, NULL, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n        } else if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {\n            /* it\'s a simple set */\n            asdl_seq *elts;\n            size = (NCH(ch) + 1) / 2; /* +1 in case no trailing comma */\n            elts = asdl_seq_new(size, c-&gt;c_arena);\n            if (!elts)\n                return NULL;\n            for (i = 0; i &lt; NCH(ch); i += 2) {\n                expr_ty expression;\n                expression = ast_for_expr(c, CHILD(ch, i));\n                if (!expression)\n                    return NULL;\n                asdl_seq_SET(elts, i / 2, expression);\n            }\n            return Set(elts, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n        } else if (TYPE(CHILD(ch, 1)) == comp_for) {\n            /* it\'s a set comprehension */\n            return ast_for_setcomp(c, ch);\n        } else if (NCH(ch) &gt; 3 &amp;&amp; TYPE(CHILD(ch, 3)) == comp_for) {\n            return ast_for_dictcomp(c, ch);\n        } else {\n            /* it\'s a dict */\n            size = (NCH(ch) + 1) / 4; /* +1 in case no trailing comma */\n            keys = asdl_seq_new(size, c-&gt;c_arena);\n            if (!keys)\n                return NULL;\n\n            values = asdl_seq_new(size, c-&gt;c_arena);\n            if (!values)\n                return NULL;\n\n            for (i = 0; i &lt; NCH(ch); i += 4) {\n                expr_ty expression;\n\n                expression = ast_for_expr(c, CHILD(ch, i));\n                if (!expression)\n                    return NULL;\n\n                asdl_seq_SET(keys, i / 4, expression);\n\n                expression = ast_for_expr(c, CHILD(ch, i + 2));\n                if (!expression)\n                    return NULL;\n\n                asdl_seq_SET(values, i / 4, expression);\n            }\n            return Dict(keys, values, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n        }\n    }\n    case BACKQUOTE: { /* repr */\n        expr_ty expression;\n        if (Py_Py3kWarningFlag &amp;&amp;\n            !ast_warn(c, n, "backquote not supported in 3.x; use repr()"))\n            return NULL;\n        expression = ast_for_testlist(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n\n        return Repr(expression, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n    }\n    default:\n        PyErr_Format(PyExc_SystemError, "unhandled atom %d", TYPE(ch));\n        return NULL;\n    }\n}',
 'static char *print_string( cJSON *item )\n{\n\treturn print_string_ptr( item-&gt;valuestring );\n}',
 'static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&amp;synth_devs[dev]-&gt;chn_info[chn];\n\n\topl3_set_instr(dev, voice, info-&gt;pgm_num);\n\n\tdevc-&gt;voc[voice].bender = 0;\n\tdevc-&gt;voc[voice].bender_range = info-&gt;bender_range;\n\tdevc-&gt;voc[voice].volume = info-&gt;controllers[CTL_MAIN_VOLUME];\n\tdevc-&gt;voc[voice].panning = (info-&gt;controllers[CTL_PAN] * 2) - 128;\n}',
 'static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm-&gt;pid  = get_pid(pid);\n\tscm-&gt;cred = cred ? get_cred(cred) : NULL;\n\tscm-&gt;creds.pid = pid_vnr(pid);\n\tscm-&gt;creds.uid = cred ? cred-&gt;euid : INVALID_UID;\n\tscm-&gt;creds.gid = cred ? cred-&gt;egid : INVALID_GID;\n}',
 'static int mongo_cursor_get_more( mongo_cursor *cursor ) {\n    int res;\n\n    if( cursor-&gt;limit &gt; 0 &amp;&amp; cursor-&gt;seen &gt;= cursor-&gt;limit ) {\n        cursor-&gt;err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor-&gt;reply ) {\n        cursor-&gt;err = MONGO_CURSOR_INVALID;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor-&gt;reply-&gt;fields.cursorID ) {\n        cursor-&gt;err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else {\n        char *data;\n        int sl = strlen( cursor-&gt;ns )+1;\n        int limit = 0;\n        mongo_message *mm;\n\n        if( cursor-&gt;limit &gt; 0 )\n            limit = cursor-&gt;limit - cursor-&gt;seen;\n\n        mm = mongo_message_create( 16 /*header*/\n                                   +4 /*ZERO*/\n                                   +sl\n                                   +4 /*numToReturn*/\n                                   +8 /*cursorID*/\n                                   , 0, 0, MONGO_OP_GET_MORE );\n        data = &amp;mm-&gt;data;\n        data = mongo_data_append32( data, &amp;ZERO );\n        data = mongo_data_append( data, cursor-&gt;ns, sl );\n        data = mongo_data_append32( data, &amp;limit );\n        mongo_data_append64( data, &amp;cursor-&gt;reply-&gt;fields.cursorID );\n\n        bson_free( cursor-&gt;reply );\n        res = mongo_message_send( cursor-&gt;conn, mm );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n\n        res = mongo_read_response( cursor-&gt;conn, &amp;( cursor-&gt;reply ) );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        cursor-&gt;current.data = NULL;\n        cursor-&gt;seen += cursor-&gt;reply-&gt;fields.num;\n\n        return MONGO_OK;\n    }\n}',
 "static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&amp;current-&gt;thread.ckpt_regs, sr);\n\n\terr |= __get_user(current-&gt;thread.tm_tfhar, &amp;sr-&gt;mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &amp;sr-&gt;mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs-&gt;msr = (regs-&gt;msr &amp; ~MSR_LE) | (msr &amp; MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current-&gt;thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs-&gt;msr &amp;= ~MSR_VEC;\n\tif (msr &amp; MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&amp;current-&gt;thread.vr_state, &amp;sr-&gt;mc_vregs,\n\t\t\t\t     sizeof(sr-&gt;mc_vregs)) ||\n\t\t    __copy_from_user(&amp;current-&gt;thread.transact_vr,\n\t\t\t\t     &amp;tm_sr-&gt;mc_vregs,\n\t\t\t\t     sizeof(sr-&gt;mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current-&gt;thread.used_vr) {\n\t\tmemset(&amp;current-&gt;thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&amp;current-&gt;thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current-&gt;thread.vrsave,\n\t\t       (u32 __user *)&amp;sr-&gt;mc_vregs[32]) ||\n\t    __get_user(current-&gt;thread.transact_vrsave,\n\t\t       (u32 __user *)&amp;tm_sr-&gt;mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current-&gt;thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs-&gt;msr &amp;= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &amp;sr-&gt;mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &amp;tm_sr-&gt;mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs-&gt;msr &amp;= ~MSR_VSX;\n\tif (msr &amp; MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &amp;sr-&gt;mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &amp;tm_sr-&gt;mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current-&gt;thread.used_vsr)\n\t\tfor (i = 0; i &lt; 32 ; i++) {\n\t\t\tcurrent-&gt;thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent-&gt;thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs-&gt;msr &amp;= ~MSR_SPE;\n\tif (msr &amp; MSR_SPE) {\n\t\tif (__copy_from_user(current-&gt;thread.evr, &amp;sr-&gt;mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current-&gt;thread.used_spe)\n\t\tmemset(current-&gt;thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current-&gt;thread.spefscr, (u32 __user *)&amp;sr-&gt;mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent-&gt;thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&amp;current-&gt;thread, msr);\n\t/* Get the top half of the MSR */\n\tif (__get_user(msr_hi, &amp;tm_sr-&gt;mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* Pull in MSR TM from user context */\n\tregs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | ((msr_hi&lt;&lt;32) &amp; MSR_TS_MASK);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr &amp; MSR_FP) {\n\t\tdo_load_up_transact_fpu(&amp;current-&gt;thread);\n\t\tregs-&gt;msr |= (MSR_FP | current-&gt;thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr &amp; MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&amp;current-&gt;thread);\n\t\tregs-&gt;msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}",
 'int main(void)\n{\n\tint fd;\n\tunsigned int i;\n\tunsigned int start = 0;\n\tunsigned int _gap = ~0;\n\tunsigned int gap = _gap / 8;\n\tstruct qcedev_cipher_op_req req = { 0 };\n\t//char data[32] = { A };\n\tchar *data;\n\tfd = open(dev, O_RDWR);\n\tif (fd &lt; 0) {\n\t\tprintf("Failed to open %s with errno %s\\n", dev,\n\t\t       strerror(errno));\n\t\treturn EXIT_FAILURE;\n\n\t}\n\tthread_func(start, start + gap, fd);\n\n\tsleep(1000000);\n\treturn EXIT_FAILURE;\n}',
 'static void save_client_addr(struct ip_addr *client_ip, uint8_t *hwaddr)\n{\n\tuint8_t d = (uint8_t)ip4_addr4(client_ip);\n\t\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tmemcpy(ip_table.client_mac[d], hwaddr, 6); \n#if (debug_dhcps)\t\n\tprintf("\\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n", __func__,\n\t\tip4_addr1(client_ip), ip4_addr2(client_ip), ip4_addr3(client_ip), ip4_addr4(client_ip),\n\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\t\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n}',
 'static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL &amp;&amp; in_path != NULL);\n\tctx=card-&gt;ctx;\n\tmemcpy(path, in_path-&gt;value, in_path-&gt;len);\n\tpathlen = in_path-&gt;len;\n\n\tsc_format_apdu(card, &amp;apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path-&gt;type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen &gt;= 2 &amp;&amp; memcmp(path, "\\x3F\\x00", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &amp;apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, "APDU transmit failed");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen &lt; 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, "received invalid template %02X\\n", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile-&gt;path = *in_path;\n\n\tfor(i=2; i+1&lt;apdu.resplen &amp;&amp; i+1+apdu.resp[i+1]&lt;apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile-&gt;size=0;\n\t\t\tfor(j=0; j&lt;len; ++j) file-&gt;size = (file-&gt;size&lt;&lt;8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile-&gt;shareable = (d[0] &amp; 0x40) ? 1 : 0;\n\t\t\tfile-&gt;ef_structure = d[0] &amp; 7;\n\t\t\tswitch ((d[0]&gt;&gt;3) &amp; 7) {\n\t\t\tcase 0: file-&gt;type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file-&gt;type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, "invalid file type %02X in file descriptor\\n", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile-&gt;id = (d[0]&lt;&lt;8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file-&gt;name, d, len);\n\t\t\tfile-&gt;namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len&gt;0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile-&gt;magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file-&gt;sec_attr, file-&gt;sec_attr_len);\n\n\treturn 0;\n}',
 'static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &amp;ms-&gt;parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec-&gt;xstart = siz-&gt;xoff;\n\tdec-&gt;ystart = siz-&gt;yoff;\n\tdec-&gt;xend = siz-&gt;width;\n\tdec-&gt;yend = siz-&gt;height;\n\tdec-&gt;tilewidth = siz-&gt;tilewidth;\n\tdec-&gt;tileheight = siz-&gt;tileheight;\n\tdec-&gt;tilexoff = siz-&gt;tilexoff;\n\tdec-&gt;tileyoff = siz-&gt;tileyoff;\n\tdec-&gt;numcomps = siz-&gt;numcomps;\n\tif (!(dec-&gt;cp = jpc_dec_cp_create(dec-&gt;numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec-&gt;cmpts = jas_alloc2(dec-&gt;numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec-&gt;cmpts; compno &lt; dec-&gt;numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt-&gt;prec = siz-&gt;comps[compno].prec;\n\t\tcmpt-&gt;sgnd = siz-&gt;comps[compno].sgnd;\n\t\tcmpt-&gt;hstep = siz-&gt;comps[compno].hsamp;\n\t\tcmpt-&gt;vstep = siz-&gt;comps[compno].vsamp;\n\t\tcmpt-&gt;width = JPC_CEILDIV(dec-&gt;xend, cmpt-&gt;hstep) -\n\t\t  JPC_CEILDIV(dec-&gt;xstart, cmpt-&gt;hstep);\n\t\tcmpt-&gt;height = JPC_CEILDIV(dec-&gt;yend, cmpt-&gt;vstep) -\n\t\t  JPC_CEILDIV(dec-&gt;ystart, cmpt-&gt;vstep);\n\t\tcmpt-&gt;hsubstep = 0;\n\t\tcmpt-&gt;vsubstep = 0;\n\t}\n\n\tdec-&gt;image = 0;\n\n\tdec-&gt;numhtiles = JPC_CEILDIV(dec-&gt;xend - dec-&gt;tilexoff, dec-&gt;tilewidth);\n\tdec-&gt;numvtiles = JPC_CEILDIV(dec-&gt;yend - dec-&gt;tileyoff, dec-&gt;tileheight);\n\tdec-&gt;numtiles = dec-&gt;numhtiles * dec-&gt;numvtiles;\n\tJAS_DBGLOG(10, ("numtiles = %d; numhtiles = %d; numvtiles = %d;\\n",\n\t  dec-&gt;numtiles, dec-&gt;numhtiles, dec-&gt;numvtiles));\n\tif (!(dec-&gt;tiles = jas_alloc2(dec-&gt;numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec-&gt;tiles; tileno &lt; dec-&gt;numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec-&gt;numhtiles;\n\t\tvtileno = tileno / dec-&gt;numhtiles;\n\t\ttile-&gt;realmode = 0;\n\t\ttile-&gt;state = JPC_TILE_INIT;\n\t\ttile-&gt;xstart = JAS_MAX(dec-&gt;tilexoff + htileno * dec-&gt;tilewidth,\n\t\t  dec-&gt;xstart);\n\t\ttile-&gt;ystart = JAS_MAX(dec-&gt;tileyoff + vtileno * dec-&gt;tileheight,\n\t\t  dec-&gt;ystart);\n\t\ttile-&gt;xend = JAS_MIN(dec-&gt;tilexoff + (htileno + 1) *\n\t\t  dec-&gt;tilewidth, dec-&gt;xend);\n\t\ttile-&gt;yend = JAS_MIN(dec-&gt;tileyoff + (vtileno + 1) *\n\t\t  dec-&gt;tileheight, dec-&gt;yend);\n\t\ttile-&gt;numparts = 0;\n\t\ttile-&gt;partno = 0;\n\t\ttile-&gt;pkthdrstream = 0;\n\t\ttile-&gt;pkthdrstreampos = 0;\n\t\ttile-&gt;pptstab = 0;\n\t\ttile-&gt;cp = 0;\n\t\ttile-&gt;pi = 0;\n\t\tif (!(tile-&gt;tcomps = jas_alloc2(dec-&gt;numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec-&gt;cmpts, tcomp = tile-&gt;tcomps;\n\t\t  compno &lt; dec-&gt;numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp-&gt;rlvls = 0;\n\t\t\ttcomp-&gt;numrlvls = 0;\n\t\t\ttcomp-&gt;data = 0;\n\t\t\ttcomp-&gt;xstart = JPC_CEILDIV(tile-&gt;xstart, cmpt-&gt;hstep);\n\t\t\ttcomp-&gt;ystart = JPC_CEILDIV(tile-&gt;ystart, cmpt-&gt;vstep);\n\t\t\ttcomp-&gt;xend = JPC_CEILDIV(tile-&gt;xend, cmpt-&gt;hstep);\n\t\t\ttcomp-&gt;yend = JPC_CEILDIV(tile-&gt;yend, cmpt-&gt;vstep);\n\t\t\ttcomp-&gt;tsfb = 0;\n\t\t}\n\t}\n\n\tdec-&gt;pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec-&gt;state = JPC_MH;\n\n\treturn 0;\n}',
 'static void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &amp;vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}',
 'inline void AveragePool(const PoolParams&amp; params,\n                        const RuntimeShape&amp; input_shape, const int8* input_data,\n                        const RuntimeShape&amp; output_shape, int8* output_data) {\n  ruy::profiler::ScopeLabel label("AveragePool/8bitWith32bitAccumulator");\n\n  // Here, and in other pooling ops, in order to maintain locality of reference,\n  // to minimize some recalculations, and to load into NEON vector registers, we\n  // use an inner loop down the depth. Since depths can be large and hence we\n  // would need arbitrarily large temporary storage, we divide the work up into\n  // depth tranches just within the batch loop.\n  static constexpr int kPoolingAccTrancheSize = 256;\n\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n\n  int32 acc[kPoolingAccTrancheSize];\n  for (int batch = 0; batch &lt; batches; ++batch) {\n    // We proceed through the depth in tranches (see comment above). The\n    // depth_base is the depth at the beginning of the tranche. The\n    // tranche_depth is the depth dimension of the tranche.\n    for (int depth_base = 0; depth_base &lt; depth;\n         depth_base += kPoolingAccTrancheSize) {\n      const int tranche_depth =\n          std::min(depth - depth_base, kPoolingAccTrancheSize);\n      for (int out_y = 0; out_y &lt; output_height; ++out_y) {\n        for (int out_x = 0; out_x &lt; output_width; ++out_x) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          const int filter_count =\n              (filter_x_end - filter_x_start) * (filter_y_end - filter_y_start);\n          memset(acc, 0, tranche_depth * sizeof(acc[0]));\n          const int8* input_ptr =\n              input_data + depth_base +\n              depth * (in_x_origin +\n                       input_width * (in_y_origin + input_height * batch));\n          for (int fy = filter_y_start; fy &lt; filter_y_end; fy++) {\n            const int8* input_row_ptr =\n                input_ptr + depth * (fy * input_width + filter_x_start);\n            for (int fx = filter_x_start; fx &lt; filter_x_end; fx++) {\n              const int8* input_channel_ptr = input_row_ptr;\n              int channel = 0;\n#ifdef USE_NEON\n              for (; channel &lt;= tranche_depth - 16; channel += 16) {\n                int16x4_t acc_reg[4];\n                int8x16_t input_reg = vld1q_s8(input_channel_ptr);\n                input_channel_ptr += 16;\n                acc_reg[0] = vget_low_s16(vmovl_s8(vget_low_s8(input_reg)));\n                acc_reg[1] = vget_high_s16(vmovl_s8(vget_low_s8(input_reg)));\n                acc_reg[2] = vget_low_s16(vmovl_s8(vget_high_s8(input_reg)));\n                acc_reg[3] = vget_high_s16(vmovl_s8(vget_high_s8(input_reg)));\n                for (int i = 0; i &lt; 4; i++) {\n                  vst1q_s32(\n                      acc + channel + 4 * i,\n                      vaddw_s16(vld1q_s32(acc + channel + 4 * i), acc_reg[i]));\n                }\n              }\n              for (; channel &lt;= tranche_depth - 8; channel += 8) {\n                int16x4_t acc_reg[2];\n                int16x8_t input_reg = vmovl_s8(vld1_s8(input_channel_ptr));\n                input_channel_ptr += 8;\n                acc_reg[0] = vget_low_s16(input_reg);\n                acc_reg[1] = vget_high_s16(input_reg);\n                for (int i = 0; i &lt; 2; i++) {\n                  vst1q_s32(\n                      acc + channel + 4 * i,\n                      vaddw_s16(vld1q_s32(acc + channel + 4 * i), acc_reg[i]));\n                }\n              }\n#endif\n              for (; channel &lt; tranche_depth; ++channel) {\n                acc[channel] += *input_channel_ptr++;\n              }\n              input_row_ptr += depth;\n            }\n          }\n          int8* output_ptr = output_data + Offset(output_shape, batch, out_y,\n                                                  out_x, depth_base);\n          int channel = 0;\n#ifdef USE_NEON\n          for (; channel &lt;= tranche_depth - 8; channel += 8) {\n            int16 buf[8];\n            for (int i = 0; i &lt; 8; i++) {\n              buf[i] =\n                  acc[channel + i] &gt; 0\n                      ? (acc[channel + i] + filter_count / 2) / filter_count\n                      : (acc[channel + i] - filter_count / 2) / filter_count;\n            }\n            int8x8_t buf8 = vqmovn_s16(vld1q_s16(buf));\n            buf8 = vmin_s8(buf8, vdup_n_s8(params.quantized_activation_max));\n            buf8 = vmax_s8(buf8, vdup_n_s8(params.quantized_activation_min));\n            vst1_s8(output_ptr + channel, buf8);\n          }\n#endif\n          for (; channel &lt; tranche_depth; ++channel) {\n            int16 a = acc[channel] &gt; 0\n                          ? (acc[channel] + filter_count / 2) / filter_count\n                          : (acc[channel] - filter_count / 2) / filter_count;\n            a = std::max&lt;int16&gt;(a, params.quantized_activation_min);\n            a = std::min&lt;int16&gt;(a, params.quantized_activation_max);\n            output_ptr[channel] = static_cast&lt;int8&gt;(a);\n          }\n        }\n      }\n    }\n  }\n}',
 'ikev2_sa_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext1,\n\t\tu_int osa_length, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth)\n{\n\tconst struct isakmp_gen *ext;\n\tstruct isakmp_gen e;\n\tu_int sa_length;\n\tconst u_char *cp;\n\tint i;\n\tint pcount;\n\tu_char np;\n\tu_int item_len;\n\n\tND_TCHECK(*ext1);\n\tUNALIGNED_MEMCPY(&amp;e, ext1, sizeof(e));\n\tikev2_pay_print(ndo, "sa", e.critical);\n\n\t/*\n\t * ikev2_sub0_print() guarantees that this is &gt;= 4.\n\t */\n\tosa_length= ntohs(e.len);\n\tsa_length = osa_length - 4;\n\tND_PRINT((ndo," len=%d", sa_length));\n\n\t/*\n\t * Print the payloads.\n\t */\n\tcp = (const u_char *)(ext1 + 1);\n\tpcount = 0;\n\tfor (np = ISAKMP_NPTYPE_P; np != 0; np = e.np) {\n\t\tpcount++;\n\t\text = (const struct isakmp_gen *)cp;\n\t\tif (sa_length &lt; sizeof(*ext))\n\t\t\tgoto toolong;\n\t\tND_TCHECK(*ext);\n\n\t\tUNALIGNED_MEMCPY(&amp;e, ext, sizeof(e));\n\n\t\t/*\n\t\t * Since we can\'t have a payload length of less than 4 bytes,\n\t\t * we need to bail out here if the generic header is nonsensical\n\t\t * or truncated, otherwise we could loop forever processing\n\t\t * zero-length items or otherwise misdissect the packet.\n\t\t */\n\t\titem_len = ntohs(e.len);\n\t\tif (item_len &lt;= 4)\n\t\t\tgoto trunc;\n\n\t\tif (sa_length &lt; item_len)\n\t\t\tgoto toolong;\n\t\tND_TCHECK2(*cp, item_len);\n\n\t\tdepth++;\n\t\tND_PRINT((ndo,"\\n"));\n\t\tfor (i = 0; i &lt; depth; i++)\n\t\t\tND_PRINT((ndo,"    "));\n\t\tND_PRINT((ndo,"("));\n\t\tif (np == ISAKMP_NPTYPE_P) {\n\t\t\tcp = ikev2_p_print(ndo, np, pcount, ext, item_len,\n\t\t\t\t\t   ep, depth);\n\t\t\tif (cp == NULL) {\n\t\t\t\t/* error, already reported */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, "%s", NPSTR(np)));\n\t\t\tcp += item_len;\n\t\t}\n\t\tND_PRINT((ndo,")"));\n\t\tdepth--;\n\t\tsa_length -= item_len;\n\t}\n\treturn cp;\ntoolong:\n\t/*\n\t * Skip the rest of the SA.\n\t */\n\tcp += sa_length;\n\tND_PRINT((ndo," [|%s]", NPSTR(tpay)));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo," [|%s]", NPSTR(tpay)));\n\treturn NULL;\n}',
 'ast_for_atom(struct compiling *c, const node *n)\n{\n    /* atom: \'(\' [yield_expr|testlist_comp] \')\' | \'[\' [testlist_comp] \']\'\n       | \'{\' [dictmaker|testlist_comp] \'}\' | NAME | NUMBER | STRING+\n       | \'...\' | \'None\' | \'True\' | \'False\'\n    */\n    node *ch = CHILD(n, 0);\n\n    switch (TYPE(ch)) {\n    case NAME: {\n        PyObject *name;\n        const char *s = STR(ch);\n        size_t len = strlen(s);\n        if (len &gt;= 4 &amp;&amp; len &lt;= 5) {\n            if (!strcmp(s, "None"))\n                return NameConstant(Py_None, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n            if (!strcmp(s, "True"))\n                return NameConstant(Py_True, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n            if (!strcmp(s, "False"))\n                return NameConstant(Py_False, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n        }\n        name = new_identifier(s, c);\n        if (!name)\n            return NULL;\n        /* All names start in Load context, but may later be changed. */\n        return Name(name, Load, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n    }\n    case STRING: {\n        expr_ty str = parsestrplus(c, n);\n        if (!str) {\n            const char *errtype = NULL;\n            if (PyErr_ExceptionMatches(PyExc_UnicodeError))\n                errtype = "unicode error";\n            else if (PyErr_ExceptionMatches(PyExc_ValueError))\n                errtype = "value error";\n            if (errtype) {\n                char buf[128];\n                const char *s = NULL;\n                PyObject *type, *value, *tback, *errstr;\n                PyErr_Fetch(&amp;type, &amp;value, &amp;tback);\n                errstr = PyObject_Str(value);\n                if (errstr)\n                    s = PyUnicode_AsUTF8(errstr);\n                if (s) {\n                    PyOS_snprintf(buf, sizeof(buf), "(%s) %s", errtype, s);\n                } else {\n                    PyErr_Clear();\n                    PyOS_snprintf(buf, sizeof(buf), "(%s) unknown error", errtype);\n                }\n                Py_XDECREF(errstr);\n                ast_error(c, n, buf);\n                Py_DECREF(type);\n                Py_XDECREF(value);\n                Py_XDECREF(tback);\n            }\n            return NULL;\n        }\n        return str;\n    }\n    case NUMBER: {\n        PyObject *pynum;\n        const char *s = STR(ch);\n        /* Underscores in numeric literals are only allowed in Python 3.6 or greater */\n        /* Check for underscores here rather than in parse_number so we can report a line number on error */\n        if (c-&gt;c_feature_version &lt; 6 &amp;&amp; strchr(s, \'_\') != NULL) {\n            ast_error(c, ch,\n                    "Underscores in numeric literals are only supported in Python 3.6 and greater");\n            return NULL;\n        }\n        pynum = parsenumber(c, s);\n        if (!pynum)\n            return NULL;\n\n        if (PyArena_AddPyObject(c-&gt;c_arena, pynum) &lt; 0) {\n            Py_DECREF(pynum);\n            return NULL;\n        }\n        return Num(pynum, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n    }\n    case ELLIPSIS: /* Ellipsis */\n        return Ellipsis(LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n    case LPAR: /* some parenthesized expressions */\n        ch = CHILD(n, 1);\n\n        if (TYPE(ch) == RPAR)\n            return Tuple(NULL, Load, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n\n        if (TYPE(ch) == yield_expr)\n            return ast_for_expr(c, ch);\n\n        /* testlist_comp: test ( comp_for | (\',\' test)* [\',\'] ) */\n        if ((NCH(ch) &gt; 1) &amp;&amp; (TYPE(CHILD(ch, 1)) == comp_for))\n            return ast_for_genexp(c, ch);\n\n        return ast_for_testlist(c, ch);\n    case LSQB: /* list (or list comprehension) */\n        ch = CHILD(n, 1);\n\n        if (TYPE(ch) == RSQB)\n            return List(NULL, Load, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n\n        REQ(ch, testlist_comp);\n        if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {\n            asdl_seq *elts = seq_for_testlist(c, ch);\n            if (!elts)\n                return NULL;\n\n            return List(elts, Load, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n        }\n        else\n            return ast_for_listcomp(c, ch);\n    case LBRACE: {\n        /* dictorsetmaker: ( ((test \':\' test | \'**\' test)\n         *                    (comp_for | (\',\' (test \':\' test | \'**\' test))* [\',\'])) |\n         *                   ((test | \'*\' test)\n         *                    (comp_for | (\',\' (test | \'*\' test))* [\',\'])) ) */\n        expr_ty res;\n        ch = CHILD(n, 1);\n        if (TYPE(ch) == RBRACE) {\n            /* It\'s an empty dict. */\n            return Dict(NULL, NULL, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n        }\n        else {\n            int is_dict = (TYPE(CHILD(ch, 0)) == DOUBLESTAR);\n            if (NCH(ch) == 1 ||\n                    (NCH(ch) &gt; 1 &amp;&amp;\n                     TYPE(CHILD(ch, 1)) == COMMA)) {\n                /* It\'s a set display. */\n                res = ast_for_setdisplay(c, ch);\n            }\n            else if (NCH(ch) &gt; 1 &amp;&amp;\n                    TYPE(CHILD(ch, 1)) == comp_for) {\n                /* It\'s a set comprehension. */\n                res = ast_for_setcomp(c, ch);\n            }\n            else if (NCH(ch) &gt; 3 - is_dict &amp;&amp;\n                    TYPE(CHILD(ch, 3 - is_dict)) == comp_for) {\n                /* It\'s a dictionary comprehension. */\n                if (is_dict) {\n                    ast_error(c, n, "dict unpacking cannot be used in "\n                            "dict comprehension");\n                    return NULL;\n                }\n                res = ast_for_dictcomp(c, ch);\n            }\n            else {\n                /* It\'s a dictionary display. */\n                res = ast_for_dictdisplay(c, ch);\n            }\n            if (res) {\n                res-&gt;lineno = LINENO(n);\n                res-&gt;col_offset = n-&gt;n_col_offset;\n            }\n            return res;\n        }\n    }\n    default:\n        PyErr_Format(PyExc_SystemError, "unhandled atom %d", TYPE(ch));\n        return NULL;\n    }\n}',
 'TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* seq_lengths = GetInput(context, node, kSeqLengthsTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(seq_lengths), 1);\n\n  if (input-&gt;type != kTfLiteInt32 &amp;&amp; input-&gt;type != kTfLiteFloat32 &amp;&amp;\n      input-&gt;type != kTfLiteUInt8 &amp;&amp; input-&gt;type != kTfLiteInt16 &amp;&amp;\n      input-&gt;type != kTfLiteInt64) {\n    context-&gt;ReportError(context,\n                         "Type \'%s\' is not supported by reverse_sequence.",\n                         TfLiteTypeGetName(input-&gt;type));\n    return kTfLiteError;\n  }\n\n  if (seq_lengths-&gt;type != kTfLiteInt32 &amp;&amp; seq_lengths-&gt;type != kTfLiteInt64) {\n    context-&gt;ReportError(\n        context, "Seq_lengths type \'%s\' is not supported by reverse_sequence.",\n        TfLiteTypeGetName(seq_lengths-&gt;type));\n    return kTfLiteError;\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCopy(input-&gt;dims);\n  TF_LITE_ENSURE_TYPES_EQ(context, output-&gt;type, input-&gt;type);\n\n  return context-&gt;ResizeTensor(context, output, output_shape);\n}',
 'unsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (len &lt; 5) {\n#ifdef CONFIG_RETPOLINE\n\t\tWARN_ONCE("Failing to patch indirect CALL in %ps\\n", (void *)addr);\n#endif\n\t\treturn len;\t/* call too long for patch site */\n\t}\n\n\tb-&gt;opcode = 0xe8; /* call */\n\tb-&gt;delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\n\treturn 5;\n}',
 "static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx-&gt;local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb-&gt;len - hdrlen - per_fragm;\n\n\tif (WARN_ON(rem &lt; 0))\n\t\treturn -EINVAL;\n\n\t/* first fragment was already added to queue by caller */\n\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\n\t\tif (fraglen &gt; rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local-&gt;tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx-&gt;sdata-&gt;encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\t__skb_queue_tail(&amp;tx-&gt;skbs, tmp);\n\n\t\tskb_reserve(tmp,\n\t\t\t    local-&gt;tx_headroom + tx-&gt;sdata-&gt;encrypt_headroom);\n\n\t\t/* copy control information */\n\t\tmemcpy(tmp-&gt;cb, skb-&gt;cb, sizeof(tmp-&gt;cb));\n\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo-&gt;flags &amp;= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\n\t\tif (rem)\n\t\t\tinfo-&gt;flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp-&gt;priority = skb-&gt;priority;\n\t\ttmp-&gt;dev = skb-&gt;dev;\n\n\t\t/* copy header and data */\n\t\tmemcpy(skb_put(tmp, hdrlen), skb-&gt;data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb-&gt;data + pos, fraglen);\n\n\t\tpos += fraglen;\n\t}\n\n\t/* adjust first fragment's length */\n\tskb-&gt;len = hdrlen + per_fragm;\n\treturn 0;\n}",
 'int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) /* q is optional */\n        return 0;\n    BN_free(dh-&gt;p);\n    BN_free(dh-&gt;q);\n    BN_free(dh-&gt;g);\n    dh-&gt;p=p;\n    dh-&gt;q=q;\n    dh-&gt;g=g;\n    if(q)\n        dh-&gt;length=BN_num_bits(q);\n    return 1;\n}',
 'crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n\n  memset (&amp;exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n\n  argp_parse (&amp;run_argp, argc, argv, ARGP_IN_ORDER, &amp;first_arg, &amp;exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n\n  ret = init_libcrun_context (&amp;crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret &lt; 0))\n    return ret;\n\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n\n  if (getenv ("LISTEN_FDS"))\n    {\n      crun_context.listen_fds = strtoll (getenv ("LISTEN_FDS"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n\n      process-&gt;args_len = argc;\n      process-&gt;args = xmalloc0 ((argc + 1) * sizeof (*process-&gt;args));\n      for (i = 0; i &lt; argc - first_arg; i++)\n        process-&gt;args[i] = xstrdup (argv[first_arg + i + 1]);\n      process-&gt;args[i] = NULL;\n      if (exec_options.cwd)\n        process-&gt;cwd = exec_options.cwd;\n      process-&gt;terminal = exec_options.tty;\n      process-&gt;env = exec_options.env;\n      process-&gt;env_len = exec_options.env_size;\n      process-&gt;user = make_oci_process_user (exec_options.user);\n\n      if (exec_options.process_label != NULL)\n        process-&gt;selinux_label = exec_options.process_label;\n\n      if (exec_options.apparmor != NULL)\n        process-&gt;apparmor_profile = exec_options.apparmor;\n\n      if (exec_options.cap_size &gt; 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n\n          capabilities-&gt;effective = exec_options.cap;\n          capabilities-&gt;effective_len = exec_options.cap_size;\n\n          capabilities-&gt;inheritable = NULL;\n          capabilities-&gt;inheritable_len = 0;\n\n          capabilities-&gt;bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities-&gt;bounding_len = exec_options.cap_size;\n\n          capabilities-&gt;ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities-&gt;ambient_len = exec_options.cap_size;\n\n          capabilities-&gt;permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities-&gt;permitted_len = exec_options.cap_size;\n\n          process-&gt;capabilities = capabilities;\n        }\n\n      // noNewPriviledges will remain `false` if basespec has `false` unless specified\n      // Default is always `true` in generated basespec config\n      if (exec_options.no_new_privs)\n        process-&gt;no_new_privileges = 1;\n\n      exec_opts.process = process;\n    }\n\n  exec_opts.cgroup = exec_options.cgroup;\n\n  return libcrun_container_exec_with_options (&amp;crun_context, argv[first_arg], &amp;exec_opts, err);\n}',
 'int mingw_rmdir(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) &lt; 0)\n\t\treturn -1;\n\n\twhile ((ret = _wrmdir(wpathname)) == -1 &amp;&amp; tries &lt; ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\terrno = err_win_to_posix(GetLastError());\n\t\tif (errno != EACCES)\n\t\t\tbreak;\n\t\tif (!is_dir_empty(wpathname)) {\n\t\t\terrno = ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We assume that some other process had the source or\n\t\t * destination file open at the wrong moment and retry.\n\t\t * In order to give the other process a higher chance to\n\t\t * complete its operation, we give up our time slice now.\n\t\t * If we have to retry again, we do sleep a bit.\n\t\t */\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 &amp;&amp; errno == EACCES &amp;&amp; is_file_in_use_error(GetLastError()) &amp;&amp;\n\t       ask_yes_no_if_possible("Deletion of directory \'%s\' failed. "\n\t\t\t"Should I try again?", pathname))\n\t       ret = _wrmdir(wpathname);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}',
 'ssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh-&gt;state;\n\tconst u_char *ssh1key, *ivin, *ivout, *keyin, *keyout, *input, *output;\n\tsize_t ssh1keylen, rlen, slen, ilen, olen;\n\tint r;\n\tu_int ssh1cipher = 0;\n\n\tif (!compat20) {\n\t\tif ((r = sshbuf_get_u32(m, &amp;state-&gt;remote_protocol_flags)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &amp;ssh1cipher)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, &amp;ssh1key, &amp;ssh1keylen)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, &amp;ivout, &amp;slen)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, &amp;ivin, &amp;rlen)) != 0)\n\t\t\treturn r;\n\t\tif (ssh1cipher &gt; INT_MAX)\n\t\t\treturn SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tssh_packet_set_encryption_key(ssh, ssh1key, ssh1keylen,\n\t\t    (int)ssh1cipher);\n\t\tif (cipher_get_keyiv_len(state-&gt;send_context) != (int)slen ||\n\t\t    cipher_get_keyiv_len(state-&gt;receive_context) != (int)rlen)\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\tif ((r = cipher_set_keyiv(state-&gt;send_context, ivout)) != 0 ||\n\t\t    (r = cipher_set_keyiv(state-&gt;receive_context, ivin)) != 0)\n\t\t\treturn r;\n\t} else {\n\t\tif ((r = kex_from_blob(m, &amp;ssh-&gt;kex)) != 0 ||\n\t\t    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||\n\t\t    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &amp;state-&gt;rekey_limit)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &amp;state-&gt;rekey_interval)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &amp;state-&gt;p_send.seqnr)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &amp;state-&gt;p_send.blocks)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &amp;state-&gt;p_send.packets)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &amp;state-&gt;p_send.bytes)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &amp;state-&gt;p_read.seqnr)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &amp;state-&gt;p_read.blocks)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &amp;state-&gt;p_read.packets)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &amp;state-&gt;p_read.bytes)) != 0)\n\t\t\treturn r;\n\t\t/*\n\t\t * We set the time here so that in post-auth privsep slave we\n\t\t * count from the completion of the authentication.\n\t\t */\n\t\tstate-&gt;rekey_time = monotime();\n\t\t/* XXX ssh_set_newkeys overrides p_read.packets? XXX */\n\t\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||\n\t\t    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_get_string_direct(m, &amp;keyout, &amp;slen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &amp;keyin, &amp;rlen)) != 0)\n\t\treturn r;\n\tif (cipher_get_keycontext(state-&gt;send_context, NULL) != (int)slen ||\n\t    cipher_get_keycontext(state-&gt;receive_context, NULL) != (int)rlen)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tcipher_set_keycontext(state-&gt;send_context, keyout);\n\tcipher_set_keycontext(state-&gt;receive_context, keyin);\n\n\tif ((r = ssh_packet_set_postauth(ssh)) != 0)\n\t\treturn r;\n\n\tsshbuf_reset(state-&gt;input);\n\tsshbuf_reset(state-&gt;output);\n\tif ((r = sshbuf_get_string_direct(m, &amp;input, &amp;ilen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &amp;output, &amp;olen)) != 0 ||\n\t    (r = sshbuf_put(state-&gt;input, input, ilen)) != 0 ||\n\t    (r = sshbuf_put(state-&gt;output, output, olen)) != 0)\n\t\treturn r;\n\n\tif (sshbuf_len(m))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug3("%s: done", __func__);\n\treturn 0;\n}',
 'xscale2pmu_handle_irq(int irq_num, void *dev)\n{\n\tunsigned long pmnc, of_flags;\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct pt_regs *regs;\n\tint idx;\n\n\t/* Disable the PMU. */\n\tpmnc = xscale2pmu_read_pmnc();\n\txscale2pmu_write_pmnc(pmnc &amp; ~XSCALE_PMU_ENABLE);\n\n\t/* Check the overflow flag register. */\n\tof_flags = xscale2pmu_read_overflow_flags();\n\tif (!(of_flags &amp; XSCALE2_OVERFLOWED_MASK))\n\t\treturn IRQ_NONE;\n\n\t/* Clear the overflow bits. */\n\txscale2pmu_write_overflow_flags(of_flags);\n\n\tregs = get_irq_regs();\n\n\tperf_sample_data_init(&amp;data, 0);\n\n\tcpuc = &amp;__get_cpu_var(cpu_hw_events);\n\tfor (idx = 0; idx &lt;= armpmu-&gt;num_events; ++idx) {\n\t\tstruct perf_event *event = cpuc-&gt;events[idx];\n\t\tstruct hw_perf_event *hwc;\n\n\t\tif (!test_bit(idx, cpuc-&gt;active_mask))\n\t\t\tcontinue;\n\n\t\tif (!xscale2_pmnc_counter_has_overflowed(pmnc, idx))\n\t\t\tcontinue;\n\n\t\thwc = &amp;event-&gt;hw;\n\t\tarmpmu_event_update(event, hwc, idx, 1);\n\t\tdata.period = event-&gt;hw.last_period;\n\t\tif (!armpmu_event_set_period(event, hwc, idx))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, &amp;data, regs))\n\t\t\tarmpmu-&gt;disable(hwc, idx);\n\t}\n\n\tirq_work_run();\n\n\t/*\n\t * Re-enable the PMU.\n\t */\n\tpmnc = xscale2pmu_read_pmnc() | XSCALE_PMU_ENABLE;\n\txscale2pmu_write_pmnc(pmnc);\n\n\treturn IRQ_HANDLED;\n}',
 'static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\n  /* the imap struct is already inited in imap_connect() */\n  struct imap_conn *imapc = &amp;conn-&gt;proto.imapc;\n  struct SessionHandle *data = conn-&gt;data;\n  const char *path = data-&gt;state.path;\n  int len;\n\n  if(!*path)\n    path = "INBOX";\n\n  /* url decode the path and use this mailbox */\n  imapc-&gt;mailbox = curl_easy_unescape(data, path, 0, &amp;len);\n  if(!imapc-&gt;mailbox)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}',
 'void cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n    if (!hooks) { /* Reset hooks */\n        cJSON_malloc = malloc;\n        cJSON_free = free;\n        return;\n    }\n\n\tcJSON_malloc = (hooks-&gt;malloc_fn)?hooks-&gt;malloc_fn:malloc;\n\tcJSON_free\t = (hooks-&gt;free_fn)?hooks-&gt;free_fn:free;\n}',
 'static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet-&gt;parsed_lines = 0, packet-&gt;empty_line_position_set = 0, packet-&gt;host_line.ptr = NULL,\n    packet-&gt;host_line.len = 0, packet-&gt;referer_line.ptr = NULL, packet-&gt;referer_line.len = 0,\n    packet-&gt;content_line.ptr = NULL, packet-&gt;content_line.len = 0, packet-&gt;accept_line.ptr = NULL,\n    packet-&gt;accept_line.len = 0, packet-&gt;user_agent_line.ptr = NULL, packet-&gt;user_agent_line.len = 0,\n    packet-&gt;http_url_name.ptr = NULL, packet-&gt;http_url_name.len = 0, packet-&gt;http_encoding.ptr = NULL,\n    packet-&gt;http_encoding.len = 0, packet-&gt;http_transfer_encoding.ptr = NULL, packet-&gt;http_transfer_encoding.len = 0,\n    packet-&gt;http_contentlen.ptr = NULL, packet-&gt;http_contentlen.len = 0, packet-&gt;content_disposition_line.ptr = NULL,\n    packet-&gt;content_disposition_line.len = 0, packet-&gt;http_cookie.ptr = NULL,\n    packet-&gt;http_cookie.len = 0, packet-&gt;http_origin.len = 0, packet-&gt;http_origin.ptr = NULL,\n    packet-&gt;http_x_session_type.ptr = NULL, packet-&gt;http_x_session_type.len = 0, packet-&gt;server_line.ptr = NULL,\n    packet-&gt;server_line.len = 0, packet-&gt;http_method.ptr = NULL, packet-&gt;http_method.len = 0,\n    packet-&gt;http_response.ptr = NULL, packet-&gt;http_response.len = 0, packet-&gt;http_num_headers = 0;\n}',
 'flac_buffer_copy (SF_PRIVATE *psf)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf-&gt;codec_data ;\n\tconst FLAC__Frame *frame = pflac-&gt;frame ;\n\tconst int32_t* const *buffer = pflac-&gt;wbuffer ;\n\tunsigned i = 0, j, offset, channels, len ;\n\n\t/*\n\t**\tframe-&gt;header.blocksize is variable and we\'re using a constant blocksize\n\t**\tof FLAC__MAX_BLOCK_SIZE.\n\t**\tCheck our assumptions here.\n\t*/\n\tif (frame-&gt;header.blocksize &gt; FLAC__MAX_BLOCK_SIZE)\n\t{\tpsf_log_printf (psf, "Ooops : frame-&gt;header.blocksize (%d) &gt; FLAC__MAX_BLOCK_SIZE (%d)\\n", __func__, __LINE__, frame-&gt;header.blocksize, FLAC__MAX_BLOCK_SIZE) ;\n\t\tpsf-&gt;error = SFE_INTERNAL ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frame-&gt;header.channels &gt; FLAC__MAX_CHANNELS)\n\t\tpsf_log_printf (psf, "Ooops : frame-&gt;header.channels (%d) &gt; FLAC__MAX_BLOCK_SIZE (%d)\\n", __func__, __LINE__, frame-&gt;header.channels, FLAC__MAX_CHANNELS) ;\n\n\tchannels = SF_MIN (frame-&gt;header.channels, FLAC__MAX_CHANNELS) ;\n\n\tif (pflac-&gt;ptr == NULL)\n\t{\t/*\n\t\t** This pointer is reset to NULL each time the current frame has been\n\t\t** decoded. Somehow its used during encoding and decoding.\n\t\t*/\n\t\tfor (i = 0 ; i &lt; channels ; i++)\n\t\t{\n\t\t\tif (pflac-&gt;rbuffer [i] == NULL)\n\t\t\t\tpflac-&gt;rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;\n\n\t\t\tmemcpy (pflac-&gt;rbuffer [i], buffer [i], frame-&gt;header.blocksize * sizeof (int32_t)) ;\n\t\t\t} ;\n\t\tpflac-&gt;wbuffer = (const int32_t* const*) pflac-&gt;rbuffer ;\n\n\t\treturn 0 ;\n\t\t} ;\n\n\n\tlen = SF_MIN (pflac-&gt;len, frame-&gt;header.blocksize) ;\n\n\tif (pflac-&gt;remain % channels != 0)\n\t{\tpsf_log_printf (psf, "Error: pflac-&gt;remain %u    channels %u\\n", pflac-&gt;remain, channels) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tswitch (pflac-&gt;pcmtype)\n\t{\tcase PFLAC_PCM_SHORT :\n\t\t\t{\tshort *retpcm = (short*) pflac-&gt;ptr ;\n\t\t\t\tint shift = 16 - frame-&gt;header.bits_per_sample ;\n\t\t\t\tif (shift &lt; 0)\n\t\t\t\t{\tshift = abs (shift) ;\n\t\t\t\t\tfor (i = 0 ; i &lt; len &amp;&amp; pflac-&gt;remain &gt; 0 ; i++)\n\t\t\t\t\t{\toffset = pflac-&gt;pos + i * channels ;\n\n\t\t\t\t\t\tif (pflac-&gt;bufferpos &gt;= frame-&gt;header.blocksize)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tif (offset + channels &gt; pflac-&gt;len)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tfor (j = 0 ; j &lt; channels ; j++)\n\t\t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac-&gt;bufferpos] &gt;&gt; shift ;\n\t\t\t\t\t\tpflac-&gt;remain -= channels ;\n\t\t\t\t\t\tpflac-&gt;bufferpos++ ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\tfor (i = 0 ; i &lt; len &amp;&amp; pflac-&gt;remain &gt; 0 ; i++)\n\t\t\t\t\t{\toffset = pflac-&gt;pos + i * channels ;\n\n\t\t\t\t\t\tif (pflac-&gt;bufferpos &gt;= frame-&gt;header.blocksize)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tif (offset + channels &gt; pflac-&gt;len)\n\t\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\tfor (j = 0 ; j &lt; channels ; j++)\n\t\t\t\t\t\t\tretpcm [offset + j] = ((uint16_t) buffer [j][pflac-&gt;bufferpos]) &lt;&lt; shift ;\n\n\t\t\t\t\t\tpflac-&gt;remain -= channels ;\n\t\t\t\t\t\tpflac-&gt;bufferpos++ ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase PFLAC_PCM_INT :\n\t\t\t{\tint *retpcm = (int*) pflac-&gt;ptr ;\n\t\t\t\tint shift = 32 - frame-&gt;header.bits_per_sample ;\n\t\t\t\tfor (i = 0 ; i &lt; len &amp;&amp; pflac-&gt;remain &gt; 0 ; i++)\n\t\t\t\t{\toffset = pflac-&gt;pos + i * channels ;\n\n\t\t\t\t\tif (pflac-&gt;bufferpos &gt;= frame-&gt;header.blocksize)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tif (offset + channels &gt; pflac-&gt;len)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tfor (j = 0 ; j &lt; channels ; j++)\n\t\t\t\t\t\tretpcm [offset + j] = ((uint32_t) buffer [j][pflac-&gt;bufferpos]) &lt;&lt; shift ;\n\t\t\t\t\tpflac-&gt;remain -= channels ;\n\t\t\t\t\tpflac-&gt;bufferpos++ ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase PFLAC_PCM_FLOAT :\n\t\t\t{\tfloat *retpcm = (float*) pflac-&gt;ptr ;\n\t\t\t\tfloat norm = (psf-&gt;norm_float == SF_TRUE) ? 1.0 / (1 &lt;&lt; (frame-&gt;header.bits_per_sample - 1)) : 1.0 ;\n\n\t\t\t\tfor (i = 0 ; i &lt; len &amp;&amp; pflac-&gt;remain &gt; 0 ; i++)\n\t\t\t\t{\toffset = pflac-&gt;pos + i * channels ;\n\n\t\t\t\t\tif (pflac-&gt;bufferpos &gt;= frame-&gt;header.blocksize)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tif (offset + channels &gt; pflac-&gt;len)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tfor (j = 0 ; j &lt; channels ; j++)\n\t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac-&gt;bufferpos] * norm ;\n\t\t\t\t\tpflac-&gt;remain -= channels ;\n\t\t\t\t\tpflac-&gt;bufferpos++ ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase PFLAC_PCM_DOUBLE :\n\t\t\t{\tdouble *retpcm = (double*) pflac-&gt;ptr ;\n\t\t\t\tdouble norm = (psf-&gt;norm_double == SF_TRUE) ? 1.0 / (1 &lt;&lt; (frame-&gt;header.bits_per_sample - 1)) : 1.0 ;\n\n\t\t\t\tfor (i = 0 ; i &lt; len &amp;&amp; pflac-&gt;remain &gt; 0 ; i++)\n\t\t\t\t{\toffset = pflac-&gt;pos + i * channels ;\n\n\t\t\t\t\tif (pflac-&gt;bufferpos &gt;= frame-&gt;header.blocksize)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tif (offset + channels &gt; pflac-&gt;len)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tfor (j = 0 ; j &lt; channels ; j++)\n\t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac-&gt;bufferpos] * norm ;\n\t\t\t\t\tpflac-&gt;remain -= channels ;\n\t\t\t\t\tpflac-&gt;bufferpos++ ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\treturn 0 ;\n\t\t} ;\n\n\toffset = i * channels ;\n\tpflac-&gt;pos += i * channels ;\n\n\treturn offset ;\n} /* flac_buffer_copy */',
 'static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}',
 'bool Unpack::UnpackLargeBlock(UnpackThreadData &amp;D)\n{\n  if (!D.TableRead)\n  {\n    D.TableRead=true;\n    if (!ReadTables(D.Inp,D.BlockHeader,D.BlockTables))\n    {\n      D.DamagedData=true;\n      return false;\n    }\n  }\n\n  if (D.Inp.InAddr&gt;D.BlockHeader.HeaderSize+D.BlockHeader.BlockSize)\n  {\n    D.DamagedData=true;\n    return false;\n  }\n  \n  int BlockBorder=D.BlockHeader.BlockStart+D.BlockHeader.BlockSize-1;\n\n  // Reserve enough space even for filter entry.\n  int DataBorder=D.DataSize-16;\n  int ReadBorder=Min(BlockBorder,DataBorder);\n\n  while (true)\n  {\n    UnpPtr&amp;=MaxWinMask;\n    if (D.Inp.InAddr&gt;=ReadBorder)\n    {\n      if (D.Inp.InAddr&gt;BlockBorder || D.Inp.InAddr==BlockBorder &amp;&amp; \n          D.Inp.InBit&gt;=D.BlockHeader.BlockBitSize)\n        break;\n\n      // If we do not have any more data in file to read, we must process\n      // what we have until last byte. Otherwise we can return and append\n      // more data to unprocessed few bytes.\n      if ((D.Inp.InAddr&gt;=DataBorder) &amp;&amp; !D.NoDataLeft || D.Inp.InAddr&gt;=D.DataSize)\n      {\n        D.Incomplete=true;\n        break;\n      }\n    }\n    if (((WriteBorder-UnpPtr) &amp; MaxWinMask)&lt;MAX_LZ_MATCH+3 &amp;&amp; WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize&gt;DestUnpSize)\n        return false;\n    }\n\n    uint MainSlot=DecodeNumber(D.Inp,&amp;D.BlockTables.LD);\n    if (MainSlot&lt;256)\n    {\n      Window[UnpPtr++]=(byte)MainSlot;\n      continue;\n    }\n    if (MainSlot&gt;=262)\n    {\n      uint Length=SlotToLength(D.Inp,MainSlot-262);\n\n      uint DBits,Distance=1,DistSlot=DecodeNumber(D.Inp,&amp;D.BlockTables.DD);\n      if (DistSlot&lt;4)\n      {\n        DBits=0;\n        Distance+=DistSlot;\n      }\n      else\n      {\n        DBits=DistSlot/2 - 1;\n        Distance+=(2 | (DistSlot &amp; 1)) &lt;&lt; DBits;\n      }\n\n      if (DBits&gt;0)\n      {\n        if (DBits&gt;=4)\n        {\n          if (DBits&gt;4)\n          {\n            Distance+=((D.Inp.getbits32()&gt;&gt;(36-DBits))&lt;&lt;4);\n            D.Inp.addbits(DBits-4);\n          }\n          uint LowDist=DecodeNumber(D.Inp,&amp;D.BlockTables.LDD);\n          Distance+=LowDist;\n        }\n        else\n        {\n          Distance+=D.Inp.getbits32()&gt;&gt;(32-DBits);\n          D.Inp.addbits(DBits);\n        }\n      }\n\n      if (Distance&gt;0x100)\n      {\n        Length++;\n        if (Distance&gt;0x2000)\n        {\n          Length++;\n          if (Distance&gt;0x40000)\n            Length++;\n        }\n      }\n\n      InsertOldDist(Distance);\n      LastLength=Length;\n      CopyString(Length,Distance);\n      continue;\n    }\n    if (MainSlot==256)\n    {\n      UnpackFilter Filter;\n      if (!ReadFilter(D.Inp,Filter) || !AddFilter(Filter))\n        break;\n      continue;\n    }\n    if (MainSlot==257)\n    {\n      if (LastLength!=0)\n        CopyString(LastLength,OldDist[0]);\n      continue;\n    }\n    if (MainSlot&lt;262)\n    {\n      uint DistNum=MainSlot-258;\n      uint Distance=OldDist[DistNum];\n      for (uint I=DistNum;I&gt;0;I--)\n        OldDist[I]=OldDist[I-1];\n      OldDist[0]=Distance;\n\n      uint LengthSlot=DecodeNumber(D.Inp,&amp;D.BlockTables.RD);\n      uint Length=SlotToLength(D.Inp,LengthSlot);\n      LastLength=Length;\n      CopyString(Length,Distance);\n      continue;\n    }\n  }\n  return true;\n}',
 '    bool IsLoaded() {return Loaded;}',
 'char *string_crypt(const char *key, const char *salt) {\n  assert(key);\n  assert(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,"$1$",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = \'\\0\';\n    return string_crypt(key, random_salt);\n  }\n\n  if ((strlen(salt) &gt; sizeof("$2X$00$")) &amp;&amp;\n    (salt[0] == \'$\') &amp;&amp;\n    (salt[1] == \'2\') &amp;&amp;\n    (salt[2] &gt;= \'a\') &amp;&amp; (salt[2] &lt;= \'z\') &amp;&amp;\n    (salt[3] == \'$\') &amp;&amp;\n    (salt[4] &gt;= \'0\') &amp;&amp; (salt[4] &lt;= \'3\') &amp;&amp;\n    (salt[5] &gt;= \'0\') &amp;&amp; (salt[5] &lt;= \'9\') &amp;&amp;\n    (salt[6] == \'$\')) {\n    // Bundled blowfish crypt()\n    char output[61];\n    if (php_crypt_blowfish_rn(key, salt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);\n    char *crypt_res = crypt(key,salt);\n\n    if (crypt_res) {\n      return strdup(crypt_res);\n    }\n#endif\n  }\n\n  return ((salt[0] == \'*\') &amp;&amp; (salt[1] == \'0\'))\n                  ? strdup("*1") : strdup("*0");\n}',
 'static CURLcode smtp_connect(struct connectdata *conn,\n                             bool *done) /* see description above */\n{\n  CURLcode result;\n  struct smtp_conn *smtpc = &amp;conn-&gt;proto.smtpc;\n  struct SessionHandle *data = conn-&gt;data;\n  struct pingpong *pp = &amp;smtpc-&gt;pp;\n  const char *path = conn-&gt;data-&gt;state.path;\n  char localhost[HOSTNAME_MAX + 1];\n\n  *done = FALSE; /* default to not done yet */\n\n  /* If there already is a protocol-specific struct allocated for this\n     sessionhandle, deal with it */\n  Curl_reset_reqproto(conn);\n\n  result = smtp_init(conn);\n  if(CURLE_OK != result)\n    return result;\n\n  /* We always support persistent connections on smtp */\n  conn-&gt;bits.close = FALSE;\n\n  pp-&gt;response_time = RESP_TIMEOUT; /* set default response time-out */\n  pp-&gt;statemach_act = smtp_statemach_act;\n  pp-&gt;endofresp = smtp_endofresp;\n  pp-&gt;conn = conn;\n\n  if(conn-&gt;bits.tunnel_proxy &amp;&amp; conn-&gt;bits.httpproxy) {\n    /* for SMTP over HTTP proxy */\n    struct HTTP http_proxy;\n    struct FTP *smtp_save;\n\n    /* BLOCKING */\n    /* We want "seamless" SMTP operations through HTTP proxy tunnel */\n\n    /* Curl_proxyCONNECT is based on a pointer to a struct HTTP at the member\n     * conn-&gt;proto.http; we want SMTP through HTTP and we have to change the\n     * member temporarily for connecting to the HTTP proxy. After\n     * Curl_proxyCONNECT we have to set back the member to the original struct\n     * SMTP pointer\n     */\n    smtp_save = data-&gt;state.proto.smtp;\n    memset(&amp;http_proxy, 0, sizeof(http_proxy));\n    data-&gt;state.proto.http = &amp;http_proxy;\n\n    result = Curl_proxyCONNECT(conn, FIRSTSOCKET,\n                               conn-&gt;host.name, conn-&gt;remote_port);\n\n    data-&gt;state.proto.smtp = smtp_save;\n\n    if(CURLE_OK != result)\n      return result;\n  }\n\n  if((conn-&gt;handler-&gt;protocol &amp; CURLPROTO_SMTPS) &amp;&amp;\n      data-&gt;state.used_interface != Curl_if_multi) {\n    /* SMTPS is simply smtp with SSL for the control channel */\n    /* now, perform the SSL initialization for this socket */\n    result = Curl_ssl_connect(conn, FIRSTSOCKET);\n    if(result)\n      return result;\n  }\n\n  Curl_pp_init(pp); /* init the response reader stuff */\n\n  pp-&gt;response_time = RESP_TIMEOUT; /* set default response time-out */\n  pp-&gt;statemach_act = smtp_statemach_act;\n  pp-&gt;endofresp = smtp_endofresp;\n  pp-&gt;conn = conn;\n\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof localhost))\n      path = localhost;\n    else\n      path = "localhost";\n  }\n\n  /* url decode the path and use it as domain with EHLO */\n  result = Curl_urldecode(conn-&gt;data, path, 0, &amp;smtpc-&gt;domain, NULL, TRUE);\n  if(result)\n    return result;\n\n  /* When we connect, we start in the state where we await the server greeting\n   */\n  state(conn, SMTP_SERVERGREET);\n\n  if(data-&gt;state.used_interface == Curl_if_multi)\n    result = smtp_multi_statemach(conn, done);\n  else {\n    result = smtp_easy_statemach(conn);\n    if(!result)\n      *done = TRUE;\n  }\n\n  return result;\n}',
 'TfLiteStatus Gather(const TfLiteGatherParams&amp; params, const TfLiteTensor* input,\n                    const TfLiteTensor* positions, TfLiteTensor* output) {\n  tflite::GatherParams op_params;\n  op_params.axis = params.axis;\n  op_params.batch_dims = params.batch_dims;\n  optimized_ops::Gather(op_params, GetTensorShape(input),\n                        GetTensorData&lt;InputT&gt;(input), GetTensorShape(positions),\n                        GetTensorData&lt;PositionsT&gt;(positions),\n                        GetTensorShape(output), GetTensorData&lt;InputT&gt;(output));\n  return kTfLiteOk;\n}',
 "buflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf-&gt;b_sfname, ignore_case);\n    if (match == NULL &amp;&amp; rmp-&gt;regprog != NULL)\n\tmatch = fname_match(rmp, buf-&gt;b_ffname, ignore_case);\n\n    return match;\n}",
 'hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode * inode;\n\tstruct dentry * root;\n\tint ret;\n\tstruct hugetlbfs_config config;\n\tstruct hugetlbfs_sb_info *sbinfo;\n\n\tsave_mount_options(sb, data);\n\n\tconfig.nr_blocks = -1; /* No limit on size by default */\n\tconfig.nr_inodes = -1; /* No limit on number of inodes by default */\n\tconfig.uid = current_fsuid();\n\tconfig.gid = current_fsgid();\n\tconfig.mode = 0755;\n\tconfig.hstate = &amp;default_hstate;\n\tret = hugetlbfs_parse_options(data, &amp;config);\n\tif (ret)\n\t\treturn ret;\n\n\tsbinfo = kmalloc(sizeof(struct hugetlbfs_sb_info), GFP_KERNEL);\n\tif (!sbinfo)\n\t\treturn -ENOMEM;\n\tsb-&gt;s_fs_info = sbinfo;\n\tsbinfo-&gt;hstate = config.hstate;\n\tspin_lock_init(&amp;sbinfo-&gt;stat_lock);\n\tsbinfo-&gt;max_inodes = config.nr_inodes;\n\tsbinfo-&gt;free_inodes = config.nr_inodes;\n\tsbinfo-&gt;spool = NULL;\n\tif (config.nr_blocks != -1) {\n\t\tsbinfo-&gt;spool = hugepage_new_subpool(config.nr_blocks);\n\t\tif (!sbinfo-&gt;spool)\n\t\t\tgoto out_free;\n\t}\n\tsb-&gt;s_maxbytes = MAX_LFS_FILESIZE;\n\tsb-&gt;s_blocksize = huge_page_size(config.hstate);\n\tsb-&gt;s_blocksize_bits = huge_page_shift(config.hstate);\n\tsb-&gt;s_magic = HUGETLBFS_MAGIC;\n\tsb-&gt;s_op = &amp;hugetlbfs_ops;\n\tsb-&gt;s_time_gran = 1;\n\tinode = hugetlbfs_get_root(sb, &amp;config);\n\tif (!inode)\n\t\tgoto out_free;\n\n\troot = d_alloc_root(inode);\n\tif (!root) {\n\t\tiput(inode);\n\t\tgoto out_free;\n\t}\n\tsb-&gt;s_root = root;\n\treturn 0;\nout_free:\n\tif (sbinfo-&gt;spool)\n\t\tkfree(sbinfo-&gt;spool);\n\tkfree(sbinfo);\n\treturn -ENOMEM;\n}',
 'static int filter_frame(AVFilterLink *inlink, AVFrame *buf)\n{\n    AVFilterContext    *ctx = inlink-&gt;dst;\n    FPSContext           *s = ctx-&gt;priv;\n    AVFilterLink   *outlink = ctx-&gt;outputs[0];\n    int64_t delta;\n    int i, ret;\n\n    s-&gt;frames_in++;\n    /* discard frames until we get the first timestamp */\n    if (s-&gt;pts == AV_NOPTS_VALUE) {\n        if (buf-&gt;pts != AV_NOPTS_VALUE) {\n            ret = write_to_fifo(s-&gt;fifo, buf);\n            if (ret &lt; 0)\n                return ret;\n\n            if (s-&gt;start_time != DBL_MAX &amp;&amp; s-&gt;start_time != AV_NOPTS_VALUE) {\n                double first_pts = s-&gt;start_time * AV_TIME_BASE;\n                first_pts = FFMIN(FFMAX(first_pts, INT64_MIN), INT64_MAX);\n                s-&gt;first_pts = s-&gt;pts = av_rescale_q(first_pts, AV_TIME_BASE_Q,\n                                                     inlink-&gt;time_base);\n                av_log(ctx, AV_LOG_VERBOSE, "Set first pts to (in:%"PRId64" out:%"PRId64")\\n",\n                       s-&gt;first_pts, av_rescale_q(first_pts, AV_TIME_BASE_Q,\n                                                  outlink-&gt;time_base));\n            } else {\n                s-&gt;first_pts = s-&gt;pts = buf-&gt;pts;\n            }\n        } else {\n            av_log(ctx, AV_LOG_WARNING, "Discarding initial frame(s) with no "\n                   "timestamp.\\n");\n            av_frame_free(&amp;buf);\n            s-&gt;drop++;\n        }\n        return 0;\n    }\n\n    /* now wait for the next timestamp */\n    if (buf-&gt;pts == AV_NOPTS_VALUE) {\n        return write_to_fifo(s-&gt;fifo, buf);\n    }\n\n    /* number of output frames */\n    delta = av_rescale_q_rnd(buf-&gt;pts - s-&gt;pts, inlink-&gt;time_base,\n                             outlink-&gt;time_base, s-&gt;rounding);\n\n    if (delta &lt; 1) {\n        /* drop the frame and everything buffered except the first */\n        AVFrame *tmp;\n        int drop = av_fifo_size(s-&gt;fifo)/sizeof(AVFrame*);\n\n        av_log(ctx, AV_LOG_DEBUG, "Dropping %d frame(s).\\n", drop);\n        s-&gt;drop += drop;\n\n        av_fifo_generic_read(s-&gt;fifo, &amp;tmp, sizeof(tmp), NULL);\n        flush_fifo(s-&gt;fifo);\n        ret = write_to_fifo(s-&gt;fifo, tmp);\n\n        av_frame_free(&amp;buf);\n        return ret;\n    }\n\n    /* can output &gt;= 1 frames */\n    for (i = 0; i &lt; delta; i++) {\n        AVFrame *buf_out;\n        av_fifo_generic_read(s-&gt;fifo, &amp;buf_out, sizeof(buf_out), NULL);\n\n        /* duplicate the frame if needed */\n        if (!av_fifo_size(s-&gt;fifo) &amp;&amp; i &lt; delta - 1) {\n            AVFrame *dup = av_frame_clone(buf_out);\n\n            av_log(ctx, AV_LOG_DEBUG, "Duplicating frame.\\n");\n            if (dup)\n                ret = write_to_fifo(s-&gt;fifo, dup);\n            else\n                ret = AVERROR(ENOMEM);\n\n            if (ret &lt; 0) {\n                av_frame_free(&amp;buf_out);\n                av_frame_free(&amp;buf);\n                return ret;\n            }\n\n            s-&gt;dup++;\n        }\n\n        buf_out-&gt;pts = av_rescale_q(s-&gt;first_pts, inlink-&gt;time_base,\n                                    outlink-&gt;time_base) + s-&gt;frames_out;\n\n        if ((ret = ff_filter_frame(outlink, buf_out)) &lt; 0) {\n            av_frame_free(&amp;buf);\n            return ret;\n        }\n\n        s-&gt;frames_out++;\n    }\n    flush_fifo(s-&gt;fifo);\n\n    ret = write_to_fifo(s-&gt;fifo, buf);\n    s-&gt;pts = s-&gt;first_pts + av_rescale_q(s-&gt;frames_out, outlink-&gt;time_base, inlink-&gt;time_base);\n\n    return ret;\n}',
 'jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox-&gt;type = type;\n\tbox-&gt;len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox-&gt;info = boxinfo;\n\tbox-&gt;ops = &amp;boxinfo-&gt;ops;\n\treturn box;\n}',
 'alloc_limit_assert (char *fn_name, size_t size)\n{\n    if (alloc_limit &amp;&amp; size &gt; alloc_limit)\n    {\n        alloc_limit_failure (fn_name, size);\n        exit (-1);\n    }\n}',
 'interp_reply(netdissect_options *ndo,\n             const struct sunrpc_msg *rp, uint32_t proc, uint32_t vers, int length)\n{\n\tregister const uint32_t *dp;\n\tregister int v3;\n\tint er;\n\n\tv3 = (vers == NFS_VER3);\n\n\tif (!v3 &amp;&amp; proc &lt; NFS_NPROCS)\n\t\tproc = nfsv3_procid[proc];\n\n\tND_PRINT((ndo, " %s", tok2str(nfsproc_str, "proc-%u", proc)));\n\tswitch (proc) {\n\n\tcase NFSPROC_GETATTR:\n\t\tdp = parserep(ndo, rp, length);\n\t\tif (dp != NULL &amp;&amp; parseattrstat(ndo, dp, !ndo-&gt;ndo_qflag, v3) != 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_SETATTR:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\treturn;\n\t\tif (v3) {\n\t\t\tif (parsewccres(ndo, dp, ndo-&gt;ndo_vflag))\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (parseattrstat(ndo, dp, !ndo-&gt;ndo_qflag, 0) != 0)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_LOOKUP:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (v3) {\n\t\t\tif (!(dp = parsestatus(ndo, dp, &amp;er)))\n\t\t\t\tbreak;\n\t\t\tif (er) {\n\t\t\t\tif (ndo-&gt;ndo_vflag &gt; 1) {\n\t\t\t\t\tND_PRINT((ndo, " post dattr:"));\n\t\t\t\t\tdp = parse_post_op_attr(ndo, dp, ndo-&gt;ndo_vflag);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!(dp = parsefh(ndo, dp, v3)))\n\t\t\t\t\tbreak;\n\t\t\t\tif ((dp = parse_post_op_attr(ndo, dp, ndo-&gt;ndo_vflag)) &amp;&amp;\n\t\t\t\t    ndo-&gt;ndo_vflag &gt; 1) {\n\t\t\t\t\tND_PRINT((ndo, " post dattr:"));\n\t\t\t\t\tdp = parse_post_op_attr(ndo, dp, ndo-&gt;ndo_vflag);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp)\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (parsediropres(ndo, dp) != 0)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_ACCESS:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (!(dp = parsestatus(ndo, dp, &amp;er)))\n\t\t\tbreak;\n\t\tif (ndo-&gt;ndo_vflag)\n\t\t\tND_PRINT((ndo, " attr:"));\n\t\tif (!(dp = parse_post_op_attr(ndo, dp, ndo-&gt;ndo_vflag)))\n\t\t\tbreak;\n\t\tif (!er) {\n\t\t\tND_TCHECK(dp[0]);\n\t\t\tND_PRINT((ndo, " c %04x", EXTRACT_32BITS(&amp;dp[0])));\n\t\t}\n\t\treturn;\n\n\tcase NFSPROC_READLINK:\n\t\tdp = parserep(ndo, rp, length);\n\t\tif (dp != NULL &amp;&amp; parselinkres(ndo, dp, v3) != 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_READ:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (v3) {\n\t\t\tif (!(dp = parsestatus(ndo, dp, &amp;er)))\n\t\t\t\tbreak;\n\t\t\tif (!(dp = parse_post_op_attr(ndo, dp, ndo-&gt;ndo_vflag)))\n\t\t\t\tbreak;\n\t\t\tif (er)\n\t\t\t\treturn;\n\t\t\tif (ndo-&gt;ndo_vflag) {\n\t\t\t\tND_TCHECK(dp[1]);\n\t\t\t\tND_PRINT((ndo, " %u bytes", EXTRACT_32BITS(&amp;dp[0])));\n\t\t\t\tif (EXTRACT_32BITS(&amp;dp[1]))\n\t\t\t\t\tND_PRINT((ndo, " EOF"));\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (parseattrstat(ndo, dp, ndo-&gt;ndo_vflag, 0) != 0)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_WRITE:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (v3) {\n\t\t\tif (!(dp = parsestatus(ndo, dp, &amp;er)))\n\t\t\t\tbreak;\n\t\t\tif (!(dp = parse_wcc_data(ndo, dp, ndo-&gt;ndo_vflag)))\n\t\t\t\tbreak;\n\t\t\tif (er)\n\t\t\t\treturn;\n\t\t\tif (ndo-&gt;ndo_vflag) {\n\t\t\t\tND_TCHECK(dp[0]);\n\t\t\t\tND_PRINT((ndo, " %u bytes", EXTRACT_32BITS(&amp;dp[0])));\n\t\t\t\tif (ndo-&gt;ndo_vflag &gt; 1) {\n\t\t\t\t\tND_TCHECK(dp[1]);\n\t\t\t\t\tND_PRINT((ndo, " &lt;%s&gt;",\n\t\t\t\t\t\ttok2str(nfsv3_writemodes,\n\t\t\t\t\t\t\tNULL, EXTRACT_32BITS(&amp;dp[1]))));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (parseattrstat(ndo, dp, ndo-&gt;ndo_vflag, v3) != 0)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_CREATE:\n\tcase NFSPROC_MKDIR:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (v3) {\n\t\t\tif (parsecreateopres(ndo, dp, ndo-&gt;ndo_vflag) != NULL)\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (parsediropres(ndo, dp) != 0)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_SYMLINK:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (v3) {\n\t\t\tif (parsecreateopres(ndo, dp, ndo-&gt;ndo_vflag) != NULL)\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (parsestatus(ndo, dp, &amp;er) != NULL)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_MKNOD:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (parsecreateopres(ndo, dp, ndo-&gt;ndo_vflag) != NULL)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_REMOVE:\n\tcase NFSPROC_RMDIR:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (v3) {\n\t\t\tif (parsewccres(ndo, dp, ndo-&gt;ndo_vflag))\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (parsestatus(ndo, dp, &amp;er) != NULL)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_RENAME:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (v3) {\n\t\t\tif (!(dp = parsestatus(ndo, dp, &amp;er)))\n\t\t\t\tbreak;\n\t\t\tif (ndo-&gt;ndo_vflag) {\n\t\t\t\tND_PRINT((ndo, " from:"));\n\t\t\t\tif (!(dp = parse_wcc_data(ndo, dp, ndo-&gt;ndo_vflag)))\n\t\t\t\t\tbreak;\n\t\t\t\tND_PRINT((ndo, " to:"));\n\t\t\t\tif (!(dp = parse_wcc_data(ndo, dp, ndo-&gt;ndo_vflag)))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (parsestatus(ndo, dp, &amp;er) != NULL)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_LINK:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (v3) {\n\t\t\tif (!(dp = parsestatus(ndo, dp, &amp;er)))\n\t\t\t\tbreak;\n\t\t\tif (ndo-&gt;ndo_vflag) {\n\t\t\t\tND_PRINT((ndo, " file POST:"));\n\t\t\t\tif (!(dp = parse_post_op_attr(ndo, dp, ndo-&gt;ndo_vflag)))\n\t\t\t\t\tbreak;\n\t\t\t\tND_PRINT((ndo, " dir:"));\n\t\t\t\tif (!(dp = parse_wcc_data(ndo, dp, ndo-&gt;ndo_vflag)))\n\t\t\t\t\tbreak;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (parsestatus(ndo, dp, &amp;er) != NULL)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_READDIR:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (v3) {\n\t\t\tif (parsev3rddirres(ndo, dp, ndo-&gt;ndo_vflag))\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (parserddires(ndo, dp) != 0)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_READDIRPLUS:\n\t\tif (!(dp = parserep(ndo, rp, length)))\n\t\t\tbreak;\n\t\tif (parsev3rddirres(ndo, dp, ndo-&gt;ndo_vflag))\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_FSSTAT:\n\t\tdp = parserep(ndo, rp, length);\n\t\tif (dp != NULL &amp;&amp; parsestatfs(ndo, dp, v3) != 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_FSINFO:\n\t\tdp = parserep(ndo, rp, length);\n\t\tif (dp != NULL &amp;&amp; parsefsinfo(ndo, dp) != 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_PATHCONF:\n\t\tdp = parserep(ndo, rp, length);\n\t\tif (dp != NULL &amp;&amp; parsepathconf(ndo, dp) != 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_COMMIT:\n\t\tdp = parserep(ndo, rp, length);\n\t\tif (dp != NULL &amp;&amp; parsewccres(ndo, dp, ndo-&gt;ndo_vflag) != 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\ntrunc:\n\tif (!nfserr)\n\t\tND_PRINT((ndo, "%s", tstr));\n}',
 'TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size &lt;= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret-&gt;size = size;\n  return ret;\n}',
 'TEST_F(QuantizedConv2DTest, OddPadding) {\n  const int stride = 2;\n  TF_ASSERT_OK(NodeDefBuilder("quantized_conv_op", "QuantizedConv2D")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr("out_type", DataTypeToEnum&lt;qint32&gt;::v())\n                   .Attr("strides", {1, stride, stride, 1})\n                   .Attr("padding", "SAME")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n\n  const int depth = 1;\n  const int image_width = 4;\n  const int image_height = 4;\n  const int image_batch_count = 1;\n  AddInputFromArray&lt;quint8&gt;(\n      TensorShape({image_batch_count, image_height, image_width, depth}),\n      {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16});\n  const int filter_size = 3;\n  const int filter_count = 1;\n  AddInputFromArray&lt;quint8&gt;(\n      TensorShape({filter_size, filter_size, depth, filter_count}),\n      {1, 2, 3, 4, 5, 6, 7, 8, 9});\n  AddInputFromArray&lt;float&gt;(TensorShape({1}), {0});\n  AddInputFromArray&lt;float&gt;(TensorShape({1}), {255.0f});\n  AddInputFromArray&lt;float&gt;(TensorShape({1}), {0});\n  AddInputFromArray&lt;float&gt;(TensorShape({1}), {255.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  const int expected_width = image_width / stride;\n  const int expected_height = (image_height * filter_count) / stride;\n  Tensor expected(DT_QINT32, TensorShape({image_batch_count, expected_height,\n                                          expected_width, filter_count}));\n  test::FillValues&lt;qint32&gt;(&amp;expected, {348, 252, 274, 175});\n  test::ExpectTensorEqual&lt;qint32&gt;(expected, *GetOutput(0));\n}',
 'latin_ptr2len(char_u *p)\n{\n    return *p == NUL ? 0 : 1;\n}',
 'static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n\n    /* Dig for more from OpenSSL error queue */\n    SSLLogErrors(action, ret, err, len, ssock);\n\n    ssock-&gt;last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}',
 'int ssl3_get_cert_verify(SSL *s)\n\t{\n\tEVP_PKEY *pkey=NULL;\n\tunsigned char *p;\n\tint al,ok,ret=0;\n\tlong n;\n\tint type=0,i,j;\n\tX509 *peer;\n\tconst EVP_MD *md = NULL;\n\tEVP_MD_CTX mctx;\n\tEVP_MD_CTX_init(&amp;mctx);\n\n\tn=s-&gt;method-&gt;ssl_get_message(s,\n\t\tSSL3_ST_SR_CERT_VRFY_A,\n\t\tSSL3_ST_SR_CERT_VRFY_B,\n\t\t-1,\n\t\tSSL3_RT_MAX_PLAIN_LENGTH,\n\t\t&amp;ok);\n\n\tif (!ok) return((int)n);\n\n\tif (s-&gt;session-&gt;peer != NULL)\n\t\t{\n\t\tpeer=s-&gt;session-&gt;peer;\n\t\tpkey=X509_get_pubkey(peer);\n\t\ttype=X509_certificate_type(peer,pkey);\n\t\t}\n\telse\n\t\t{\n\t\tpeer=NULL;\n\t\tpkey=NULL;\n\t\t}\n\n\tif (s-&gt;s3-&gt;tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\n\t\t{\n\t\ts-&gt;s3-&gt;tmp.reuse_message=1;\n\t\tif ((peer != NULL) &amp;&amp; (type &amp; EVP_PKT_SIGN))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tret=1;\n\t\tgoto end;\n\t\t}\n\n\tif (peer == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\tif (!(type &amp; EVP_PKT_SIGN))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tgoto f_err;\n\t\t}\n\n\tif (s-&gt;s3-&gt;change_cipher_spec)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\t/* we now have a signature that we need to verify */\n\tp=(unsigned char *)s-&gt;init_msg;\n\t/* Check for broken implementations of GOST ciphersuites */\n\t/* If key is GOST and n is exactly 64, it is bare\n\t * signature without length field */\n\tif (n==64 &amp;&amp; (pkey-&gt;type==NID_id_GostR3410_94 ||\n\t\tpkey-&gt;type == NID_id_GostR3410_2001) )\n\t\t{\n\t\ti=64;\n\t\t} \n\telse \n\t\t{\t\n\t\tif (SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint rv = tls12_check_peer_sigalg(&amp;md, s, p, pkey);\n\t\t\tif (rv == -1)\n\t\t\t\t{\n\t\t\t\tal = SSL_AD_INTERNAL_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\telse if (rv == 0)\n\t\t\t\t{\n\t\t\t\tal = SSL_AD_DECODE_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, "USING TLSv1.2 HASH %s\\n", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tif (i &gt; n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n    \t}\n\tj=EVP_PKEY_size(pkey);\n\tif ((i &gt; j) || (n &gt; j) || (n &lt;= 0))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tgoto f_err;\n\t\t}\n\n\tif (SSL_USE_SIGALGS(s))\n\t\t{\n\t\tlong hdatalen = 0;\n\t\tvoid *hdata;\n\t\thdatalen = BIO_get_mem_data(s-&gt;s3-&gt;handshake_buffer, &amp;hdata);\n\t\tif (hdatalen &lt;= 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n#ifdef SSL_DEBUG\n\t\tfprintf(stderr, "Using TLS 1.2 with client verify alg %s\\n",\n\t\t\t\t\t\t\tEVP_MD_name(md));\n#endif\n\t\tif (!EVP_VerifyInit_ex(&amp;mctx, md, NULL)\n\t\t\t|| !EVP_VerifyUpdate(&amp;mctx, hdata, hdatalen))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (EVP_VerifyFinal(&amp;mctx, p , i, pkey) &lt;= 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#ifndef OPENSSL_NO_RSA \n\tif (pkey-&gt;type == EVP_PKEY_RSA)\n\t\t{\n\t\ti=RSA_verify(NID_md5_sha1, s-&gt;s3-&gt;tmp.cert_verify_md,\n\t\t\tMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, \n\t\t\t\t\t\t\tpkey-&gt;pkey.rsa);\n\t\tif (i &lt; 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tif (pkey-&gt;type == EVP_PKEY_DSA)\n\t\t{\n\t\tj=DSA_verify(pkey-&gt;save_type,\n\t\t\t&amp;(s-&gt;s3-&gt;tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey-&gt;pkey.dsa);\n\t\tif (j &lt;= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tif (pkey-&gt;type == EVP_PKEY_EC)\n\t\t{\n\t\tj=ECDSA_verify(pkey-&gt;save_type,\n\t\t\t&amp;(s-&gt;s3-&gt;tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey-&gt;pkey.ec);\n\t\tif (j &lt;= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t    SSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n\tif (pkey-&gt;type == NID_id_GostR3410_94 || pkey-&gt;type == NID_id_GostR3410_2001)\n\t\t{   unsigned char signature[64];\n\t\t\tint idx;\n\t\t\tEVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);\n\t\t\tEVP_PKEY_verify_init(pctx);\n\t\t\tif (i!=64) {\n\t\t\t\tfprintf(stderr,"GOST signature length is %d",i);\n\t\t\t}\t\n\t\t\tfor (idx=0;idx&lt;64;idx++) {\n\t\t\t\tsignature[63-idx]=p[idx];\n\t\t\t}\t\n\t\t\tj=EVP_PKEY_verify(pctx,signature,64,s-&gt;s3-&gt;tmp.cert_verify_md,32);\n\t\t\tEVP_PKEY_CTX_free(pctx);\n\t\t\tif (j&lt;=0) \n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t\t\tSSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\t\n\t\t}\n\telse\t\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\tal=SSL_AD_UNSUPPORTED_CERTIFICATE;\n\t\tgoto f_err;\n\t\t}\n\n\n\tret=1;\n\tif (0)\n\t\t{\nf_err:\n\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\t\t}\nend:\n\tif (s-&gt;s3-&gt;handshake_buffer)\n\t\t{\n\t\tBIO_free(s-&gt;s3-&gt;handshake_buffer);\n\t\ts-&gt;s3-&gt;handshake_buffer = NULL;\n\t\ts-&gt;s3-&gt;flags &amp;= ~TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t}\n\tEVP_MD_CTX_cleanup(&amp;mctx);\n\tEVP_PKEY_free(pkey);\n\treturn(ret);\n\t}',
 "static int DefragTrackerReuseTest(void)\n{\n    int ret = 0;\n    int id = 1;\n    Packet *p1 = NULL;\n    DefragTracker *tracker1 = NULL, *tracker2 = NULL;\n\n    DefragInit();\n\n    /* Build a packet, its not a fragment but shouldn't matter for\n     * this test. */\n    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n    if (p1 == NULL) {\n        goto end;\n    }\n\n    /* Get a tracker. It shouldn't look like its already in use. */\n    tracker1 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker1 == NULL) {\n        goto end;\n    }\n    if (tracker1-&gt;seen_last) {\n        goto end;\n    }\n    if (tracker1-&gt;remove) {\n        goto end;\n    }\n    DefragTrackerRelease(tracker1);\n\n    /* Get a tracker again, it should be the same one. */\n    tracker2 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker2 == NULL) {\n        goto end;\n    }\n    if (tracker2 != tracker1) {\n        goto end;\n    }\n    DefragTrackerRelease(tracker1);\n\n    /* Now mark the tracker for removal. It should not be returned\n     * when we get a tracker for a packet that may have the same\n     * attributes. */\n    tracker1-&gt;remove = 1;\n\n    tracker2 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker2 == NULL) {\n        goto end;\n    }\n    if (tracker2 == tracker1) {\n        goto end;\n    }\n    if (tracker2-&gt;remove) {\n        goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    DefragDestroy();\n    return ret;\n}",
 'static int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)\n{\n    uint16_t option_number = *dst;\n\n    if (option_number == 13) {\n        uint8_t option_ext;\n        int8_t read_result = sn_coap_parser_read_packet_u8(&amp;option_ext,\n                                                            *packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len);\n        if (read_result != 0) {\n            /* packet_data_pptr would overflow! */\n            tr_error("sn_coap_parser_options_parse - **packet_data_pptr overflow !");\n            return -1;\n        }\n        else {\n                option_number += option_ext;\n                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                               packet_data_start_ptr,\n                                                               packet_len,\n                                                               1);\n        }\n    } else if (option_number == 14) {\n            int8_t read_result = sn_coap_parser_read_packet_u16(&amp;option_number,\n                                                                *packet_data_pptr,\n                                                                packet_data_start_ptr,\n                                                                packet_len);\n            if (read_result != 0) {\n                /* packet_data_pptr would overflow! */\n                tr_error("sn_coap_parser_options_parse - **packet_data_pptr overflow !");\n                return -1;\n            }\n            else {\n            option_number += 269;\n            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                           packet_data_start_ptr,\n                                                           packet_len,\n                                                           2);\n            }\n    }\n    /* Option number 15 reserved for payload marker. This is handled as a error! */\n    else if (option_number == 15) {\n        tr_error("sn_coap_parser_options_parse - invalid option number(15)!");\n        return -1;\n    }\n\n    *dst = option_number;\n    return 0;\n}',
 'process_db_args(krb5_context context, char **db_args, xargs_t *xargs,\n                OPERATION optype)\n{\n    int                   i=0;\n    krb5_error_code       st=0;\n    char                  *arg=NULL, *arg_val=NULL;\n    char                  **dptr=NULL;\n    unsigned int          arg_val_len=0;\n\n    if (db_args) {\n        for (i=0; db_args[i]; ++i) {\n            arg = strtok_r(db_args[i], "=", &amp;arg_val);\n            arg = (arg != NULL) ? arg : "";\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                dptr = &amp;xargs-&gt;tktpolicydn;\n            } else {\n                if (strcmp(arg, USERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs-&gt;dn != NULL || xargs-&gt;containerdn != NULL ||\n                        xargs-&gt;linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _("%s option not supported"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &amp;xargs-&gt;dn;\n                } else if (strcmp(arg, CONTAINERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs-&gt;dn != NULL || xargs-&gt;containerdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _("%s option not supported"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &amp;xargs-&gt;containerdn;\n                } else if (strcmp(arg, LINKDN_ARG) == 0) {\n                    if (xargs-&gt;dn != NULL || xargs-&gt;linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _("%s option not supported"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &amp;xargs-&gt;linkdn;\n                } else {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _("unknown option: %s"), arg);\n                    goto cleanup;\n                }\n\n                xargs-&gt;dn_from_kbd = TRUE;\n                if (arg_val == NULL || strlen(arg_val) == 0) {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _("%s option value missing"), arg);\n                    goto cleanup;\n                }\n            }\n\n            if (arg_val == NULL) {\n                st = EINVAL;\n                k5_setmsg(context, st, _("%s option value missing"), arg);\n                goto cleanup;\n            }\n            arg_val_len = strlen(arg_val) + 1;\n\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                if ((st = krb5_ldap_name_to_policydn (context,\n                                                      arg_val,\n                                                      dptr)) != 0)\n                    goto cleanup;\n            } else {\n                *dptr = k5memdup(arg_val, arg_val_len, &amp;st);\n                if (*dptr == NULL)\n                    goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    return st;\n}',
 'static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r-&gt;req.dev);\n\n    if (!r-&gt;iov.iov_base) {\n        r-&gt;buflen = SCSI_DMA_BUF_SIZE;\n        r-&gt;iov.iov_base = qemu_blockalign(s-&gt;bs, r-&gt;buflen);\n    }\n    r-&gt;iov.iov_len = MIN(r-&gt;sector_count * 512, r-&gt;buflen);\n    qemu_iovec_init_external(&amp;r-&gt;qiov, &amp;r-&gt;iov, 1);\n    return r-&gt;qiov.size / 512;\n}',
 '    void readBytes(void* data, int length) {\n      U8* dataPtr = (U8*)data;\n      U8* dataEnd = dataPtr + length;\n      while (dataPtr &lt; dataEnd) {\n        int n = check(1, dataEnd - dataPtr);\n        memcpy(dataPtr, ptr, n);\n        ptr += n;\n        dataPtr += n;\n      }\n    }',
 "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\n\tunix_remove_socket(sk);\n\n\t/* Clear state */\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk-&gt;sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u-&gt;path;\n\tu-&gt;path.dentry = NULL;\n\tu-&gt;path.mnt = NULL;\n\tstate = sk-&gt;sk_state;\n\tsk-&gt;sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\n\twake_up_interruptible_all(&amp;u-&gt;peer_wait);\n\n\tskpair = unix_peer(sk);\n\n\tif (skpair != NULL) {\n\t\tif (sk-&gt;sk_type == SOCK_STREAM || sk-&gt;sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\t/* No more writes */\n\t\t\tskpair-&gt;sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&amp;sk-&gt;sk_receive_queue) || embrion)\n\t\t\t\tskpair-&gt;sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair-&gt;sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); /* It may now die */\n\t\tunix_peer(sk) = NULL;\n\t}\n\n\t/* Try to flush out this socket. Throw out buffers at least */\n\n\twhile ((skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb-&gt;sk, 1);\n\t\t/* passed fds are erased in the kfree_skb hook\t      */\n\t\tUNIXCB(skb).consumed = skb-&gt;len;\n\t\tkfree_skb(skb);\n\t}\n\n\tif (path.dentry)\n\t\tpath_put(&amp;path);\n\n\tsock_put(sk);\n\n\t/* ---- Socket is dead now and most probably destroyed ---- */\n\n\t/*\n\t * Fixme: BSD difference: In BSD all sockets connected to us get\n\t *\t  ECONNRESET and we die on the spot. In Linux we behave\n\t *\t  like files and pipes do and wait for the last\n\t *\t  dereference.\n\t *\n\t * Can't we simply set sock-&gt;err?\n\t *\n\t *\t  What the above comment does talk about? --ANK(980817)\n\t */\n\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t/* Garbage collect fds */\n}",
 'static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev-&gt;hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev-&gt;dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report-&gt;report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &amp;\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid("%s: device list is empty\\n", __func__);\n\t\tdjrcv_dev-&gt;querying_devices = false;\n\t\treturn;\n\t}\n\n\tif ((dj_report-&gt;device_index &lt; DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report-&gt;device_index &gt; DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&amp;djrcv_hdev-&gt;dev, "%s: invalid device index:%d\\n",\n\t\t\t__func__, dj_report-&gt;device_index);\n\t\treturn;\n\t}\n\n\tif (djrcv_dev-&gt;paired_dj_devices[dj_report-&gt;device_index]) {\n\t\t/* The device is already known. No need to reallocate it. */\n\t\tdbg_hid("%s: device is already known\\n", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&amp;djrcv_hdev-&gt;dev, "%s: hid_allocate_device failed\\n",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev-&gt;ll_driver = &amp;logi_dj_ll_driver;\n\n\tdj_hiddev-&gt;dev.parent = &amp;djrcv_hdev-&gt;dev;\n\tdj_hiddev-&gt;bus = BUS_USB;\n\tdj_hiddev-&gt;vendor = le16_to_cpu(usbdev-&gt;descriptor.idVendor);\n\tdj_hiddev-&gt;product = le16_to_cpu(usbdev-&gt;descriptor.idProduct);\n\tsnprintf(dj_hiddev-&gt;name, sizeof(dj_hiddev-&gt;name),\n\t\t"Logitech Unifying Device. Wireless PID:%02x%02x",\n\t\tdj_report-&gt;report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report-&gt;report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev-&gt;phys, sizeof(dj_hiddev-&gt;phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), ":%d", dj_report-&gt;device_index);\n\tstrlcat(dj_hiddev-&gt;phys, tmpstr, sizeof(dj_hiddev-&gt;phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&amp;djrcv_hdev-&gt;dev, "%s: failed allocating dj_device\\n",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev-&gt;reports_supported = get_unaligned_le32(\n\t\tdj_report-&gt;report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev-&gt;hdev = dj_hiddev;\n\tdj_dev-&gt;dj_receiver_dev = djrcv_dev;\n\tdj_dev-&gt;device_index = dj_report-&gt;device_index;\n\tdj_hiddev-&gt;driver_data = dj_dev;\n\n\tdjrcv_dev-&gt;paired_dj_devices[dj_report-&gt;device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&amp;djrcv_hdev-&gt;dev, "%s: failed adding dj_device\\n",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev-&gt;paired_dj_devices[dj_report-&gt;device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}',
 'Ta3AST_FromNodeObject(const node *n, PyCompilerFlags *flags,\n                      PyObject *filename, int feature_version,\n                      PyArena *arena)\n{\n    int i, j, k, num;\n    asdl_seq *stmts = NULL;\n    asdl_seq *type_ignores = NULL;\n    stmt_ty s;\n    node *ch;\n    struct compiling c;\n    mod_ty res = NULL;\n    asdl_seq *argtypes = NULL;\n    expr_ty ret, arg;\n\n    c.c_arena = arena;\n    /* borrowed reference */\n    c.c_filename = filename;\n    c.c_normalize = NULL;\n    c.c_feature_version = feature_version;\n\n    if (TYPE(n) == encoding_decl)\n        n = CHILD(n, 0);\n\n    k = 0;\n    switch (TYPE(n)) {\n        case file_input:\n            stmts = _Ta3_asdl_seq_new(num_stmts(n), arena);\n            if (!stmts)\n                goto out;\n            for (i = 0; i &lt; NCH(n) - 1; i++) {\n                ch = CHILD(n, i);\n                if (TYPE(ch) == NEWLINE)\n                    continue;\n                REQ(ch, stmt);\n                num = num_stmts(ch);\n                if (num == 1) {\n                    s = ast_for_stmt(&amp;c, ch);\n                    if (!s)\n                        goto out;\n                    asdl_seq_SET(stmts, k++, s);\n                }\n                else {\n                    ch = CHILD(ch, 0);\n                    REQ(ch, simple_stmt);\n                    for (j = 0; j &lt; num; j++) {\n                        s = ast_for_stmt(&amp;c, CHILD(ch, j * 2));\n                        if (!s)\n                            goto out;\n                        asdl_seq_SET(stmts, k++, s);\n                    }\n                }\n            }\n\n            /* Type ignores are stored under the ENDMARKER in file_input. */\n            ch = CHILD(n, NCH(n) - 1);\n            REQ(ch, ENDMARKER);\n            num = NCH(ch);\n            type_ignores = _Ta3_asdl_seq_new(num, arena);\n            if (!type_ignores)\n                goto out;\n\n            for (i = 0; i &lt; num; i++) {\n                type_ignore_ty ti = TypeIgnore(LINENO(CHILD(ch, i)), arena);\n                if (!ti)\n                   goto out;\n               asdl_seq_SET(type_ignores, i, ti);\n            }\n\n            res = Module(stmts, type_ignores, arena);\n            break;\n        case eval_input: {\n            expr_ty testlist_ast;\n\n            /* XXX Why not comp_for here? */\n            testlist_ast = ast_for_testlist(&amp;c, CHILD(n, 0));\n            if (!testlist_ast)\n                goto out;\n            res = Expression(testlist_ast, arena);\n            break;\n        }\n        case single_input:\n            if (TYPE(CHILD(n, 0)) == NEWLINE) {\n                stmts = _Ta3_asdl_seq_new(1, arena);\n                if (!stmts)\n                    goto out;\n                asdl_seq_SET(stmts, 0, Pass(n-&gt;n_lineno, n-&gt;n_col_offset,\n                                            arena));\n                if (!asdl_seq_GET(stmts, 0))\n                    goto out;\n                res = Interactive(stmts, arena);\n            }\n            else {\n                n = CHILD(n, 0);\n                num = num_stmts(n);\n                stmts = _Ta3_asdl_seq_new(num, arena);\n                if (!stmts)\n                    goto out;\n                if (num == 1) {\n                    s = ast_for_stmt(&amp;c, n);\n                    if (!s)\n                        goto out;\n                    asdl_seq_SET(stmts, 0, s);\n                }\n                else {\n                    /* Only a simple_stmt can contain multiple statements. */\n                    REQ(n, simple_stmt);\n                    for (i = 0; i &lt; NCH(n); i += 2) {\n                        if (TYPE(CHILD(n, i)) == NEWLINE)\n                            break;\n                        s = ast_for_stmt(&amp;c, CHILD(n, i));\n                        if (!s)\n                            goto out;\n                        asdl_seq_SET(stmts, i / 2, s);\n                    }\n                }\n\n                res = Interactive(stmts, arena);\n            }\n            break;\n        case func_type_input:\n            n = CHILD(n, 0);\n            REQ(n, func_type);\n\n            if (TYPE(CHILD(n, 1)) == typelist) {\n                ch = CHILD(n, 1);\n                /* this is overly permissive -- we don\'t pay any attention to\n                 * stars on the args -- just parse them into an ordered list */\n                num = 0;\n                for (i = 0; i &lt; NCH(ch); i++) {\n                    if (TYPE(CHILD(ch, i)) == test)\n                        num++;\n                }\n\n                argtypes = _Ta3_asdl_seq_new(num, arena);\n\n                j = 0;\n                for (i = 0; i &lt; NCH(ch); i++) {\n                    if (TYPE(CHILD(ch, i)) == test) {\n                        arg = ast_for_expr(&amp;c, CHILD(ch, i));\n                        if (!arg)\n                            goto out;\n                        asdl_seq_SET(argtypes, j++, arg);\n                    }\n                }\n            }\n            else\n                argtypes = _Ta3_asdl_seq_new(0, arena);\n\n            ret = ast_for_expr(&amp;c, CHILD(n, NCH(n) - 1));\n            if (!ret)\n                goto out;\n            res = FunctionType(argtypes, ret, arena);\n            break;\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         "invalid node %d for Ta3AST_FromNode", TYPE(n));\n            goto out;\n    }\n out:\n    if (c.c_normalize) {\n        Py_DECREF(c.c_normalize);\n    }\n    return res;\n}',
 'Status OpLevelCostEstimator::PredictCropAndResize(const OpContext&amp; op_context,\n                                                  NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n\n  const auto method = op_context.op_info.attr().find("method");\n  bool use_bilinear_interp;\n  if (method == op_context.op_info.attr().end() ||\n      method-&gt;second.s() == "bilinear") {\n    use_bilinear_interp = true;\n  } else if (method-&gt;second.s() == "nearest") {\n    use_bilinear_interp = false;\n  } else {\n    LOG(WARNING) &lt;&lt; "method attr in CropAndResize invalid; expected bilinear "\n                    "or nearest.";\n    return PredictCostOfAnUnknownOp(op_context, node_costs);\n  }\n\n  const int64_t num_boxes = op_context.op_info.inputs(1).shape().dim(0).size();\n  const auto crop_shape = MaybeGetMinimumShape(\n      op_context.op_info.outputs(0).shape(), 4, &amp;found_unknown_shapes);\n  const int64_t crop_height = crop_shape.dim(1).size();\n  const int64_t crop_width = crop_shape.dim(2).size();\n  const int64_t output_elements = CalculateTensorElementCount(\n      op_context.op_info.outputs(0), &amp;found_unknown_shapes);\n\n#define EIGEN_COST(X) Eigen::internal::functor_traits&lt;Eigen::internal::X&gt;::Cost\n  const auto sub_cost = EIGEN_COST(scalar_difference_op&lt;float&gt;);\n  const auto add_cost = EIGEN_COST(scalar_sum_op&lt;float&gt;);\n  const auto mul_cost = EIGEN_COST(scalar_product_op&lt;float&gt;);\n  auto div_cost = EIGEN_COST(scalar_div_cost&lt;float&gt;);\n  const auto floor_cost = EIGEN_COST(scalar_floor_op&lt;float&gt;);\n  const auto ceil_cost = EIGEN_COST(scalar_ceil_op&lt;float&gt;);\n  auto round_cost = EIGEN_COST(scalar_round_op&lt;float&gt;);\n  const auto cast_to_float_cost = Eigen::internal::functor_traits&lt;\n      Eigen::internal::scalar_cast_op&lt;int64_t, float&gt;&gt;::Cost;\n#undef EIGEN_COST\n\n  // Computing ops following\n  // tensorflow/core/kernels/image/crop_and_resize_op.cc at 08/25/2020. Op\n  // calculation differs from rough estimate in implementation, as it separates\n  // out cost per box from cost per pixel and cost per element.\n\n  // Ops for variables height_scale and width_scale.\n  int64_t ops = (sub_cost * 6 + mul_cost * 2 + div_cost * 2) * num_boxes;\n  // Ops for variable in_y.\n  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * num_boxes;\n  // Ops for variable in_x (same computation across both branches).\n  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * crop_width *\n         num_boxes;\n  // Specify op_cost based on the method.\n  if (use_bilinear_interp) {\n    // Ops for variables top_y_index, bottom_y_index, y_lerp.\n    ops += (floor_cost + ceil_cost + sub_cost) * crop_height * num_boxes;\n    // Ops for variables left_x, right_x, x_lerp;\n    ops += (floor_cost + ceil_cost + sub_cost) * crop_height * crop_width *\n           num_boxes;\n    // Ops for innermost loop across depth.\n    ops +=\n        (cast_to_float_cost * 4 + add_cost * 3 + sub_cost * 3 + mul_cost * 3) *\n        output_elements;\n  } else /* method == "nearest" */ {\n    // Ops for variables closest_x_index and closest_y_index.\n    ops += round_cost * 2 * crop_height * crop_width * num_boxes;\n    // Ops for innermost loop across depth.\n    ops += cast_to_float_cost * output_elements;\n  }\n  return PredictDefaultNodeCosts(ops, op_context, &amp;found_unknown_shapes,\n                                 node_costs);\n}',
 "reg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp-&gt;w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp-&gt;w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp-&gt;w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp-&gt;w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf-&gt;b_visual.vi_start, curbuf-&gt;b_visual.vi_end))\n\t{\n\t    top = curbuf-&gt;b_visual.vi_start;\n\t    bot = curbuf-&gt;b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf-&gt;b_visual.vi_end;\n\t    bot = curbuf-&gt;b_visual.vi_start;\n\t}\n\tmode = curbuf-&gt;b_visual.vi_mode;\n\tcurswant = curbuf-&gt;b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum &lt; top.lnum || lnum &gt; bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum &amp;&amp; col &lt; top.col)\n\t\t|| (lnum == bot.lnum &amp;&amp; col &gt;= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &amp;top, &amp;start, NULL, &amp;end);\n\tgetvvcol(wp, &amp;bot, &amp;start2, NULL, &amp;end2);\n\tif (start2 &lt; start)\n\t    start = start2;\n\tif (end2 &gt; end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t// getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.line, col);\n\tif (cols &lt; start || cols &gt; end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}",
 'static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev-&gt;hdev;\n\tu8 *buf = dev-&gt;in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&amp;dev-&gt;lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, "error requesting GPIO config: %d\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &amp;= ~(1 &lt;&lt; offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret &lt; 0) {\n\t\thid_err(hdev, "error setting GPIO config: %d\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tmutex_unlock(&amp;dev-&gt;lock);\n\treturn ret &lt;= 0 ? ret : -EIO;\n}',
 'char* oidc_util_javascript_escape(apr_pool_t *pool, const char *s) {\n    const char *cp;\n    char *output;\n    size_t outputlen;\n    int i;\n\n    if (s == NULL) {\n        return NULL;\n    }\n\n    outputlen = 0;\n    for (cp = s; *cp; cp++) {\n        switch (*cp) {\n        case \'\\\'\':\n        case \'"\':\n        case \'\\\\\':\n        case \'/\':\n        case 0x0D:\n        case 0x0A:\n            outputlen += 2;\n            break;\n        case \'&lt;\':\n        case \'&gt;\':\n            outputlen += 4;\n            break;\n        default:\n            outputlen += 1;\n            break;\n        }\n    }\n\n    i = 0;\n    output = apr_palloc(pool, outputlen + 1);\n    for (cp = s; *cp; cp++) {\n        switch (*cp) {\n        case \'\\\'\':\n            (void)strcpy(&amp;output[i], "\\\\\'");\n            i += 2;\n            break;\n        case \'"\':\n            (void)strcpy(&amp;output[i], "\\\\\\"");\n            i += 2;\n            break;\n        case \'\\\\\':\n            (void)strcpy(&amp;output[i], "\\\\\\\\");\n            i += 2;\n            break;\n        case \'/\':\n            (void)strcpy(&amp;output[i], "\\\\/");\n            i += 2;\n            break;\n        case 0x0D:\n            (void)strcpy(&amp;output[i], "\\\\r");\n            i += 2;\n            break;\n        case 0x0A:\n            (void)strcpy(&amp;output[i], "\\\\n");\n            i += 2;\n            break;\n        case \'&lt;\':\n            (void)strcpy(&amp;output[i], "\\\\x3c");\n            i += 4;\n            break;\n        case \'&gt;\':\n            (void)strcpy(&amp;output[i], "\\\\x3e");\n            i += 4;\n            break;\n        default:\n            output[i] = *cp;\n            i += 1;\n            break;\n        }\n    }\n    output[i] = \'\\0\';\n    return output;\n}',
 'int __cil_resolve_ast_node_helper(struct cil_tree_node *node, uint32_t *finished, void *extra_args)\n{\n\tint rc = SEPOL_OK;\n\tstruct cil_args_resolve *args = extra_args;\n\tenum cil_pass pass = args-&gt;pass;\n\tstruct cil_tree_node *block = args-&gt;block;\n\tstruct cil_tree_node *macro = args-&gt;macro;\n\tstruct cil_tree_node *optional = args-&gt;optional;\n\tstruct cil_tree_node *boolif = args-&gt;boolif;\n\n\tif (node == NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (block != NULL) {\n\t\tif (node-&gt;flavor == CIL_CAT ||\n\t\t    node-&gt;flavor == CIL_SENS) {\n\t\t\tcil_tree_log(node, CIL_ERR, "%s statement is not allowed in blocks", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (macro != NULL) {\n\t\tif (node-&gt;flavor == CIL_BLOCK ||\n\t\t    node-&gt;flavor == CIL_BLOCKINHERIT ||\n\t\t    node-&gt;flavor == CIL_BLOCKABSTRACT ||\n\t\t    node-&gt;flavor == CIL_MACRO) {\n\t\t\tcil_tree_log(node, CIL_ERR, "%s statement is not allowed in macros", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (optional != NULL) {\n\t\tif (node-&gt;flavor == CIL_TUNABLE ||\n\t\t\tnode-&gt;flavor == CIL_IN ||\n\t\t\tnode-&gt;flavor == CIL_BLOCK ||\n\t\t\tnode-&gt;flavor == CIL_BLOCKABSTRACT ||\n\t\t    node-&gt;flavor == CIL_MACRO) {\n\t\t\tcil_tree_log(node, CIL_ERR, "%s statement is not allowed in optionals", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (boolif != NULL) {\n\t\tif (node-&gt;flavor != CIL_TUNABLEIF &amp;&amp;\n\t\t\tnode-&gt;flavor != CIL_CALL &amp;&amp;\n\t\t\tnode-&gt;flavor != CIL_CONDBLOCK &amp;&amp;\n\t\t\tnode-&gt;flavor != CIL_AVRULE &amp;&amp;\n\t\t\tnode-&gt;flavor != CIL_TYPE_RULE &amp;&amp;\n\t\t\tnode-&gt;flavor != CIL_NAMETYPETRANSITION) {\n\t\t\trc = SEPOL_ERR;\n\t\t} else if (node-&gt;flavor == CIL_AVRULE) {\n\t\t\tstruct cil_avrule *rule = node-&gt;data;\n\t\t\tif (rule-&gt;rule_kind == CIL_AVRULE_NEVERALLOW) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t\tif (rc == SEPOL_ERR) {\n\t\t\tif (((struct cil_booleanif*)boolif-&gt;data)-&gt;preserved_tunable) {\n\t\t\t\tcil_tree_log(node, CIL_ERR, "%s statement is not allowed in booleanifs (tunableif treated as a booleanif)", cil_node_to_string(node));\n\t\t\t} else {\n\t\t\t\tcil_tree_log(node, CIL_ERR, "%s statement is not allowed in booleanifs", cil_node_to_string(node));\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (node-&gt;flavor == CIL_MACRO) {\n\t\tif (pass != CIL_PASS_TIF &amp;&amp; pass != CIL_PASS_MACRO) {\n\t\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\t\trc = SEPOL_OK;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (node-&gt;flavor == CIL_BLOCK &amp;&amp; ((((struct cil_block*)node-&gt;data)-&gt;is_abstract == CIL_TRUE) &amp;&amp; (pass &gt; CIL_PASS_BLKABS))) {\n\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\trc = __cil_resolve_ast_node(node, extra_args);\n\tif (rc == SEPOL_ENOENT) {\n\t\tenum cil_log_level lvl = CIL_ERR;\n\n\t\tif (optional != NULL) {\n\t\t\tlvl = CIL_INFO;\n\n\t\t\tstruct cil_optional *opt = (struct cil_optional *)optional-&gt;data;\n\t\t\tstruct cil_tree_node *opt_node = NODE(opt);;\n\t\t\t/* disable an optional if something failed to resolve */\n\t\t\topt-&gt;enabled = CIL_FALSE;\n\t\t\tcil_tree_log(node, lvl, "Failed to resolve %s statement", cil_node_to_string(node));\n\t\t\tcil_tree_log(opt_node, lvl, "Disabling optional \'%s\'", opt-&gt;datum.name);\n\t\t\trc = SEPOL_OK;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tcil_tree_log(node, lvl, "Failed to resolve %s statement", cil_node_to_string(node));\n\t\tgoto exit;\n\t}\n\n\treturn rc;\n\nexit:\n\treturn rc;\n}',
 'int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q-&gt;dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) &amp; align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) &amp; iov_iter_gap_alignment(iter);\n\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &amp;i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq-&gt;bio;\n\t} while (iov_iter_count(&amp;i));\n\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq-&gt;cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\nfail:\n\trq-&gt;bio = NULL;\n\treturn -EINVAL;\n}',
 'static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&amp;sk-&gt;sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags &amp; MSG_DONTWAIT), &amp;err);\n\t\tif (skb == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb-&gt;transport_header = skb-&gt;network_header + fragheaderlen;\n\n\t\tskb-&gt;ip_summed = CHECKSUM_PARTIAL;\n\t\tskb-&gt;csum = 0;\n\t}\n\n\terr = skb_append_datato_frags(sk,skb, getfrag, from,\n\t\t\t\t      (length - transhdrlen));\n\tif (!err) {\n\t\tstruct frag_hdr fhdr;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)-&gt;gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) &amp; ~7;\n\t\tskb_shinfo(skb)-&gt;gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&amp;fhdr, rt);\n\t\tskb_shinfo(skb)-&gt;ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&amp;sk-&gt;sk_write_queue, skb);\n\n\t\treturn 0;\n\t}\n\t/* There is not enough support do UPD LSO,\n\t * so follow normal path\n\t */\n\tkfree_skb(skb);\n\n\treturn err;\n}',
 'void jas_matrix_asl(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) &gt; 0 &amp;&amp; jas_matrix_numcols(matrix) &gt; 0) {\n\t\tassert(matrix-&gt;rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix-&gt;numrows_, rowstart = matrix-&gt;rows_[0]; i &gt; 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix-&gt;numcols_, data = rowstart; j &gt; 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data &lt;&lt;= n;\n\t\t\t\t*data = jas_seqent_asl(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}',
 'psf_allocate (void)\n{\tSF_PRIVATE * psf ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t\treturn\tNULL ;\n\n\tif ((psf-&gt;header.ptr = calloc (1, INITAL_HEADER_SIZE)) == NULL)\n\t{\tfree (psf) ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf-&gt;header.len = INITAL_HEADER_SIZE ;\n\n\treturn psf ;\n} /* psf_allocate */',
 "l_strnstart(netdissect_options *ndo, const char *tstr1, u_int tl1,\n    const char *str2, u_int l2)\n{\n\tif (!ND_TTEST2(*str2, tl1)) {\n\t\t/*\n\t\t * We don't have tl1 bytes worth of captured data\n\t\t * for the string, so we can't check for this\n\t\t * string.\n\t\t */\n\t\treturn 0;\n\t}\n\tif (tl1 &gt; l2)\n\t\treturn 0;\n\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}",
 'static void watchdog_overflow_callback(struct perf_event *event, int nmi,\n\t\t struct perf_sample_data *data,\n\t\t struct pt_regs *regs)\n{\n\t/* Ensure the watchdog never gets throttled */\n\tevent-&gt;hw.interrupts = 0;\n\n\tif (__this_cpu_read(watchdog_nmi_touch) == true) {\n\t\t__this_cpu_write(watchdog_nmi_touch, false);\n\t\treturn;\n\t}\n\n\t/* check for a hardlockup\n\t * This is done by making sure our timer interrupt\n\t * is incrementing.  The timer interrupt should have\n\t * fired multiple times before we overflow\'d.  If it hasn\'t\n\t * then this is a good indication the cpu is stuck\n\t */\n\tif (is_hardlockup()) {\n\t\tint this_cpu = smp_processor_id();\n\n\t\t/* only print hardlockups once */\n\t\tif (__this_cpu_read(hard_watchdog_warn) == true)\n\t\t\treturn;\n\n\t\tif (hardlockup_panic)\n\t\t\tpanic("Watchdog detected hard LOCKUP on cpu %d", this_cpu);\n\t\telse\n\t\t\tWARN(1, "Watchdog detected hard LOCKUP on cpu %d", this_cpu);\n\n\t\t__this_cpu_write(hard_watchdog_warn, true);\n\t\treturn;\n\t}\n\n\t__this_cpu_write(hard_watchdog_warn, false);\n\treturn;\n}',
 'static void mpeg4_encode_gop_header(MpegEncContext *s)\n{\n    int hours, minutes, seconds;\n    int64_t time;\n\n    put_bits(&amp;s-&gt;pb, 16, 0);\n    put_bits(&amp;s-&gt;pb, 16, GOP_STARTCODE);\n\n    time = s-&gt;current_picture_ptr-&gt;f-&gt;pts;\n    if (s-&gt;reordered_input_picture[1])\n        time = FFMIN(time, s-&gt;reordered_input_picture[1]-&gt;f-&gt;pts);\n    time = time * s-&gt;avctx-&gt;time_base.num;\n    s-&gt;last_time_base = FFUDIV(time, s-&gt;avctx-&gt;time_base.den);\n\n    seconds = FFUDIV(time, s-&gt;avctx-&gt;time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n\n    put_bits(&amp;s-&gt;pb, 5, hours);\n    put_bits(&amp;s-&gt;pb, 6, minutes);\n    put_bits(&amp;s-&gt;pb, 1, 1);\n    put_bits(&amp;s-&gt;pb, 6, seconds);\n\n    put_bits(&amp;s-&gt;pb, 1, !!(s-&gt;avctx-&gt;flags &amp; AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&amp;s-&gt;pb, 1, 0);  // broken link == NO\n\n    ff_mpeg4_stuffing(&amp;s-&gt;pb);\n}',
 'ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tce = mb_cache_entry_get(ext4_mb_cache, bh-&gt;b_bdev, bh-&gt;b_blocknr);\n\tBUFFER_TRACE(bh, "get_write_access");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\n\tlock_buffer(bh);\n\tif (BHDR(bh)-&gt;h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, "refcount now=0; freeing");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&amp;BHDR(bh)-&gt;h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\t/*\n\t\t * Beware of this ugliness: Releasing of xattr block references\n\t\t * from different inodes can race and so we have to protect\n\t\t * from a race where someone else frees the block (and releases\n\t\t * its journal_head) before we are done dirtying the buffer. In\n\t\t * nojournal mode this race is harmless and we actually cannot\n\t\t * call ext4_handle_dirty_xattr_block() with locked buffer as\n\t\t * that function can call sync_dirty_buffer() so for that case\n\t\t * we handle the dirtying after unlocking the buffer.\n\t\t */\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode-&gt;i_sb), 1));\n\t\tea_bdebug(bh, "refcount now=%d; releasing",\n\t\t\t  le32_to_cpu(BHDR(bh)-&gt;h_refcount));\n\t}\nout:\n\text4_std_error(inode-&gt;i_sb, error);\n\treturn;\n}',
 "TfLiteStatus CheckInputTensorDimensions(TfLiteContext* context,\n                                        TfLiteNode* node, int n_input,\n                                        int n_output, int n_cell,\n                                        bool is_layer_norm_lstm) {\n  const auto* params = reinterpret_cast&lt;TfLiteLSTMParams*&gt;(node-&gt;builtin_data);\n\n  // Making sure clipping parameters have valid values.\n  // == 0 means no clipping\n  //  &gt; 0 means clipping\n  TF_LITE_ENSURE(context, params-&gt;cell_clip &gt;= 0);\n  TF_LITE_ENSURE(context, params-&gt;proj_clip &gt;= 0);\n\n  const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kInputToInputWeightsTensor);\n  if (input_to_input_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights-&gt;dims-&gt;size, 2);\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights-&gt;dims-&gt;data[0], n_cell);\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights-&gt;dims-&gt;data[1], n_input);\n  }\n\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, lstm::full::kInputToForgetWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights-&gt;dims-&gt;size, 2);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights-&gt;dims-&gt;data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights-&gt;dims-&gt;data[1], n_input);\n\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, lstm::full::kInputToCellWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights-&gt;dims-&gt;size, 2);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights-&gt;dims-&gt;data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights-&gt;dims-&gt;data[1], n_input);\n\n  const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kRecurrentToInputWeightsTensor);\n  if (recurrent_to_input_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights-&gt;dims-&gt;size, 2);\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights-&gt;dims-&gt;data[0],\n                      n_cell);\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights-&gt;dims-&gt;data[1],\n                      n_output);\n  }\n\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, lstm::full::kRecurrentToForgetWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights-&gt;dims-&gt;size, 2);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights-&gt;dims-&gt;data[0],\n                    n_cell);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights-&gt;dims-&gt;data[1],\n                    n_output);\n\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, lstm::full::kRecurrentToCellWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights-&gt;dims-&gt;size, 2);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights-&gt;dims-&gt;data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights-&gt;dims-&gt;data[1],\n                    n_output);\n\n  // We make sure the input-gate's parameters are either both present (regular\n  // LSTM) or not at all (CIFG-LSTM).\n  const bool cifg_weights_all_or_none =\n      ((input_to_input_weights != nullptr) &amp;&amp;\n       (recurrent_to_input_weights != nullptr)) ||\n      ((input_to_input_weights == nullptr) &amp;&amp;\n       (recurrent_to_input_weights == nullptr));\n  TF_LITE_ENSURE(context, cifg_weights_all_or_none == true);\n\n  const TfLiteTensor* cell_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToInputWeightsTensor);\n  if (cell_to_input_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, cell_to_input_weights-&gt;dims-&gt;size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_input_weights-&gt;dims-&gt;data[0], n_cell);\n  }\n\n  const TfLiteTensor* cell_to_forget_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToForgetWeightsTensor);\n  if (cell_to_forget_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, cell_to_forget_weights-&gt;dims-&gt;size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_forget_weights-&gt;dims-&gt;data[0], n_cell);\n  }\n\n  const TfLiteTensor* cell_to_output_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToOutputWeightsTensor);\n  if (cell_to_output_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, cell_to_output_weights-&gt;dims-&gt;size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_output_weights-&gt;dims-&gt;data[0], n_cell);\n  }\n\n  // Making sure the peephole weights are there all or none.\n  const bool use_cifg = (input_to_input_weights == nullptr);\n  const bool peephole_weights_all_or_none =\n      ((cell_to_input_weights != nullptr || use_cifg) &amp;&amp;\n       (cell_to_forget_weights != nullptr) &amp;&amp;\n       (cell_to_output_weights != nullptr)) ||\n      ((cell_to_input_weights == nullptr) &amp;&amp;\n       (cell_to_forget_weights == nullptr) &amp;&amp;\n       (cell_to_output_weights == nullptr));\n  TF_LITE_ENSURE(context, peephole_weights_all_or_none == true);\n\n  // Make sure the input gate bias is present only when not a CIFG-LSTM.\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, lstm::full::kInputGateBiasTensor);\n  if (use_cifg) {\n    TF_LITE_ENSURE_EQ(context, input_gate_bias, nullptr);\n  } else {\n    TF_LITE_ENSURE_EQ(context, input_gate_bias-&gt;dims-&gt;size, 1);\n    TF_LITE_ENSURE_EQ(context, input_gate_bias-&gt;dims-&gt;data[0], n_cell);\n  }\n\n  const TfLiteTensor* forget_gate_bias =\n      GetInput(context, node, lstm::full::kForgetGateBiasTensor);\n  TF_LITE_ENSURE_EQ(context, forget_gate_bias-&gt;dims-&gt;size, 1);\n  TF_LITE_ENSURE_EQ(context, forget_gate_bias-&gt;dims-&gt;data[0], n_cell);\n\n  const TfLiteTensor* cell_gate_bias =\n      GetInput(context, node, lstm::full::kCellGateBiasTensor);\n  TF_LITE_ENSURE_EQ(context, cell_gate_bias-&gt;dims-&gt;size, 1);\n  TF_LITE_ENSURE_EQ(context, cell_gate_bias-&gt;dims-&gt;data[0], n_cell);\n\n  const TfLiteTensor* output_gate_bias =\n      GetInput(context, node, lstm::full::kOutputGateBiasTensor);\n  TF_LITE_ENSURE_EQ(context, output_gate_bias-&gt;dims-&gt;size, 1);\n  TF_LITE_ENSURE_EQ(context, output_gate_bias-&gt;dims-&gt;data[0], n_cell);\n\n  const TfLiteTensor* projection_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kProjectionWeightsTensor);\n  if (projection_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, projection_weights-&gt;dims-&gt;size, 2);\n    TF_LITE_ENSURE_EQ(context, projection_weights-&gt;dims-&gt;data[0], n_output);\n    TF_LITE_ENSURE_EQ(context, projection_weights-&gt;dims-&gt;data[1], n_cell);\n  }\n\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, lstm::full::kProjectionBiasTensor);\n  if (projection_bias != nullptr) {\n    TF_LITE_ENSURE_EQ(context, projection_bias-&gt;dims-&gt;size, 1);\n    TF_LITE_ENSURE_EQ(context, projection_bias-&gt;dims-&gt;data[0], n_output);\n  }\n\n  // Making sure the projection tensors are consistent:\n  // 1) If projection weight is not present, then projection bias should not be\n  // present.\n  // 2) If projection weight is present, then projection bias is optional.\n  // TODO(ghodrat): make sure this is correct.\n  const bool projecton_tensors_consistent =\n      ((projection_weights != nullptr) || (projection_bias == nullptr));\n  TF_LITE_ENSURE(context, projecton_tensors_consistent == true);\n\n  if (is_layer_norm_lstm) {\n    const TfLiteTensor* input_layer_norm_coefficients = GetOptionalInputTensor(\n        context, node, lstm::full::kInputLayerNormCoefficientsTensor);\n    if (use_cifg) {\n      TF_LITE_ENSURE_EQ(context, input_layer_norm_coefficients, nullptr);\n    } else {\n      TF_LITE_ENSURE(context, input_layer_norm_coefficients != nullptr);\n      TF_LITE_ENSURE_EQ(context, input_layer_norm_coefficients-&gt;dims-&gt;size, 1);\n      TF_LITE_ENSURE_EQ(context, input_layer_norm_coefficients-&gt;dims-&gt;data[0],\n                        n_cell);\n      TF_LITE_ENSURE_TYPES_EQ(context, input_layer_norm_coefficients-&gt;type,\n                              kTfLiteFloat32);\n    }\n\n    const TfLiteTensor* forget_layer_norm_coefficients =\n        GetInput(context, node, lstm::full::kForgetLayerNormCoefficientsTensor);\n    TF_LITE_ENSURE(context, forget_layer_norm_coefficients != nullptr);\n    TF_LITE_ENSURE_EQ(context, forget_layer_norm_coefficients-&gt;dims-&gt;size, 1);\n    TF_LITE_ENSURE_EQ(context, forget_layer_norm_coefficients-&gt;dims-&gt;data[0],\n                      n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, forget_layer_norm_coefficients-&gt;type,\n                            kTfLiteFloat32);\n\n    const TfLiteTensor* cell_layer_norm_coefficients =\n        GetInput(context, node, lstm::full::kCellLayerNormCoefficientsTensor);\n    TF_LITE_ENSURE(context, cell_layer_norm_coefficients != nullptr);\n    TF_LITE_ENSURE_EQ(context, cell_layer_norm_coefficients-&gt;dims-&gt;size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_layer_norm_coefficients-&gt;dims-&gt;data[0],\n                      n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, cell_layer_norm_coefficients-&gt;type,\n                            kTfLiteFloat32);\n\n    const TfLiteTensor* output_layer_norm_coefficients =\n        GetInput(context, node, lstm::full::kOutputLayerNormCoefficientsTensor);\n    TF_LITE_ENSURE(context, output_layer_norm_coefficients != nullptr);\n    TF_LITE_ENSURE_EQ(context, output_layer_norm_coefficients-&gt;dims-&gt;size, 1);\n    TF_LITE_ENSURE_EQ(context, output_layer_norm_coefficients-&gt;dims-&gt;data[0],\n                      n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, output_layer_norm_coefficients-&gt;type,\n                            kTfLiteFloat32);\n  }\n\n  return kTfLiteOk;\n}",
 'static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tuint\taddr, length;\n\tint alen;\n\tint\tj, nbytes, linebytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\t/* We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip   = i2c_dp_last_chip;\n\taddr   = i2c_dp_last_addr;\n\talen   = i2c_dp_last_alen;\n\tlength = i2c_dp_last_length;\n\n\tif (argc &lt; 3)\n\t\treturn CMD_RET_USAGE;\n\n\tif ((flag &amp; CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.\n\t\t */\n\n\t\t/*\n\t\t * I2C chip address\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * I2C data address within the chip.  This can be 1 or\n\t\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen &gt; 3)\n\t\t\treturn CMD_RET_USAGE;\n\n\t\t/*\n\t\t * If another parameter, it is the length to display.\n\t\t * Length is the number of objects, not number of bytes.\n\t\t */\n\t\tif (argc &gt; 3)\n\t\t\tlength = hextoul(argv[3], NULL);\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &amp;dev);\n\tif (!ret &amp;&amp; alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\n\t/*\n\t * Print the lines.\n\t *\n\t * We buffer all read data, so we can make sure data is read only\n\t * once.\n\t */\n\tnbytes = length;\n\tdo {\n\t\tunsigned char\tlinebuf[DISP_LINE_LEN];\n\t\tunsigned char\t*cp;\n\n\t\tlinebytes = (nbytes &gt; DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, linebuf, linebytes);\n#else\n\t\tret = i2c_read(chip, addr, alen, linebuf, linebytes);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\t\telse {\n\t\t\tprintf("%04x:", addr);\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j&lt;linebytes; j++) {\n\t\t\t\tprintf(" %02x", *cp++);\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tputs ("    ");\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j&lt;linebytes; j++) {\n\t\t\t\tif ((*cp &lt; 0x20) || (*cp &gt; 0x7e))\n\t\t\t\t\tputs (".");\n\t\t\t\telse\n\t\t\t\t\tprintf("%c", *cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tputc (\'\\n\');\n\t\t}\n\t\tnbytes -= linebytes;\n\t} while (nbytes &gt; 0);\n\n\ti2c_dp_last_chip   = chip;\n\ti2c_dp_last_addr   = addr;\n\ti2c_dp_last_alen   = alen;\n\ti2c_dp_last_length = length;\n\n\treturn 0;\n}',
 'int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties&amp; tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) &lt;&lt; "Count: " &lt;&lt; count &lt;&lt; " DataTypeSize: " &lt;&lt; size;\n  return count * size;\n}',
 'build_config(char *prefix, struct manager_ctx *manager, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server-&gt;port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, "%s/.shadowsocks_%s.conf", prefix, server-&gt;port);\n    FILE *f = fopen(path, "w+");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE("unable to open config file");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, "{\\n");\n    fprintf(f, "\\"server_port\\":%d,\\n", atoi(server-&gt;port));\n    fprintf(f, "\\"password\\":\\"%s\\"", server-&gt;password);\n    if (server-&gt;method)\n        fprintf(f, ",\\n\\"method\\":\\"%s\\"", server-&gt;method);\n    else if (manager-&gt;method)\n        fprintf(f, ",\\n\\"method\\":\\"%s\\"", manager-&gt;method);\n    if (server-&gt;fast_open[0])\n        fprintf(f, ",\\n\\"fast_open\\": %s", server-&gt;fast_open);\n    if (server-&gt;mode)\n        fprintf(f, ",\\n\\"mode\\":\\"%s\\"", server-&gt;mode);\n    if (server-&gt;plugin)\n        fprintf(f, ",\\n\\"plugin\\":\\"%s\\"", server-&gt;plugin);\n    if (server-&gt;plugin_opts)\n        fprintf(f, ",\\n\\"plugin_opts\\":\\"%s\\"", server-&gt;plugin_opts);\n    fprintf(f, "\\n}\\n");\n    fclose(f);\n    ss_free(path);\n}',
 'int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode-&gt;i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode-&gt;i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &amp;mode);\n\t\t\tif (ret &lt; 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode-&gt;i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &amp;size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     "", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, "", value, size, 0);\n\n\tkfree(value);\n\n\treturn ret;\n}',
 "static int FNAME(fetch)(struct kvm_vcpu *vcpu, gpa_t addr,\n\t\t\t struct guest_walker *gw, u32 error_code,\n\t\t\t int max_level, kvm_pfn_t pfn, bool map_writable,\n\t\t\t bool prefault)\n{\n\tbool nx_huge_page_workaround_enabled = is_nx_huge_page_enabled();\n\tbool write_fault = error_code &amp; PFERR_WRITE_MASK;\n\tbool exec = error_code &amp; PFERR_FETCH_MASK;\n\tbool huge_page_disallowed = exec &amp;&amp; nx_huge_page_workaround_enabled;\n\tstruct kvm_mmu_page *sp = NULL;\n\tstruct kvm_shadow_walk_iterator it;\n\tunsigned direct_access, access = gw-&gt;pt_access;\n\tint top_level, level, req_level, ret;\n\tgfn_t base_gfn = gw-&gt;gfn;\n\n\tdirect_access = gw-&gt;pte_access;\n\n\ttop_level = vcpu-&gt;arch.mmu-&gt;root_level;\n\tif (top_level == PT32E_ROOT_LEVEL)\n\t\ttop_level = PT32_ROOT_LEVEL;\n\t/*\n\t * Verify that the top-level gpte is still there.  Since the page\n\t * is a root page, it is either write protected (and cannot be\n\t * changed from now on) or it is invalid (in which case, we don't\n\t * really care if it changes underneath us after this point).\n\t */\n\tif (FNAME(gpte_changed)(vcpu, gw, top_level))\n\t\tgoto out_gpte_changed;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu-&gt;arch.mmu-&gt;root_hpa)))\n\t\tgoto out_gpte_changed;\n\n\tfor (shadow_walk_init(&amp;it, vcpu, addr);\n\t     shadow_walk_okay(&amp;it) &amp;&amp; it.level &gt; gw-&gt;level;\n\t     shadow_walk_next(&amp;it)) {\n\t\tgfn_t table_gfn;\n\n\t\tclear_sp_write_flooding_count(it.sptep);\n\t\tdrop_large_spte(vcpu, it.sptep);\n\n\t\tsp = NULL;\n\t\tif (!is_shadow_present_pte(*it.sptep)) {\n\t\t\ttable_gfn = gw-&gt;table_gfn[it.level - 2];\n\t\t\tsp = kvm_mmu_get_page(vcpu, table_gfn, addr, it.level-1,\n\t\t\t\t\t      false, access);\n\t\t}\n\n\t\t/*\n\t\t * Verify that the gpte in the page we've just write\n\t\t * protected is still there.\n\t\t */\n\t\tif (FNAME(gpte_changed)(vcpu, gw, it.level - 1))\n\t\t\tgoto out_gpte_changed;\n\n\t\tif (sp)\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t}\n\n\tlevel = kvm_mmu_hugepage_adjust(vcpu, gw-&gt;gfn, max_level, &amp;pfn,\n\t\t\t\t\thuge_page_disallowed, &amp;req_level);\n\n\ttrace_kvm_mmu_spte_requested(addr, gw-&gt;level, pfn);\n\n\tfor (; shadow_walk_okay(&amp;it); shadow_walk_next(&amp;it)) {\n\t\tclear_sp_write_flooding_count(it.sptep);\n\n\t\t/*\n\t\t * We cannot overwrite existing page tables with an NX\n\t\t * large page, as the leaf could be executable.\n\t\t */\n\t\tif (nx_huge_page_workaround_enabled)\n\t\t\tdisallowed_hugepage_adjust(*it.sptep, gw-&gt;gfn, it.level,\n\t\t\t\t\t\t   &amp;pfn, &amp;level);\n\n\t\tbase_gfn = gw-&gt;gfn &amp; ~(KVM_PAGES_PER_HPAGE(it.level) - 1);\n\t\tif (it.level == level)\n\t\t\tbreak;\n\n\t\tvalidate_direct_spte(vcpu, it.sptep, direct_access);\n\n\t\tdrop_large_spte(vcpu, it.sptep);\n\n\t\tif (!is_shadow_present_pte(*it.sptep)) {\n\t\t\tsp = kvm_mmu_get_page(vcpu, base_gfn, addr,\n\t\t\t\t\t      it.level - 1, true, direct_access);\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t\t\tif (huge_page_disallowed &amp;&amp; req_level &gt;= it.level)\n\t\t\t\taccount_huge_nx_page(vcpu-&gt;kvm, sp);\n\t\t}\n\t}\n\n\tret = mmu_set_spte(vcpu, it.sptep, gw-&gt;pte_access, write_fault,\n\t\t\t   it.level, base_gfn, pfn, prefault, map_writable);\n\tif (ret == RET_PF_SPURIOUS)\n\t\treturn ret;\n\n\tFNAME(pte_prefetch)(vcpu, gw, it.sptep);\n\t++vcpu-&gt;stat.pf_fixed;\n\treturn ret;\n\nout_gpte_changed:\n\treturn RET_PF_RETRY;\n}",
 "DefragIPv4TooLargeTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* Create a fragment that would extend past the max allowable size\n     * for an IPv4 packet. */\n    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should have\n     * been allocated from the pool. */\n    if (dc-&gt;frag_pool-&gt;outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}",
 'static int em_call_far(struct x86_emulate_ctxt *ctxt)\n{\n\tu16 sel, old_cs;\n\tulong old_eip;\n\tint rc;\n\n\told_cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\told_eip = ctxt-&gt;_eip;\n\n\tmemcpy(&amp;sel, ctxt-&gt;src.valptr + ctxt-&gt;op_bytes, 2);\n\tif (load_segment_descriptor(ctxt, sel, VCPU_SREG_CS))\n\t\treturn X86EMUL_CONTINUE;\n\n\tctxt-&gt;_eip = 0;\n\tmemcpy(&amp;ctxt-&gt;_eip, ctxt-&gt;src.valptr, ctxt-&gt;op_bytes);\n\n\tctxt-&gt;src.val = old_cs;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt-&gt;src.val = old_eip;\n\treturn em_push(ctxt);\n}',
 '  void Compute(OpKernelContext* context) override {\n    const Tensor* input_indices;\n    const Tensor* input_values;\n    const Tensor* input_shape;\n    SparseTensorsMap* map;\n\n    OP_REQUIRES_OK(context, context-&gt;input("sparse_indices", &amp;input_indices));\n    OP_REQUIRES_OK(context, context-&gt;input("sparse_values", &amp;input_values));\n    OP_REQUIRES_OK(context, context-&gt;input("sparse_shape", &amp;input_shape));\n    OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &amp;map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices-&gt;shape()),\n                errors::InvalidArgument(\n                    "Input indices should be a matrix but received shape ",\n                    input_indices-&gt;shape().DebugString()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values-&gt;shape()),\n                errors::InvalidArgument(\n                    "Input values should be a vector but received shape ",\n                    input_values-&gt;shape().DebugString()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape-&gt;shape()),\n                errors::InvalidArgument(\n                    "Input shape should be a vector but received shape ",\n                    input_shape-&gt;shape().DebugString()));\n\n    int rank = input_shape-&gt;NumElements();\n\n    OP_REQUIRES(\n        context, rank &gt; 1,\n        errors::InvalidArgument(\n            "Rank of input SparseTensor should be &gt; 1, but saw rank: ", rank));\n\n    TensorShape tensor_input_shape(input_shape-&gt;vec&lt;int64&gt;());\n    gtl::InlinedVector&lt;int64, 8&gt; std_order(rank);\n    std::iota(std_order.begin(), std_order.end(), 0);\n    SparseTensor input_st;\n    OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,\n                                                 tensor_input_shape, std_order,\n                                                 &amp;input_st));\n\n    auto input_shape_t = input_shape-&gt;vec&lt;int64&gt;();\n    const int64 N = input_shape_t(0);\n\n    Tensor sparse_handles(DT_INT64, TensorShape({N}));\n    auto sparse_handles_t = sparse_handles.vec&lt;int64&gt;();\n\n    OP_REQUIRES_OK(context, input_st.IndicesValid());\n\n    // We can generate the output shape proto string now, for all\n    // minibatch entries.\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                input_shape_t.data() + 1,\n                                input_shape-&gt;NumElements() - 1, &amp;output_shape));\n\n    // Get groups by minibatch dimension\n    std::unordered_set&lt;int64&gt; visited;\n    sparse::GroupIterable minibatch = input_st.group({0});\n    for (const auto&amp; subset : minibatch) {\n      const int64 b = subset.group()[0];\n      visited.insert(b);\n      OP_REQUIRES(\n          context, b &gt; -1 &amp;&amp; b &lt; N,\n          errors::InvalidArgument(\n              "Received unexpected column 0 value in input SparseTensor: ", b,\n              " &lt; 0 or &gt;= N (= ", N, ")"));\n\n      const auto indices = subset.indices();\n      const auto values = subset.values&lt;T&gt;();\n      const int64 num_entries = values.size();\n\n      Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});\n      Tensor output_values = Tensor(DataTypeToEnum&lt;T&gt;::value, {num_entries});\n\n      auto output_indices_t = output_indices.matrix&lt;int64&gt;();\n      auto output_values_t = output_values.vec&lt;T&gt;();\n\n      for (int i = 0; i &lt; num_entries; ++i) {\n        for (int d = 1; d &lt; rank; ++d) {\n          output_indices_t(i, d - 1) = indices(i, d);\n        }\n        output_values_t(i) = values(i);\n      }\n\n      SparseTensor st_i;\n      OP_REQUIRES_OK(context,\n                     SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &amp;st_i));\n      int64 handle;\n      OP_REQUIRES_OK(context, map-&gt;AddSparseTensor(context, st_i, &amp;handle));\n      sparse_handles_t(b) = handle;\n    }\n\n    // Fill in any gaps; we must provide an empty ST for batch entries\n    // the grouper didn\'t find.\n    if (visited.size() &lt; N) {\n      Tensor empty_indices(DT_INT64, {0, rank - 1});\n      Tensor empty_values(DataTypeToEnum&lt;T&gt;::value, {0});\n      SparseTensor empty_st;\n      OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,\n                                                   output_shape, &amp;empty_st));\n\n      for (int64 b = 0; b &lt; N; ++b) {\n        // We skipped this batch entry.\n        if (visited.find(b) == visited.end()) {\n          int64 handle;\n          OP_REQUIRES_OK(context,\n                         map-&gt;AddSparseTensor(context, empty_st, &amp;handle));\n          sparse_handles_t(b) = handle;\n        }\n      }\n    }\n\n    context-&gt;set_output(0, sparse_handles);\n  }',
 '  Status check_index_ordering(const Tensor&amp; indices) {\n    auto findices = indices.flat&lt;int&gt;();\n\n    for (std::size_t i = 0; i &lt; findices.dimension(0) - 1; ++i) {\n      if (findices(i) &lt; findices(i + 1)) {\n        continue;\n      }\n\n      return Status(\n          errors::InvalidArgument("Indices are not strictly ordered"));\n    }\n\n    return Status::OK();\n  }',
 'void ksz9131WritePhyReg(NetInterface *interface, uint8_t address,\n   uint16_t data)\n{\n   //Write the specified PHY register\n   if(interface-&gt;smiDriver != NULL)\n   {\n      interface-&gt;smiDriver-&gt;writePhyReg(SMI_OPCODE_WRITE,\n         interface-&gt;phyAddr, address, data);\n   }\n   else\n   {\n      interface-&gt;nicDriver-&gt;writePhyReg(SMI_OPCODE_WRITE,\n         interface-&gt;phyAddr, address, data);\n   }\n}',
 'int main(int argc, char **argv)\n{\n  MYSQL mysql;\n  option_string *eptr;\n\n  MY_INIT(argv[0]);\n\n  my_getopt_use_args_separator= TRUE;\n  if (load_defaults("my",load_default_groups,&amp;argc,&amp;argv))\n  {\n    my_end(0);\n    exit(1);\n  }\n  my_getopt_use_args_separator= FALSE;\n  defaults_argv=argv;\n  if (get_options(&amp;argc,&amp;argv))\n  {\n    free_defaults(defaults_argv);\n    my_end(0);\n    exit(1);\n  }\n\n  /* Seed the random number generator if we will be using it. */\n  if (auto_generate_sql)\n    srandom((uint)time(NULL));\n\n  /* globals? Yes, so we only have to run strlen once */\n  delimiter_length= strlen(delimiter);\n\n  if (argc &gt; 2)\n  {\n    fprintf(stderr,"%s: Too many arguments\\n",my_progname);\n    free_defaults(defaults_argv);\n    my_end(0);\n    exit(1);\n  }\n  mysql_init(&amp;mysql);\n  if (opt_compress)\n    mysql_options(&amp;mysql,MYSQL_OPT_COMPRESS,NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&amp;mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&amp;mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&amp;mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n#endif\n  if (opt_protocol)\n    mysql_options(&amp;mysql,MYSQL_OPT_PROTOCOL,(char*)&amp;opt_protocol);\n#if defined (_WIN32) &amp;&amp; !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&amp;mysql,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  mysql_options(&amp;mysql, MYSQL_SET_CHARSET_NAME, default_charset);\n\n  if (opt_plugin_dir &amp;&amp; *opt_plugin_dir)\n    mysql_options(&amp;mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n\n  if (opt_default_auth &amp;&amp; *opt_default_auth)\n    mysql_options(&amp;mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n\n  mysql_options(&amp;mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(&amp;mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 "program_name", "mysqlslap");\n  if (using_opt_enable_cleartext_plugin)\n    mysql_options(&amp;mysql, MYSQL_ENABLE_CLEARTEXT_PLUGIN, \n                  (char*) &amp;opt_enable_cleartext_plugin);\n  if (!opt_only_print) \n  {\n    if (!(mysql_real_connect(&amp;mysql, host, user, opt_password,\n                             NULL, opt_mysql_port,\n                             opt_mysql_unix_port, connect_flags)))\n    {\n      fprintf(stderr,"%s: Error when connecting to server: %s\\n",\n              my_progname,mysql_error(&amp;mysql));\n      free_defaults(defaults_argv);\n      my_end(0);\n      exit(1);\n    }\n  }\n\n  pthread_mutex_init(&amp;counter_mutex, NULL);\n  pthread_cond_init(&amp;count_threshhold, NULL);\n  pthread_mutex_init(&amp;sleeper_mutex, NULL);\n  pthread_cond_init(&amp;sleep_threshhold, NULL);\n\n  /* Main iterations loop */\n  eptr= engine_options;\n  do\n  {\n    /* For the final stage we run whatever queries we were asked to run */\n    uint *current;\n\n    if (verbose &gt;= 2)\n      printf("Starting Concurrency Test\\n");\n\n    if (*concurrency)\n    {\n      for (current= concurrency; current &amp;&amp; *current; current++)\n        concurrency_loop(&amp;mysql, *current, eptr);\n    }\n    else\n    {\n      uint infinite= 1;\n      do {\n        concurrency_loop(&amp;mysql, infinite, eptr);\n      }\n      while (infinite++);\n    }\n\n    if (!opt_preserve)\n      drop_schema(&amp;mysql, create_schema_string);\n\n  } while (eptr ? (eptr= eptr-&gt;next) : 0);\n\n  pthread_mutex_destroy(&amp;counter_mutex);\n  pthread_cond_destroy(&amp;count_threshhold);\n  pthread_mutex_destroy(&amp;sleeper_mutex);\n  pthread_cond_destroy(&amp;sleep_threshhold);\n\n  if (!opt_only_print) \n    mysql_close(&amp;mysql); /* Close &amp; free connection */\n\n  /* now free all the strings we created */\n  my_free(opt_password);\n  my_free(concurrency);\n\n  statement_cleanup(create_statements);\n  statement_cleanup(query_statements);\n  statement_cleanup(pre_statements);\n  statement_cleanup(post_statements);\n  option_cleanup(engine_options);\n\n#if defined (_WIN32) &amp;&amp; !defined (EMBEDDED_LIBRARY)\n  my_free(shared_memory_base_name);\n#endif\n  free_defaults(defaults_argv);\n  my_end(my_end_arg);\n\n  return 0;\n}',
 'static void __nfs4_close(struct path *path, struct nfs4_state *state, mode_t mode, int wait)\n{\n\tstruct nfs4_state_owner *owner = state-&gt;owner;\n\tint call_close = 0;\n\tint newstate;\n\n\tatomic_inc(&amp;owner-&gt;so_count);\n\t/* Protect against nfs4_find_state() */\n\tspin_lock(&amp;owner-&gt;so_lock);\n\tswitch (mode &amp; (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate-&gt;n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate-&gt;n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate-&gt;n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state-&gt;n_rdwr == 0) {\n\t\tif (state-&gt;n_rdonly == 0) {\n\t\t\tnewstate &amp;= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &amp;state-&gt;flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &amp;state-&gt;flags);\n\t\t}\n\t\tif (state-&gt;n_wronly == 0) {\n\t\t\tnewstate &amp;= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &amp;state-&gt;flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &amp;state-&gt;flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &amp;state-&gt;flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&amp;owner-&gt;so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(path, state, wait);\n}',
 'obj2ast_withitem(PyObject* obj, withitem_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    expr_ty context_expr;\n    expr_ty optional_vars;\n\n    if (lookup_attr_id(obj, &amp;PyId_context_expr, &amp;tmp) &lt; 0) {\n        return 1;\n    }\n    if (tmp == NULL) {\n        PyErr_SetString(PyExc_TypeError, "required field \\"context_expr\\" missing from withitem");\n        return 1;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &amp;context_expr, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    if (lookup_attr_id(obj, &amp;PyId_optional_vars, &amp;tmp) &lt; 0) {\n        return 1;\n    }\n    if (tmp == NULL || tmp == Py_None) {\n        Py_CLEAR(tmp);\n        optional_vars = NULL;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &amp;optional_vars, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    *out = withitem(context_expr, optional_vars, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}',
 'static int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_16 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tctxt-&gt;_eip = tss-&gt;ip;\n\tctxt-&gt;eflags = tss-&gt;flag | 2;\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss-&gt;ax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss-&gt;cx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss-&gt;dx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss-&gt;bx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss-&gt;sp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss-&gt;bp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss-&gt;si;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss-&gt;di;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss-&gt;ldt, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss-&gt;es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss-&gt;cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss-&gt;ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss-&gt;ds, VCPU_SREG_DS);\n\n\tcpl = tss-&gt;cs &amp; 3;\n\n\t/*\n\t * Now load segment descriptors. If fault happens at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss-&gt;ldt, VCPU_SREG_LDTR, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss-&gt;es, VCPU_SREG_ES, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss-&gt;cs, VCPU_SREG_CS, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss-&gt;ss, VCPU_SREG_SS, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss-&gt;ds, VCPU_SREG_DS, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}',
 "static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id)\n{\n\tGF_List *list = NULL, *alt_list = NULL;\n\tGF_NALUFFParam *sl;\n\tu32 i, count;\n\tu32 crc = gf_crc_32(data, size);\n\n\tif (ctx-&gt;codecid==GF_CODECID_HEVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tif (!ctx-&gt;vps) ctx-&gt;vps = gf_list_new();\n\t\t\tlist = ctx-&gt;vps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx-&gt;sps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx-&gt;pps;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else if (ctx-&gt;codecid==GF_CODECID_VVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tif (!ctx-&gt;vps) ctx-&gt;vps = gf_list_new();\n\t\t\tlist = ctx-&gt;vps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx-&gt;sps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx-&gt;pps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tif (!ctx-&gt;vvc_dci) ctx-&gt;vvc_dci = gf_list_new();\n\t\t\tlist = ctx-&gt;vvc_dci;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tif (!ctx-&gt;vvc_aps_pre) ctx-&gt;vvc_aps_pre = gf_list_new();\n\t\t\tlist = ctx-&gt;vvc_aps_pre;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (ps_type) {\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx-&gt;sps;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx-&gt;pps;\n\t\t\talt_list = ctx-&gt;pps_svc;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tif (!ctx-&gt;sps_ext) ctx-&gt;sps_ext = gf_list_new();\n\t\t\tlist = ctx-&gt;sps_ext;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tsl = NULL;\n\tcount = gf_list_count(list);\n\tfor (i=0; i&lt;count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (sl-&gt;id != ps_id) {\n\t\t\tsl = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t//same ID, same CRC, we don't change our state\n\t\tif (sl-&gt;crc == crc) return;\n\t\tbreak;\n\t}\n\t//handle alt PPS list for SVC\n\tif (!sl &amp;&amp; alt_list) {\n\t\tcount = gf_list_count(alt_list);\n\t\tfor (i=0; i&lt;count; i++) {\n\t\t\tsl = gf_list_get(alt_list, i);\n\t\t\tif (sl-&gt;id != ps_id) {\n\t\t\t\tsl = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//same ID, same CRC, we don't change our state\n\t\t\tif (sl-&gt;crc == crc) return;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sl) {\n\t\t//otherwise we keep this new param set\n\t\tsl-&gt;data = gf_realloc(sl-&gt;data, size);\n\t\tmemcpy(sl-&gt;data, data, size);\n\t\tsl-&gt;size = size;\n\t\tsl-&gt;crc = crc;\n\t\tctx-&gt;ps_modified = GF_TRUE;\n\t\treturn;\n\t}\n\t//TODO we might want to purge the list after a while !!\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl-&gt;data = gf_malloc(sizeof(char) * size);\n\tif (!sl-&gt;data) {\n\t\tgf_free(sl);\n\t\treturn;\n\t}\n\tmemcpy(sl-&gt;data, data, size);\n\tsl-&gt;size = size;\n\tsl-&gt;id = ps_id;\n\tsl-&gt;crc = crc;\n\n\tctx-&gt;ps_modified = GF_TRUE;\n\tgf_list_add(list, sl);\n}",
 'static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream-&gt;codecpar;\n\n    if (!strcmp(attr, "packetization-mode")) {\n        av_log(s, AV_LOG_DEBUG, "RTP Packetization Mode: %d\\n", atoi(value));\n        h264_data-&gt;packetization_mode = atoi(value);\n        /*\n         * Packetization Mode:\n         * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n         * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n         * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A),\n         *                      and 29 (FU-B) are allowed.\n         */\n        if (h264_data-&gt;packetization_mode &gt; 1)\n            av_log(s, AV_LOG_ERROR,\n                   "Interleaved RTP mode is not supported yet.\\n");\n    } else if (!strcmp(attr, "profile-level-id")) {\n        if (strlen(value) == 6)\n            parse_profile_level_id(s, h264_data, value);\n    } else if (!strcmp(attr, "sprop-parameter-sets")) {\n        int ret;\n        if (*value == 0 || value[strlen(value) - 1] == \',\') {\n            av_log(s, AV_LOG_WARNING, "Missing PPS in sprop-parameter-sets, ignoring\\n");\n            return 0;\n        }\n        par-&gt;extradata_size = 0;\n        av_freep(&amp;par-&gt;extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &amp;par-&gt;extradata,\n                                                 &amp;par-&gt;extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, "Extradata set to %p (size: %d)\\n",\n               par-&gt;extradata, par-&gt;extradata_size);\n        return ret;\n    }\n    return 0;\n}',
 'TfLiteStatus HardSwishEval(TfLiteContext* context, TfLiteNode* node) {\n  HardSwishData* data = static_cast&lt;HardSwishData*&gt;(node-&gt;user_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &amp;input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &amp;output));\n  switch (input-&gt;type) {\n    case kTfLiteFloat32: {\n      if (kernel_type == kReference) {\n        reference_ops::HardSwish(\n            GetTensorShape(input), GetTensorData&lt;float&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;float&gt;(output));\n      } else {\n        optimized_ops::HardSwish(\n            GetTensorShape(input), GetTensorData&lt;float&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;float&gt;(output));\n      }\n      return kTfLiteOk;\n    } break;\n    case kTfLiteUInt8: {\n      HardSwishParams&amp; params = data-&gt;params;\n      if (kernel_type == kReference) {\n        reference_ops::HardSwish(\n            params, GetTensorShape(input), GetTensorData&lt;uint8_t&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;uint8_t&gt;(output));\n      } else {\n        optimized_ops::HardSwish(\n            params, GetTensorShape(input), GetTensorData&lt;uint8_t&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;uint8_t&gt;(output));\n      }\n      return kTfLiteOk;\n    } break;\n    case kTfLiteInt8: {\n      HardSwishParams&amp; params = data-&gt;params;\n      if (kernel_type == kReference) {\n        reference_ops::HardSwish(\n            params, GetTensorShape(input), GetTensorData&lt;int8_t&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;int8_t&gt;(output));\n      } else {\n        optimized_ops::HardSwish(\n            params, GetTensorShape(input), GetTensorData&lt;int8_t&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;int8_t&gt;(output));\n      }\n      return kTfLiteOk;\n    } break;\n    default:\n      TF_LITE_KERNEL_LOG(\n          context,\n          "Only float32, uint8 and int8 are supported currently, got %s.",\n          TfLiteTypeGetName(input-&gt;type));\n      return kTfLiteError;\n  }\n}',
 'FdInStream::FdInStream(int fd_, FdInStreamBlockCallback* blockCallback_,\n                       int bufSize_)\n  : fd(fd_), timeoutms(0), blockCallback(blockCallback_),\n    timing(false), timeWaitedIn100us(5), timedKbits(0),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = end = start = new U8[bufSize];\n}',
 'static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&amp;c-&gt;object, NULL, NULL, data);\n}',
 'static int snd_ctl_elem_add(struct snd_ctl_file *file,\n\t\t\t    struct snd_ctl_elem_info *info, int replace)\n{\n\tstruct snd_card *card = file-&gt;card;\n\tstruct snd_kcontrol kctl, *_kctl;\n\tunsigned int access;\n\tlong private_size;\n\tstruct user_element *ue;\n\tint idx, err;\n\n\tif (!replace &amp;&amp; card-&gt;user_ctl_count &gt;= MAX_USER_CONTROLS)\n\t\treturn -ENOMEM;\n\tif (info-&gt;count &lt; 1)\n\t\treturn -EINVAL;\n\taccess = info-&gt;access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :\n\t\t(info-&gt;access &amp; (SNDRV_CTL_ELEM_ACCESS_READWRITE|\n\t\t\t\t SNDRV_CTL_ELEM_ACCESS_INACTIVE|\n\t\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));\n\tinfo-&gt;id.numid = 0;\n\tmemset(&amp;kctl, 0, sizeof(kctl));\n\tdown_write(&amp;card-&gt;controls_rwsem);\n\t_kctl = snd_ctl_find_id(card, &amp;info-&gt;id);\n\terr = 0;\n\tif (_kctl) {\n\t\tif (replace)\n\t\t\terr = snd_ctl_remove(card, _kctl);\n\t\telse\n\t\t\terr = -EBUSY;\n\t} else {\n\t\tif (replace)\n\t\t\terr = -ENOENT;\n\t}\n\tup_write(&amp;card-&gt;controls_rwsem);\n\tif (err &lt; 0)\n\t\treturn err;\n\tmemcpy(&amp;kctl.id, &amp;info-&gt;id, sizeof(info-&gt;id));\n\tkctl.count = info-&gt;owner ? info-&gt;owner : 1;\n\taccess |= SNDRV_CTL_ELEM_ACCESS_USER;\n\tif (info-&gt;type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)\n\t\tkctl.info = snd_ctl_elem_user_enum_info;\n\telse\n\t\tkctl.info = snd_ctl_elem_user_info;\n\tif (access &amp; SNDRV_CTL_ELEM_ACCESS_READ)\n\t\tkctl.get = snd_ctl_elem_user_get;\n\tif (access &amp; SNDRV_CTL_ELEM_ACCESS_WRITE)\n\t\tkctl.put = snd_ctl_elem_user_put;\n\tif (access &amp; SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {\n\t\tkctl.tlv.c = snd_ctl_elem_user_tlv;\n\t\taccess |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t}\n\tswitch (info-&gt;type) {\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tprivate_size = sizeof(long);\n\t\tif (info-&gt;count &gt; 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\t\tprivate_size = sizeof(long long);\n\t\tif (info-&gt;count &gt; 64)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tprivate_size = sizeof(unsigned int);\n\t\tif (info-&gt;count &gt; 128 || info-&gt;value.enumerated.items == 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_BYTES:\n\t\tprivate_size = sizeof(unsigned char);\n\t\tif (info-&gt;count &gt; 512)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_IEC958:\n\t\tprivate_size = sizeof(struct snd_aes_iec958);\n\t\tif (info-&gt;count != 1)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tprivate_size *= info-&gt;count;\n\tue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);\n\tif (ue == NULL)\n\t\treturn -ENOMEM;\n\tue-&gt;card = card;\n\tue-&gt;info = *info;\n\tue-&gt;info.access = 0;\n\tue-&gt;elem_data = (char *)ue + sizeof(*ue);\n\tue-&gt;elem_data_size = private_size;\n\tif (ue-&gt;info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {\n\t\terr = snd_ctl_elem_init_enum_names(ue);\n\t\tif (err &lt; 0) {\n\t\t\tkfree(ue);\n\t\t\treturn err;\n\t\t}\n\t}\n\tkctl.private_free = snd_ctl_elem_user_free;\n\t_kctl = snd_ctl_new(&amp;kctl, access);\n\tif (_kctl == NULL) {\n\t\tkfree(ue-&gt;priv_data);\n\t\tkfree(ue);\n\t\treturn -ENOMEM;\n\t}\n\t_kctl-&gt;private_data = ue;\n\tfor (idx = 0; idx &lt; _kctl-&gt;count; idx++)\n\t\t_kctl-&gt;vd[idx].owner = file;\n\terr = snd_ctl_add(card, _kctl);\n\tif (err &lt; 0)\n\t\treturn err;\n\n\tdown_write(&amp;card-&gt;controls_rwsem);\n\tcard-&gt;user_ctl_count++;\n\tup_write(&amp;card-&gt;controls_rwsem);\n\n\treturn 0;\n}',
 'server_read_httprange(struct bufferevent *bev, void *arg)\n{\n\tstruct client\t\t*clt = arg;\n\tstruct evbuffer\t\t*src = EVBUFFER_INPUT(bev);\n\tsize_t\t\t\t size;\n\tstruct media_type\t*media;\n\tstruct range_data\t*r = &amp;clt-&gt;clt_ranges;\n\tstruct range\t\t*range;\n\n\tgetmonotime(&amp;clt-&gt;clt_tv_last);\n\n\tif (r-&gt;range_toread &gt; 0) {\n\t\tsize = EVBUFFER_LENGTH(src);\n\t\tif (!size)\n\t\t\treturn;\n\n\t\t/* Read chunk data */\n\t\tif ((off_t)size &gt; r-&gt;range_toread) {\n\t\t\tsize = r-&gt;range_toread;\n\t\t\tif (server_bufferevent_write_chunk(clt, src, size)\n\t\t\t    == -1)\n\t\t\t\tgoto fail;\n\t\t\tr-&gt;range_toread = 0;\n\t\t} else {\n\t\t\tif (server_bufferevent_write_buffer(clt, src) == -1)\n\t\t\t\tgoto fail;\n\t\t\tr-&gt;range_toread -= size;\n\t\t}\n\t\tif (r-&gt;range_toread &lt; 1)\n\t\t\tr-&gt;range_toread = TOREAD_HTTP_RANGE;\n\t\tDPRINTF("%s: done, size %lu, to read %lld", __func__,\n\t\t    size, r-&gt;range_toread);\n\t}\n\n\tswitch (r-&gt;range_toread) {\n\tcase TOREAD_HTTP_RANGE:\n\t\tif (r-&gt;range_index &gt;= r-&gt;range_count) {\n\t\t\tif (r-&gt;range_count &gt; 1) {\n\t\t\t\t/* Add end marker */\n\t\t\t\tif (server_bufferevent_printf(clt,\n\t\t\t\t    "\\r\\n--%llu--\\r\\n",\n\t\t\t\t    clt-&gt;clt_boundary) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tr-&gt;range_toread = TOREAD_HTTP_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\trange = &amp;r-&gt;range[r-&gt;range_index];\n\n\t\tif (r-&gt;range_count &gt; 1) {\n\t\t\tmedia = r-&gt;range_media;\n\t\t\tif (server_bufferevent_printf(clt,\n\t\t\t    "\\r\\n--%llu\\r\\n"\n\t\t\t    "Content-Type: %s/%s\\r\\n"\n\t\t\t    "Content-Range: bytes %lld-%lld/%zu\\r\\n\\r\\n",\n\t\t\t    clt-&gt;clt_boundary,\n\t\t\t    media-&gt;media_type, media-&gt;media_subtype,\n\t\t\t    range-&gt;start, range-&gt;end, r-&gt;range_total) == -1)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tr-&gt;range_toread = range-&gt;end - range-&gt;start + 1;\n\n\t\tif (lseek(clt-&gt;clt_fd, range-&gt;start, SEEK_SET) == -1)\n\t\t\tgoto fail;\n\n\t\t/* Throw away bytes that are already in the input buffer */\n\t\tevbuffer_drain(src, EVBUFFER_LENGTH(src));\n\n\t\t/* Increment for the next part */\n\t\tr-&gt;range_index++;\n\t\tbreak;\n\tcase TOREAD_HTTP_NONE:\n\tcase 0:\n\t\tbreak;\n\t}\n\n\tif (clt-&gt;clt_done)\n\t\tgoto done;\n\n\tif (EVBUFFER_LENGTH(EVBUFFER_OUTPUT(clt-&gt;clt_bev)) &gt; (size_t)\n\t    SERVER_MAX_PREFETCH * clt-&gt;clt_sndbufsiz) {\n\t\tbufferevent_disable(clt-&gt;clt_srvbev, EV_READ);\n\t\tclt-&gt;clt_srvbev_throttled = 1;\n\t}\n\n\treturn;\n done:\n\t(*bev-&gt;errorcb)(bev, EVBUFFER_READ, bev-&gt;cbarg);\n\treturn;\n fail:\n\tserver_close(clt, strerror(errno));\n}',
 'TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast&lt;TfLiteSpaceToDepthParams*&gt;(node-&gt;builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n#define TF_LITE_SPACE_TO_DEPTH(type, scalar)                               \\\n  tflite::SpaceToDepthParams op_params;                                    \\\n  op_params.block_size = params-&gt;block_size;                               \\\n  type::SpaceToDepth(op_params, GetTensorShape(input),                     \\\n                     GetTensorData&lt;scalar&gt;(input), GetTensorShape(output), \\\n                     GetTensorData&lt;scalar&gt;(output))\n  switch (input-&gt;type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      if (kernel_type == kReference) {\n        TF_LITE_SPACE_TO_DEPTH(reference_ops, float);\n      } else {\n        TF_LITE_SPACE_TO_DEPTH(optimized_ops, float);\n      }\n      break;\n    case kTfLiteUInt8:\n      if (kernel_type == kReference) {\n        TF_LITE_SPACE_TO_DEPTH(reference_ops, uint8_t);\n      } else {\n        TF_LITE_SPACE_TO_DEPTH(optimized_ops, uint8_t);\n      }\n      break;\n    case kTfLiteInt8:\n      if (kernel_type == kReference) {\n        TF_LITE_SPACE_TO_DEPTH(reference_ops, int8_t);\n      } else {\n        TF_LITE_SPACE_TO_DEPTH(optimized_ops, int8_t);\n      }\n      break;\n    case kTfLiteInt32:\n      if (kernel_type == kReference) {\n        TF_LITE_SPACE_TO_DEPTH(reference_ops, int32_t);\n      } else {\n        TF_LITE_SPACE_TO_DEPTH(optimized_ops, int32_t);\n      }\n      break;\n    case kTfLiteInt64:\n      if (kernel_type == kReference) {\n        TF_LITE_SPACE_TO_DEPTH(reference_ops, int64_t);\n      } else {\n        TF_LITE_SPACE_TO_DEPTH(optimized_ops, int64_t);\n      }\n      break;\n    default:\n      context-&gt;ReportError(context, "Type \'%s\' not currently supported.",\n                           TfLiteTypeGetName(input-&gt;type));\n      return kTfLiteError;\n  }\n#undef TF_LITE_SPACE_TO_DEPTH\n\n  return kTfLiteOk;\n}',
 'gss_krb5int_export_lucid_sec_context(\n    OM_uint32           *minor_status,\n    const gss_ctx_id_t  context_handle,\n    const gss_OID       desired_object,\n    gss_buffer_set_t    *data_set)\n{\n    krb5_error_code     kret = 0;\n    OM_uint32           retval;\n    krb5_gss_ctx_id_t   ctx = (krb5_gss_ctx_id_t)context_handle;\n    void                *lctx = NULL;\n    int                 version = 0;\n    gss_buffer_desc     rep;\n\n    /* Assume failure */\n    retval = GSS_S_FAILURE;\n    *minor_status = 0;\n    *data_set = GSS_C_NO_BUFFER_SET;\n\n    if (ctx-&gt;terminated || !ctx-&gt;established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    retval = generic_gss_oid_decompose(minor_status,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH,\n                                       desired_object,\n                                       &amp;version);\n    if (GSS_ERROR(retval))\n        return retval;\n\n    /* Externalize a structure of the right version */\n    switch (version) {\n    case 1:\n        kret = make_external_lucid_ctx_v1((krb5_pointer)ctx,\n                                          version, &amp;lctx);\n        break;\n    default:\n        kret = (OM_uint32) KG_LUCID_VERSION;\n        break;\n    }\n\n    if (kret)\n        goto error_out;\n\n    rep.value = &amp;lctx;\n    rep.length = sizeof(lctx);\n\n    retval = generic_gss_add_buffer_set_member(minor_status, &amp;rep, data_set);\n    if (GSS_ERROR(retval))\n        goto error_out;\n\nerror_out:\n    if (*minor_status == 0)\n        *minor_status = (OM_uint32) kret;\n    return(retval);\n}',
 'ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header-&gt;h_hash);\n\tstruct mb2_cache_entry *ce;\n\tstruct mb2_cache *ext2_mb_cache = EXT2_SB(inode-&gt;i_sb)-&gt;s_mb_cache;\n\n\tif (!header-&gt;h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, "looking for cached blocks [%x]", (int)hash);\nagain:\n\tce = mb2_cache_entry_find_first(ext2_mb_cache, hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = sb_bread(inode-&gt;i_sb, ce-&gt;e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode-&gt;i_sb, "ext2_xattr_cache_find",\n\t\t\t\t"inode %ld: block %ld read error",\n\t\t\t\tinode-&gt;i_ino, (unsigned long) ce-&gt;e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\t/*\n\t\t\t * We have to be careful about races with freeing or\n\t\t\t * rehashing of xattr block. Once we hold buffer lock\n\t\t\t * xattr block\'s state is stable so we can check\n\t\t\t * whether the block got freed / rehashed or not.\n\t\t\t * Since we unhash mbcache entry under buffer lock when\n\t\t\t * freeing / rehashing xattr block, checking whether\n\t\t\t * entry is still hashed is reliable.\n\t\t\t */\n\t\t\tif (hlist_bl_unhashed(&amp;ce-&gt;e_hash_list)) {\n\t\t\t\tmb2_cache_entry_put(ext2_mb_cache, ce);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto again;\n\t\t\t} else if (le32_to_cpu(HDR(bh)-&gt;h_refcount) &gt;\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, "block %ld refcount %d&gt;%d",\n\t\t\t\t\t  (unsigned long) ce-&gt;e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)-&gt;h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, "b_count=%d",\n\t\t\t\t\t  atomic_read(&amp;(bh-&gt;b_count)));\n\t\t\t\tmb2_cache_entry_touch(ext2_mb_cache, ce);\n\t\t\t\tmb2_cache_entry_put(ext2_mb_cache, ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb2_cache_entry_find_next(ext2_mb_cache, ce);\n\t}\n\treturn NULL;\n}',
 'l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (length &lt; 4) {\n\t\tND_PRINT((ndo, "AVP too short"));\n\t\treturn;\n\t}\n\tif (EXTRACT_32BITS(ptr) &amp;  L2TP_BEARER_CAP_ANALOG_MASK) {\n\t\tND_PRINT((ndo, "A"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &amp;  L2TP_BEARER_CAP_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, "D"));\n\t}\n}',
 'TEST_F(ListenerManagerImplQuicOnlyTest, QuicListenerFactoryWithWrongTransportSocket) {\n  const std::string yaml = TestEnvironment::substitute(R"EOF(\naddress:\n  socket_address:\n    address: 127.0.0.1\n    protocol: UDP\n    port_value: 1234\nfilter_chains:\n- filter_chain_match:\n    transport_protocol: "quic"\n  filters: []\n  transport_socket:\n    name: envoy.transport_sockets.quic\n    typed_config:\n      "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext\n      common_tls_context:\n        tls_certificates:\n        - certificate_chain:\n            filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem"\n          private_key:\n            filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem"\n        validation_context:\n          trusted_ca:\n            filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem"\n          match_typed_subject_alt_names:\n          - matcher:\n              exact: localhost\n            san_type: URI\n          - matcher:\n              exact: 127.0.0.1\n            san_type: IP_ADDRESS\nudp_listener_config:\n  quic_options: {}\n  )EOF",\n                                                       Network::Address::IpVersion::v4);\n\n  envoy::config::listener::v3::Listener listener_proto = parseListenerFromV3Yaml(yaml);\n\n#if defined(ENVOY_ENABLE_QUIC)\n  EXPECT_THROW_WITH_REGEX(manager_-&gt;addOrUpdateListener(listener_proto, "", true), EnvoyException,\n                          "wrong transport socket config specified for quic transport socket");\n#else\n  EXPECT_THROW_WITH_REGEX(manager_-&gt;addOrUpdateListener(listener_proto, "", true), EnvoyException,\n                          "QUIC is configured but not enabled in the build.");\n#endif\n}',
 'TEST_P(SslSPIFFECertValidatorIntegrationTest, ServerRsaSPIFFEValidatorSANMatch) {\n  auto typed_conf = new envoy::config::core::v3::TypedExtensionConfig();\n  TestUtility::loadFromYaml(TestEnvironment::substitute(R"EOF(\nname: envoy.tls.cert_validator.spiffe\ntyped_config:\n  "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.SPIFFECertValidatorConfig\n  trust_domains:\n    - name: lyft.com\n      trust_bundle:\n        filename: "{{ test_rundir }}/test/config/integration/certs/cacert.pem"\n  )EOF"),\n                            *typed_conf);\n  custom_validator_config_ = typed_conf;\n\n  envoy::type::matcher::v3::StringMatcher matcher;\n  matcher.set_prefix("spiffe://lyft.com/");\n  san_matchers_ = {matcher};\n\n  ConnectionCreationFunction creator = [&amp;]() -&gt; Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &amp;creator);\n  checkVerifyErrorCouter(0);\n}',
 'void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces-&gt;setTorrent(m_torrent);\n    pieces_availability-&gt;setTorrent(m_torrent);\n    if (!m_torrent) return;\n\n    // Save path\n    updateSavePath(m_torrent);\n    // Hash\n    hash_lbl-&gt;setText(m_torrent-&gt;hash());\n    PropListModel-&gt;model()-&gt;clear();\n    if (m_torrent-&gt;hasMetadata()) {\n        // Creation date\n        lbl_creationDate-&gt;setText(m_torrent-&gt;creationDate().toString(Qt::DefaultLocaleShortDate));\n\n        label_total_size_val-&gt;setText(Utils::Misc::friendlyUnit(m_torrent-&gt;totalSize()));\n\n        // Comment\n        comment_text-&gt;setText(Utils::Misc::parseHtmlLinks(m_torrent-&gt;comment()));\n\n        // URL seeds\n        loadUrlSeeds();\n\n        label_created_by_val-&gt;setText(m_torrent-&gt;creator());\n\n        // List files in torrent\n        PropListModel-&gt;model()-&gt;setupModelData(m_torrent-&gt;info());\n        filesList-&gt;setExpanded(PropListModel-&gt;index(0, 0), true);\n\n        // Load file priorities\n        PropListModel-&gt;model()-&gt;updateFilesPriorities(m_torrent-&gt;filePriorities());\n    }\n    // Load dynamic data\n    loadDynamicData();\n}',
 'static BOOL nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n                                      UINT32 scanline)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tUINT16 rw;\n\tBYTE ccl;\n\tconst BYTE* src;\n\tBYTE* yplane = NULL;\n\tBYTE* coplane = NULL;\n\tBYTE* cgplane = NULL;\n\tBYTE* aplane = NULL;\n\tINT16 r_val;\n\tINT16 g_val;\n\tINT16 b_val;\n\tBYTE a_val;\n\tUINT32 tempWidth;\n\n\tif (!context || data || (scanline == 0))\n\t\treturn FALSE;\n\n\ttempWidth = ROUND_UP_TO(context-&gt;width, 8);\n\trw = (context-&gt;ChromaSubsamplingLevel ? tempWidth : context-&gt;width);\n\tccl = context-&gt;ColorLossLevel;\n\n\tif (context-&gt;priv-&gt;PlaneBuffersLength &lt; rw * scanline)\n\t\treturn FALSE;\n\n\tif (rw &lt; scanline * 2)\n\t\treturn FALSE;\n\n\tfor (y = 0; y &lt; context-&gt;height; y++)\n\t{\n\t\tsrc = data + (context-&gt;height - 1 - y) * scanline;\n\t\typlane = context-&gt;priv-&gt;PlaneBuffers[0] + y * rw;\n\t\tcoplane = context-&gt;priv-&gt;PlaneBuffers[1] + y * rw;\n\t\tcgplane = context-&gt;priv-&gt;PlaneBuffers[2] + y * rw;\n\t\taplane = context-&gt;priv-&gt;PlaneBuffers[3] + y * context-&gt;width;\n\n\t\tfor (x = 0; x &lt; context-&gt;width; x++)\n\t\t{\n\t\t\tswitch (context-&gt;format)\n\t\t\t{\n\t\t\t\tcase PIXEL_FORMAT_BGRX32:\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tsrc++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGRA32:\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\ta_val = *src++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGBX32:\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tsrc++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGBA32:\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\ta_val = *src++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGR24:\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB24:\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGR16:\n\t\t\t\t\tb_val = (INT16)(((*(src + 1)) &amp; 0xF8) | ((*(src + 1)) &gt;&gt; 5));\n\t\t\t\t\tg_val = (INT16)((((*(src + 1)) &amp; 0x07) &lt;&lt; 5) | (((*src) &amp; 0xE0) &gt;&gt; 3));\n\t\t\t\t\tr_val = (INT16)((((*src) &amp; 0x1F) &lt;&lt; 3) | (((*src) &gt;&gt; 2) &amp; 0x07));\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tsrc += 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB16:\n\t\t\t\t\tr_val = (INT16)(((*(src + 1)) &amp; 0xF8) | ((*(src + 1)) &gt;&gt; 5));\n\t\t\t\t\tg_val = (INT16)((((*(src + 1)) &amp; 0x07) &lt;&lt; 5) | (((*src) &amp; 0xE0) &gt;&gt; 3));\n\t\t\t\t\tb_val = (INT16)((((*src) &amp; 0x1F) &lt;&lt; 3) | (((*src) &gt;&gt; 2) &amp; 0x07));\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tsrc += 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_A4:\n\t\t\t\t\t{\n\t\t\t\t\t\tint shift;\n\t\t\t\t\t\tBYTE idx;\n\t\t\t\t\t\tshift = (7 - (x % 8));\n\t\t\t\t\t\tidx = ((*src) &gt;&gt; shift) &amp; 1;\n\t\t\t\t\t\tidx |= (((*(src + 1)) &gt;&gt; shift) &amp; 1) &lt;&lt; 1;\n\t\t\t\t\t\tidx |= (((*(src + 2)) &gt;&gt; shift) &amp; 1) &lt;&lt; 2;\n\t\t\t\t\t\tidx |= (((*(src + 3)) &gt;&gt; shift) &amp; 1) &lt;&lt; 3;\n\t\t\t\t\t\tidx *= 3;\n\t\t\t\t\t\tr_val = (INT16) context-&gt;palette[idx];\n\t\t\t\t\t\tg_val = (INT16) context-&gt;palette[idx + 1];\n\t\t\t\t\t\tb_val = (INT16) context-&gt;palette[idx + 2];\n\n\t\t\t\t\t\tif (shift == 0)\n\t\t\t\t\t\t\tsrc += 4;\n\t\t\t\t\t}\n\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB8:\n\t\t\t\t\t{\n\t\t\t\t\t\tint idx = (*src) * 3;\n\t\t\t\t\t\tr_val = (INT16) context-&gt;palette[idx];\n\t\t\t\t\t\tg_val = (INT16) context-&gt;palette[idx + 1];\n\t\t\t\t\t\tb_val = (INT16) context-&gt;palette[idx + 2];\n\t\t\t\t\t\tsrc++;\n\t\t\t\t\t}\n\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tr_val = g_val = b_val = a_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t*yplane++ = (BYTE)((r_val &gt;&gt; 2) + (g_val &gt;&gt; 1) + (b_val &gt;&gt; 2));\n\t\t\t/* Perform color loss reduction here */\n\t\t\t*coplane++ = (BYTE)((r_val - b_val) &gt;&gt; ccl);\n\t\t\t*cgplane++ = (BYTE)((-(r_val &gt;&gt; 1) + g_val - (b_val &gt;&gt; 1)) &gt;&gt; ccl);\n\t\t\t*aplane++ = a_val;\n\t\t}\n\n\t\tif (context-&gt;ChromaSubsamplingLevel &amp;&amp; (x % 2) == 1)\n\t\t{\n\t\t\t*yplane = *(yplane - 1);\n\t\t\t*coplane = *(coplane - 1);\n\t\t\t*cgplane = *(cgplane - 1);\n\t\t}\n\t}\n\n\tif (context-&gt;ChromaSubsamplingLevel &amp;&amp; (y % 2) == 1)\n\t{\n\t\typlane = context-&gt;priv-&gt;PlaneBuffers[0] + y * rw;\n\t\tcoplane = context-&gt;priv-&gt;PlaneBuffers[1] + y * rw;\n\t\tcgplane = context-&gt;priv-&gt;PlaneBuffers[2] + y * rw;\n\t\tCopyMemory(yplane, yplane - rw, rw);\n\t\tCopyMemory(coplane, coplane - rw, rw);\n\t\tCopyMemory(cgplane, cgplane - rw, rw);\n\t}\n\n\treturn TRUE;\n}',
 'long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\n\t/* We can reliably get at most 31 bits since ISO/IEC 9899 only\n\t  guarantees that a long can represent values up to 2^31-1. */\n\t//assert(n &gt;= 0 &amp;&amp; n &lt; 32);\n\tif (n &lt; 0 || n &gt;= 32) {\n\t\treturn -1;\n\t}\n\n\t/* Get the number of bits requested from the specified bit stream. */\n\tv = 0;\n\twhile (--n &gt;= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) &lt; 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v &lt;&lt; 1) | u;\n\t}\n\treturn v;\n}',
 'static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tunsigned long reserve;\n\tunsigned long start;\n\tunsigned long end;\n\n\tif (reservations) {\n\t\tstart = vma_hugecache_offset(h, vma, vma-&gt;vm_start);\n\t\tend = vma_hugecache_offset(h, vma, vma-&gt;vm_end);\n\n\t\treserve = (end - start) -\n\t\t\tregion_count(&amp;reservations-&gt;regions, start, end);\n\n\t\tkref_put(&amp;reservations-&gt;refs, resv_map_release);\n\n\t\tif (reserve) {\n\t\t\thugetlb_acct_memory(h, -reserve);\n\t\t\thugetlb_put_quota(vma-&gt;vm_file-&gt;f_mapping, reserve);\n\t\t}\n\t}\n}',
 'TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* size_splits,\n                                 const TfLiteTensor* axis) {\n  int axis_value = GetTensorData&lt;int&gt;(axis)[0];\n  if (axis_value &lt; 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  std::vector&lt;int64_t&gt; size_splits_vector;\n  if (size_splits-&gt;type == kTfLiteInt32) {\n    GetSizeSplitsVector&lt;int32_t&gt;(size_splits, &amp;size_splits_vector);\n  } else if (size_splits-&gt;type == kTfLiteInt64) {\n    GetSizeSplitsVector&lt;int64_t&gt;(size_splits, &amp;size_splits_vector);\n  } else {\n    context-&gt;ReportError(context, "size_splits only support type int32|int64.");\n    return kTfLiteError;\n  }\n\n  int minus_one_index = -1;\n  int64_t size_splits_sum = 0;\n\n  for (int i = 0; i &lt; size_splits_vector.size(); ++i) {\n    if (size_splits_vector.at(i) == -1) {\n      if (minus_one_index == -1) {\n        minus_one_index = i;\n      } else {\n        context-&gt;ReportError(context,\n                             "The size_splits contains more than one -1.");\n      }\n    } else {\n      size_splits_sum += size_splits_vector.at(i);\n    }\n  }\n\n  const int input_size = SizeOfDimension(input, axis_value);\n\n  if (minus_one_index != -1) {\n    if (size_splits_sum &gt; input_size) {\n      context-&gt;ReportError(\n          context,\n          "The sum of size_splits must be less than the dimension of value.");\n    } else {\n      size_splits_vector[minus_one_index] = input_size - size_splits_sum;\n    }\n  } else if (size_splits_sum != input_size) {\n    context-&gt;ReportError(\n        context,\n        "The size_splits must sum to the dimension of value along axis.");\n  }\n\n  for (int i = 0; i &lt; NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input-&gt;dims);\n    output_dims-&gt;data[axis_value] = size_splits_vector.at(i);\n    TfLiteTensor* output = GetOutput(context, node, i);\n    TF_LITE_ENSURE_STATUS(context-&gt;ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}',
 'temac_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct cdmac_bd *cur_p;\n\tdma_addr_t tail_p, skb_dma_addr;\n\tint ii;\n\tunsigned long num_frag;\n\tskb_frag_t *frag;\n\n\tnum_frag = skb_shinfo(skb)-&gt;nr_frags;\n\tfrag = &amp;skb_shinfo(skb)-&gt;frags[0];\n\tcur_p = &amp;lp-&gt;tx_bd_v[lp-&gt;tx_bd_tail];\n\n\tif (temac_check_tx_bd_space(lp, num_frag + 1)) {\n\t\tif (netif_queue_stopped(ndev))\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tnetif_stop_queue(ndev);\n\n\t\t/* Matches barrier in temac_start_xmit_done */\n\t\tsmp_mb();\n\n\t\t/* Space might have just been freed - check again */\n\t\tif (temac_check_tx_bd_space(lp, num_frag))\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tnetif_wake_queue(ndev);\n\t}\n\n\tcur_p-&gt;app0 = 0;\n\tif (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {\n\t\tunsigned int csum_start_off = skb_checksum_start_offset(skb);\n\t\tunsigned int csum_index_off = csum_start_off + skb-&gt;csum_offset;\n\n\t\tcur_p-&gt;app0 |= cpu_to_be32(0x000001); /* TX Checksum Enabled */\n\t\tcur_p-&gt;app1 = cpu_to_be32((csum_start_off &lt;&lt; 16)\n\t\t\t\t\t  | csum_index_off);\n\t\tcur_p-&gt;app2 = 0;  /* initial checksum seed */\n\t}\n\n\tcur_p-&gt;app0 |= cpu_to_be32(STS_CTRL_APP0_SOP);\n\tskb_dma_addr = dma_map_single(ndev-&gt;dev.parent, skb-&gt;data,\n\t\t\t\t      skb_headlen(skb), DMA_TO_DEVICE);\n\tcur_p-&gt;len = cpu_to_be32(skb_headlen(skb));\n\tif (WARN_ON_ONCE(dma_mapping_error(ndev-&gt;dev.parent, skb_dma_addr))) {\n\t\tdev_kfree_skb_any(skb);\n\t\tndev-&gt;stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\tcur_p-&gt;phys = cpu_to_be32(skb_dma_addr);\n\n\tfor (ii = 0; ii &lt; num_frag; ii++) {\n\t\tif (++lp-&gt;tx_bd_tail &gt;= lp-&gt;tx_bd_num)\n\t\t\tlp-&gt;tx_bd_tail = 0;\n\n\t\tcur_p = &amp;lp-&gt;tx_bd_v[lp-&gt;tx_bd_tail];\n\t\tskb_dma_addr = dma_map_single(ndev-&gt;dev.parent,\n\t\t\t\t\t      skb_frag_address(frag),\n\t\t\t\t\t      skb_frag_size(frag),\n\t\t\t\t\t      DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(ndev-&gt;dev.parent, skb_dma_addr)) {\n\t\t\tif (--lp-&gt;tx_bd_tail &lt; 0)\n\t\t\t\tlp-&gt;tx_bd_tail = lp-&gt;tx_bd_num - 1;\n\t\t\tcur_p = &amp;lp-&gt;tx_bd_v[lp-&gt;tx_bd_tail];\n\t\t\twhile (--ii &gt;= 0) {\n\t\t\t\t--frag;\n\t\t\t\tdma_unmap_single(ndev-&gt;dev.parent,\n\t\t\t\t\t\t be32_to_cpu(cur_p-&gt;phys),\n\t\t\t\t\t\t skb_frag_size(frag),\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tif (--lp-&gt;tx_bd_tail &lt; 0)\n\t\t\t\t\tlp-&gt;tx_bd_tail = lp-&gt;tx_bd_num - 1;\n\t\t\t\tcur_p = &amp;lp-&gt;tx_bd_v[lp-&gt;tx_bd_tail];\n\t\t\t}\n\t\t\tdma_unmap_single(ndev-&gt;dev.parent,\n\t\t\t\t\t be32_to_cpu(cur_p-&gt;phys),\n\t\t\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tndev-&gt;stats.tx_dropped++;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tcur_p-&gt;phys = cpu_to_be32(skb_dma_addr);\n\t\tcur_p-&gt;len = cpu_to_be32(skb_frag_size(frag));\n\t\tcur_p-&gt;app0 = 0;\n\t\tfrag++;\n\t}\n\tcur_p-&gt;app0 |= cpu_to_be32(STS_CTRL_APP0_EOP);\n\n\t/* Mark last fragment with skb address, so it can be consumed\n\t * in temac_start_xmit_done()\n\t */\n\tptr_to_txbd((void *)skb, cur_p);\n\n\ttail_p = lp-&gt;tx_bd_p + sizeof(*lp-&gt;tx_bd_v) * lp-&gt;tx_bd_tail;\n\tlp-&gt;tx_bd_tail++;\n\tif (lp-&gt;tx_bd_tail &gt;= lp-&gt;tx_bd_num)\n\t\tlp-&gt;tx_bd_tail = 0;\n\n\tskb_tx_timestamp(skb);\n\n\t/* Kick off the transfer */\n\twmb();\n\tlp-&gt;dma_out(lp, TX_TAILDESC_PTR, tail_p); /* DMA start */\n\n\treturn NETDEV_TX_OK;\n}',
 'bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 &lt; sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&amp;rela-&gt;r_info) &gt;&gt; 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, "__libc_start_main")  // glibc\n        ||  0==strcmp(symnam, "__libc_init")  // Android\n        ||  0==strcmp(symnam, "__uClibc_main")\n        ||  0==strcmp(symnam, "__uClibc_start_main"))\n            return true;\n    }\n    return false;\n}',
 'gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree-&gt;car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, "Can\'t assign to numbered parameter");\n    break;\n\n  default:\n    codegen_error(s, "unknown lhs");\n    break;\n  }\n\n  tree = tree-&gt;cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx &gt; 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree-&gt;car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree-&gt;cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree-&gt;cdr-&gt;car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree-&gt;car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree-&gt;car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree-&gt;cdr-&gt;cdr-&gt;car;\n      if (tree) {\n        if (tree-&gt;car) {            /* positional arguments */\n          n = gen_values(s, tree-&gt;car, VAL, (tree-&gt;cdr-&gt;car)?13:14);\n          if (n &lt; 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree-&gt;cdr-&gt;car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree-&gt;cdr-&gt;car-&gt;cdr, VAL, 0);\n          if (n &lt; 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n &lt; 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s-&gt;sp = call;\n      if (mid == MRB_OPSYM_2(s-&gt;mrb, aref) &amp;&amp; n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s-&gt;sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_vmassignment(s, tree-&gt;car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, "unknown lhs");\n    break;\n  }\n  if (val) push();\n}',
 'static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr-&gt;sadb_msg_satype &gt; SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr-&gt;sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk-&gt;registered&amp;(1&lt;&lt;hdr-&gt;sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk-&gt;registered |= (1&lt;&lt;hdr-&gt;sadb_msg_satype);\n\t}\n\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr-&gt;sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk-&gt;registered &amp;= ~(1&lt;&lt;hdr-&gt;sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}',
 'void bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\tstruct bpf_binary_header *header = NULL;\n\tint proglen, oldproglen = 0;\n\tstruct jit_context ctx = {};\n\tu8 *image = NULL;\n\tint *addrs;\n\tint pass;\n\tint i;\n\n\tif (!bpf_jit_enable)\n\t\treturn;\n\n\tif (!prog || !prog-&gt;len)\n\t\treturn;\n\n\taddrs = kmalloc(prog-&gt;len * sizeof(*addrs), GFP_KERNEL);\n\tif (!addrs)\n\t\treturn;\n\n\t/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t */\n\tfor (proglen = 0, i = 0; i &lt; prog-&gt;len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\n\tfor (pass = 0; pass &lt; 10; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &amp;ctx);\n\t\tif (proglen &lt;= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err("bpf_jit: proglen=%d != oldproglen=%d\\n",\n\t\t\t\t       proglen, oldproglen);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\theader = bpf_jit_binary_alloc(proglen, &amp;image,\n\t\t\t\t\t\t      1, jit_fill_hole);\n\t\t\tif (!header)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\n\tif (bpf_jit_enable &gt; 1)\n\t\tbpf_jit_dump(prog-&gt;len, proglen, 0, image);\n\n\tif (image) {\n\t\tbpf_flush_icache(header, image + proglen);\n\t\tset_memory_ro((unsigned long)header, header-&gt;pages);\n\t\tprog-&gt;bpf_func = (void *)image;\n\t\tprog-&gt;jited = true;\n\t}\nout:\n\tkfree(addrs);\n}',
 'void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &amp;x1, &amp;y1, &amp;w1, &amp;h1, "rfbScaledScreenUpdateRect");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen-&gt;bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen-&gt;frameBuffer +\n     (y0 * screen-&gt;paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr-&gt;frameBuffer +\n     ( y1 * ptr-&gt;paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) &gt; (ptr-&gt;width))\n    {\n      if (x1==0) w1=ptr-&gt;width; else x1 = ptr-&gt;width - w1;\n    }\n    if ((y1+h1) &gt; (ptr-&gt;height))\n    {\n      if (y1==0) h1=ptr-&gt;height; else y1 = ptr-&gt;height - h1;\n    }\n    /*\n     * rfbLog("rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  -&gt;  %dXx%dY-%dWx%dH &lt;%dx%d&gt;) {%dWx%dH -&gt; %dWx%dH} 0x%p\\n",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen-&gt;width, screen-&gt;height, ptr-&gt;width, ptr-&gt;height, ptr-&gt;frameBuffer);\n     */\n\n    if (screen-&gt;serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen-&gt;serverFormat.redShift;\n      unsigned int greenShift = screen-&gt;serverFormat.greenShift;\n      unsigned int blueShift = screen-&gt;serverFormat.blueShift;\n      unsigned long redMax = screen-&gt;serverFormat.redMax;\n      unsigned long greenMax = screen-&gt;serverFormat.greenMax;\n      unsigned long blueMax = screen-&gt;serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y &lt; h1; y++) {\n       for (x = 0; x &lt; w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w &lt; areaX; w++) {\n           for (v = 0; v &lt; areaY; v++) {\n             srcptr2 = &amp;srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen-&gt;paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z &lt; bytesPerPixel; z++)\n                 pixel_value += ((unsigned long)srcptr2[z] &lt;&lt; (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value &gt;&gt; redShift) &amp; redMax);\n            green += ((pixel_value &gt;&gt; greenShift) &amp; greenMax);\n            blue += ((pixel_value &gt;&gt; blueShift) &amp; blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red &amp; redMax) &lt;&lt; redShift) | ((green &amp; greenMax) &lt;&lt; greenShift) | ((blue &amp; blueMax) &lt;&lt; blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z &lt; bytesPerPixel; z++)\n             dstptr[z]=(pixel_value &gt;&gt; (8 * z)) &amp; 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen-&gt;paddedWidthInBytes * areaY);\n       dstptr += (ptr-&gt;paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can\'t blend. Just use the top-left pixel instead */\n     for (y = y1; y &lt; (y1+h1); y++) {\n       for (x = x1; x &lt; (x1+w1); x++)\n         memcpy (&amp;ptr-&gt;frameBuffer[(y *ptr-&gt;paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &amp;screen-&gt;frameBuffer[(y * areaY * screen-&gt;paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}',
 'DSA_PrivateKey::create_signature_op(RandomNumberGenerator&amp; rng,\n                                    const std::string&amp; params,\n                                    const std::string&amp; provider) const\n   {\n   if(provider == "base" || provider.empty())\n      return std::unique_ptr&lt;PK_Ops::Signature&gt;(new DSA_Signature_Operation(*this, params, rng));\n   throw Provider_Not_Found(algo_name(), provider);\n   }',
 '  std::shared_ptr&lt;Grammar&gt; perform_core(const char *s, size_t n,\n                                        const Rules &amp;rules, std::string &amp;start,\n                                        Log log) {\n    Data data;\n    any dt = &amp;data;\n    auto r = g["Grammar"].parse(s, n, dt);\n\n    if (!r.ret) {\n      if (log) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, "syntax error");\n        }\n      }\n      return nullptr;\n    }\n\n    auto &amp;grammar = *data.grammar;\n\n    // User provided rules\n    for (const auto &amp;x : rules) {\n      auto name = x.first;\n      bool ignore = false;\n      if (!name.empty() &amp;&amp; name[0] == \'~\') {\n        ignore = true;\n        name.erase(0, 1);\n      }\n      if (!name.empty()) {\n        auto &amp;rule = grammar[name];\n        rule &lt;= x.second;\n        rule.name = name;\n        rule.ignoreSemanticValue = ignore;\n      }\n    }\n\n    // Check duplicated definitions\n    bool ret = data.duplicates.empty();\n\n    for (const auto &amp;x : data.duplicates) {\n      if (log) {\n        const auto &amp;name = x.first;\n        auto ptr = x.second;\n        auto line = line_info(s, ptr);\n        log(line.first, line.second, "\'" + name + "\' is already defined.");\n      }\n    }\n\n    // Check if the start rule has ignore operator\n    {\n      auto &amp;rule = grammar[data.start];\n      if (rule.ignoreSemanticValue) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              "Ignore operator cannot be applied to \'" + rule.name + "\'.");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Check missing definitions\n    for (auto &amp;x : grammar) {\n      auto &amp;rule = x.second;\n\n      ReferenceChecker vis(*data.grammar, rule.params);\n      rule.accept(vis);\n      for (const auto &amp;y : vis.error_s) {\n        const auto &amp;name = y.first;\n        const auto ptr = y.second;\n        if (log) {\n          auto line = line_info(s, ptr);\n          log(line.first, line.second, vis.error_message[name]);\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Link references\n    for (auto &amp;x : grammar) {\n      auto &amp;rule = x.second;\n      LinkReferences vis(*data.grammar, rule.params);\n      rule.accept(vis);\n    }\n\n    // Check left recursion\n    ret = true;\n\n    for (auto &amp;x : grammar) {\n      const auto &amp;name = x.first;\n      auto &amp;rule = x.second;\n\n      DetectLeftRecursion vis(name);\n      rule.accept(vis);\n      if (vis.error_s) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second, "\'" + name + "\' is left recursive.");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Set root definition\n    auto &amp;start_rule = (*data.grammar)[data.start];\n\n    // Check infinite loop\n    {\n      DetectInfiniteLoop vis(data.start_pos, data.start);\n      start_rule.accept(vis);\n      if (vis.has_error) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second,\n              "infinite loop is detected in \'" + vis.error_name + "\'.");\n        }\n        return nullptr;\n      }\n    }\n\n    // Automatic whitespace skipping\n    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {\n      for (auto &amp;x : grammar) {\n        auto &amp;rule = x.second;\n        auto ope = rule.get_core_operator();\n        if (IsLiteralToken::check(*ope)) { rule &lt;= tok(ope); }\n      }\n\n      start_rule.whitespaceOpe =\n          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());\n    }\n\n    // Word expression\n    if (grammar.count(WORD_DEFINITION_NAME)) {\n      start_rule.wordOpe =\n          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();\n    }\n\n    // Apply instructions\n    for (const auto &amp;item : data.instructions) {\n      const auto &amp;name = item.first;\n      const auto &amp;instruction = item.second;\n      auto &amp;rule = grammar[name];\n\n      if (instruction.type == "precedence") {\n        const auto &amp;info =\n            any_cast&lt;PrecedenceClimbing::BinOpeInfo&gt;(instruction.data);\n\n        if (!apply_precedence_instruction(rule, info, s, log)) {\n          return nullptr;\n        }\n      }\n    }\n\n    // Set root definition\n    start = data.start;\n\n    return data.grammar;\n  }',
 'static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t-&gt;u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)-&gt;verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}',
 'static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\n\tif (len &lt; ndp_msg_type_info(msg_type)-&gt;raw_struct_size)\n\t\treturn false;\n\n\tif (ndp_msg_type_info(msg_type)-&gt;addrto_validate)\n\t\treturn ndp_msg_type_info(msg_type)-&gt;addrto_validate(&amp;msg-&gt;addrto);\n\telse\n\t\treturn true;\n}',
 'static inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)-&gt;daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)-&gt;saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)-&gt;dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)-&gt;dccph_sport     );\n\n}',
 'AP4_Processor::Process(AP4_ByteStream&amp;   input, \n                       AP4_ByteStream&amp;   output,\n                       AP4_ByteStream*   fragments,\n                       ProgressListener* listener,\n                       AP4_AtomFactory&amp;  atom_factory)\n{\n    // read all atoms.\n    // keep all atoms except [mdat]\n    // keep a ref to [moov]\n    // put [moof] atoms in a separate list\n    AP4_AtomParent              top_level;\n    AP4_MoovAtom*               moov = NULL;\n    AP4_ContainerAtom*          mfra = NULL;\n    AP4_SidxAtom*               sidx = NULL;\n    AP4_List&lt;AP4_AtomLocator&gt;   frags;\n    AP4_UI64                    stream_offset = 0;\n    bool                        in_fragments = false;\n    unsigned int                sidx_count = 0;\n    for (AP4_Atom* atom = NULL;\n        AP4_SUCCEEDED(atom_factory.CreateAtomFromStream(input, atom));\n        input.Tell(stream_offset)) {\n        if (atom-&gt;GetType() == AP4_ATOM_TYPE_MDAT) {\n            delete atom;\n            continue;\n        } else if (atom-&gt;GetType() == AP4_ATOM_TYPE_MOOV) {\n            moov = AP4_DYNAMIC_CAST(AP4_MoovAtom, atom);\n            if (fragments) break;\n        } else if (atom-&gt;GetType() == AP4_ATOM_TYPE_MFRA) {\n            mfra = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n            continue;\n        } else if (atom-&gt;GetType() == AP4_ATOM_TYPE_SIDX) {\n            // don\'t keep the index, it is likely to be invalidated, we will recompute it later\n            ++sidx_count;\n            if (sidx == NULL) {\n                sidx = AP4_DYNAMIC_CAST(AP4_SidxAtom, atom);\n            } else {\n                delete atom;\n                continue;\n            }\n        } else if (atom-&gt;GetType() == AP4_ATOM_TYPE_SSIX) {\n            // don\'t keep the index, it is likely to be invalidated\n            delete atom;\n            continue;\n        } else if (!fragments &amp;&amp; (in_fragments || atom-&gt;GetType() == AP4_ATOM_TYPE_MOOF)) {\n            in_fragments = true;\n            frags.Add(new AP4_AtomLocator(atom, stream_offset));\n            continue;\n        }\n        top_level.AddChild(atom);\n    }\n\n    // check that we have at most one sidx (we can\'t deal with multi-sidx streams here\n    if (sidx_count &gt; 1) {\n        top_level.RemoveChild(sidx);\n        delete sidx;\n        sidx = NULL;\n    }\n    \n    // if we have a fragments stream, get the fragment locators from there\n    if (fragments) {\n        stream_offset = 0;\n        for (AP4_Atom* atom = NULL;\n            AP4_SUCCEEDED(atom_factory.CreateAtomFromStream(*fragments, atom));\n            fragments-&gt;Tell(stream_offset)) {\n            if (atom-&gt;GetType() == AP4_ATOM_TYPE_MDAT) {\n                delete atom;\n                continue;\n            }\n            frags.Add(new AP4_AtomLocator(atom, stream_offset));\n        }\n    }\n    \n    // initialize the processor\n    AP4_Result result = Initialize(top_level, input);\n    if (AP4_FAILED(result)) return result;\n\n    // process the tracks if we have a moov atom\n    AP4_Array&lt;AP4_SampleLocator&gt; locators;\n    AP4_Cardinal                 track_count       = 0;\n    AP4_List&lt;AP4_TrakAtom&gt;*      trak_atoms        = NULL;\n    AP4_LargeSize                mdat_payload_size = 0;\n    AP4_SampleCursor*            cursors           = NULL;\n    if (moov) {\n        // build an array of track sample locators\n        trak_atoms = &amp;moov-&gt;GetTrakAtoms();\n        track_count = trak_atoms-&gt;ItemCount();\n        cursors = new AP4_SampleCursor[track_count];\n        m_TrackHandlers.SetItemCount(track_count);\n        m_TrackIds.SetItemCount(track_count);\n        for (AP4_Ordinal i=0; i&lt;track_count; i++) {\n            m_TrackHandlers[i] = NULL;\n            m_TrackIds[i] = 0;\n        }\n        \n        unsigned int index = 0;\n        for (AP4_List&lt;AP4_TrakAtom&gt;::Item* item = trak_atoms-&gt;FirstItem(); item; item=item-&gt;GetNext()) {\n            AP4_TrakAtom* trak = item-&gt;GetData();\n\n            // find the stsd atom\n            AP4_ContainerAtom* stbl = AP4_DYNAMIC_CAST(AP4_ContainerAtom, trak-&gt;FindChild("mdia/minf/stbl"));\n            if (stbl == NULL) continue;\n            \n            // see if there\'s an external data source for this track\n            AP4_ByteStream* trak_data_stream = &amp;input;\n            for (AP4_List&lt;ExternalTrackData&gt;::Item* ditem = m_ExternalTrackData.FirstItem(); ditem; ditem=ditem-&gt;GetNext()) {\n                ExternalTrackData* tdata = ditem-&gt;GetData();\n                if (tdata-&gt;m_TrackId == trak-&gt;GetId()) {\n                    trak_data_stream = tdata-&gt;m_MediaData;\n                    break;\n                }\n            }\n\n            // create the track handler    \n            m_TrackHandlers[index] = CreateTrackHandler(trak);\n            m_TrackIds[index]      = trak-&gt;GetId();\n            cursors[index].m_Locator.m_TrakIndex   = index;\n            cursors[index].m_Locator.m_SampleTable = new AP4_AtomSampleTable(stbl, *trak_data_stream);\n            cursors[index].m_Locator.m_SampleIndex = 0;\n            cursors[index].m_Locator.m_ChunkIndex  = 0;\n            if (cursors[index].m_Locator.m_SampleTable-&gt;GetSampleCount()) {\n                cursors[index].m_Locator.m_SampleTable-&gt;GetSample(0, cursors[index].m_Locator.m_Sample);\n            } else {\n                cursors[index].m_EndReached = true;\n            }\n\n            index++;            \n        }\n\n        // figure out the layout of the chunks\n        for (;;) {\n            // see which is the next sample to write\n            AP4_UI64 min_offset = (AP4_UI64)(-1);\n            int cursor = -1;\n            for (unsigned int i=0; i&lt;track_count; i++) {\n                if (!cursors[i].m_EndReached &amp;&amp;\n                    cursors[i].m_Locator.m_SampleTable &amp;&amp;\n                    cursors[i].m_Locator.m_Sample.GetOffset() &lt;= min_offset) {\n                    min_offset = cursors[i].m_Locator.m_Sample.GetOffset();\n                    cursor = i;\n                }\n            }\n\n            // stop if all cursors are exhausted\n            if (cursor == -1) break;\n\n            // append this locator to the layout list\n            AP4_SampleLocator&amp; locator = cursors[cursor].m_Locator;\n            locators.Append(locator);\n\n            // move the cursor to the next sample\n            locator.m_SampleIndex++;\n            if (locator.m_SampleIndex == locator.m_SampleTable-&gt;GetSampleCount()) {\n                // mark this track as completed\n                cursors[cursor].m_EndReached = true;\n            } else {\n                // get the next sample info\n                locator.m_SampleTable-&gt;GetSample(locator.m_SampleIndex, locator.m_Sample);\n                AP4_Ordinal skip, sdesc;\n                locator.m_SampleTable-&gt;GetChunkForSample(locator.m_SampleIndex,\n                                                         locator.m_ChunkIndex,\n                                                         skip, sdesc);\n            }\n        }\n\n        // update the stbl atoms and compute the mdat size\n        int current_track = -1;\n        int current_chunk = -1;\n        AP4_Position current_chunk_offset = 0;\n        AP4_Size current_chunk_size = 0;\n        for (AP4_Ordinal i=0; i&lt;locators.ItemCount(); i++) {\n            AP4_SampleLocator&amp; locator = locators[i];\n            if ((int)locator.m_TrakIndex  != current_track ||\n                (int)locator.m_ChunkIndex != current_chunk) {\n                // start a new chunk for this track\n                current_chunk_offset += current_chunk_size;\n                current_chunk_size = 0;\n                current_track = locator.m_TrakIndex;\n                current_chunk = locator.m_ChunkIndex;\n                locator.m_SampleTable-&gt;SetChunkOffset(locator.m_ChunkIndex, current_chunk_offset);\n            } \n            AP4_Size sample_size;\n            TrackHandler* handler = m_TrackHandlers[locator.m_TrakIndex];\n            if (handler) {\n                sample_size = handler-&gt;GetProcessedSampleSize(locator.m_Sample);\n                locator.m_SampleTable-&gt;SetSampleSize(locator.m_SampleIndex, sample_size);\n            } else {\n                sample_size = locator.m_Sample.GetSize();\n            }\n            current_chunk_size += sample_size;\n            mdat_payload_size  += sample_size;\n        }\n\n        // process the tracks (ex: sample descriptions processing)\n        for (AP4_Ordinal i=0; i&lt;track_count; i++) {\n            TrackHandler* handler = m_TrackHandlers[i];\n            if (handler) handler-&gt;ProcessTrack();\n        }\n    }\n\n    // finalize the processor\n    Finalize(top_level);\n\n    if (!fragments) {\n        // calculate the size of all atoms combined\n        AP4_UI64 atoms_size = 0;\n        top_level.GetChildren().Apply(AP4_AtomSizeAdder(atoms_size));\n\n        // see if we need a 64-bit or 32-bit mdat\n        AP4_Size mdat_header_size = AP4_ATOM_HEADER_SIZE;\n        if (mdat_payload_size+mdat_header_size &gt; 0xFFFFFFFF) {\n            // we need a 64-bit size\n            mdat_header_size += 8;\n        }\n        \n        // adjust the chunk offsets\n        for (AP4_Ordinal i=0; i&lt;track_count; i++) {\n            AP4_TrakAtom* trak;\n            trak_atoms-&gt;Get(i, trak);\n            trak-&gt;AdjustChunkOffsets(atoms_size+mdat_header_size);\n        }\n\n        // write all atoms\n        top_level.GetChildren().Apply(AP4_AtomListWriter(output));\n\n        // write mdat header\n        if (mdat_payload_size) {\n            if (mdat_header_size == AP4_ATOM_HEADER_SIZE) {\n                // 32-bit size\n                output.WriteUI32((AP4_UI32)(mdat_header_size+mdat_payload_size));\n                output.WriteUI32(AP4_ATOM_TYPE_MDAT);\n            } else {\n                // 64-bit size\n                output.WriteUI32(1);\n                output.WriteUI32(AP4_ATOM_TYPE_MDAT);\n                output.WriteUI64(mdat_header_size+mdat_payload_size);\n            }\n        }        \n    }\n    \n    // write the samples\n    if (moov) {\n        if (!fragments) {\n#if defined(AP4_DEBUG)\n            AP4_Position before;\n            output.Tell(before);\n#endif\n            AP4_Sample     sample;\n            AP4_DataBuffer data_in;\n            AP4_DataBuffer data_out;\n            for (unsigned int i=0; i&lt;locators.ItemCount(); i++) {\n                AP4_SampleLocator&amp; locator = locators[i];\n                locator.m_Sample.ReadData(data_in);\n                TrackHandler* handler = m_TrackHandlers[locator.m_TrakIndex];\n                if (handler) {\n                    result = handler-&gt;ProcessSample(data_in, data_out);\n                    if (AP4_FAILED(result)) return result;\n                    output.Write(data_out.GetData(), data_out.GetDataSize());\n                } else {\n                    output.Write(data_in.GetData(), data_in.GetDataSize());            \n                }\n\n                // notify the progress listener\n                if (listener) {\n                    listener-&gt;OnProgress(i+1, locators.ItemCount());\n                }\n            }\n\n#if defined(AP4_DEBUG)\n            AP4_Position after;\n            output.Tell(after);\n            AP4_ASSERT(after-before == mdat_payload_size);\n#endif\n        }\n        \n        // find the position of the sidx atom\n        AP4_Position sidx_position = 0;\n        if (sidx) {\n            for (AP4_List&lt;AP4_Atom&gt;::Item* item = top_level.GetChildren().FirstItem();\n                                           item;\n                                           item = item-&gt;GetNext()) {\n                AP4_Atom* atom = item-&gt;GetData();\n                if (atom-&gt;GetType() == AP4_ATOM_TYPE_SIDX) {\n                    break;\n                }\n                sidx_position += atom-&gt;GetSize();\n            }\n        }\n        \n        // process the fragments, if any\n        result = ProcessFragments(moov, frags, mfra, sidx, sidx_position, fragments?*fragments:input, output);\n        if (AP4_FAILED(result)) return result;\n        \n        // update and re-write the sidx if we have one\n        if (sidx &amp;&amp; sidx_position) {\n            AP4_Position where = 0;\n            output.Tell(where);\n            output.Seek(sidx_position);\n            result = sidx-&gt;Write(output);\n            if (AP4_FAILED(result)) return result;\n            output.Seek(where);\n        }\n        \n        if (!fragments) {\n            // write the mfra atom at the end if we have one\n            if (mfra) {\n                mfra-&gt;Write(output);\n            }\n        }\n        \n        // cleanup\n        for (AP4_Ordinal i=0; i&lt;track_count; i++) {\n            delete cursors[i].m_Locator.m_SampleTable;\n            delete m_TrackHandlers[i];\n        }\n        m_TrackHandlers.Clear();\n        delete[] cursors;\n    }\n\n    // cleanup\n    frags.DeleteReferences();\n    delete mfra;\n    \n    return AP4_SUCCESS;\n}',
 'static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tns-&gt;shm_tot -= (shp-&gt;shm_segsz + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shp-&gt;shm_file))\n\t\tshmem_lock(shp-&gt;shm_file, 0, shp-&gt;mlock_user);\n\telse if (shp-&gt;mlock_user)\n\t\tuser_shm_unlock(file_inode(shp-&gt;shm_file)-&gt;i_size,\n\t\t\t\t\t\tshp-&gt;mlock_user);\n\tfput (shp-&gt;shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}',
 'static inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = \'\\0\';\n    const char *protoname = "?";\n    unsigned short port = 0;\n\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &amp;((struct sockaddr_in *)sock_addr)-&gt;sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)-&gt;sin_port);\n            protoname = IS_UDP(c-&gt;transport) ? "udp" : "tcp";\n            break;\n\n        case AF_INET6:\n            addr_text[0] = \'[\';\n            addr_text[1] = \'\\0\';\n            if (inet_ntop(af,\n                    &amp;((struct sockaddr_in6 *)sock_addr)-&gt;sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, "]");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)-&gt;sin6_port);\n            protoname = IS_UDP(c-&gt;transport) ? "udp6" : "tcp6";\n            break;\n\n        case AF_UNIX:\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)-&gt;sun_path,\n                    sizeof(addr_text) - 1);\n            addr_text[sizeof(addr_text)-1] = \'\\0\';\n            protoname = "unix";\n            break;\n    }\n\n    if (strlen(addr_text) &lt; 2) {\n        /* Most likely this is a connected UNIX-domain client which\n         * has no peer socket address, but there\'s no portable way\n         * to tell for sure.\n         */\n        sprintf(addr_text, "&lt;AF %d&gt;", af);\n    }\n\n    if (port) {\n        sprintf(addr, "%s:%s:%u", protoname, addr_text, port);\n    } else {\n        sprintf(addr, "%s:%s", protoname, addr_text);\n    }\n}',
 "static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\t/* Allow mapping to your own filesystem ids */\n\tif ((new_map-&gt;nr_extents == 1) &amp;&amp; (new_map-&gt;extent[0].count == 1)) {\n\t\tu32 id = new_map-&gt;extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns-&gt;parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns-&gt;parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n\t */\n\tif (ns_capable(ns-&gt;parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}",
 'CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext&amp; config,\n    Api::Api&amp; api)\n    : ca_cert_(Config::DataSource::read(config.trusted_ca(), true, api)),\n      ca_cert_path_(Config::DataSource::getPath(config.trusted_ca())\n                        .value_or(ca_cert_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      certificate_revocation_list_(Config::DataSource::read(config.crl(), true, api)),\n      certificate_revocation_list_path_(\n          Config::DataSource::getPath(config.crl())\n              .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      subject_alt_name_matchers_(getSubjectAltNameMatchers(config)),\n      verify_certificate_hash_list_(config.verify_certificate_hash().begin(),\n                                    config.verify_certificate_hash().end()),\n      verify_certificate_spki_list_(config.verify_certificate_spki().begin(),\n                                    config.verify_certificate_spki().end()),\n      allow_expired_certificate_(config.allow_expired_certificate()),\n      trust_chain_verification_(config.trust_chain_verification()),\n      custom_validator_config_(\n          config.has_custom_validator_config()\n              ? absl::make_optional&lt;envoy::config::core::v3::TypedExtensionConfig&gt;(\n                    config.custom_validator_config())\n              : absl::nullopt),\n      api_(api), only_verify_leaf_cert_crl_(config.only_verify_leaf_cert_crl()) {\n  if (ca_cert_.empty() &amp;&amp; custom_validator_config_ == absl::nullopt) {\n    if (!certificate_revocation_list_.empty()) {\n      throw EnvoyException(fmt::format("Failed to load CRL from {} without trusted CA",\n                                       certificateRevocationListPath()));\n    }\n    if (!subject_alt_name_matchers_.empty()) {\n      throw EnvoyException("SAN-based verification of peer certificates without "\n                           "trusted CA is insecure and not allowed");\n    }\n    if (allow_expired_certificate_) {\n      throw EnvoyException("Certificate validity period is always ignored without trusted CA");\n    }\n  }\n}',
 'TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params =\n      reinterpret_cast&lt;TfLiteUnidirectionalSequenceLSTMParams*&gt;(\n          node-&gt;builtin_data);\n  const OpData* op_data = reinterpret_cast&lt;OpData*&gt;(node-&gt;user_data);\n  const bool is_layer_norm_lstm = op_data-&gt;is_layer_norm_lstm;\n  const bool time_major = params-&gt;time_major;\n  const TfLiteTensor* input = GetInput(context, node, lstm::full::kInputTensor);\n\n  const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, lstm::full::kInputToForgetWeightsTensor);\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, lstm::full::kInputToCellWeightsTensor);\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, lstm::full::kInputToOutputWeightsTensor);\n\n  const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, lstm::full::kRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, lstm::full::kRecurrentToCellWeightsTensor);\n  const TfLiteTensor* recurrent_to_output_weights =\n      GetInput(context, node, lstm::full::kRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* cell_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToInputWeightsTensor);\n  const TfLiteTensor* cell_to_forget_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToForgetWeightsTensor);\n  const TfLiteTensor* cell_to_output_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToOutputWeightsTensor);\n\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, lstm::full::kInputGateBiasTensor);\n  const TfLiteTensor* forget_gate_bias =\n      GetInput(context, node, lstm::full::kForgetGateBiasTensor);\n  const TfLiteTensor* cell_gate_bias =\n      GetInput(context, node, lstm::full::kCellGateBiasTensor);\n  const TfLiteTensor* output_gate_bias =\n      GetInput(context, node, lstm::full::kOutputGateBiasTensor);\n\n  const TfLiteTensor* projection_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, lstm::full::kProjectionBiasTensor);\n\n  // Index the scratch buffers pointers to the global scratch buffer.\n  TfLiteTensor* scratch_buffer = GetTemporary(context, node, kScratchBuffer);\n\n  TfLiteTensor* output_state =\n      GetVariableInput(context, node, lstm::full::kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n  TfLiteTensor* cell_state =\n      GetVariableInput(context, node, lstm::full::kCellStateTensor);\n  TF_LITE_ENSURE(context, cell_state != nullptr);\n\n  const TfLiteTensor* input_layer_norm_coefficients =\n      is_layer_norm_lstm\n          ? GetOptionalInputTensor(\n                context, node, lstm::full::kInputLayerNormCoefficientsTensor)\n          : nullptr;\n  const TfLiteTensor* forget_layer_norm_coefficients =\n      is_layer_norm_lstm\n          ? GetInput(context, node,\n                     lstm::full::kForgetLayerNormCoefficientsTensor)\n          : nullptr;\n  const TfLiteTensor* cell_layer_norm_coefficients =\n      is_layer_norm_lstm\n          ? GetInput(context, node,\n                     lstm::full::kCellLayerNormCoefficientsTensor)\n          : nullptr;\n  const TfLiteTensor* output_layer_norm_coefficients =\n      is_layer_norm_lstm\n          ? GetInput(context, node,\n                     lstm::full::kOutputLayerNormCoefficientsTensor)\n          : nullptr;\n\n  TfLiteTensor* output = GetOutput(context, node, lstm::full::kOutputTensor);\n\n  // Copy out the LSTM specific params so they can be passed in the function.\n  TfLiteLSTMParams lstm_params;\n  lstm_params.activation = params-&gt;activation;\n  lstm_params.cell_clip = params-&gt;cell_clip;\n  lstm_params.proj_clip = params-&gt;proj_clip;\n  lstm_params.asymmetric_quantize_inputs = params-&gt;asymmetric_quantize_inputs;\n\n  switch (input_to_output_weights-&gt;type) {\n    case kTfLiteFloat32: {\n      return lstm_eval::EvalFloat(\n          input, input_to_input_weights, input_to_forget_weights,\n          input_to_cell_weights, input_to_output_weights,\n          recurrent_to_input_weights, recurrent_to_forget_weights,\n          recurrent_to_cell_weights, recurrent_to_output_weights,\n          cell_to_input_weights, cell_to_forget_weights, cell_to_output_weights,\n          input_layer_norm_coefficients, forget_layer_norm_coefficients,\n          cell_layer_norm_coefficients, output_layer_norm_coefficients,\n          /*aux_input=*/nullptr,\n          /*aux_input_to_input_weights=*/nullptr,\n          /*aux_input_to_forget_weights=*/nullptr,\n          /*aux_input_to_cell_weights=*/nullptr,\n          /*aux_input_to_output_weights=*/nullptr, input_gate_bias,\n          forget_gate_bias, cell_gate_bias, output_gate_bias,\n          projection_weights, projection_bias, &amp;lstm_params,\n          /*forward_sequence=*/true, time_major,\n          /*output_offset=*/0, scratch_buffer, output_state, cell_state,\n          output);\n    }\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      OpData* op_data = reinterpret_cast&lt;OpData*&gt;(node-&gt;user_data);\n      TfLiteTensor* row_sums = GetTemporary(context, node, kRowSums);\n      const int row_sums_size = row_sums-&gt;dims-&gt;data[0];\n      return lstm_eval::EvalHybrid(\n          input, input_to_input_weights,\n          /*input_to_input_weights_ledger*/ nullptr, input_to_forget_weights,\n          /*input_to_forget_weights_ledger*/ nullptr, input_to_cell_weights,\n          /*input_to_cell_weights_ledger*/ nullptr, input_to_output_weights,\n          /*input_to_output_weights_ledger*/ nullptr,\n          recurrent_to_input_weights,\n          /*recurrent_to_input_weights_ledger*/ nullptr,\n          recurrent_to_forget_weights,\n          /*recurrent_to_forget_weights_ledger*/ nullptr,\n          recurrent_to_cell_weights,\n          /*recurrent_to_cell_weights_ledger*/ nullptr,\n          recurrent_to_output_weights,\n          /*recurrent_to_output_weights_ledger*/ nullptr, cell_to_input_weights,\n          cell_to_forget_weights, cell_to_output_weights,\n          input_layer_norm_coefficients, forget_layer_norm_coefficients,\n          cell_layer_norm_coefficients, output_layer_norm_coefficients,\n          /*aux_input=*/nullptr,\n          /*aux_input_to_input_weights=*/nullptr,\n          /*aux_input_to_forget_weights=*/nullptr,\n          /*aux_input_to_cell_weights=*/nullptr,\n          /*aux_input_to_output_weights=*/nullptr, input_gate_bias,\n          forget_gate_bias, cell_gate_bias, output_gate_bias,\n          projection_weights, /*projection_weights_ledger*/ nullptr,\n          projection_bias, &amp;lstm_params,\n          /*forward_sequence=*/true, time_major,\n          /*output_offset=*/0, scratch_buffer,\n          GetTemporary(context, node, kInputScalingFactors),\n          /*aux_input_sf=*/nullptr,\n          GetTemporary(context, node, kOutputStateScalingFactors),\n          GetTemporary(context, node, kProductScalingFactors),\n          GetTemporary(context, node, kRecoveredCellWeights),\n          GetTemporary(context, node, kInputQuantized),\n          /*aux_input_quantized=*/nullptr,\n          GetTemporary(context, node, kOutputStateQuantized),\n          GetTemporary(context, node, kCellStateQuantized), output_state,\n          cell_state, GetTemporary(context, node, kAccumScratch), output,\n          GetTemporary(context, node, kInputZeroPoints),\n          /*aux_input_zp=*/nullptr,\n          GetTemporary(context, node, kOutputStateZeroPoints), row_sums,\n          row_sums_size, &amp;op_data-&gt;compute_row_sums,\n          CpuBackendContext::GetFromContext(context));\n    }\n    default:\n      TF_LITE_KERNEL_LOG(context, "Type %s is not currently supported.",\n                         TfLiteTypeGetName(input_to_output_weights-&gt;type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}',
 'jas_image_t *jas_image_create0()\n{\n\tjas_image_t *image;\n\n\tif (!(image = jas_malloc(sizeof(jas_image_t)))) {\n\t\treturn 0;\n\t}\n\n\timage-&gt;tlx_ = 0;\n\timage-&gt;tly_ = 0;\n\timage-&gt;brx_ = 0;\n\timage-&gt;bry_ = 0;\n\timage-&gt;clrspc_ = JAS_CLRSPC_UNKNOWN;\n\timage-&gt;numcmpts_ = 0;\n\timage-&gt;maxcmpts_ = 0;\n\timage-&gt;cmpts_ = 0;\n\timage-&gt;inmem_ = true;\n\timage-&gt;cmprof_ = 0;\n\n\treturn image;\n}',
 'static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session )\n{\n    TPM_RC rval;\n    TPM2B_ENCRYPTED_SECRET key;\n    char label[] = "ATH";\n    UINT16 bytes;\n    int i;\n\n    key.t.size = 0;\n\n    if( session-&gt;nonceOlder.t.size == 0 )\n    {\n        /* this is an internal routine to TSS and should be removed */\n        session-&gt;nonceOlder.t.size = GetDigestSize( TPM_ALG_SHA1 );\n        for( i = 0; i &lt; session-&gt;nonceOlder.t.size; i++ )\n            session-&gt;nonceOlder.t.buffer[i] = 0;\n    }\n\n    session-&gt;nonceNewer.t.size = session-&gt;nonceOlder.t.size;\n    rval = Tss2_Sys_StartAuthSession( sapi_context, session-&gt;tpmKey, session-&gt;bind, 0,\n            &amp;( session-&gt;nonceOlder ), &amp;( session-&gt;encryptedSalt ), session-&gt;sessionType,\n            &amp;( session-&gt;symmetric ), session-&gt;authHash, &amp;( session-&gt;sessionHandle ),\n            &amp;( session-&gt;nonceNewer ), 0 );\n\n    if( rval == TPM_RC_SUCCESS )\n    {\n        if( session-&gt;tpmKey == TPM_RH_NULL )\n            session-&gt;salt.t.size = 0;\n        if( session-&gt;bind == TPM_RH_NULL )\n            session-&gt;authValueBind.t.size = 0;\n\n        if( session-&gt;tpmKey == TPM_RH_NULL &amp;&amp; session-&gt;bind == TPM_RH_NULL )\n        {\n            session-&gt;sessionKey.b.size = 0;\n        }\n        else\n        {\n            // Generate the key used as input to the KDF.\n            // Generate the key used as input to the KDF.\n            bool result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&amp;key, &amp;( session-&gt;authValueBind.b ) );\n            if (!result)\n            {\n               return TSS2_SYS_RC_BAD_VALUE;\n            }\n\n            result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&amp;key, &amp;( session-&gt;salt.b ) );\n            if (!result)\n            {\n                return TSS2_SYS_RC_BAD_VALUE;\n            }\n\n            bytes = GetDigestSize( session-&gt;authHash );\n\n            if( key.t.size == 0 )\n            {\n                session-&gt;sessionKey.t.size = 0;\n            }\n            else\n            {\n                rval = tpm_kdfa(session-&gt;authHash, &amp;(key.b), label, &amp;( session-&gt;nonceNewer.b ),\n                        &amp;( session-&gt;nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&amp;( session-&gt;sessionKey ) );\n            }\n\n            if( rval != TPM_RC_SUCCESS )\n            {\n                return( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );\n            }\n        }\n\n        session-&gt;nonceTpmDecrypt.b.size = 0;\n        session-&gt;nonceTpmEncrypt.b.size = 0;\n        session-&gt;nvNameChanged = 0;\n    }\n\n    return rval;\n}',
 'static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&amp;cert)) {\n        json_array_append_new(j_error, json_string("check_attestation_fido_u2f - Error gnutls_x509_crt_init"));\n        break;\n      }\n      if (gnutls_pubkey_init(&amp;pubkey)) {\n        json_array_append_new(j_error, json_string("check_attestation_fido_u2f - Error gnutls_pubkey_init"));\n        break;\n      }\n      \n      // Step 1\n      if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error, json_string("CBOR map value \'attStmt\' invalid format"));\n        break;\n      }\n      for (i=0; i&lt;2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), "x5c", MIN(o_strlen("x5c"), cbor_string_length(key)))) {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), "sig", MIN(o_strlen("sig"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n          } else {\n            message = msprintf("attStmt map element %d key is not valid: \'%.*s\'", i, cbor_string_length(key), cbor_string_handle(key));\n            json_array_append_new(j_error, json_string(message));\n            o_free(message);\n            break;\n          }\n        } else {\n          message = msprintf("attStmt map element %d key is not a string", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string("CBOR map value \'x5c\' invalid format"));\n        break;\n      }\n      att_cert = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert, &amp;cert_dat, GNUTLS_X509_FMT_DER)) &lt; 0) {\n        json_array_append_new(j_error, json_string("Error importing x509 certificate"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, "check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d", ret);\n        break;\n      }\n      if (json_object_get(j_params, "root-ca-list") != json_null() &amp;&amp; validate_certificate_from_root(j_params, cert, x5c) != G_OK) {\n        json_array_append_new(j_error, json_string("Unrecognized certificate authority"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &amp;cert_issued_by) &gt;= 0) {\n          message = msprintf("Unrecognized certificate autohority: %.*s", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG, "check_attestation_fido_u2f - %s", message);\n          o_free(message);\n          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG, "check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) &lt; 0) {\n        json_array_append_new(j_error, json_string("Error importing x509 certificate"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, "check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &amp;cert_export_len)) &lt; 0) {\n        json_array_append_new(j_error, json_string("Error exporting x509 certificate"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, "check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d", ret);\n        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &amp;cert_export_b64_len)) {\n        json_array_append_new(j_error, json_string("Internal error"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, "check_attestation_fido_u2f - Error o_base64_encode cert_export");\n        break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &amp;client_data_hash_len)) {\n        json_array_append_new(j_error, json_string("Internal error"));\n        y_log_message(Y_LOG_LEVEL_ERROR, "check_attestation_fido_u2f - Error generate_digest_raw client_data");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string("Error sig is not a bytestring"));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n      \n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n      \n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n      data_signed_offset+=cert_x_len;\n      \n      memcpy(data_signed+data_signed_offset, cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n        \n      // Let\'s verify sig over data_signed\n      data.data = data_signed;\n      data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &amp;data, &amp;signature)) {\n        json_array_append_new(j_error, json_string("Invalid signature"));\n      }\n      \n    } while (0);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack("{sisO}", "result", G_ERROR_PARAM, "error", j_error);\n    } else {\n      j_return = json_pack("{sis{ss%}}", "result", G_OK, "data", "certificate", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&amp;att_cert);\n    }\n    \n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, "check_attestation_fido_u2f - Error allocating resources for j_error");\n    j_return = json_pack("{si}", "result", G_ERROR);\n  }\n  return j_return;\n}',
 'bool initiate_stratum(struct pool *pool)\n{\n\tchar s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;\n\tjson_t *val = NULL, *res_val, *err_val;\n\tbool ret = false, recvd = false;\n\tjson_error_t err;\n\tint n2size;\n\n\tif (!setup_stratum_curl(pool))\n\t\tgoto out;\n\nresend:\n\tif (pool-&gt;sessionid)\n\t\tsprintf(s, "{\\"id\\": %d, \\"method\\": \\"mining.subscribe\\", \\"params\\": [\\"%s\\"]}", swork_id++, pool-&gt;sessionid);\n\telse\n\t\tsprintf(s, "{\\"id\\": %d, \\"method\\": \\"mining.subscribe\\", \\"params\\": []}", swork_id++);\n\n\tif (!__stratum_send(pool, s, strlen(s))) {\n\t\tapplog(LOG_DEBUG, "Failed to send s in initiate_stratum");\n\t\tgoto out;\n\t}\n\n\tif (!socket_full(pool, true)) {\n\t\tapplog(LOG_DEBUG, "Timed out waiting for response in initiate_stratum");\n\t\tgoto out;\n\t}\n\n\tsret = recv_line(pool);\n\tif (!sret)\n\t\tgoto out;\n\n\trecvd = true;\n\n\tval = JSON_LOADS(sret, &amp;err);\n\tfree(sret);\n\tif (!val) {\n\t\tapplog(LOG_INFO, "JSON decode failed(%d): %s", err.line, err.text);\n\t\tgoto out;\n\t}\n\n\tres_val = json_object_get(val, "result");\n\terr_val = json_object_get(val, "error");\n\n\tif (!res_val || json_is_null(res_val) ||\n\t    (err_val &amp;&amp; !json_is_null(err_val))) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup("(unknown reason)");\n\n\t\tapplog(LOG_INFO, "JSON-RPC decode failed: %s", ss);\n\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tsessionid = json_array_string(json_array_get(res_val, 0), 1);\n\tif (!sessionid) {\n\t\tapplog(LOG_INFO, "Failed to get sessionid in initiate_stratum");\n\t\tgoto out;\n\t}\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, "Failed to get nonce1 in initiate_stratum");\n\t\tfree(sessionid);\n\t\tgoto out;\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (!n2size) {\n\t\tapplog(LOG_INFO, "Failed to get n2size in initiate_stratum");\n\t\tfree(sessionid);\n\t\tfree(nonce1);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&amp;pool-&gt;pool_lock);\n\tpool-&gt;sessionid = sessionid;\n\tfree(pool-&gt;nonce1);\n\tpool-&gt;nonce1 = nonce1;\n\tpool-&gt;n1_len = strlen(nonce1) / 2;\n\tpool-&gt;n2size = n2size;\n\tmutex_unlock(&amp;pool-&gt;pool_lock);\n\n\tapplog(LOG_DEBUG, "Pool %d stratum session id: %s", pool-&gt;pool_no, pool-&gt;sessionid);\n\n\tret = true;\nout:\n\tif (val)\n\t\tjson_decref(val);\n\n\tif (ret) {\n\t\tif (!pool-&gt;stratum_url)\n\t\t\tpool-&gt;stratum_url = pool-&gt;sockaddr_url;\n\t\tpool-&gt;stratum_active = true;\n\t\tpool-&gt;swork.diff = 1;\n\t\tif (opt_protocol) {\n\t\t\tapplog(LOG_DEBUG, "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",\n\t\t\t       pool-&gt;pool_no, pool-&gt;nonce1, pool-&gt;n2size);\n\t\t}\n\t} else {\n\t\tif (recvd &amp;&amp; pool-&gt;sessionid) {\n\t\t\t/* Reset the sessionid used for stratum resuming in case the pool\n\t\t\t* does not support it, or does not know how to respond to the\n\t\t\t* presence of the sessionid parameter. */\n\t\t\tmutex_lock(&amp;pool-&gt;pool_lock);\n\t\t\tfree(pool-&gt;sessionid);\n\t\t\tfree(pool-&gt;nonce1);\n\t\t\tpool-&gt;sessionid = pool-&gt;nonce1 = NULL;\n\t\t\tmutex_unlock(&amp;pool-&gt;pool_lock);\n\t\t\tapplog(LOG_DEBUG, "Failed to resume stratum, trying afresh");\n\t\t\tgoto resend;\n\t\t}\n\t\tapplog(LOG_DEBUG, "Initiate stratum failed");\n\t\tif (pool-&gt;sock != INVSOCK) {\n\t\t\tshutdown(pool-&gt;sock, SHUT_RDWR);\n\t\t\tpool-&gt;sock = INVSOCK;\n\t\t}\n\t}\n\n\treturn ret;\n}',
 "static unsigned int unix_dgram_poll(struct file *file, struct socket *sock,\n\t\t\t\t    poll_table *wait)\n{\n\tstruct sock *sk = sock-&gt;sk, *other;\n\tunsigned int mask, writable;\n\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\n\t/* exceptional events? */\n\tif (sk-&gt;sk_err || !skb_queue_empty(&amp;sk-&gt;sk_error_queue))\n\t\tmask |= POLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\n\n\tif (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP | POLLIN | POLLRDNORM;\n\tif (sk-&gt;sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\n\t/* readable? */\n\tif (!skb_queue_empty(&amp;sk-&gt;sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\t/* Connection-based need to check for termination and startup */\n\tif (sk-&gt;sk_type == SOCK_SEQPACKET) {\n\t\tif (sk-&gt;sk_state == TCP_CLOSE)\n\t\t\tmask |= POLLHUP;\n\t\t/* connection hasn't started yet? */\n\t\tif (sk-&gt;sk_state == TCP_SYN_SENT)\n\t\t\treturn mask;\n\t}\n\n\t/* No write status requested, avoid expensive OUT tests. */\n\tif (!(poll_requested_events(wait) &amp; (POLLWRBAND|POLLWRNORM|POLLOUT)))\n\t\treturn mask;\n\n\twritable = unix_writable(sk);\n\tif (writable) {\n\t\tunix_state_lock(sk);\n\n\t\tother = unix_peer(sk);\n\t\tif (other &amp;&amp; unix_peer(other) != sk &amp;&amp;\n\t\t    unix_recvq_full(other) &amp;&amp;\n\t\t    unix_dgram_peer_wake_me(sk, other))\n\t\t\twritable = 0;\n\n\t\tunix_state_unlock(sk);\n\t}\n\n\tif (writable)\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\telse\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);\n\n\treturn mask;\n}",
 'handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; /* index for kwdefaults and kwonlyargs */\n\n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), "named arguments must follow bare *");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i &lt; NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 &lt; NCH(n) &amp;&amp; TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; /* \'=\' and test */\n                }\n                else { /* setting NULL if no default value exists */\n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    /* ch is NAME \':\' test */\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch-&gt;n_col_offset,\n                          c-&gt;c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; /* the name */\n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                /* arg will be equal to the last argument processed */\n                arg-&gt;type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg-&gt;type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, "unexpected node");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}',
 '  void Compute(OpKernelContext* context) override {\n    const Tensor&amp; indices = context-&gt;input(0);\n    const Tensor&amp; values = context-&gt;input(1);\n    const Tensor&amp; shape = context-&gt;input(2);\n    const Tensor&amp; weights = context-&gt;input(3);\n    bool use_weights = weights.NumElements() &gt; 0;\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    "Input indices must be a 2-dimensional tensor. Got: ",\n                    indices.shape().DebugString()));\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              "Weights and values must have the same shape. Weight shape: ",\n              weights.shape().DebugString(),\n              "; values shape: ", values.shape().DebugString()));\n    }\n\n    bool is_1d = shape.NumElements() == 1;\n    int num_batches = is_1d ? 1 : shape.flat&lt;int64&gt;()(0);\n    int num_values = values.NumElements();\n\n    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    "Number of values must match first dimension of indices.",\n                    "Got ", num_values,\n                    " values, indices shape: ", indices.shape().DebugString()));\n\n    const auto indices_values = indices.matrix&lt;int64&gt;();\n    const auto values_values = values.flat&lt;T&gt;();\n    const auto weight_values = weights.flat&lt;W&gt;();\n\n    auto per_batch_counts = BatchedMap&lt;W&gt;(num_batches);\n\n    T max_value = 0;\n\n    for (int idx = 0; idx &lt; num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      const auto&amp; value = values_values(idx);\n      if (value &gt;= 0 &amp;&amp; (maxlength_ &lt;= 0 || value &lt; maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value &gt; max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse&lt;W&gt;(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }',
 'static int lz4_uncompress(const char *source, char *dest, int osize)\n{\n\tconst BYTE *ip = (const BYTE *) source;\n\tconst BYTE *ref;\n\tBYTE *op = (BYTE *) dest;\n\tBYTE * const oend = op + osize;\n\tBYTE *cpy;\n\tunsigned token;\n\tsize_t length;\n\tsize_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};\n#if LZ4_ARCH64\n\tsize_t dec64table[] = {0, 0, 0, -1, 0, 1, 2, 3};\n#endif\n\n\twhile (1) {\n\n\t\t/* get runlength */\n\t\ttoken = *ip++;\n\t\tlength = (token &gt;&gt; ML_BITS);\n\t\tif (length == RUN_MASK) {\n\t\t\tsize_t len;\n\n\t\t\tlen = *ip++;\n\t\t\tfor (; len == 255; length += 255)\n\t\t\t\tlen = *ip++;\n\t\t\tif (unlikely(length &gt; (size_t)(length + len)))\n\t\t\t\tgoto _output_error;\n\t\t\tlength += len;\n\t\t}\n\n\t\t/* copy literals */\n\t\tcpy = op + length;\n\t\tif (unlikely(cpy &gt; oend - COPYLENGTH)) {\n\t\t\t/*\n\t\t\t * Error: not enough place for another match\n\t\t\t * (min 4) + 5 literals\n\t\t\t */\n\t\t\tif (cpy != oend)\n\t\t\t\tgoto _output_error;\n\n\t\t\tmemcpy(op, ip, length);\n\t\t\tip += length;\n\t\t\tbreak; /* EOF */\n\t\t}\n\t\tLZ4_WILDCOPY(ip, op, cpy);\n\t\tip -= (op - cpy);\n\t\top = cpy;\n\n\t\t/* get offset */\n\t\tLZ4_READ_LITTLEENDIAN_16(ref, cpy, ip);\n\t\tip += 2;\n\n\t\t/* Error: offset create reference outside destination buffer */\n\t\tif (unlikely(ref &lt; (BYTE *const) dest))\n\t\t\tgoto _output_error;\n\n\t\t/* get matchlength */\n\t\tlength = token &amp; ML_MASK;\n\t\tif (length == ML_MASK) {\n\t\t\tfor (; *ip == 255; length += 255)\n\t\t\t\tip++;\n\t\t\tlength += *ip++;\n\t\t}\n\n\t\t/* copy repeated sequence */\n\t\tif (unlikely((op - ref) &lt; STEPSIZE)) {\n#if LZ4_ARCH64\n\t\t\tsize_t dec64 = dec64table[op - ref];\n#else\n\t\t\tconst int dec64 = 0;\n#endif\n\t\t\top[0] = ref[0];\n\t\t\top[1] = ref[1];\n\t\t\top[2] = ref[2];\n\t\t\top[3] = ref[3];\n\t\t\top += 4;\n\t\t\tref += 4;\n\t\t\tref -= dec32table[op-ref];\n\t\t\tPUT4(ref, op);\n\t\t\top += STEPSIZE - 4;\n\t\t\tref -= dec64;\n\t\t} else {\n\t\t\tLZ4_COPYSTEP(ref, op);\n\t\t}\n\t\tcpy = op + length - (STEPSIZE - 4);\n\t\tif (cpy &gt; (oend - COPYLENGTH)) {\n\n\t\t\t/* Error: request to write beyond destination buffer */\n\t\t\tif (cpy &gt; oend)\n\t\t\t\tgoto _output_error;\n\t\t\tLZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));\n\t\t\twhile (op &lt; cpy)\n\t\t\t\t*op++ = *ref++;\n\t\t\top = cpy;\n\t\t\t/*\n\t\t\t * Check EOF (should never happen, since last 5 bytes\n\t\t\t * are supposed to be literals)\n\t\t\t */\n\t\t\tif (op == oend)\n\t\t\t\tgoto _output_error;\n\t\t\tcontinue;\n\t\t}\n\t\tLZ4_SECURECOPY(ref, op, cpy);\n\t\top = cpy; /* correction */\n\t}\n\t/* end of decoding */\n\treturn (int) (((char *)ip) - source);\n\n\t/* write overflow error detected */\n_output_error:\n\treturn (int) (-(((char *)ip) - source));\n}',
 'static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, "submodule", &amp;subsection, &amp;subsection_len, &amp;key) &lt; 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) &lt; 0)\n\t\tdata-&gt;ret |= report(data-&gt;options, data-&gt;obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    "disallowed submodule name: %s",\n\t\t\t\t    name);\n\tif (!strcmp(key, "url") &amp;&amp; value &amp;&amp;\n\t    looks_like_command_line_option(value))\n\t\tdata-&gt;ret |= report(data-&gt;options, data-&gt;obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    "disallowed submodule url: %s",\n\t\t\t\t    value);\n\tif (!strcmp(key, "path") &amp;&amp; value &amp;&amp;\n\t    looks_like_command_line_option(value))\n\t\tdata-&gt;ret |= report(data-&gt;options, data-&gt;obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    "disallowed submodule path: %s",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}',
 'static int cg_rmdir(const char *path)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &amp;cgdir, &amp;fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfprintf(stderr, "rmdir: verifying access to %s:%s (req path %s)\\n",\n\t\t\tcontroller, cgdir, path);\n\tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc-&gt;pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}',
 'int64_t TensorByteSize(const TensorProto&amp; t) {\n  // num_elements returns -1 if shape is not fully defined.\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n  return num_elems &lt; 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}',
 'TfLiteStatus GetInputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                          int index, const TfLiteTensor** tensor) {\n  return GetMutableInputSafe(context, node, index, tensor);\n}',
 'is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n\n    res = FALSE;\n\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n\n    return res;\n}',
 'static void kgdb_hw_overflow_handler(struct perf_event *event,\n\t\tstruct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tint i;\n\n\tfor (i = 0; i &lt; 4; i++)\n\t\tif (breakinfo[i].enabled)\n\t\t\ttsk-&gt;thread.debugreg6 |= (DR_TRAP0 &lt;&lt; i);\n}',
 'iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n{\n    iakerb_ctx_id_t ctx;\n    krb5_error_code code;\n\n    *pctx = NULL;\n\n    ctx = k5alloc(sizeof(*ctx), &amp;code);\n    if (ctx == NULL)\n        goto cleanup;\n    ctx-&gt;defcred = GSS_C_NO_CREDENTIAL;\n    ctx-&gt;magic = KG_IAKERB_CONTEXT;\n    ctx-&gt;state = IAKERB_AS_REQ;\n    ctx-&gt;count = 0;\n    ctx-&gt;initiate = initiate;\n    ctx-&gt;established = 0;\n\n    code = krb5_gss_init_context(&amp;ctx-&gt;k5c);\n    if (code != 0)\n        goto cleanup;\n\n    *pctx = ctx;\n\ncleanup:\n    if (code != 0)\n        iakerb_release_context(ctx);\n\n    return code;\n}',
 "bool Archive::GetComment(Array&lt;wchar&gt; *CmtData)\n{\n  if (!MainComment)\n    return false;\n  SaveFilePos SavePos(*this);\n\n#ifndef SFX_MODULE\n  uint CmtLength;\n  if (Format==RARFMT14)\n  {\n    Seek(SFXSize+SIZEOF_MAINHEAD14,SEEK_SET);\n    CmtLength=GetByte();\n    CmtLength+=(GetByte()&lt;&lt;8);\n  }\n  else\n#endif\n  {\n    if (MainHead.CommentInHeader)\n    {\n      // Old style (RAR 2.9) archive comment embedded into the main \n      // archive header.\n      Seek(SFXSize+SIZEOF_MARKHEAD3+SIZEOF_MAINHEAD3,SEEK_SET);\n      if (!ReadHeader())\n        return false;\n    }\n    else\n    {\n      // Current (RAR 3.0+) version of archive comment.\n      Seek(GetStartPos(),SEEK_SET);\n      return SearchSubBlock(SUBHEAD_TYPE_CMT)!=0 &amp;&amp; ReadCommentData(CmtData);\n    }\n#ifndef SFX_MODULE\n    // Old style (RAR 2.9) comment header embedded into the main \n    // archive header.\n    if (BrokenHeader)\n    {\n      uiMsg(UIERROR_CMTBROKEN,FileName);\n      return false;\n    }\n    CmtLength=CommHead.HeadSize-SIZEOF_COMMHEAD;\n#endif\n  }\n#ifndef SFX_MODULE\n  if (Format==RARFMT14 &amp;&amp; MainHead.PackComment || Format!=RARFMT14 &amp;&amp; CommHead.Method!=0x30)\n  {\n    if (Format!=RARFMT14 &amp;&amp; (CommHead.UnpVer &lt; 15 || CommHead.UnpVer &gt; VER_UNPACK || CommHead.Method &gt; 0x35))\n      return false;\n    ComprDataIO DataIO;\n    DataIO.SetTestMode(true);\n    uint UnpCmtLength;\n    if (Format==RARFMT14)\n    {\n#ifdef RAR_NOCRYPT\n      return false;\n#else\n      UnpCmtLength=GetByte();\n      UnpCmtLength+=(GetByte()&lt;&lt;8);\n      CmtLength-=2;\n      DataIO.SetCmt13Encryption();\n      CommHead.UnpVer=15;\n#endif\n    }\n    else\n      UnpCmtLength=CommHead.UnpSize;\n    DataIO.SetFiles(this,NULL);\n    DataIO.EnableShowProgress(false);\n    DataIO.SetPackedSizeToRead(CmtLength);\n    DataIO.UnpHash.Init(HASH_CRC32,1);\n    DataIO.SetNoFileHeader(true); // this-&gt;FileHead is not filled yet.\n\n    Unpack CmtUnpack(&amp;DataIO);\n    CmtUnpack.Init(0x10000,false);\n    CmtUnpack.SetDestSize(UnpCmtLength);\n    CmtUnpack.DoUnpack(CommHead.UnpVer,false);\n\n    if (Format!=RARFMT14 &amp;&amp; (DataIO.UnpHash.GetCRC32()&amp;0xffff)!=CommHead.CommCRC)\n    {\n      uiMsg(UIERROR_CMTBROKEN,FileName);\n      return false;\n    }\n    else\n    {\n      byte *UnpData;\n      size_t UnpDataSize;\n      DataIO.GetUnpackedData(&amp;UnpData,&amp;UnpDataSize);\n#ifdef _WIN_ALL\n      // If we ever decide to extend it to Android, we'll need to alloc\n      // 4x memory for OEM to UTF-8 output here.\n      OemToCharBuffA((char *)UnpData,(char *)UnpData,(DWORD)UnpDataSize);\n#endif\n      CmtData-&gt;Alloc(UnpDataSize+1);\n      memset(CmtData-&gt;Addr(0),0,CmtData-&gt;Size()*sizeof(wchar));\n      CharToWide((char *)UnpData,CmtData-&gt;Addr(0),CmtData-&gt;Size());\n      CmtData-&gt;Alloc(wcslen(CmtData-&gt;Addr(0)));\n    }\n  }\n  else\n  {\n    if (CmtLength==0)\n      return false;\n    Array&lt;byte&gt; CmtRaw(CmtLength);\n    int ReadSize=Read(&amp;CmtRaw[0],CmtLength);\n    if (ReadSize&gt;=0 &amp;&amp; (uint)ReadSize&lt;CmtLength) // Comment is shorter than declared.\n    {\n      CmtLength=ReadSize;\n      CmtRaw.Alloc(CmtLength);\n    }\n\n    if (Format!=RARFMT14 &amp;&amp; CommHead.CommCRC!=(~CRC32(0xffffffff,&amp;CmtRaw[0],CmtLength)&amp;0xffff))\n    {\n      uiMsg(UIERROR_CMTBROKEN,FileName);\n      return false;\n    }\n    CmtData-&gt;Alloc(CmtLength+1);\n    CmtRaw.Push(0);\n#ifdef _WIN_ALL\n    // If we ever decide to extend it to Android, we'll need to alloc\n    // 4x memory for OEM to UTF-8 output here.\n    OemToCharA((char *)&amp;CmtRaw[0],(char *)&amp;CmtRaw[0]);\n#endif\n    CharToWide((char *)&amp;CmtRaw[0],CmtData-&gt;Addr(0),CmtLength);\n    CmtData-&gt;Alloc(wcslen(CmtData-&gt;Addr(0)));\n  }\n#endif\n  return CmtData-&gt;Size() &gt; 0;\n}",
 'static char *print_number( cJSON *item )\n{\n\tchar *str;\n\tdouble f, f2;\n\tint64_t i;\n\n\tstr = (char*) cJSON_malloc( 64 );\n\tif ( str ) {\n\t\tf = item-&gt;valuefloat;\n\t\ti = f;\n\t\tf2 = i;\n\t\tif ( f2 == f &amp;&amp; item-&gt;valueint &gt;= LLONG_MIN &amp;&amp; item-&gt;valueint &lt;= LLONG_MAX )\n\t\t\tsprintf( str, "%lld", (long long) item-&gt;valueint );\n\t\telse\n\t\t\tsprintf( str, "%g", item-&gt;valuefloat );\n\t}\n\treturn str;\n}',
 "static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n\t\t\t\tconst pj_uint8_t *start, const pj_uint8_t *max, \n\t\t\t\tint *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter &gt; 10) {\n\t/* Too many name recursion */\n\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n\tif ((*p &amp; 0xc0) == 0xc0) {\n\t    /* Compression is found! */\n\t    int ptr_len = 0;\n\t    int dummy;\n\t    pj_uint16_t offset;\n\n\t    /* Get the 14bit offset */\n\t    pj_memcpy(&amp;offset, p, 2);\n\t    offset ^= pj_htons((pj_uint16_t)(0xc0 &lt;&lt; 8));\n\t    offset = pj_ntohs(offset);\n\n\t    /* Check that offset is valid */\n\t    if (offset &gt;= max - pkt)\n\t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n\n\t    /* Get the name length from that offset. */\n\t    status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n\t\t\t\t  &amp;dummy, &amp;ptr_len);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\n\t    *parsed_len += 2;\n\t    *name_len += ptr_len;\n\n\t    return PJ_SUCCESS;\n\t} else {\n\t    unsigned label_len = *p;\n\n\t    /* Check that label length is valid.\n\t     * Each label consists of an octet length (of size 1) followed\n\t     * by the octet of the specified length (label_len). Then it\n\t     * must be followed by either another label's octet length or\n\t     * a zero length octet (that terminates the sequence).\n\t     */\n\t    if (p+1+label_len+1 &gt; max)\n\t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n\n\t    p += (label_len + 1);\n\t    *parsed_len += (label_len + 1);\n\n\t    if (*p != 0)\n\t\t++label_len;\n\t    \n\t    *name_len += label_len;\n\t}\n    }\n    ++p;\n    (*parsed_len)++;\n\n    return PJ_SUCCESS;\n}",
 'do_pax_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 &amp;&amp; strcmp((char *)&amp;nbuf[noff], "PaX") == 0 &amp;&amp;\n\t    type == NT_NETBSD_PAX &amp;&amp; descsz == 4) {\n\t\tstatic const char *pax[] = {\n\t\t    "+mprotect",\n\t\t    "-mprotect",\n\t\t    "+segvguard",\n\t\t    "-segvguard",\n\t\t    "+ASLR",\n\t\t    "-ASLR",\n\t\t};\n\t\tuint32_t desc;\n\t\tsize_t i;\n\t\tint did = 0;\n\n\t\t*flags |= FLAGS_DID_NETBSD_PAX;\n\t\t(void)memcpy(&amp;desc, &amp;nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\n\t\tif (desc &amp;&amp; file_printf(ms, ", PaX: ") == -1)\n\t\t\treturn 1;\n\n\t\tfor (i = 0; i &lt; __arraycount(pax); i++) {\n\t\t\tif (((1 &lt;&lt; i) &amp; desc) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (file_printf(ms, "%s%s", did++ ? "," : "",\n\t\t\t    pax[i]) == -1)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}',
 'static int unix_getpw(UNUSED void *instance, REQUEST *request,\n\t\t      VALUE_PAIR **vp_list)\n{\n\tconst char\t*name;\n\tconst char\t*encrypted_pass;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd\t*spwd = NULL;\n#endif\n#ifdef OSFC2\n\tstruct pr_passwd *pr_pw;\n#else\n\tstruct passwd\t*pwd;\n#endif\n#ifdef HAVE_GETUSERSHELL\n\tchar\t\t*shell;\n#endif\n\tVALUE_PAIR\t*vp;\n\n\t/*\n\t *\tWe can only authenticate user requests which HAVE\n\t *\ta User-Name attribute.\n\t */\n\tif (!request-&gt;username) {\n\t\treturn RLM_MODULE_NOOP;\n\t}\n\n\tname = (char *)request-&gt;username-&gt;vp_strvalue;\n\tencrypted_pass = NULL;\n\n#ifdef OSFC2\n\tif ((pr_pw = getprpwnam(name)) == NULL)\n\t\treturn RLM_MODULE_NOTFOUND;\n\tencrypted_pass = pr_pw-&gt;ufld.fd_encrypt;\n\n\t/*\n\t *\tCheck if account is locked.\n\t */\n\tif (pr_pw-&gt;uflg.fg_lock!=1) {\n\t\tradlog(L_AUTH, "rlm_unix: [%s]: account locked", name);\n\t\treturn RLM_MODULE_USERLOCK;\n\t}\n#else /* OSFC2 */\n\tif ((pwd = getpwnam(name)) == NULL) {\n\t\treturn RLM_MODULE_NOTFOUND;\n\t}\n\tencrypted_pass = pwd-&gt;pw_passwd;\n#endif /* OSFC2 */\n\n#ifdef HAVE_GETSPNAM\n\t/*\n\t *      See if there is a shadow password.\n\t *\n\t *\tOnly query the _system_ shadow file if the encrypted\n\t *\tpassword from the passwd file is &lt; 10 characters (i.e.\n\t *\ta valid password would never crypt() to it).  This will\n\t *\tprevents users from using NULL password fields as things\n\t *\tstand right now.\n\t */\n\tif ((encrypted_pass == NULL) || (strlen(encrypted_pass) &lt; 10)) {\n\t\tif ((spwd = getspnam(name)) == NULL) {\n\t\t\treturn RLM_MODULE_NOTFOUND;\n\t\t}\n\t\tencrypted_pass = spwd-&gt;sp_pwdp;\n\t}\n#endif\t/* HAVE_GETSPNAM */\n\n/*\n *\tThese require \'pwd != NULL\', which isn\'t true on OSFC2\n */\n#ifndef OSFC2\n#ifdef DENY_SHELL\n\t/*\n\t *\tUsers with a particular shell are denied access\n\t */\n\tif (strcmp(pwd-&gt;pw_shell, DENY_SHELL) == 0) {\n\t\tradlog_request(L_AUTH, 0, request,\n\t\t\t       "rlm_unix: [%s]: invalid shell", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#ifdef HAVE_GETUSERSHELL\n\t/*\n\t *\tCheck /etc/shells for a valid shell. If that file\n\t *\tcontains /RADIUSD/ANY/SHELL then any shell will do.\n\t */\n\twhile ((shell = getusershell()) != NULL) {\n\t\tif (strcmp(shell, pwd-&gt;pw_shell) == 0 ||\n\t\t    strcmp(shell, "/RADIUSD/ANY/SHELL") == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendusershell();\n\tif (shell == NULL) {\n\t\tradlog_request(L_AUTH, 0, request, "[%s]: invalid shell [%s]",\n\t\t       name, pwd-&gt;pw_shell);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n#endif /* OSFC2 */\n\n#if defined(HAVE_GETSPNAM) &amp;&amp; !defined(M_UNIX)\n\t/*\n\t *      Check if password has expired.\n\t */\n\tif (spwd &amp;&amp; spwd-&gt;sp_lstchg &gt; 0 &amp;&amp; spwd-&gt;sp_max &gt;= 0 &amp;&amp;\n\t    (request-&gt;timestamp / 86400) &gt; (spwd-&gt;sp_lstchg + spwd-&gt;sp_max)) {\n\t\tradlog_request(L_AUTH, 0, request, "[%s]: password has expired", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n\t/*\n\t *      Check if account has expired.\n\t */\n\tif (spwd &amp;&amp; spwd-&gt;sp_expire &gt; 0 &amp;&amp;\n\t    (request-&gt;timestamp / 86400) &gt; spwd-&gt;sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, "[%s]: account has expired", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)\n\t/*\n\t *\tCheck if password has expired.\n\t */\n\tif ((pwd-&gt;pw_expire &gt; 0) &amp;&amp;\n\t    (request-&gt;timestamp &gt; pwd-&gt;pw_expire)) {\n\t\tradlog_request(L_AUTH, 0, request, "[%s]: password has expired", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n\t/*\n\t *\tWe might have a passwordless account.\n\t *\n\t *\tFIXME: Maybe add Auth-Type := Accept?\n\t */\n\tif (encrypted_pass[0] == 0)\n\t\treturn RLM_MODULE_NOOP;\n\n\tvp = pairmake("Crypt-Password", encrypted_pass, T_OP_SET);\n\tif (!vp) return RLM_MODULE_FAIL;\n\n\tpairmove(vp_list, &amp;vp);\n\tpairfree(&amp;vp);\t\t/* might not be NULL; */\n\n\treturn RLM_MODULE_UPDATED;\n}',
 'static bool path_connected(const struct path *path)\n{\n\tstruct vfsmount *mnt = path-&gt;mnt;\n\n\t/* Only bind mounts can have disconnected paths */\n\tif (mnt-&gt;mnt_root == mnt-&gt;mnt_sb-&gt;s_root)\n\t\treturn true;\n\n\treturn is_subdir(path-&gt;dentry, mnt-&gt;mnt_root);\n}',
 'Variant HHVM_FUNCTION(apc_store,\n                      const Variant&amp; key_or_array,\n                      const Variant&amp; var /* = null */,\n                      int64_t ttl /* = 0 */) {\n  if (!apcExtension::Enable) return Variant(false);\n\n  if (key_or_array.isArray()) {\n    Array valuesArr = key_or_array.toArray();\n\n    for (ArrayIter iter(valuesArr); iter; ++iter) {\n      Variant key = iter.first();\n      if (!key.isString()) {\n        throw_invalid_argument("apc key: (not a string)");\n        return Variant(false);\n      }\n      Variant v = iter.second();\n\n      auto const&amp; strKey = key.toCStrRef();\n      if (isKeyInvalid(strKey)) {\n        throw_invalid_argument("apc key: (contains invalid characters)");\n        return Variant(false);\n      }\n      apc_store().set(strKey, v, ttl);\n    }\n    return Variant(ArrayData::Create());\n  }\n\n  if (!key_or_array.isString()) {\n    throw_invalid_argument("apc key: (not a string)");\n    return Variant(false);\n  }\n  String strKey = key_or_array.toString();\n\n  if (isKeyInvalid(strKey)) {\n    throw_invalid_argument("apc key: (contains invalid characters)");\n    return Variant(false);\n  }\n  apc_store().set(strKey, var, ttl);\n  return Variant(true);\n}',
 'static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\n\tpte_unmap(page_table);\n\n\t/* File mapping without -&gt;vm_ops ? */\n\tif (vma-&gt;vm_flags &amp; VM_SHARED)\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/* Check if we need to add a guard page to the stack */\n\tif (check_stack_guard_page(vma, address) &lt; 0)\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/* Use the zero-page for reads */\n\tif (!(flags &amp; FAULT_FLAG_WRITE) &amp;&amp; !mm_forbids_zeropage(mm)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\n\t\t\t\t\t\tvma-&gt;vm_page_prot));\n\t\tpage_table = pte_offset_map_lock(mm, pmd, address, &amp;ptl);\n\t\tif (!pte_none(*page_table))\n\t\t\tgoto unlock;\n\t\tgoto setpte;\n\t}\n\n\t/* Allocate our own private page. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, address);\n\tif (!page)\n\t\tgoto oom;\n\n\tif (mem_cgroup_try_charge(page, mm, GFP_KERNEL, &amp;memcg))\n\t\tgoto oom_free_page;\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceeding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\n\tentry = mk_pte(page, vma-&gt;vm_page_prot);\n\tif (vma-&gt;vm_flags &amp; VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &amp;ptl);\n\tif (!pte_none(*page_table))\n\t\tgoto release;\n\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, address);\n\tmem_cgroup_commit_charge(page, memcg, false);\n\tlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\n\tset_pte_at(mm, address, page_table, entry);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\treturn 0;\nrelease:\n\tmem_cgroup_cancel_charge(page, memcg);\n\tpage_cache_release(page);\n\tgoto unlock;\noom_free_page:\n\tpage_cache_release(page);\noom:\n\treturn VM_FAULT_OOM;\n}',
 'void lpc54xxxEthWritePhyReg(uint8_t opcode, uint8_t phyAddr,\n   uint8_t regAddr, uint16_t data)\n{\n   uint32_t temp;\n\n   //Valid opcode?\n   if(opcode == SMI_OPCODE_WRITE)\n   {\n      //Take care not to alter MDC clock configuration\n      temp = ENET-&gt;MAC_MDIO_ADDR &amp; ENET_MAC_MDIO_ADDR_CR_MASK;\n      //Set up a write operation\n      temp |= ENET_MAC_MDIO_ADDR_MOC(1) | ENET_MAC_MDIO_ADDR_MB_MASK;\n      //PHY address\n      temp |= ENET_MAC_MDIO_ADDR_PA(phyAddr);\n      //Register address\n      temp |= ENET_MAC_MDIO_ADDR_RDA(regAddr);\n\n      //Data to be written in the PHY register\n      ENET-&gt;MAC_MDIO_DATA = data &amp; ENET_MAC_MDIO_DATA_MD_MASK;\n\n      //Start a write operation\n      ENET-&gt;MAC_MDIO_ADDR = temp;\n      //Wait for the write to complete\n      while((ENET-&gt;MAC_MDIO_ADDR &amp; ENET_MAC_MDIO_ADDR_MB_MASK) != 0)\n      {\n      }\n   }\n   else\n   {\n      //The MAC peripheral only supports standard Clause 22 opcodes\n   }\n}',
 'static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, "%s", "shash");\n\trhash.blocksize = alg-&gt;cra_blocksize;\n\trhash.digestsize = salg-&gt;digestsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &amp;rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}',
 'static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tQnxObj *qo = R_NEW0 (QnxObj);\n\tif (!qo) {\n\t\treturn false;\n\t}\n\tlmf_record lrec;\n\tlmf_resource lres;\n\tlmf_data ldata;\n\tut64 offset = QNX_RECORD_SIZE;\n\tRList *sections = NULL;\n\tRList *fixups = NULL;\n\n\tif (!qo) {\n\t\tgoto beach;\n\t}\n\tif (!(sections = r_list_newf ((RListFree)r_bin_section_free)) || !(fixups = r_list_new ())) {\n\t\tgoto beach;\n\t}\n\tqo-&gt;kv = sdb_new0 ();\n\tif (!qo-&gt;kv) {\n\t\tgoto beach;\n\t}\n\t// Read the first record\n\tif (r_buf_fread_at (bf-&gt;buf, 0, (ut8 *)&amp;lrec, "ccss", 1) &lt; QNX_RECORD_SIZE) {\n\t\tgoto beach;\n\t}\n\t// Load the header\n\tlmf_header_load (&amp;qo-&gt;lmfh, bf-&gt;buf, qo-&gt;kv);\n\toffset += lrec.data_nbytes;\n\n\tfor (;;) {\n\t\tif (r_buf_fread_at (bf-&gt;buf, offset, (ut8 *)&amp;lrec, "ccss", 1) &lt; QNX_RECORD_SIZE) {\n\t\t\tgoto beach;\n\t\t}\n\t\toffset += sizeof (lmf_record);\n\n\t\tif (lrec.rec_type == LMF_IMAGE_END_REC) {\n\t\t\tbreak;\n\t\t} else if (lrec.rec_type == LMF_RESOURCE_REC) {\n\t\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bf-&gt;buf, offset, (ut8 *)&amp;lres, "ssss", 1) &lt; sizeof (lmf_resource)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr-&gt;name = strdup ("LMF_RESOURCE");\n\t\t\tptr-&gt;paddr = offset;\n\t\t\tptr-&gt;vsize = lrec.data_nbytes - sizeof (lmf_resource);\n\t\t\tptr-&gt;size = ptr-&gt;vsize;\n\t\t\tptr-&gt;add = true;\n\t\t \tr_list_append (sections, ptr);\n\t\t} else if (lrec.rec_type == LMF_LOAD_REC) {\n\t\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\t\tif (r_buf_fread_at (bf-&gt;buf, offset, (ut8 *)&amp;ldata, "si", 1) &lt; sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr-&gt;name = strdup ("LMF_LOAD");\n\t\t\tptr-&gt;paddr = offset;\n\t\t\tptr-&gt;vaddr = ldata.offset;\n\t\t\tptr-&gt;vsize = lrec.data_nbytes - sizeof (lmf_data);\n\t\t\tptr-&gt;size = ptr-&gt;vsize;\n\t\t\tptr-&gt;add = true;\n\t\t \tr_list_append (sections, ptr);\n\t\t} else if (lrec.rec_type == LMF_FIXUP_REC) {\n\t\t\tRBinReloc *ptr = R_NEW0 (RBinReloc);\n\t\t\tif (!ptr || r_buf_fread_at (bf-&gt;buf, offset, (ut8 *)&amp;ldata, "si", 1) &lt; sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr-&gt;vaddr = ptr-&gt;paddr = ldata.offset;\n\t\t\tptr-&gt;type = \'f\'; // "LMF_FIXUP";\n\t\t\tr_list_append (fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {\n\t\t\tRBinReloc *ptr = R_NEW0 (RBinReloc);\n\t\t\tif (!ptr || r_buf_fread_at (bf-&gt;buf, offset, (ut8 *)&amp;ldata, "si", 1) &lt; sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr-&gt;vaddr = ptr-&gt;paddr = ldata.offset;\n\t\t\tptr-&gt;type = \'F\'; // "LMF_8087_FIXUP";\n\t\t\tr_list_append (fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_RW_END_REC) {\n\t\t\tr_buf_fread_at (bf-&gt;buf, offset, (ut8 *)&amp;qo-&gt;rwend, "si", 1);\n\t\t}\n\t\toffset += lrec.data_nbytes;\n\t}\n\tsdb_ns_set (sdb, "info", qo-&gt;kv);\n\tqo-&gt;sections = sections;\n\tqo-&gt;fixups = fixups;\n\t*bin_obj = qo;\n\treturn true;\nbeach:\n\tfree (qo);\n\tr_list_free (fixups);\n\tr_list_free (sections);\n\treturn false;\n}',
 "ctcompare(const char *a,\t\t/* I - First string */\n          const char *b)\t\t/* I - Second string */\n{\n  int\tresult = 0;\t\t\t/* Result */\n\n\n  while (*a &amp;&amp; *b)\n  {\n    result |= *a ^ *b;\n    a ++;\n    b ++;\n  }\n\n /*\n  * The while loop finishes when *a == '\\0' or *b == '\\0'\n  * so after the while loop either both *a and *b == '\\0',\n  * or one points inside a string, so when we apply logical OR on *a,\n  * *b and result, we get a non-zero return value if the compared strings don't match.\n  */\n\n  return (result | *a | *b);\n}",
 '  static NAN_METHOD(Decrypt) {\n    MarkPopErrorOnReturn mark_pop_error_on_return;\n\n    ChaChaPolyDecipher* obj =\n      ObjectWrap::Unwrap&lt;ChaChaPolyDecipher&gt;(info.Holder());\n\n    if (!Buffer::HasInstance(info[0]))\n      return Nan::ThrowTypeError("Missing/Invalid packet");\n\n    if (!Buffer::HasInstance(info[1])\n        || Buffer::Length(info[1]) != POLY1305_TAGLEN) {\n      return Nan::ThrowTypeError("Missing/Invalid mac");\n    }\n\n    if (!info[2]-&gt;IsUint32())\n      return Nan::ThrowTypeError("Missing/Invalid sequence number");\n\n    ErrorType r = obj-&gt;decrypt(\n      reinterpret_cast&lt;unsigned char*&gt;(Buffer::Data(info[0])),\n      Buffer::Length(info[0]),\n      reinterpret_cast&lt;unsigned char*&gt;(Buffer::Data(info[1])),\n      Nan::To&lt;uint32_t&gt;(info[2]).FromJust()\n    );\n\n    switch (r) {\n      case kErrNone:\n        return;\n      case kErrInvalidMAC:\n        return Nan::ThrowError("Invalid MAC");\n      case kErrPartialDecrypt:\n        return Nan::ThrowError("Failed to completely decrypt packet length");\n      case kErrOpenSSL: {\n        char msg_buf[128] = {0};\n        ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));\n        return Nan::ThrowError(msg_buf);\n      }\n      default:\n        return Nan::ThrowError("Unknown decrypt failure");\n    }\n  }',
 "int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, struct timespec *timeout)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct timespec end_time;\n\n\tif (timeout &amp;&amp;\n\t    poll_select_set_timeout(&amp;end_time, timeout-&gt;tv_sec,\n\t\t\t\t    timeout-&gt;tv_nsec))\n\t\treturn -EINVAL;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\terr = sock_error(sock-&gt;sk);\n\tif (err)\n\t\tgoto out_put;\n\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\n\twhile (datagrams &lt; vlen) {\n\t\t/*\n\t\t * No need to ask LSM for more than the first datagram.\n\t\t */\n\t\tif (MSG_CMSG_COMPAT &amp; flags) {\n\t\t\terr = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,\n\t\t\t\t\t     &amp;msg_sys, flags &amp; ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err &lt; 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &amp;compat_entry-&gt;msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = ___sys_recvmsg(sock,\n\t\t\t\t\t     (struct user_msghdr __user *)entry,\n\t\t\t\t\t     &amp;msg_sys, flags &amp; ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err &lt; 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &amp;entry-&gt;msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\n\t\t/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */\n\t\tif (flags &amp; MSG_WAITFORONE)\n\t\t\tflags |= MSG_DONTWAIT;\n\n\t\tif (timeout) {\n\t\t\tktime_get_ts(timeout);\n\t\t\t*timeout = timespec_sub(end_time, *timeout);\n\t\t\tif (timeout-&gt;tv_sec &lt; 0) {\n\t\t\t\ttimeout-&gt;tv_sec = timeout-&gt;tv_nsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Timeout, return less than vlen datagrams */\n\t\t\tif (timeout-&gt;tv_nsec == 0 &amp;&amp; timeout-&gt;tv_sec == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Out of band data, return right away */\n\t\tif (msg_sys.msg_flags &amp; MSG_OOB)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tif (err == 0)\n\t\tgoto out_put;\n\n\tif (datagrams == 0) {\n\t\tdatagrams = err;\n\t\tgoto out_put;\n\t}\n\n\t/*\n\t * We may return less entries than requested (vlen) if the\n\t * sock is non block and there aren't enough datagrams...\n\t */\n\tif (err != -EAGAIN) {\n\t\t/*\n\t\t * ... or  if recvmsg returns an error after we\n\t\t * received some datagrams, where we record the\n\t\t * error to return on the next call or if the\n\t\t * app asks about it using getsockopt(SO_ERROR).\n\t\t */\n\t\tsock-&gt;sk-&gt;sk_err = -err;\n\t}\nout_put:\n\tfput_light(sock-&gt;file, fput_needed);\n\n\treturn datagrams;\n}",
 'TfLiteStatus HardSwishEval(TfLiteContext* context, TfLiteNode* node) {\n  HardSwishData* data = static_cast&lt;HardSwishData*&gt;(node-&gt;user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  switch (input-&gt;type) {\n    case kTfLiteFloat32: {\n      if (kernel_type == kReference) {\n        reference_ops::HardSwish(\n            GetTensorShape(input), GetTensorData&lt;float&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;float&gt;(output));\n      } else {\n        optimized_ops::HardSwish(\n            GetTensorShape(input), GetTensorData&lt;float&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;float&gt;(output));\n      }\n      return kTfLiteOk;\n    } break;\n    case kTfLiteUInt8: {\n      HardSwishParams&amp; params = data-&gt;params;\n      if (kernel_type == kReference) {\n        reference_ops::HardSwish(\n            params, GetTensorShape(input), GetTensorData&lt;uint8_t&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;uint8_t&gt;(output));\n      } else {\n        optimized_ops::HardSwish(\n            params, GetTensorShape(input), GetTensorData&lt;uint8_t&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;uint8_t&gt;(output));\n      }\n      return kTfLiteOk;\n    } break;\n    case kTfLiteInt8: {\n      HardSwishParams&amp; params = data-&gt;params;\n      if (kernel_type == kReference) {\n        reference_ops::HardSwish(\n            params, GetTensorShape(input), GetTensorData&lt;int8_t&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;int8_t&gt;(output));\n      } else {\n        optimized_ops::HardSwish(\n            params, GetTensorShape(input), GetTensorData&lt;int8_t&gt;(input),\n            GetTensorShape(output), GetTensorData&lt;int8_t&gt;(output));\n      }\n      return kTfLiteOk;\n    } break;\n    default:\n      TF_LITE_KERNEL_LOG(\n          context,\n          "Only float32, uint8 and int8 are supported currently, got %s.",\n          TfLiteTypeGetName(input-&gt;type));\n      return kTfLiteError;\n  }\n}',
 'static void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i &lt; npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags &amp; TTM_PAGE_FLAG_DMA32) &amp;&amp;\n\t\t\t    (npages - i) &gt;= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 0; j &lt; HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err("Erroneous page count. Leaking pages.\\n");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 &lt;&lt; order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&amp;huge-&gt;lock, irq_flags);\n\t\twhile ((npages - i) &gt;= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 0; j &lt; HPAGE_PMD_NR; ++j)\n\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&amp;pages[i]-&gt;lru, &amp;huge-&gt;list);\n\n\t\t\tfor (j = 0; j &lt; HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge-&gt;npages++;\n\t\t}\n\n\t\t/* Check that we don\'t go over the pool limit */\n\t\tmax_size = _manager-&gt;options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge-&gt;npages &gt; max_size)\n\t\t\tn2free = huge-&gt;npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&amp;huge-&gt;lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&amp;pool-&gt;lock, irq_flags);\n\twhile (i &lt; npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err("Erroneous page count. Leaking pages.\\n");\n\t\t\tlist_add_tail(&amp;pages[i]-&gt;lru, &amp;pool-&gt;list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool-&gt;npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don\'t go over the pool limit */\n\tnpages = 0;\n\tif (pool-&gt;npages &gt; _manager-&gt;options.max_size) {\n\t\tnpages = pool-&gt;npages - _manager-&gt;options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages &lt; NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&amp;pool-&gt;lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}',
 'bool ValidateInput(const Tensor&amp; updates) {\n  const auto updates_flat = updates.flat&lt;T&gt;();\n  const T zero(0);\n  for (int i = 0; i &lt; updates.NumElements(); i++) {\n    if (updates_flat(i) == zero) return false;\n  }\n  return true;\n}',
 'TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast&lt;OpData*&gt;(node-&gt;user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (input1-&gt;type) {\n    case kTfLiteInt32: {\n      return EvalImpl&lt;int32_t&gt;(context, data-&gt;requires_broadcast, input1,\n                               input2, output);\n    }\n    case kTfLiteInt64: {\n      return EvalImpl&lt;int64_t&gt;(context, data-&gt;requires_broadcast, input1,\n                               input2, output);\n    }\n    case kTfLiteFloat32: {\n      return EvalImpl&lt;float&gt;(context, data-&gt;requires_broadcast, input1, input2,\n                             output);\n    }\n    default: {\n      context-&gt;ReportError(context, "Type \'%s\' is not supported by floor_mod.",\n                           TfLiteTypeGetName(input1-&gt;type));\n      return kTfLiteError;\n    }\n  }\n}',
 'int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    *flags = 0;\n\n    if( profile == NULL )\n    {\n        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n        goto exit;\n    }\n\n    if( cn != NULL )\n    {\n        name = &amp;crt-&gt;subject;\n        cn_len = strlen( cn );\n\n        if( crt-&gt;ext_types &amp; MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &amp;crt-&gt;subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur-&gt;buf.len == cn_len &amp;&amp;\n                    x509_memcasecmp( cn, cur-&gt;buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur-&gt;buf.len &gt; 2 &amp;&amp;\n                    memcmp( cur-&gt;buf.p, "*.", 2 ) == 0 &amp;&amp;\n                    x509_check_wildcard( cn, &amp;cur-&gt;buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur-&gt;next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &amp;name-&gt;oid ) == 0 )\n                {\n                    if( name-&gt;val.len == cn_len &amp;&amp;\n                        x509_memcasecmp( name-&gt;val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name-&gt;val.len &gt; 2 &amp;&amp;\n                        memcmp( name-&gt;val.p, "*.", 2 ) == 0 &amp;&amp;\n                        x509_check_wildcard( cn, &amp;name-&gt;val ) == 0 )\n                        break;\n                }\n\n                name = name-&gt;next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &amp;crt-&gt;pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &amp;crt-&gt;pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent-&gt;next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            goto exit;\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt-&gt;next; parent != NULL; parent = parent-&gt;next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n    }\n\nexit:\n    if( ret != 0 )\n    {\n        *flags = (uint32_t) -1;\n        return( ret );\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}',
 'void AveragePool(const uint8* input_data, const Dims&lt;4&gt;&amp; input_dims, int stride,\n                 int pad_width, int pad_height, int filter_width,\n                 int filter_height, int32 output_activation_min,\n                 int32 output_activation_max, uint8* output_data,\n                 const Dims&lt;4&gt;&amp; output_dims) {\n  AveragePool&lt;Ac&gt;(input_data, input_dims, stride, stride, pad_width, pad_height,\n                  filter_width, filter_height, output_activation_min,\n                  output_activation_max, output_data, output_dims);\n}',
 'TEST_P(WasmTest, DivByZero) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api-&gt;allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope("wasm."));\n  NiceMock&lt;LocalInfo::MockLocalInfo&gt; local_info;\n  auto name = "";\n  auto root_id = "";\n  auto vm_id = "";\n  auto vm_configuration = "";\n  auto plugin = std::make_shared&lt;Extensions::Common::Wasm::Plugin&gt;(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique&lt;Extensions::Common::Wasm::Wasm&gt;(\n      absl::StrCat("envoy.wasm.runtime.", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      "{{ test_rundir }}/test/extensions/wasm/test_data/segv_cpp.wasm"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique&lt;TestContext&gt;(wasm.get());\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq("before div by zero")));\n  EXPECT_TRUE(wasm-&gt;initialize(code, false));\n  wasm-&gt;setContext(context.get());\n\n  if (GetParam() == "v8") {\n    EXPECT_THROW_WITH_MESSAGE(\n        context-&gt;onLog(), Extensions::Common::Wasm::WasmException,\n        "Function: proxy_onLog failed: Uncaught RuntimeError: divide by zero");\n  } else if (GetParam() == "wavm") {\n    EXPECT_THROW_WITH_REGEX(context-&gt;onLog(), Extensions::Common::Wasm::WasmException,\n                            "Function: proxy_onLog failed: wavm.integerDivideByZeroOrOverflow.*");\n  } else {\n    ASSERT_FALSE(true); // Neither of the above was matched.\n  }\n}',
 "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\n\tgeneric_gss_release_oid(&amp;tmpmin, &amp;sc-&gt;internal_mech);\n\tgss_delete_sec_context(&amp;tmpmin, &amp;sc-&gt;ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\n\t/* Find supportedMech in sc-&gt;mech_set. */\n\tfor (i = 0; i &lt; sc-&gt;mech_set-&gt;count; i++) {\n\t\tif (g_OID_equal(supportedMech, &amp;sc-&gt;mech_set-&gt;elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc-&gt;mech_set-&gt;count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc-&gt;internal_mech = &amp;sc-&gt;mech_set-&gt;elements[i];\n\n\t/*\n\t * Windows 2003 and earlier don't correctly send a\n\t * negState of request-mic when counter-proposing a\n\t * mechanism.  They probably don't handle mechListMICs\n\t * properly either.\n\t */\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tsc-&gt;mech_complete = 0;\n\tsc-&gt;mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}",
 'void RemoteDevicePropertiesWidget::checkSaveable()\n{\n    RemoteFsDevice::Details det=details();\n    modified=det!=orig;\n    saveable=!det.isEmpty();\n    if (saveable &amp;&amp; Type_SambaAvahi==type-&gt;itemData(type-&gt;currentIndex()).toInt()) {\n        saveable=!smbAvahiName-&gt;text().trimmed().isEmpty();\n    }\n    emit updated();\n}',
 'void IGDstartelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tmemcpy( datas-&gt;cureltname, name, l);\n\tdatas-&gt;cureltname[l] = \'\\0\';\n\tdatas-&gt;level++;\n\tif( (l==7) &amp;&amp; !memcmp(name, "service", l) ) {\n\t\tdatas-&gt;tmp.controlurl[0] = \'\\0\';\n\t\tdatas-&gt;tmp.eventsuburl[0] = \'\\0\';\n\t\tdatas-&gt;tmp.scpdurl[0] = \'\\0\';\n\t\tdatas-&gt;tmp.servicetype[0] = \'\\0\';\n\t}\n}',
 'static int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tuint\talen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n\tstruct dm_i2c_chip *i2c_chip;\n#endif\n\n\tif ((argc &lt; 5) || (argc &gt; 6))\n\t\treturn cmd_usage(cmdtp);\n\n\t/*\n\t * memaddr is the address where to store things in memory\n\t */\n\tmemaddr = (u_char *)hextoul(argv[1], NULL);\n\n\t/*\n\t * I2C chip address\n\t */\n\tchip = hextoul(argv[2], NULL);\n\n\t/*\n\t * I2C data address within the chip.  This can be 1 or\n\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t */\n\tdevaddr = hextoul(argv[3], NULL);\n\talen = get_alen(argv[3], DEFAULT_ADDR_LEN);\n\tif (alen &gt; 3)\n\t\treturn cmd_usage(cmdtp);\n\n\t/*\n\t * Length is the number of bytes.\n\t */\n\tlength = hextoul(argv[4], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &amp;dev);\n\tif (!ret &amp;&amp; alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\ti2c_chip = dev_get_parent_plat(dev);\n\tif (!i2c_chip)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\n\tif (argc == 6 &amp;&amp; !strcmp(argv[5], "-s")) {\n\t\t/*\n\t\t * Write all bytes in a single I2C transaction. If the target\n\t\t * device is an EEPROM, it is your responsibility to not cross\n\t\t * a page boundary. No write delay upon completion, take this\n\t\t * into account if linking commands.\n\t\t */\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\ti2c_chip-&gt;flags &amp;= ~DM_I2C_CHIP_WR_ADDRESS;\n\t\tret = dm_i2c_write(dev, devaddr, memaddr, length);\n#else\n\t\tret = i2c_write(chip, devaddr, alen, memaddr, length);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t} else {\n\t\t/*\n\t\t * Repeated addressing - perform &lt;length&gt; separate\n\t\t * write transactions of one byte each\n\t\t */\n\t\twhile (length-- &gt; 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\t\ti2c_chip-&gt;flags |= DM_I2C_CHIP_WR_ADDRESS;\n\t\t\tret = dm_i2c_write(dev, devaddr++, memaddr++, 1);\n#else\n\t\t\tret = i2c_write(chip, devaddr++, alen, memaddr++, 1);\n#endif\n\t\t\tif (ret)\n\t\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n/*\n * No write delay with FRAM devices.\n */\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\t\tudelay(11000);\n#endif\n\t\t}\n\t}\n\treturn 0;\n}',
 'TEST_P(SslSocketTest, GetUriWithUriSan) {\n  const std::string client_ctx_yaml = R"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem"\n      private_key:\n        filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem"\n)EOF";\n\n  const std::string server_ctx_yaml = R"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem"\n      private_key:\n        filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem"\n    validation_context:\n      trusted_ca:\n        filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem"\n      match_typed_subject_alt_names:\n      - san_type: URI\n        matcher:\n          exact: "spiffe://lyft.com/test-team"\n)EOF";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedClientCertUri("spiffe://lyft.com/test-team")\n               .setExpectedSerialNumber(TEST_SAN_URI_CERT_SERIAL));\n}',
 'static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb-&gt;csum;\n\n\tif (skb-&gt;ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &amp;csum);\n}',
 'String StringUtil::Implode(const Variant&amp; items, const String&amp; delim,\n                           const bool checkIsContainer /* = true */) {\n  if (checkIsContainer &amp;&amp; !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n\n  req::vector&lt;String&gt; sitems;\n  sitems.reserve(size);\n  size_t len = 0;\n  size_t lenDelim = delim.size();\n  for (ArrayIter iter(items); iter; ++iter) {\n    sitems.emplace_back(iter.second().toString());\n    len += sitems.back().size() + lenDelim;\n  }\n  len -= lenDelim; // always one delimiter less than count of items\n  assert(sitems.size() == size);\n\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &amp;init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  for (int i = 1; i &lt; size; i++) {\n    String &amp;item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n  }\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}',
 "evutil_parse_sockaddr_port(const char *ip_as_string, struct sockaddr *out, int *outlen)\n{\n\tint port;\n\tchar buf[128];\n\tconst char *cp, *addr_part, *port_part;\n\tint is_ipv6;\n\t/* recognized formats are:\n\t * [ipv6]:port\n\t * ipv6\n\t * [ipv6]\n\t * ipv4:port\n\t * ipv4\n\t */\n\n\tcp = strchr(ip_as_string, ':');\n\tif (*ip_as_string == '[') {\n\t\tint len;\n\t\tif (!(cp = strchr(ip_as_string, ']'))) {\n\t\t\treturn -1;\n\t\t}\n\t\tlen = (int) ( cp-(ip_as_string + 1) );\n\t\tif (len &gt; (int)sizeof(buf)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, ip_as_string+1, len);\n\t\tbuf[len] = '\\0';\n\t\taddr_part = buf;\n\t\tif (cp[1] == ':')\n\t\t\tport_part = cp+2;\n\t\telse\n\t\t\tport_part = NULL;\n\t\tis_ipv6 = 1;\n\t} else if (cp &amp;&amp; strchr(cp+1, ':')) {\n\t\tis_ipv6 = 1;\n\t\taddr_part = ip_as_string;\n\t\tport_part = NULL;\n\t} else if (cp) {\n\t\tis_ipv6 = 0;\n\t\tif (cp - ip_as_string &gt; (int)sizeof(buf)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, ip_as_string, cp-ip_as_string);\n\t\tbuf[cp-ip_as_string] = '\\0';\n\t\taddr_part = buf;\n\t\tport_part = cp+1;\n\t} else {\n\t\taddr_part = ip_as_string;\n\t\tport_part = NULL;\n\t\tis_ipv6 = 0;\n\t}\n\n\tif (port_part == NULL) {\n\t\tport = 0;\n\t} else {\n\t\tport = atoi(port_part);\n\t\tif (port &lt;= 0 || port &gt; 65535) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!addr_part)\n\t\treturn -1; /* Should be impossible. */\n#ifdef AF_INET6\n\tif (is_ipv6)\n\t{\n\t\tstruct sockaddr_in6 sin6;\n\t\tmemset(&amp;sin6, 0, sizeof(sin6));\n#ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n\t\tsin6.sin6_len = sizeof(sin6);\n#endif\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_port = htons(port);\n\t\tif (1 != evutil_inet_pton(AF_INET6, addr_part, &amp;sin6.sin6_addr))\n\t\t\treturn -1;\n\t\tif ((int)sizeof(sin6) &gt; *outlen)\n\t\t\treturn -1;\n\t\tmemset(out, 0, *outlen);\n\t\tmemcpy(out, &amp;sin6, sizeof(sin6));\n\t\t*outlen = sizeof(sin6);\n\t\treturn 0;\n\t}\n\telse\n#endif\n\t{\n\t\tstruct sockaddr_in sin;\n\t\tmemset(&amp;sin, 0, sizeof(sin));\n#ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n\t\tsin.sin_len = sizeof(sin);\n#endif\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(port);\n\t\tif (1 != evutil_inet_pton(AF_INET, addr_part, &amp;sin.sin_addr))\n\t\t\treturn -1;\n\t\tif ((int)sizeof(sin) &gt; *outlen)\n\t\t\treturn -1;\n\t\tmemset(out, 0, *outlen);\n\t\tmemcpy(out, &amp;sin, sizeof(sin));\n\t\t*outlen = sizeof(sin);\n\t\treturn 0;\n\t}\n}",
 '\t\tint fail(int* error_pos\n\t\t\t, std::vector&lt;lazy_entry*&gt;&amp; stack\n\t\t\t, char const* start\n\t\t\t, char const* orig_start)\n\t\t{\n\t\t\twhile (!stack.empty()) {\n\t\t\t\tlazy_entry* top = stack.back();\n\t\t\t\tif (top-&gt;type() == lazy_entry::dict_t || top-&gt;type() == lazy_entry::list_t)\n\t\t\t\t{\n\t\t\t\t\ttop-&gt;pop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstack.pop_back();\n\t\t\t}\n\t\t\tif (error_pos) *error_pos = start - orig_start;\n\t\t\treturn -1;\n\t\t}',
 'tok_nextc(struct tok_state *tok)\n{\n    for (;;) {\n        if (tok-&gt;cur != tok-&gt;inp) {\n            return Py_CHARMASK(*tok-&gt;cur++); /* Fast path */\n        }\n        if (tok-&gt;done != E_OK)\n            return EOF;\n        if (tok-&gt;fp == NULL) {\n            char *end = strchr(tok-&gt;inp, \'\\n\');\n            if (end != NULL)\n                end++;\n            else {\n                end = strchr(tok-&gt;inp, \'\\0\');\n                if (end == tok-&gt;inp) {\n                    tok-&gt;done = E_EOF;\n                    return EOF;\n                }\n            }\n            if (tok-&gt;start == NULL)\n                tok-&gt;buf = tok-&gt;cur;\n            tok-&gt;line_start = tok-&gt;cur;\n            tok-&gt;lineno++;\n            tok-&gt;inp = end;\n            return Py_CHARMASK(*tok-&gt;cur++);\n        }\n        if (tok-&gt;prompt != NULL) {\n            char *newtok = PyOS_Readline(stdin, stdout, tok-&gt;prompt);\n#ifndef PGEN\n            if (newtok != NULL) {\n                char *translated = translate_newlines(newtok, 0, tok);\n                PyMem_FREE(newtok);\n                if (translated == NULL)\n                    return EOF;\n                newtok = translated;\n            }\n            if (tok-&gt;encoding &amp;&amp; newtok &amp;&amp; *newtok) {\n                /* Recode to UTF-8 */\n                Py_ssize_t buflen;\n                const char* buf;\n                PyObject *u = translate_into_utf8(newtok, tok-&gt;encoding);\n                PyMem_FREE(newtok);\n                if (!u) {\n                    tok-&gt;done = E_DECODE;\n                    return EOF;\n                }\n                buflen = PyBytes_GET_SIZE(u);\n                buf = PyBytes_AS_STRING(u);\n                newtok = PyMem_MALLOC(buflen+1);\n                if (newtok == NULL) {\n                    Py_DECREF(u);\n                    tok-&gt;done = E_NOMEM;\n                    return EOF;\n                }\n                strcpy(newtok, buf);\n                Py_DECREF(u);\n            }\n#endif\n            if (tok-&gt;nextprompt != NULL)\n                tok-&gt;prompt = tok-&gt;nextprompt;\n            if (newtok == NULL)\n                tok-&gt;done = E_INTR;\n            else if (*newtok == \'\\0\') {\n                PyMem_FREE(newtok);\n                tok-&gt;done = E_EOF;\n            }\n            else if (tok-&gt;start != NULL) {\n                size_t start = tok-&gt;start - tok-&gt;buf;\n                size_t oldlen = tok-&gt;cur - tok-&gt;buf;\n                size_t newlen = oldlen + strlen(newtok);\n                char *buf = tok-&gt;buf;\n                buf = (char *)PyMem_REALLOC(buf, newlen+1);\n                tok-&gt;lineno++;\n                if (buf == NULL) {\n                    PyMem_FREE(tok-&gt;buf);\n                    tok-&gt;buf = NULL;\n                    PyMem_FREE(newtok);\n                    tok-&gt;done = E_NOMEM;\n                    return EOF;\n                }\n                tok-&gt;buf = buf;\n                tok-&gt;cur = tok-&gt;buf + oldlen;\n                tok-&gt;line_start = tok-&gt;cur;\n                strcpy(tok-&gt;buf + oldlen, newtok);\n                PyMem_FREE(newtok);\n                tok-&gt;inp = tok-&gt;buf + newlen;\n                tok-&gt;end = tok-&gt;inp + 1;\n                tok-&gt;start = tok-&gt;buf + start;\n            }\n            else {\n                tok-&gt;lineno++;\n                if (tok-&gt;buf != NULL)\n                    PyMem_FREE(tok-&gt;buf);\n                tok-&gt;buf = newtok;\n                tok-&gt;cur = tok-&gt;buf;\n                tok-&gt;line_start = tok-&gt;buf;\n                tok-&gt;inp = strchr(tok-&gt;buf, \'\\0\');\n                tok-&gt;end = tok-&gt;inp + 1;\n            }\n        }\n        else {\n            int done = 0;\n            Py_ssize_t cur = 0;\n            char *pt;\n            if (tok-&gt;start == NULL) {\n                if (tok-&gt;buf == NULL) {\n                    tok-&gt;buf = (char *)\n                        PyMem_MALLOC(BUFSIZ);\n                    if (tok-&gt;buf == NULL) {\n                        tok-&gt;done = E_NOMEM;\n                        return EOF;\n                    }\n                    tok-&gt;end = tok-&gt;buf + BUFSIZ;\n                }\n                if (decoding_fgets(tok-&gt;buf, (int)(tok-&gt;end - tok-&gt;buf),\n                          tok) == NULL) {\n                    if (!tok-&gt;decoding_erred)\n                        tok-&gt;done = E_EOF;\n                    done = 1;\n                }\n                else {\n                    tok-&gt;done = E_OK;\n                    tok-&gt;inp = strchr(tok-&gt;buf, \'\\0\');\n                    done = tok-&gt;inp == tok-&gt;buf || tok-&gt;inp[-1] == \'\\n\';\n                }\n            }\n            else {\n                cur = tok-&gt;cur - tok-&gt;buf;\n                if (decoding_feof(tok)) {\n                    tok-&gt;done = E_EOF;\n                    done = 1;\n                }\n                else\n                    tok-&gt;done = E_OK;\n            }\n            tok-&gt;lineno++;\n            /* Read until \'\\n\' or EOF */\n            while (!done) {\n                Py_ssize_t curstart = tok-&gt;start == NULL ? -1 :\n                          tok-&gt;start - tok-&gt;buf;\n                Py_ssize_t curvalid = tok-&gt;inp - tok-&gt;buf;\n                Py_ssize_t newsize = curvalid + BUFSIZ;\n                char *newbuf = tok-&gt;buf;\n                newbuf = (char *)PyMem_REALLOC(newbuf,\n                                               newsize);\n                if (newbuf == NULL) {\n                    tok-&gt;done = E_NOMEM;\n                    tok-&gt;cur = tok-&gt;inp;\n                    return EOF;\n                }\n                tok-&gt;buf = newbuf;\n                tok-&gt;cur = tok-&gt;buf + cur;\n                tok-&gt;line_start = tok-&gt;cur;\n                tok-&gt;inp = tok-&gt;buf + curvalid;\n                tok-&gt;end = tok-&gt;buf + newsize;\n                tok-&gt;start = curstart &lt; 0 ? NULL :\n                         tok-&gt;buf + curstart;\n                if (decoding_fgets(tok-&gt;inp,\n                               (int)(tok-&gt;end - tok-&gt;inp),\n                               tok) == NULL) {\n                    /* Break out early on decoding\n                       errors, as tok-&gt;buf will be NULL\n                     */\n                    if (tok-&gt;decoding_erred)\n                        return EOF;\n                    /* Last line does not end in \\n,\n                       fake one */\n                    strcpy(tok-&gt;inp, "\\n");\n                }\n                tok-&gt;inp = strchr(tok-&gt;inp, \'\\0\');\n                done = tok-&gt;inp[-1] == \'\\n\';\n            }\n            if (tok-&gt;buf != NULL) {\n                tok-&gt;cur = tok-&gt;buf + cur;\n                tok-&gt;line_start = tok-&gt;cur;\n                /* replace "\\r\\n" with "\\n" */\n                /* For Mac leave the \\r, giving a syntax error */\n                pt = tok-&gt;inp - 2;\n                if (pt &gt;= tok-&gt;buf &amp;&amp; *pt == \'\\r\') {\n                    *pt++ = \'\\n\';\n                    *pt = \'\\0\';\n                    tok-&gt;inp = pt;\n                }\n            }\n        }\n        if (tok-&gt;done != E_OK) {\n            if (tok-&gt;prompt != NULL)\n                PySys_WriteStderr("\\n");\n            tok-&gt;cur = tok-&gt;inp;\n            return EOF;\n        }\n    }\n    /*NOTREACHED*/\n}',
 'uint32 TIFF_WriteOverview( TIFF *hTIFF, uint32 nXSize, uint32 nYSize,\n                           int nBitsPerPixel, int nPlanarConfig, int nSamples, \n                           int nBlockXSize, int nBlockYSize,\n                           int bTiled, int nCompressFlag, int nPhotometric,\n                           int nSampleFormat,\n                           unsigned short *panRed,\n                           unsigned short *panGreen,\n                           unsigned short *panBlue,\n                           int bUseSubIFDs,\n                           int nHorSubsampling, int nVerSubsampling )\n\n{\n    toff_t\tnBaseDirOffset;\n    toff_t\tnOffset;\n\n    (void) bUseSubIFDs;\n\n    nBaseDirOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFCreateDirectory( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Setup TIFF fields.                                              */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    if( nSamples == 1 )\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    else\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig );\n\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n\n    if( bTiled )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize );\n        TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize );\n    }\n    else\n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize );\n\n    TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE );\n\n    if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, nHorSubsampling, nVerSubsampling);\n        /* TODO: also write YCbCrPositioning and YCbCrCoefficients tag identical to source IFD */\n    }\n    /* TODO: add command-line parameter for selecting jpeg compression quality\n     * that gets ignored when compression isn\'t jpeg */\n\n/* -------------------------------------------------------------------- */\n/*\tWrite color table if one is present.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( panRed != NULL )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write directory, and return byte offset.                        */\n/* -------------------------------------------------------------------- */\n    if( TIFFWriteCheck( hTIFF, bTiled, "TIFFBuildOverviews" ) == 0 )\n        return 0;\n\n    TIFFWriteDirectory( hTIFF );\n    TIFFSetDirectory( hTIFF, (tdir_t) (TIFFNumberOfDirectories(hTIFF)-1) );\n\n    nOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n\n    return nOffset;\n}',
 'static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n\n    buffer = sizeof(small) &lt; size ? small : g_malloc(MIN(65536, size));\n    while (size &gt; 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n\n        if (count &lt;= 0) {\n            goto cleanup;\n        }\n        assert(count &lt;= size);\n        size -= count;\n        ret += count;\n    }\n\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}',
 'TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  // Check for supported activation types.\n  auto* params =\n      reinterpret_cast&lt;TfLiteFullyConnectedParams*&gt;(node-&gt;builtin_data);\n  const TfLiteTensor* filter;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kWeightsTensor, &amp;filter));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &amp;input));\n  const bool is_quantized =\n      ((filter-&gt;type == kTfLiteUInt8) || (filter-&gt;type == kTfLiteInt8));\n  const bool is_hybrid = is_quantized &amp;&amp; (input-&gt;type == kTfLiteFloat32);\n  const bool is_pie = kernel_type == kLegacyPie;\n\n  // Pie and hybrid path supports all kinds of fused activations, otherwise only\n  // clipping activations are supported.\n  if (!is_pie &amp;&amp; !is_hybrid) {\n    TF_LITE_ENSURE(context, params-&gt;activation == kTfLiteActNone ||\n                                params-&gt;activation == kTfLiteActRelu ||\n                                params-&gt;activation == kTfLiteActReluN1To1 ||\n                                params-&gt;activation == kTfLiteActRelu6);\n  }\n  return PrepareImpl(context, node);\n}',
 'static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *last,\n\t\t\tvoid *data)\n{\n\tchar *name = path_name(path, last);\n\n\tadd_preferred_base_object(name);\n\tadd_object_entry(obj-&gt;oid.hash, obj-&gt;type, name, 0);\n\tobj-&gt;flags |= OBJECT_ADDED;\n\n\t/*\n\t * We will have generated the hash from the name,\n\t * but not saved a pointer to it - we can free it\n\t */\n\tfree((char *)name);\n}',
 "\tint lazy_bdecode(char const* start, char const* end, lazy_entry&amp; ret\n\t\t, error_code&amp; ec, int* error_pos, int depth_limit, int item_limit)\n\t{\n\t\tchar const* const orig_start = start;\n\t\tret.clear();\n\t\tif (start == end) return 0;\n\n\t\tstd::vector&lt;lazy_entry*&gt; stack;\n\n\t\tstack.push_back(&amp;ret);\n\t\twhile (start &lt; end)\n\t\t{\n\t\t\tif (stack.empty()) break; // done!\n\n\t\t\tlazy_entry* top = stack.back();\n\n\t\t\tif (int(stack.size()) &gt; depth_limit) TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);\n\t\t\tif (start &gt;= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\tchar t = *start;\n\t\t\t++start;\n\t\t\tif (start &gt;= end &amp;&amp; t != 'e') TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\n\t\t\tswitch (top-&gt;type())\n\t\t\t{\n\t\t\t\tcase lazy_entry::dict_t:\n\t\t\t\t{\n\t\t\t\t\tif (t == 'e')\n\t\t\t\t\t{\n\t\t\t\t\t\ttop-&gt;set_end(start);\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!is_digit(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);\n\t\t\t\t\tboost::int64_t len = t - '0';\n\t\t\t\t\tstart = parse_int(start, end, ':', len);\n\t\t\t\t\tif (start == 0 || start + len + 3 &gt; end || *start != ':')\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);\n\t\t\t\t\t++start;\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tlazy_entry* ent = top-&gt;dict_append(start);\n\t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n\t\t\t\t\tstart += len;\n\t\t\t\t\tif (start &gt;= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tstack.push_back(ent);\n\t\t\t\t\tt = *start;\n\t\t\t\t\t++start;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase lazy_entry::list_t:\n\t\t\t\t{\n\t\t\t\t\tif (t == 'e')\n\t\t\t\t\t{\n\t\t\t\t\t\ttop-&gt;set_end(start);\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlazy_entry* ent = top-&gt;list_append();\n\t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n\t\t\t\t\tstack.push_back(ent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault: break;\n\t\t\t}\n\n\t\t\t--item_limit;\n\t\t\tif (item_limit &lt;= 0) TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);\n\n\t\t\ttop = stack.back();\n\t\t\tswitch (t)\n\t\t\t{\n\t\t\t\tcase 'd':\n\t\t\t\t\ttop-&gt;construct_dict(start - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'l':\n\t\t\t\t\ttop-&gt;construct_list(start - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'i':\n\t\t\t\t{\n\t\t\t\t\tchar const* int_start = start;\n\t\t\t\t\tstart = find_char(start, end, 'e');\n\t\t\t\t\ttop-&gt;construct_int(int_start, start - int_start);\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tTORRENT_ASSERT(*start == 'e');\n\t\t\t\t\t++start;\n\t\t\t\t\tstack.pop_back();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif (!is_digit(t))\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_value);\n\n\t\t\t\t\tboost::int64_t len = t - '0';\n\t\t\t\t\tstart = parse_int(start, end, ':', len);\n\t\t\t\t\tif (start == 0 || start + len + 1 &gt; end || *start != ':')\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);\n\t\t\t\t\t++start;\n\t\t\t\t\ttop-&gt;construct_string(start, int(len));\n\t\t\t\t\tstack.pop_back();\n\t\t\t\t\tstart += len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t}",
 '  ErrorType encrypt(unsigned char* packet,\n                    uint32_t packet_len,\n                    uint32_t seqno) {\n    ErrorType r = kErrNone;\n\n    // `packet` layout:\n    //   &lt;packet length&gt; &lt;padding length&gt; &lt;payload&gt; &lt;padding&gt; &lt;mac&gt;\n    uint32_t data_len = packet_len - hmac_len_;\n\n    int outlen;\n\n    uint8_t seqbuf[4] = {0};\n    ((uint8_t*)(seqbuf))[0] = (seqno &gt;&gt; 24) &amp; 0xff;\n    ((uint8_t*)(seqbuf))[1] = (seqno &gt;&gt; 16) &amp; 0xff;\n    ((uint8_t*)(seqbuf))[2] = (seqno &gt;&gt; 8) &amp; 0xff;\n    ((uint8_t*)(seqbuf))[3] = seqno &amp; 0xff;\n\n    if (is_etm_) {\n      // Encrypt everything but packet length\n      if (EVP_EncryptUpdate(ctx_,\n                            packet + 4,\n                            &amp;outlen,\n                            packet + 4,\n                            data_len - 4) != 1) {\n        r = kErrOpenSSL;\n        goto out;\n      }\n      if (static_cast&lt;size_t&gt;(outlen) != data_len - 4) {\n        r = kErrPartialEncrypt;\n        goto out;\n      }\n\n      // HMAC over unencrypted packet length and ciphertext\n      {\n        unsigned int outlen = hmac_len_;\n        if (HMAC_Init_ex(ctx_hmac_, nullptr, 0, nullptr, nullptr) != 1\n            || HMAC_Update(ctx_hmac_, seqbuf, sizeof(seqbuf)) != 1\n            || HMAC_Update(ctx_hmac_, packet, data_len) != 1\n            || HMAC_Final(ctx_hmac_, packet + data_len, &amp;outlen) != 1) {\n          r = kErrOpenSSL;\n          goto out;\n        }\n        if (outlen != hmac_len_) {\n          r = kErrBadHMACLen;\n          goto out;\n        }\n      }\n    } else {\n      // HMAC over plaintext\n      {\n        unsigned int outlen = hmac_len_;\n        if (HMAC_Init_ex(ctx_hmac_, nullptr, 0, nullptr, nullptr) != 1\n            || HMAC_Update(ctx_hmac_, seqbuf, sizeof(seqbuf)) != 1\n            || HMAC_Update(ctx_hmac_, packet, data_len) != 1\n            || HMAC_Final(ctx_hmac_, packet + data_len, &amp;outlen) != 1) {\n          r = kErrOpenSSL;\n          goto out;\n        }\n        if (outlen != hmac_len_) {\n          r = kErrBadHMACLen;\n          goto out;\n        }\n      }\n\n      // Encrypt packet\n      if (EVP_EncryptUpdate(ctx_,\n                            packet,\n                            &amp;outlen,\n                            packet,\n                            data_len) != 1) {\n        r = kErrOpenSSL;\n        goto out;\n      }\n      if (static_cast&lt;size_t&gt;(outlen) != data_len) {\n        \n        r = kErrPartialEncrypt;\n        goto out;\n      }\n    }\n\nout:\n    return r;\n  }',
 'ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf-&gt;b_op_start.lnum = n + 1;\n\tcurbuf-&gt;b_op_end.lnum = n + count;\n\tcurbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin-&gt;w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin-&gt;w_cursor.lnum = n;\n    while (line1 &lt;= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin-&gt;w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin-&gt;w_cursor.lnum;\n\t++line1;\n\tif (curwin-&gt;w_cursor.lnum &lt; line1)\n\t    ++line1;\n\tif (curwin-&gt;w_cursor.lnum &lt; line2)\n\t    ++line2;\n\t++curwin-&gt;w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n    if (VIsual_active)\n\tcheck_pos(curbuf, &amp;VIsual);\n\n    msgmore((long)count);\n}',
 'static int http_connect(http_subtransport *t)\n{\n\tint error;\n\n\tif (t-&gt;connected &amp;&amp;\n\t\thttp_should_keep_alive(&amp;t-&gt;parser) &amp;&amp;\n\t\tt-&gt;parse_finished)\n\t\treturn 0;\n\n\tif (t-&gt;io) {\n\t\tgit_stream_close(t-&gt;io);\n\t\tgit_stream_free(t-&gt;io);\n\t\tt-&gt;io = NULL;\n\t\tt-&gt;connected = 0;\n\t}\n\n\tif (t-&gt;connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&amp;t-&gt;io, t-&gt;connection_data.host, t-&gt;connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&amp;t-&gt;io, t-&gt;connection_data.host, t-&gt;connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&amp;t-&gt;io,  t-&gt;connection_data.host, t-&gt;connection_data.port);\n#endif\n\t}\n\n\tif (error &lt; 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t-&gt;io, GIT_STREAM_VERSION, "git_stream");\n\n\tapply_proxy_config(t);\n\n\terror = git_stream_connect(t-&gt;io);\n\n\tif ((!error || error == GIT_ECERTIFICATE) &amp;&amp; t-&gt;owner-&gt;certificate_check_cb != NULL &amp;&amp;\n\t    git_stream_is_encrypted(t-&gt;io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&amp;cert, t-&gt;io)) &lt; 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t-&gt;owner-&gt;certificate_check_cb(cert, is_valid, t-&gt;connection_data.host, t-&gt;owner-&gt;message_cb_payload);\n\n\t\tif (error &lt; 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, "user cancelled certificate check");\n\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (error &lt; 0)\n\t\treturn error;\n\n\tt-&gt;connected = 1;\n\treturn 0;\n}',
 'spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}',
 'Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &amp;pSrc-&gt;a[iSrc];\n    p-&gt;y.pTab = pItem-&gt;pTab;\n    p-&gt;iTable = pItem-&gt;iCursor;\n    if( p-&gt;y.pTab-&gt;iPKey==iCol ){\n      p-&gt;iColumn = -1;\n    }else{\n      p-&gt;iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem-&gt;colUsed |= ((Bitmask)1)&lt;&lt;(iCol&gt;=BMS ? BMS-1 : iCol);\n    }\n  }\n  return p;\n}',
 'static cJSON *create_reference( cJSON *item )\n{\n\tcJSON *ref;\n\tif ( ! ( ref = cJSON_New_Item() ) )\n\t\treturn 0;\n\tmemcpy( ref, item, sizeof(cJSON) );\n\tref-&gt;string = 0;\n\tref-&gt;type |= cJSON_IsReference;\n\tref-&gt;next = ref-&gt;prev = 0;\n\treturn ref;\n}',
 'static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n\n    if (ctx-&gt;trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) &lt; zeroes + 1) {\n            av_log(ctx-&gt;log_ctx, AV_LOG_ERROR, "Invalid uvlc code at "\n                   "%s: bitstream ended.\\n", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc)) {\n            bits[i++] = \'1\';\n            break;\n        } else {\n            bits[i++] = \'0\';\n            ++zeroes;\n        }\n    }\n\n    if (zeroes &gt;= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n\n        for (j = 0; j &lt; zeroes; j++)\n            bits[i++] = (value &gt;&gt; (zeroes - j - 1) &amp; 1) ? \'1\' : \'0\';\n\n        value += (1 &lt;&lt; zeroes) - 1;\n    }\n\n    if (ctx-&gt;trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n\n    if (value &lt; range_min || value &gt; range_max) {\n        av_log(ctx-&gt;log_ctx, AV_LOG_ERROR, "%s out of range: "\n               "%"PRIu32", but must be in [%"PRIu32",%"PRIu32"].\\n",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;\n    return 0;\n}',
 'prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser-&gt;m_encoding, s, end, &amp;next);\n  return doProlog(parser, parser-&gt;m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser-&gt;m_parsingStatus.finalBuffer, XML_TRUE);\n}',
 'static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\n\t*num_xfrms = pols[0]-&gt;xfrm_nr;\n\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]-&gt;action == XFRM_POLICY_ALLOW &amp;&amp;\n\t    pols[0]-&gt;type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]-&gt;if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]-&gt;xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i &lt; *num_pols; i++) {\n\t\tif (pols[i]-&gt;action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}',
 'TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input-&gt;type, output-&gt;type);\n\n  return context-&gt;ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input-&gt;dims));\n}',
 'BigInt EC_Group::multiply_mod_order(const BigInt&amp; x, const BigInt&amp; y, const BigInt&amp; z) const\n   {\n   return data().multiply_mod_order(x, y, z);\n   }',
 'handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; /* index for kwdefaults and kwonlyargs */\n\n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), "named arguments must follow bare *");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i &lt; NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 &lt; NCH(n) &amp;&amp; TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; /* \'=\' and test */\n                }\n                else { /* setting NULL if no default value exists */\n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    /* ch is NAME \':\' test */\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, LINENO(ch), ch-&gt;n_col_offset,\n                          ch-&gt;n_end_lineno, ch-&gt;n_end_col_offset,\n                          c-&gt;c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 2; /* the name and the comma */\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, "unexpected node");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}',
 '  void Compute(OpKernelContext* ctx) override {\n    const Tensor* inputs;\n    const Tensor* labels_indices;\n    const Tensor* labels_values;\n    const Tensor* seq_len;\n    OP_REQUIRES_OK(ctx, ctx-&gt;input("inputs", &amp;inputs));\n    OP_REQUIRES_OK(ctx, ctx-&gt;input("labels_indices", &amp;labels_indices));\n    OP_REQUIRES_OK(ctx, ctx-&gt;input("labels_values", &amp;labels_values));\n    OP_REQUIRES_OK(ctx, ctx-&gt;input("sequence_length", &amp;seq_len));\n\n    OP_REQUIRES(ctx, inputs-&gt;shape().dims() == 3,\n                errors::InvalidArgument("inputs is not a 3-Tensor"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(seq_len-&gt;shape()),\n                errors::InvalidArgument("sequence_length is not a vector"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(labels_indices-&gt;shape()),\n                errors::InvalidArgument("labels_indices is not a matrix"));\n    OP_REQUIRES(ctx, labels_indices-&gt;dim_size(1) &gt; 1,\n                errors::InvalidArgument(\n                    "labels_indices second dimension must be &gt;= 1. Received ",\n                    labels_indices-&gt;dim_size(1)));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(labels_values-&gt;shape()),\n                errors::InvalidArgument("labels_values is not a vector"));\n\n    const TensorShape&amp; inputs_shape = inputs-&gt;shape();\n    const int64 max_time = inputs_shape.dim_size(0);\n    const int64 batch_size = inputs_shape.dim_size(1);\n    const int64 num_classes_raw = inputs_shape.dim_size(2);\n    OP_REQUIRES(\n        ctx, FastBoundsCheck(num_classes_raw, std::numeric_limits&lt;int&gt;::max()),\n        errors::InvalidArgument("num_classes cannot exceed max int"));\n    const int num_classes = static_cast&lt;const int&gt;(num_classes_raw);\n\n    OP_REQUIRES(\n        ctx, batch_size == seq_len-&gt;dim_size(0),\n        errors::InvalidArgument("len(sequence_length) != batch_size.  ",\n                                "len(sequence_length):  ", seq_len-&gt;dim_size(0),\n                                " batch_size: ", batch_size));\n    auto seq_len_t = seq_len-&gt;vec&lt;int32&gt;();\n\n    OP_REQUIRES(ctx, labels_indices-&gt;dim_size(0) == labels_values-&gt;dim_size(0),\n                errors::InvalidArgument(\n                    "labels_indices and labels_values must contain the "\n                    "same number of rows, but saw shapes: ",\n                    labels_indices-&gt;shape().DebugString(), " vs. ",\n                    labels_values-&gt;shape().DebugString()));\n\n    OP_REQUIRES(ctx, batch_size != 0,\n                errors::InvalidArgument("batch_size must not be 0"));\n\n    // Figure out the maximum label length to use as sparse tensor dimension.\n    auto labels_indices_t = labels_indices-&gt;matrix&lt;int64&gt;();\n    int64 max_label_len = 0;\n    for (int i = 0; i &lt; labels_indices-&gt;dim_size(0); i++) {\n      max_label_len = std::max(max_label_len, labels_indices_t(i, 1) + 1);\n    }\n\n    TensorShape labels_shape({batch_size, max_label_len});\n    std::vector&lt;int64&gt; order{0, 1};\n    sparse::SparseTensor labels_sp;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(*labels_indices, *labels_values,\n                                          labels_shape, order, &amp;labels_sp));\n\n    Status labels_sp_valid = labels_sp.IndicesValid();\n    OP_REQUIRES(ctx, labels_sp_valid.ok(),\n                errors::InvalidArgument("label SparseTensor is not valid: ",\n                                        labels_sp_valid.error_message()));\n\n    typename ctc::CTCLossCalculator&lt;T&gt;::LabelSequences labels_t(batch_size);\n    for (const auto&amp; g : labels_sp.group({0})) {  // iterate by batch\n      const int64 batch_indices = g.group()[0];\n      OP_REQUIRES(ctx, FastBoundsCheck(batch_indices, batch_size),\n                  errors::InvalidArgument("labels batch index must be between ",\n                                          0, " and ", batch_size,\n                                          " but saw: ", batch_indices));\n\n      auto values = g.values&lt;int32&gt;();\n      std::vector&lt;int&gt;* b_values = &amp;labels_t[batch_indices];\n      b_values-&gt;resize(values.size());\n      for (int i = 0; i &lt; values.size(); ++i) (*b_values)[i] = values(i);\n    }\n\n    OP_REQUIRES(ctx, static_cast&lt;size_t&gt;(batch_size) == labels_t.size(),\n                errors::InvalidArgument("len(labels) != batch_size.  ",\n                                        "len(labels):  ", labels_t.size(),\n                                        " batch_size: ", batch_size));\n\n    for (int64 b = 0; b &lt; batch_size; ++b) {\n      OP_REQUIRES(\n          ctx, seq_len_t(b) &lt;= max_time,\n          errors::InvalidArgument("sequence_length(", b, ") &lt;= ", max_time));\n    }\n\n    Tensor* loss = nullptr;\n    OP_REQUIRES_OK(ctx, ctx-&gt;allocate_output("loss", seq_len-&gt;shape(), &amp;loss));\n    auto loss_t = loss-&gt;vec&lt;T&gt;();\n\n    Tensor* gradient;\n    OP_REQUIRES_OK(ctx,\n                   ctx-&gt;allocate_output("gradient", inputs_shape, &amp;gradient));\n    auto gradient_t = gradient-&gt;tensor&lt;T, 3&gt;();\n    auto inputs_t = inputs-&gt;tensor&lt;T, 3&gt;();\n    std::vector&lt;OutputMap&gt; gradient_list_t;\n    std::vector&lt;InputMap&gt; input_list_t;\n\n    for (std::size_t t = 0; t &lt; max_time; ++t) {\n      input_list_t.emplace_back(inputs_t.data() + t * batch_size * num_classes,\n                                batch_size, num_classes);\n      gradient_list_t.emplace_back(\n          gradient_t.data() + t * batch_size * num_classes, batch_size,\n          num_classes);\n    }\n\n    gradient_t.setZero();\n\n    // Assumption: the blank index is num_classes - 1\n    ctc::CTCLossCalculator&lt;T&gt; ctc_loss_calculator(num_classes - 1, 0);\n    DeviceBase::CpuWorkerThreads workers =\n        *ctx-&gt;device()-&gt;tensorflow_cpu_worker_threads();\n    OP_REQUIRES_OK(ctx, ctc_loss_calculator.CalculateLoss(\n                            seq_len_t, labels_t, input_list_t,\n                            preprocess_collapse_repeated_, ctc_merge_repeated_,\n                            ignore_longer_outputs_than_inputs_, &amp;loss_t,\n                            &amp;gradient_list_t, &amp;workers));\n  }',
 'SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n\t\tstruct epoll_event __user *, event)\n{\n\tint error;\n\tint did_lock_epmutex = 0;\n\tstruct file *file, *tfile;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct epoll_event epds;\n\n\terror = -EFAULT;\n\tif (ep_op_has_event(op) &amp;&amp;\n\t    copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))\n\t\tgoto error_return;\n\n\t/* Get the "struct file *" for the eventpoll file */\n\terror = -EBADF;\n\tfile = fget(epfd);\n\tif (!file)\n\t\tgoto error_return;\n\n\t/* Get the "struct file *" for the target file */\n\ttfile = fget(fd);\n\tif (!tfile)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (file == tfile || !is_file_epoll(file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * At this point it is safe to assume that the "private_data" contains\n\t * our own data structure.\n\t */\n\tep = file-&gt;private_data;\n\n\t/*\n\t * When we insert an epoll file descriptor, inside another epoll file\n\t * descriptor, there is the change of creating closed loops, which are\n\t * better be handled here, than in more critical paths. While we are\n\t * checking for loops we also determine the list of files reachable\n\t * and hang them on the tfile_check_list, so we can check that we\n\t * haven\'t created too many possible wakeup paths.\n\t *\n\t * We need to hold the epmutex across both ep_insert and ep_remove\n\t * b/c we want to make sure we are looking at a coherent view of\n\t * epoll network.\n\t */\n\tif (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) {\n\t\tmutex_lock(&amp;epmutex);\n\t\tdid_lock_epmutex = 1;\n\t}\n\tif (op == EPOLL_CTL_ADD) {\n\t\tif (is_file_epoll(tfile)) {\n\t\t\terror = -ELOOP;\n\t\t\tif (ep_loop_check(ep, tfile) != 0) {\n\t\t\t\tclear_tfile_check_list();\n\t\t\t\tgoto error_tgt_fput;\n\t\t\t}\n\t\t} else\n\t\t\tlist_add(&amp;tfile-&gt;f_tfile_llink, &amp;tfile_check_list);\n\t}\n\n\tmutex_lock_nested(&amp;ep-&gt;mtx, 0);\n\n\t/*\n\t * Try to lookup the file inside our RB tree, Since we grabbed "mtx"\n\t * above, we can be sure to be able to use the item looked up by\n\t * ep_find() till we release the mutex.\n\t */\n\tepi = ep_find(ep, tfile, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:\n\t\tif (!epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_insert(ep, &amp;epds, tfile, fd);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tclear_tfile_check_list();\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:\n\t\tif (epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_modify(ep, epi, &amp;epds);\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tmutex_unlock(&amp;ep-&gt;mtx);\n\nerror_tgt_fput:\n\tif (did_lock_epmutex)\n\t\tmutex_unlock(&amp;epmutex);\n\n\tfput(tfile);\nerror_fput:\n\tfput(file);\nerror_return:\n\n\treturn error;\n}',
 'int CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff &amp;&amp; (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) /* "HEAP" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}',
 'static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * "/run" + "/lxc/lock/$lxcpath/$lxcname + \'\\0\' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + "/lxc/lock/$lxcpath/$lxcname + \'\\0\' if non-root\n\t */\n\n\t/* length of "/lxc/lock/" + $lxcpath + "/" + "." + $lxcname + \'\\0\' */\n\tlen = strlen("/lxc/lock/") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, "%s/lxc/lock/%s", rundir, p);\n\tif (ret &lt; 0 || ret &gt;= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret &lt; 0) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, "%s/lxc/lock/%s/.%s", rundir, p, n);\n\tfree(rundir);\n\tif (ret &lt; 0 || ret &gt;= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}',
 'static void nsc_encode_subsampling(NSC_CONTEXT* context)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tBYTE* co_dst;\n\tBYTE* cg_dst;\n\tINT8* co_src0;\n\tINT8* co_src1;\n\tINT8* cg_src0;\n\tINT8* cg_src1;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\ttempWidth = ROUND_UP_TO(context-&gt;width, 8);\n\ttempHeight = ROUND_UP_TO(context-&gt;height, 2);\n\n\tfor (y = 0; y &lt; tempHeight &gt;&gt; 1; y++)\n\t{\n\t\tco_dst = context-&gt;priv-&gt;PlaneBuffers[1] + y * (tempWidth &gt;&gt; 1);\n\t\tcg_dst = context-&gt;priv-&gt;PlaneBuffers[2] + y * (tempWidth &gt;&gt; 1);\n\t\tco_src0 = (INT8*) context-&gt;priv-&gt;PlaneBuffers[1] + (y &lt;&lt; 1) * tempWidth;\n\t\tco_src1 = co_src0 + tempWidth;\n\t\tcg_src0 = (INT8*) context-&gt;priv-&gt;PlaneBuffers[2] + (y &lt;&lt; 1) * tempWidth;\n\t\tcg_src1 = cg_src0 + tempWidth;\n\n\t\tfor (x = 0; x &lt; tempWidth &gt;&gt; 1; x++)\n\t\t{\n\t\t\t*co_dst++ = (BYTE)(((INT16) * co_src0 + (INT16) * (co_src0 + 1) +\n\t\t\t                    (INT16) * co_src1 + (INT16) * (co_src1 + 1)) &gt;&gt; 2);\n\t\t\t*cg_dst++ = (BYTE)(((INT16) * cg_src0 + (INT16) * (cg_src0 + 1) +\n\t\t\t                    (INT16) * cg_src1 + (INT16) * (cg_src1 + 1)) &gt;&gt; 2);\n\t\t\tco_src0 += 2;\n\t\t\tco_src1 += 2;\n\t\t\tcg_src0 += 2;\n\t\t\tcg_src1 += 2;\n\t\t}\n\t}\n}',
 "int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n\t\t    struct cmsghdr *cmsg)\n{\n\tstruct page *page = NULL;\n\tstruct rds_atomic_args *args;\n\tint ret = 0;\n\n\tif (cmsg-&gt;cmsg_len &lt; CMSG_LEN(sizeof(struct rds_atomic_args))\n\t || rm-&gt;atomic.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\t/* Nonmasked &amp; masked cmsg ops converted to masked hw ops */\n\tswitch (cmsg-&gt;cmsg_type) {\n\tcase RDS_CMSG_ATOMIC_FADD:\n\t\trm-&gt;atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm-&gt;atomic.op_m_fadd.add = args-&gt;fadd.add;\n\t\trm-&gt;atomic.op_m_fadd.nocarry_mask = 0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_FADD:\n\t\trm-&gt;atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm-&gt;atomic.op_m_fadd.add = args-&gt;m_fadd.add;\n\t\trm-&gt;atomic.op_m_fadd.nocarry_mask = args-&gt;m_fadd.nocarry_mask;\n\t\tbreak;\n\tcase RDS_CMSG_ATOMIC_CSWP:\n\t\trm-&gt;atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm-&gt;atomic.op_m_cswp.compare = args-&gt;cswp.compare;\n\t\trm-&gt;atomic.op_m_cswp.swap = args-&gt;cswp.swap;\n\t\trm-&gt;atomic.op_m_cswp.compare_mask = ~0;\n\t\trm-&gt;atomic.op_m_cswp.swap_mask = ~0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_CSWP:\n\t\trm-&gt;atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm-&gt;atomic.op_m_cswp.compare = args-&gt;m_cswp.compare;\n\t\trm-&gt;atomic.op_m_cswp.swap = args-&gt;m_cswp.swap;\n\t\trm-&gt;atomic.op_m_cswp.compare_mask = args-&gt;m_cswp.compare_mask;\n\t\trm-&gt;atomic.op_m_cswp.swap_mask = args-&gt;m_cswp.swap_mask;\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* should never happen */\n\t}\n\n\trm-&gt;atomic.op_notify = !!(args-&gt;flags &amp; RDS_RDMA_NOTIFY_ME);\n\trm-&gt;atomic.op_silent = !!(args-&gt;flags &amp; RDS_RDMA_SILENT);\n\trm-&gt;atomic.op_active = 1;\n\trm-&gt;atomic.op_recverr = rs-&gt;rs_recverr;\n\trm-&gt;atomic.op_sg = rds_message_alloc_sgs(rm, 1);\n\tif (!rm-&gt;atomic.op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* verify 8 byte-aligned */\n\tif (args-&gt;local_addr &amp; 0x7) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = rds_pin_pages(args-&gt;local_addr, 1, &amp;page, 1);\n\tif (ret != 1)\n\t\tgoto err;\n\tret = 0;\n\n\tsg_set_page(rm-&gt;atomic.op_sg, page, 8, offset_in_page(args-&gt;local_addr));\n\n\tif (rm-&gt;atomic.op_notify || rm-&gt;atomic.op_recverr) {\n\t\t/* We allocate an uninitialized notifier here, because\n\t\t * we don't want to do that in the completion handler. We\n\t\t * would have to use GFP_ATOMIC there, and don't want to deal\n\t\t * with failed allocations.\n\t\t */\n\t\trm-&gt;atomic.op_notifier = kmalloc(sizeof(*rm-&gt;atomic.op_notifier), GFP_KERNEL);\n\t\tif (!rm-&gt;atomic.op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trm-&gt;atomic.op_notifier-&gt;n_user_token = args-&gt;user_token;\n\t\trm-&gt;atomic.op_notifier-&gt;n_status = RDS_RDMA_SUCCESS;\n\t}\n\n\trm-&gt;atomic.op_rkey = rds_rdma_cookie_key(args-&gt;cookie);\n\trm-&gt;atomic.op_remote_addr = args-&gt;remote_addr + rds_rdma_cookie_offset(args-&gt;cookie);\n\n\treturn ret;\nerr:\n\tif (page)\n\t\tput_page(page);\n\trm-&gt;atomic.op_active = 0;\n\tkfree(rm-&gt;atomic.op_notifier);\n\n\treturn ret;\n}",
 'DSA_PrivateKey::create_signature_op(RandomNumberGenerator&amp; /*rng*/,\n                                    const std::string&amp; params,\n                                    const std::string&amp; provider) const\n   {\n   if(provider == "base" || provider.empty())\n      return std::unique_ptr&lt;PK_Ops::Signature&gt;(new DSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }',
 'static noinline int btrfs_ioctl_resize(struct file *file,\n\t\t\t\t\tvoid __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode-&gt;i_sb);\n\tu64 new_size;\n\tu64 old_size;\n\tu64 devid = 1;\n\tstruct btrfs_root *root = BTRFS_I(inode)-&gt;root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device = NULL;\n\tchar *sizestr;\n\tchar *retptr;\n\tchar *devstr = NULL;\n\tint ret = 0;\n\tint mod = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (test_and_set_bit(BTRFS_FS_EXCL_OP, &amp;fs_info-&gt;flags)) {\n\t\tmnt_drop_write_file(file);\n\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t}\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args-&gt;name[BTRFS_PATH_NAME_MAX] = \'\\0\';\n\n\tsizestr = vol_args-&gt;name;\n\tdevstr = strchr(sizestr, \':\');\n\tif (devstr) {\n\t\tsizestr = devstr + 1;\n\t\t*devstr = \'\\0\';\n\t\tdevstr = vol_args-&gt;name;\n\t\tret = kstrtoull(devstr, 10, &amp;devid);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t\tif (!devid) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbtrfs_info(fs_info, "resizing devid %llu", devid);\n\t}\n\n\tdevice = btrfs_find_device(fs_info-&gt;fs_devices, devid, NULL, NULL);\n\tif (!device) {\n\t\tbtrfs_info(fs_info, "resizer unable to find device %llu",\n\t\t\t   devid);\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tif (!test_bit(BTRFS_DEV_STATE_WRITEABLE, &amp;device-&gt;dev_state)) {\n\t\tbtrfs_info(fs_info,\n\t\t\t   "resizer unable to apply on readonly device %llu",\n\t\t       devid);\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\tif (!strcmp(sizestr, "max"))\n\t\tnew_size = device-&gt;bdev-&gt;bd_inode-&gt;i_size;\n\telse {\n\t\tif (sizestr[0] == \'-\') {\n\t\t\tmod = -1;\n\t\t\tsizestr++;\n\t\t} else if (sizestr[0] == \'+\') {\n\t\t\tmod = 1;\n\t\t\tsizestr++;\n\t\t}\n\t\tnew_size = memparse(sizestr, &amp;retptr);\n\t\tif (*retptr != \'\\0\' || new_size == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &amp;device-&gt;dev_state)) {\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\told_size = btrfs_device_get_total_bytes(device);\n\n\tif (mod &lt; 0) {\n\t\tif (new_size &gt; old_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size - new_size;\n\t} else if (mod &gt; 0) {\n\t\tif (new_size &gt; ULLONG_MAX - old_size) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size + new_size;\n\t}\n\n\tif (new_size &lt; SZ_256M) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (new_size &gt; device-&gt;bdev-&gt;bd_inode-&gt;i_size) {\n\t\tret = -EFBIG;\n\t\tgoto out_free;\n\t}\n\n\tnew_size = round_down(new_size, fs_info-&gt;sectorsize);\n\n\tbtrfs_info_in_rcu(fs_info, "new size for %s is %llu",\n\t\t\t  rcu_str_deref(device-&gt;name), new_size);\n\n\tif (new_size &gt; old_size) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out_free;\n\t\t}\n\t\tret = btrfs_grow_device(trans, device, new_size);\n\t\tbtrfs_commit_transaction(trans);\n\t} else if (new_size &lt; old_size) {\n\t\tret = btrfs_shrink_device(device, new_size);\n\t} /* equal, nothing need to do */\n\nout_free:\n\tkfree(vol_args);\nout:\n\tclear_bit(BTRFS_FS_EXCL_OP, &amp;fs_info-&gt;flags);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}',
 'open_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog("Could not create new SSL context.\\n");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    verify_crls = cred-&gt;x509Credential.x509CrlVerifyMode;\n    if (cred-&gt;x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred-&gt;x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog("Failed to load CA certificate from %s.\\n",\n                     cred-&gt;x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog("Using default paths for certificate verification.\\n");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred-&gt;x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred-&gt;x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog("CRLs could not be loaded.\\n");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred-&gt;x509Credential.x509ClientCertFile &amp;&amp; cred-&gt;x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred-&gt;x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog("Client certificate could not be loaded.\\n");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred-&gt;x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog("Client private key could not be loaded.\\n");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog("Client certificate and private key do not match.\\n");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client-&gt;serverHost, strlen(client-&gt;serverHost)))\n    {\n      rfbClientLog("Could not set server name for verification.\\n");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog("Could not create a new SSL session.\\n");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, "ALL");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 &amp;&amp; finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}',
 "init_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc &gt; 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(exmode_active ? 250 : indent + 1);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc &lt;= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}",
 'static char *http_get_w32(const char *url, int *code, int *rlen) {\n\tHINTERNET hInternet = InternetOpenA ("radare2 "R2_VERSION, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\n\tif (!hInternet) {\n\t\tr_sys_perror ("InternetOpenA");\n\t\treturn NULL;\n\t}\n\tHINTERNET hOpenUrl = InternetOpenUrlA (hInternet, url, NULL, 0, 0, 0);\n\tif (!hOpenUrl) {\n\t\tr_sys_perror ("InternetOpenUrlA");\n\t\tInternetCloseHandle (hInternet);\n\t\treturn NULL;\n\t}\n\n\tchar *ret = NULL;\n\tsize_t read_sz = 0x100000;\n\tDWORD r = 0, w = 0;\n\tbool res = true;\n\tdo {\n\t\tw += r;\n\t\tif (!res &amp;&amp; GetLastError () == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tread_sz *= 2;\n\t\t}\n\t\tchar *tmp = realloc (ret, read_sz + w);\n\t\tif (!tmp) {\n\t\t\tR_FREE (ret);\n\t\t\tgoto exit;\n\t\t}\n\t\tret = tmp;\n\t} while (!(res = InternetReadFile (hOpenUrl, ret + w, read_sz, &amp;r)) || r);\n\n\tif (w) {\n\t\tchar *tmp = realloc (ret, (size_t)w + 1);\n\t\tif (tmp) {\n\t\t\tret = tmp;\n\t\t\tret[w] = 0;\n\t\t} else {\n\t\t\tR_FREE (ret);\n\t\t}\n\t} else {\n\t\tR_FREE (ret);\n\t}\n\nexit:\n\tif (rlen) {\n\t\t*rlen = w;\n\t}\n\tif (code &amp;&amp; w) {\n\t\t*code = 200;\n\t}\n\tInternetCloseHandle (hInternet);\n\tInternetCloseHandle (hOpenUrl);\n\treturn ret;\n}',
 'static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tget_futex_key_refs(&amp;q-&gt;key);\n\thb = hash_futex(&amp;q-&gt;key);\n\tq-&gt;lock_ptr = &amp;hb-&gt;lock;\n\n\tspin_lock(&amp;hb-&gt;lock);\n\treturn hb;\n}',
 'void invalidate_lstat_cache(void)\n{\n\treset_lstat_cache(&amp;default_cache);\n}',
 "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream&amp; stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    \n    // read the name unless it is empty\n    if (size &lt; AP4_FULL_ATOM_HEADER_SIZE+20) return;\n    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    char* name = new char[name_size+1];\n    if (name == NULL) return;\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; // force a null termination\n    // handle a special case: the Quicktime files have a pascal\n    // string here, but ISO MP4 files have a C string.\n    // we try to detect a pascal encoding and correct it.\n    if ((AP4_UI08)name[0] == (AP4_UI08)(name_size-1)) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}",
 'static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock-&gt;sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg-&gt;msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg-&gt;msg_flags&amp;MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (NULL == siocb-&gt;scm)\n\t\tsiocb-&gt;scm = &amp;scm;\n\n\terr = scm_send(sock, msg, siocb-&gt;scm);\n\tif (err &lt; 0)\n\t\treturn err;\n\n\tif (msg-&gt;msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr-&gt;nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr-&gt;nl_pid;\n\t\tdst_group = ffs(addr-&gt;nl_groups);\n\t\terr =  -EPERM;\n\t\tif (dst_group &amp;&amp; !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk-&gt;dst_pid;\n\t\tdst_group = nlk-&gt;dst_group;\n\t}\n\n\tif (!nlk-&gt;pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len &gt; sk-&gt;sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk-&gt;pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &amp;siocb-&gt;scm-&gt;creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg-&gt;msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&amp;skb-&gt;users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb-&gt;scm);\n\treturn err;\n}',
 'static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key-&gt;description);\n\tif (key_is_positive(key)) {\n\t\tint err = PTR_ERR(key-&gt;payload.data[dns_key_error]);\n\n\t\tif (err)\n\t\t\tseq_printf(m, ": %d", err);\n\t\telse\n\t\t\tseq_printf(m, ": %u", key-&gt;datalen);\n\t}\n}',
 'cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)\n{\n\tconst char *end=0,**ep=return_parse_end?return_parse_end:&amp;global_ep;\n\tcJSON *c=cJSON_New_Item();\n\t*ep=0;\n\tif (!c) return 0;       /* memory fail */\n\n\tend=parse_value(c,skip(value),ep);\n\tif (!end)\t{cJSON_Delete(c);return 0;}\t/* parse failure. ep is set. */\n\n\t/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n\tif (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}\n\tif (return_parse_end) *return_parse_end=end;\n\treturn c;\n}',
 'void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&amp;unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (atomic_long_inc_return(&amp;u-&gt;inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&amp;u-&gt;link));\n\t\t\tlist_add_tail(&amp;u-&gt;link, &amp;gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&amp;u-&gt;link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t}\n\tfp-&gt;f_cred-&gt;user-&gt;unix_inflight++;\n\tspin_unlock(&amp;unix_gc_lock);\n}',
 'void ecall_find_range_bounds(uint8_t *sort_order, size_t sort_order_length,\n                             uint32_t num_partitions,\n                             uint8_t *input_rows, size_t input_rows_length,\n                             uint8_t **output_rows, size_t *output_rows_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  sgx_lfence();\n\n  try {\n    find_range_bounds(sort_order, sort_order_length,\n                      num_partitions,\n                      input_rows, input_rows_length,\n                      output_rows, output_rows_length);\n  } catch (const std::runtime_error &amp;e) {\n    ocall_throw(e.what());\n  }\n}',
 'static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx-&gt;priv_data;\n    AVPacket pkt;\n    int ret;\n\n    if (!s-&gt;initialized) {\n        ff_vp8_decode_init(avctx);\n        s-&gt;initialized = 1;\n        if (s-&gt;has_alpha)\n            avctx-&gt;pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s-&gt;lossless = 0;\n\n    if (data_size &gt; INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, "unsupported chunk size\\n");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_init_packet(&amp;pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &amp;pkt);\n    if (ret &lt; 0)\n        return ret;\n\n    update_canvas_size(avctx, avctx-&gt;width, avctx-&gt;height);\n\n    if (s-&gt;has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s-&gt;alpha_data,\n                                     s-&gt;alpha_data_size);\n        if (ret &lt; 0)\n            return ret;\n    }\n    return ret;\n}',
 'int treeRead(struct READER *reader, struct DATAOBJECT *data) {\n\n\tint i, j, err, olen, elements, size, x, y, z, b, e, dy, dz, sx, sy, sz, dzy,\n\t\tszy;\n\tchar *input, *output;\n\n\tuint8_t node_type, node_level;\n\tuint16_t entries_used;\n\tuint32_t size_of_chunk;\n\tuint32_t filter_mask;\n\tuint64_t address_of_left_sibling, address_of_right_sibling, start[4],\n\t\tchild_pointer, key, store;\n\n\tchar buf[4];\n\n\tUNUSED(node_level);\n\tUNUSED(address_of_right_sibling);\n\tUNUSED(address_of_left_sibling);\n\tUNUSED(key);\n\n\tif (data-&gt;ds.dimensionality &gt; 3) {\n\t\tlog("TREE dimensions &gt; 3");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader-&gt;fhd) != 4 || strncmp(buf, "TREE", 4)) {\n\t\tlog("cannot read signature of TREE\\n");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t} log("%08lX %.4s\\n", (uint64_t )ftell(reader-&gt;fhd) - 4, buf);\n\n\tnode_type = (uint8_t)fgetc(reader-&gt;fhd);\n\tnode_level = (uint8_t)fgetc(reader-&gt;fhd);\n\tentries_used = (uint16_t)readValue(reader, 2);\n\tif(entries_used&gt;0x1000)\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\taddress_of_left_sibling = readValue(reader,\n\t\t\t\t\t    reader-&gt;superblock.size_of_offsets);\n\taddress_of_right_sibling = readValue(reader,\n\t\t\t\t\t     reader-&gt;superblock.size_of_offsets);\n\n\telements = 1;\n\tfor (j = 0; j &lt; data-&gt;ds.dimensionality; j++)\n\t\telements *= data-&gt;datalayout_chunk[j];\n\tdy = data-&gt;datalayout_chunk[1];\n\tdz = data-&gt;datalayout_chunk[2];\n\tsx = data-&gt;ds.dimension_size[0];\n\tsy = data-&gt;ds.dimension_size[1];\n\tsz = data-&gt;ds.dimension_size[2];\n\tdzy = dz * dy;\n\tszy = sz * sy;\n\tsize = data-&gt;datalayout_chunk[data-&gt;ds.dimensionality];\n\n\tlog("elements %d size %d\\n",elements,size);\n\n\tif (!(output = malloc(elements * size))) {\n\t\treturn MYSOFA_NO_MEMORY;\n\t}\n\n\tfor (e = 0; e &lt; entries_used * 2; e++) {\n\t\tif (node_type == 0) {\n\t\t\tkey = readValue(reader, reader-&gt;superblock.size_of_lengths);\n\t\t} else {\n\t\t\tsize_of_chunk = (uint32_t)readValue(reader, 4);\n\t\t\tfilter_mask = (uint32_t)readValue(reader, 4);\n\t\t\tif (filter_mask) {\n\t\t\t\tlog("TREE all filters must be enabled\\n");\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tfor (j = 0; j &lt; data-&gt;ds.dimensionality; j++) {\n\t\t\t\tstart[j] = readValue(reader, 8);\n\t\t\t\tlog("start %d %lu\\n",j,start[j]);\n\t\t\t}\n\n\t\t\tif (readValue(reader, 8)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchild_pointer = readValue(reader,\n\t\t\t\t\t\t  reader-&gt;superblock.size_of_offsets);\n\t\t\tlog(" data at %lX len %u\\n", child_pointer, size_of_chunk);\n\n\t\t\t/* read data */\n\t\t\tstore = ftell(reader-&gt;fhd);\n\t\t\tif (fseek(reader-&gt;fhd, child_pointer, SEEK_SET)&lt;0) {\n\t\t\t\tfree(output);\n\t\t\t\treturn errno;\n\t\t\t}\n\n\t\t\tif (!(input = malloc(size_of_chunk))) {\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t}\n\t\t\tif (fread(input, 1, size_of_chunk, reader-&gt;fhd) != size_of_chunk) {\n\t\t\t\tfree(output);\n\t\t\t\tfree(input);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tolen = elements * size;\n\t\t\terr = gunzip(size_of_chunk, input, &amp;olen, output);\n\t\t\tfree(input);\n\n\t\t\tlog("   gunzip %d %d %d\\n",err, olen, elements*size);\n\t\t\tif (err || olen != elements * size) {\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tswitch (data-&gt;ds.dimensionality) {\n\t\t\tcase 1:\n\t\t\t\tfor (i = 0; i &lt; olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements + start[0];\n\t\t\t\t\tif (x &lt; sx) {\n\t\t\t\t\t\tj = x * size + b;\n\t\t\t\t\t\t((char*)data-&gt;data)[j] = output[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfor (i = 0; i &lt; olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements;\n\t\t\t\t\ty = x % dy + start[1];\n\t\t\t\t\tx = x / dy + start[0];\n\t\t\t\t\tif (y &lt; sy &amp;&amp; x &lt; sx) {\n\t\t\t\t\t\tj = ((x * sy + y) * size) + b;\n\t\t\t\t\t\t((char*)data-&gt;data)[j] = output[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfor (i = 0; i &lt; olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements;\n\t\t\t\t\tz = x % dz + start[2];\n\t\t\t\t\ty = (x / dz) % dy + start[1];\n\t\t\t\t\tx = (x / dzy) + start[0];\n\t\t\t\t\tif (z &lt; sz &amp;&amp; y &lt; sy &amp;&amp; x &lt; sx) {\n\t\t\t\t\t\tj = (x * szy + y * sz + z) * size + b;\n\t\t\t\t\t\t((char*)data-&gt;data)[j] = output[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog("invalid dim\\n");\n\t\t\t\treturn MYSOFA_INTERNAL_ERROR;\n\t\t\t}\n\n\t\t\tif(fseek(reader-&gt;fhd, store, SEEK_SET)&lt;0) {\n\t\t\t\tfree(output);\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(output);\n\tif(fseek(reader-&gt;fhd, 4, SEEK_CUR)&lt;0) /* skip checksum */\n\t\treturn errno;\n\n\treturn MYSOFA_OK;\n}',
 'get_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)\n{\n    static gprinc_ret               ret;\n    char                            *prime_arg, *funcname;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprinc_ret, &amp;ret);\n\n    if ((ret.code = new_server_handle(arg-&gt;api_version, rqstp, &amp;handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle-&gt;api_version;\n\n    funcname = "kadm5_get_principal";\n\n    if (setup_gss_names(rqstp, &amp;client_name, &amp;service_name) &lt; 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle-&gt;context, arg-&gt;princ, &amp;prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg-&gt;princ) &amp;&amp;\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle-&gt;context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg-&gt;princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(funcname, prime_arg,\n                   &amp;client_name, &amp;service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_principal(handle, arg-&gt;princ, &amp;ret.rec,\n                                       arg-&gt;mask);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle-&gt;context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &amp;client_name, &amp;service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle-&gt;context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&amp;minor_stat, &amp;client_name);\n    gss_release_buffer(&amp;minor_stat, &amp;service_name);\nexit_func:\n    free_server_handle(handle);\n    return &amp;ret;\n}',
 'MONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,\n        const char *code, size_t len, const bson *scope ) {\n\n    size_t sl, size;\n    if ( !scope ) return BSON_ERROR;\n    sl = len + 1;\n    size = 4 + 4 + sl + bson_size( scope );\n    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32_as_int( b, ( int )size );\n    bson_append32( b, &amp;sl );\n    bson_append( b, code, sl );\n    bson_append( b, scope-&gt;data, bson_size( scope ) );\n    return BSON_OK;\n}',
 'init_connection_options(MYSQL *mysql)\n{\n  my_bool handle_expired= (opt_connect_expired_password || !status.batch) ?\n    TRUE : FALSE;\n\n  if (opt_init_command)\n    mysql_options(mysql, MYSQL_INIT_COMMAND, opt_init_command);\n\n  if (opt_connect_timeout)\n  {\n    uint timeout= opt_connect_timeout;\n    mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, (char*) &amp;timeout);\n  }\n\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n\n  if (opt_compress)\n    mysql_options(mysql, MYSQL_OPT_COMPRESS, NullS);\n\n  if (!opt_secure_auth)\n    mysql_options(mysql, MYSQL_SECURE_AUTH, (char *) &amp;opt_secure_auth);\n\n  if (using_opt_local_infile)\n    mysql_options(mysql, MYSQL_OPT_LOCAL_INFILE, (char*) &amp;opt_local_infile);\n\n#if defined(HAVE_OPENSSL) &amp;&amp; !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &amp;opt_ssl_verify_server_cert);\n#endif\n\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &amp;opt_protocol);\n\n#if defined (_WIN32) &amp;&amp; !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n\n  if (safe_updates)\n  {\n    char init_command[100];\n    sprintf(init_command,\n\t    "SET SQL_SAFE_UPDATES=1,SQL_SELECT_LIMIT=%lu,MAX_JOIN_SIZE=%lu",\n\t    select_limit, max_join_size);\n    mysql_options(mysql, MYSQL_INIT_COMMAND, init_command);\n  }\n\n  mysql_set_character_set(mysql, default_charset);\n\n  if (opt_plugin_dir &amp;&amp; *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n\n  if (opt_default_auth &amp;&amp; *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n\n#if !defined(HAVE_YASSL)\n  if (opt_server_public_key &amp;&amp; *opt_server_public_key)\n    mysql_options(mysql, MYSQL_SERVER_PUBLIC_KEY, opt_server_public_key);\n#endif\n\n  if (using_opt_enable_cleartext_plugin)\n    mysql_options(mysql, MYSQL_ENABLE_CLEARTEXT_PLUGIN,\n                  (char*) &amp;opt_enable_cleartext_plugin);\n\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, "program_name", "mysql");\n\n  mysql_options(mysql, MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS, &amp;handle_expired);\n}',
 'ikev1_t_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi _U_,\n\t      uint32_t proto, int depth _U_)\n{\n\tconst struct ikev1_pl_t *p;\n\tstruct ikev1_pl_t t;\n\tconst u_char *cp;\n\tconst char *idstr;\n\tconst struct attrmap *map;\n\tsize_t nmap;\n\tconst u_char *ep2;\n\n\tND_PRINT((ndo,"%s:", NPSTR(ISAKMP_NPTYPE_T)));\n\n\tp = (const struct ikev1_pl_t *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&amp;t, ext, sizeof(t));\n\n\tswitch (proto) {\n\tcase 1:\n\t\tidstr = STR_OR_ID(t.t_id, ikev1_p_map);\n\t\tmap = oakley_t_map;\n\t\tnmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\tbreak;\n\tcase 2:\n\t\tidstr = STR_OR_ID(t.t_id, ah_p_map);\n\t\tmap = ipsec_t_map;\n\t\tnmap = sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0]);\n\t\tbreak;\n\tcase 3:\n\t\tidstr = STR_OR_ID(t.t_id, esp_p_map);\n\t\tmap = ipsec_t_map;\n\t\tnmap = sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0]);\n\t\tbreak;\n\tcase 4:\n\t\tidstr = STR_OR_ID(t.t_id, ipcomp_p_map);\n\t\tmap = ipsec_t_map;\n\t\tnmap = sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0]);\n\t\tbreak;\n\tdefault:\n\t\tidstr = NULL;\n\t\tmap = NULL;\n\t\tnmap = 0;\n\t\tbreak;\n\t}\n\n\tif (idstr)\n\t\tND_PRINT((ndo," #%d id=%s ", t.t_no, idstr));\n\telse\n\t\tND_PRINT((ndo," #%d id=%d ", t.t_no, t.t_id));\n\tcp = (const u_char *)(p + 1);\n\tep2 = (const u_char *)p + item_len;\n\twhile (cp &lt; ep &amp;&amp; cp &lt; ep2) {\n\t\tif (map &amp;&amp; nmap) {\n\t\t\tcp = ikev1_attrmap_print(ndo, cp, (ep &lt; ep2) ? ep : ep2,\n\t\t\t\tmap, nmap);\n\t\t} else\n\t\t\tcp = ikev1_attr_print(ndo, cp, (ep &lt; ep2) ? ep : ep2);\n\t}\n\tif (ep &lt; ep2)\n\t\tND_PRINT((ndo,"..."));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_T)));\n\treturn NULL;\n}',
 'static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)\n{\n\n    *profile = get_bits(gb, 4);\n    *level   = get_bits(gb, 4);\n\n    // for Simple profile, level 0\n    if (*profile == 0 &amp;&amp; *level == 8) {\n        *level = 0;\n    }\n\n    return 0;\n}',
 'Http::FilterDataStatus Context::onResponseBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_-&gt;onResponseBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              -&gt;onResponseBody_(this, id_, static_cast&lt;uint32_t&gt;(body_buffer_length),\n                                static_cast&lt;uint32_t&gt;(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}',
 '  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {\n    // The shape of \'image\' is [batch_size, image_height, image_width,\n    // channels].\n    const Tensor&amp; image = context-&gt;input(0);\n    // The shape of \'boxes\' is [num_boxes, 4].\n    const Tensor&amp; boxes = context-&gt;input(1);\n    // The shape of \'box_index\' is [num_boxes].\n    const Tensor&amp; box_index = context-&gt;input(2);\n    // The shape of \'crop_size\' is [2].\n    const Tensor&amp; crop_size = context-&gt;input(3);\n\n    // Validate inputs dimensions.\n    OP_REQUIRES_ASYNC(context, image.dims() == 4,\n                      errors::InvalidArgument("input image must be 4-D",\n                                              image.shape().DebugString()),\n                      done);\n    const int batch_size = image.dim_size(0);\n    const int image_height = image.dim_size(1);\n    const int image_width = image.dim_size(2);\n    const int depth = image.dim_size(3);\n    OP_REQUIRES_ASYNC(\n        context, image_height &gt; 0 &amp;&amp; image_width &gt; 0,\n        errors::InvalidArgument("image dimensions must be positive"), done);\n    int num_boxes = 0;\n    OP_REQUIRES_OK_ASYNC(\n        context, ParseAndCheckBoxSizes(boxes, box_index, &amp;num_boxes), done);\n\n    OP_REQUIRES_ASYNC(context, crop_size.dims() == 1,\n                      errors::InvalidArgument("crop_size must be 1-D",\n                                              crop_size.shape().DebugString()),\n                      done);\n    OP_REQUIRES_ASYNC(\n        context, crop_size.dim_size(0) == 2,\n        errors::InvalidArgument("crop_size must have two elements",\n                                crop_size.shape().DebugString()),\n        done);\n\n    // Copy and validate crop sizes.\n    auto crop_size_vec = crop_size.vec&lt;int32&gt;();\n    const int crop_height = internal::SubtleMustCopy(crop_size_vec(0));\n    const int crop_width = internal::SubtleMustCopy(crop_size_vec(1));\n    OP_REQUIRES_ASYNC(\n        context, crop_height &gt; 0 &amp;&amp; crop_width &gt; 0,\n        errors::InvalidArgument("crop dimensions must be positive"), done);\n\n    // Allocate output tensor.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        context-&gt;allocate_output(\n            0, TensorShape({num_boxes, crop_height, crop_width, depth}),\n            &amp;output),\n        done);\n\n    auto compute_callback = [this, context, output]() {\n      const Tensor&amp; image = context-&gt;input(0);\n      const Tensor&amp; boxes = context-&gt;input(1);\n      const Tensor&amp; box_index = context-&gt;input(2);\n      const bool status = functor::CropAndResize&lt;Device, T&gt;()(\n          context, image.tensor&lt;T, 4&gt;(), boxes.tensor&lt;float, 2&gt;(),\n          box_index.tensor&lt;int32, 1&gt;(), method_, extrapolation_value_,\n          output-&gt;tensor&lt;float, 4&gt;());\n\n      if (!status) {\n        context-&gt;SetStatus(\n            errors::Internal("Failed to launch CropAndResizeKernel."));\n      }\n    };\n\n    RunIfBoxIndexIsValid&lt;Device&gt;(context, box_index.tensor&lt;int32, 1&gt;(),\n                                 batch_size, std::move(compute_callback),\n                                 std::move(done));\n  }',
 'static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) &gt; 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, "Company",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length &gt; 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1-1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, "Info",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}',
 'ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header-&gt;h_hash);\n\tstruct mb_cache_entry *ce;\n\n\tif (!header-&gt;h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, "looking for cached blocks [%x]", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode-&gt;i_sb-&gt;s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = sb_bread(inode-&gt;i_sb, ce-&gt;e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode-&gt;i_sb, "ext2_xattr_cache_find",\n\t\t\t\t"inode %ld: block %ld read error",\n\t\t\t\tinode-&gt;i_ino, (unsigned long) ce-&gt;e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)-&gt;h_refcount) &gt;\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, "block %ld refcount %d&gt;%d",\n\t\t\t\t\t  (unsigned long) ce-&gt;e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)-&gt;h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, "b_count=%d",\n\t\t\t\t\t  atomic_read(&amp;(bh-&gt;b_count)));\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ce, inode-&gt;i_sb-&gt;s_bdev, hash);\n\t}\n\treturn NULL;\n}',
 "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    if (g-&gt;gckind == KGC_INC)  /* incremental mode? */\n      makewhite(g, o);  /* mark 'o' as white to avoid other barriers */\n  }\n}",
 'void handle_ld_nf(u32 insn, struct pt_regs *regs)\n{\n\tint rd = ((insn &gt;&gt; 25) &amp; 0x1f);\n\tint from_kernel = (regs-&gt;tstate &amp; TSTATE_PRIV) != 0;\n\tunsigned long *reg;\n\t                        \n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n\n\tmaybe_flush_windows(0, 0, rd, from_kernel);\n\treg = fetch_reg_addr(rd, regs);\n\tif (from_kernel || rd &lt; 16) {\n\t\treg[0] = 0;\n\t\tif ((insn &amp; 0x780000) == 0x180000)\n\t\t\treg[1] = 0;\n\t} else if (test_thread_flag(TIF_32BIT)) {\n\t\tput_user(0, (int __user *) reg);\n\t\tif ((insn &amp; 0x780000) == 0x180000)\n\t\t\tput_user(0, ((int __user *) reg) + 1);\n\t} else {\n\t\tput_user(0, (unsigned long __user *) reg);\n\t\tif ((insn &amp; 0x780000) == 0x180000)\n\t\t\tput_user(0, (unsigned long __user *) reg + 1);\n\t}\n\tadvance(regs);\n}',
 'int ff_jpeg2000_init_component(Jpeg2000Component *comp,\n                               Jpeg2000CodingStyle *codsty,\n                               Jpeg2000QuantStyle *qntsty,\n                               int cbps, int dx, int dy,\n                               AVCodecContext *avctx)\n{\n    uint8_t log2_band_prec_width, log2_band_prec_height;\n    int reslevelno, bandno, gbandno = 0, ret, i, j;\n    uint32_t csize;\n\n    if (codsty-&gt;nreslevels2decode &lt;= 0) {\n        av_log(avctx, AV_LOG_ERROR, "nreslevels2decode %d invalid or uninitialized\\n", codsty-&gt;nreslevels2decode);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ret = ff_jpeg2000_dwt_init(&amp;comp-&gt;dwt, comp-&gt;coord,\n                                   codsty-&gt;nreslevels2decode - 1,\n                                   codsty-&gt;transform))\n        return ret;\n    // component size comp-&gt;coord is uint16_t so ir cannot overflow\n    csize = (comp-&gt;coord[0][1] - comp-&gt;coord[0][0]) *\n            (comp-&gt;coord[1][1] - comp-&gt;coord[1][0]);\n\n    if (codsty-&gt;transform == FF_DWT97) {\n        comp-&gt;i_data = NULL;\n        comp-&gt;f_data = av_malloc_array(csize, sizeof(*comp-&gt;f_data));\n        if (!comp-&gt;f_data)\n            return AVERROR(ENOMEM);\n    } else {\n        comp-&gt;f_data = NULL;\n        comp-&gt;i_data = av_malloc_array(csize, sizeof(*comp-&gt;i_data));\n        if (!comp-&gt;i_data)\n            return AVERROR(ENOMEM);\n    }\n    comp-&gt;reslevel = av_malloc_array(codsty-&gt;nreslevels, sizeof(*comp-&gt;reslevel));\n    if (!comp-&gt;reslevel)\n        return AVERROR(ENOMEM);\n    /* LOOP on resolution levels */\n    for (reslevelno = 0; reslevelno &lt; codsty-&gt;nreslevels; reslevelno++) {\n        int declvl = codsty-&gt;nreslevels - reslevelno;    // N_L -r see  ISO/IEC 15444-1:2002 B.5\n        Jpeg2000ResLevel *reslevel = comp-&gt;reslevel + reslevelno;\n\n        /* Compute borders for each resolution level.\n         * Computation of trx_0, trx_1, try_0 and try_1.\n         * see ISO/IEC 15444-1:2002 eq. B.5 and B-14 */\n        for (i = 0; i &lt; 2; i++)\n            for (j = 0; j &lt; 2; j++)\n                reslevel-&gt;coord[i][j] =\n                    ff_jpeg2000_ceildivpow2(comp-&gt;coord_o[i][j], declvl - 1);\n        // update precincts size: 2^n value\n        reslevel-&gt;log2_prec_width  = codsty-&gt;log2_prec_widths[reslevelno];\n        reslevel-&gt;log2_prec_height = codsty-&gt;log2_prec_heights[reslevelno];\n\n        /* Number of bands for each resolution level */\n        if (reslevelno == 0)\n            reslevel-&gt;nbands = 1;\n        else\n            reslevel-&gt;nbands = 3;\n\n        /* Number of precincts wich span the tile for resolution level reslevelno\n         * see B.6 in ISO/IEC 15444-1:2002 eq. B-16\n         * num_precincts_x = |- trx_1 / 2 ^ log2_prec_width) -| - (trx_0 / 2 ^ log2_prec_width)\n         * num_precincts_y = |- try_1 / 2 ^ log2_prec_width) -| - (try_0 / 2 ^ log2_prec_width)\n         * for Dcinema profiles in JPEG 2000\n         * num_precincts_x = |- trx_1 / 2 ^ log2_prec_width) -|\n         * num_precincts_y = |- try_1 / 2 ^ log2_prec_width) -| */\n        if (reslevel-&gt;coord[0][1] == reslevel-&gt;coord[0][0])\n            reslevel-&gt;num_precincts_x = 0;\n        else\n            reslevel-&gt;num_precincts_x =\n                ff_jpeg2000_ceildivpow2(reslevel-&gt;coord[0][1],\n                                        reslevel-&gt;log2_prec_width) -\n                (reslevel-&gt;coord[0][0] &gt;&gt; reslevel-&gt;log2_prec_width);\n\n        if (reslevel-&gt;coord[1][1] == reslevel-&gt;coord[1][0])\n            reslevel-&gt;num_precincts_y = 0;\n        else\n            reslevel-&gt;num_precincts_y =\n                ff_jpeg2000_ceildivpow2(reslevel-&gt;coord[1][1],\n                                        reslevel-&gt;log2_prec_height) -\n                (reslevel-&gt;coord[1][0] &gt;&gt; reslevel-&gt;log2_prec_height);\n\n        reslevel-&gt;band = av_calloc(reslevel-&gt;nbands, sizeof(*reslevel-&gt;band));\n        if (!reslevel-&gt;band)\n            return AVERROR(ENOMEM);\n\n        for (bandno = 0; bandno &lt; reslevel-&gt;nbands; bandno++, gbandno++) {\n            Jpeg2000Band *band = reslevel-&gt;band + bandno;\n            int cblkno, precno;\n            int nb_precincts;\n\n            /* TODO: Implementation of quantization step not finished,\n             * see ISO/IEC 15444-1:2002 E.1 and A.6.4. */\n            switch (qntsty-&gt;quantsty) {\n                uint8_t gain;\n                int numbps;\n            case JPEG2000_QSTY_NONE:\n                /* TODO: to verify. No quantization in this case */\n                band-&gt;f_stepsize = 1;\n                break;\n            case JPEG2000_QSTY_SI:\n                /*TODO: Compute formula to implement. */\n                numbps = cbps +\n                         lut_gain[codsty-&gt;transform == FF_DWT53][bandno + (reslevelno &gt; 0)];\n                band-&gt;f_stepsize = SHL(2048 + qntsty-&gt;mant[gbandno],\n                                       2 + numbps - qntsty-&gt;expn[gbandno]);\n                break;\n            case JPEG2000_QSTY_SE:\n                /* Exponent quantization step.\n                 * Formula:\n                 * delta_b = 2 ^ (R_b - expn_b) * (1 + (mant_b / 2 ^ 11))\n                 * R_b = R_I + log2 (gain_b )\n                 * see ISO/IEC 15444-1:2002 E.1.1 eqn. E-3 and E-4 */\n                /* TODO/WARN: value of log2 (gain_b ) not taken into account\n                 * but it works (compared to OpenJPEG). Why?\n                 * Further investigation needed. */\n                gain            = cbps;\n                band-&gt;f_stepsize  = pow(2.0, gain - qntsty-&gt;expn[gbandno]);\n                band-&gt;f_stepsize *= qntsty-&gt;mant[gbandno] / 2048.0 + 1.0;\n                break;\n            default:\n                band-&gt;f_stepsize = 0;\n                av_log(avctx, AV_LOG_ERROR, "Unknown quantization format\\n");\n                break;\n            }\n            /* FIXME: In openjepg code stespize = stepsize * 0.5. Why?\n             * If not set output of entropic decoder is not correct. */\n            if (!av_codec_is_encoder(avctx-&gt;codec))\n                band-&gt;f_stepsize *= 0.5;\n\n            band-&gt;i_stepsize = band-&gt;f_stepsize * (1 &lt;&lt; 15);\n\n            /* computation of tbx_0, tbx_1, tby_0, tby_1\n             * see ISO/IEC 15444-1:2002 B.5 eq. B-15 and tbl B.1\n             * codeblock width and height is computed for\n             * DCI JPEG 2000 codeblock_width = codeblock_width = 32 = 2 ^ 5 */\n            if (reslevelno == 0) {\n                /* for reslevelno = 0, only one band, x0_b = y0_b = 0 */\n                for (i = 0; i &lt; 2; i++)\n                    for (j = 0; j &lt; 2; j++)\n                        band-&gt;coord[i][j] =\n                            ff_jpeg2000_ceildivpow2(comp-&gt;coord_o[i][j] - comp-&gt;coord_o[i][0],\n                                                    declvl - 1);\n                log2_band_prec_width  = reslevel-&gt;log2_prec_width;\n                log2_band_prec_height = reslevel-&gt;log2_prec_height;\n                /* see ISO/IEC 15444-1:2002 eq. B-17 and eq. B-15 */\n                band-&gt;log2_cblk_width  = FFMIN(codsty-&gt;log2_cblk_width,\n                                               reslevel-&gt;log2_prec_width);\n                band-&gt;log2_cblk_height = FFMIN(codsty-&gt;log2_cblk_height,\n                                               reslevel-&gt;log2_prec_height);\n            } else {\n                /* 3 bands x0_b = 1 y0_b = 0; x0_b = 0 y0_b = 1; x0_b = y0_b = 1 */\n                /* x0_b and y0_b are computed with ((bandno + 1 &gt;&gt; i) &amp; 1) */\n                for (i = 0; i &lt; 2; i++)\n                    for (j = 0; j &lt; 2; j++)\n                        /* Formula example for tbx_0 = ceildiv((tcx_0 - 2 ^ (declvl - 1) * x0_b) / declvl) */\n                        band-&gt;coord[i][j] =\n                            ff_jpeg2000_ceildivpow2(comp-&gt;coord_o[i][j] - comp-&gt;coord_o[i][0] -\n                                                    (((bandno + 1 &gt;&gt; i) &amp; 1) &lt;&lt; declvl - 1),\n                                                    declvl);\n                /* TODO: Manage case of 3 band offsets here or\n                 * in coding/decoding function? */\n\n                /* see ISO/IEC 15444-1:2002 eq. B-17 and eq. B-15 */\n                band-&gt;log2_cblk_width  = FFMIN(codsty-&gt;log2_cblk_width,\n                                               reslevel-&gt;log2_prec_width - 1);\n                band-&gt;log2_cblk_height = FFMIN(codsty-&gt;log2_cblk_height,\n                                               reslevel-&gt;log2_prec_height - 1);\n\n                log2_band_prec_width  = reslevel-&gt;log2_prec_width  - 1;\n                log2_band_prec_height = reslevel-&gt;log2_prec_height - 1;\n            }\n\n            for (j = 0; j &lt; 2; j++)\n                band-&gt;coord[0][j] = ff_jpeg2000_ceildiv(band-&gt;coord[0][j], dx);\n            for (j = 0; j &lt; 2; j++)\n                band-&gt;coord[1][j] = ff_jpeg2000_ceildiv(band-&gt;coord[1][j], dy);\n\n            band-&gt;prec = av_calloc(reslevel-&gt;num_precincts_x *\n                                         (uint64_t)reslevel-&gt;num_precincts_y,\n                                         sizeof(*band-&gt;prec));\n            if (!band-&gt;prec)\n                return AVERROR(ENOMEM);\n\n            nb_precincts = reslevel-&gt;num_precincts_x * reslevel-&gt;num_precincts_y;\n\n            for (precno = 0; precno &lt; nb_precincts; precno++) {\n                Jpeg2000Prec *prec = band-&gt;prec + precno;\n\n                /* TODO: Explain formula for JPEG200 DCINEMA. */\n                /* TODO: Verify with previous count of codeblocks per band */\n\n                /* Compute P_x0 */\n                prec-&gt;coord[0][0] = (precno % reslevel-&gt;num_precincts_x) *\n                                    (1 &lt;&lt; log2_band_prec_width);\n                prec-&gt;coord[0][0] = FFMAX(prec-&gt;coord[0][0], band-&gt;coord[0][0]);\n\n                /* Compute P_y0 */\n                prec-&gt;coord[1][0] = (precno / reslevel-&gt;num_precincts_x) *\n                                    (1 &lt;&lt; log2_band_prec_height);\n                prec-&gt;coord[1][0] = FFMAX(prec-&gt;coord[1][0], band-&gt;coord[1][0]);\n\n                /* Compute P_x1 */\n                prec-&gt;coord[0][1] = prec-&gt;coord[0][0] +\n                                    (1 &lt;&lt; log2_band_prec_width);\n                prec-&gt;coord[0][1] = FFMIN(prec-&gt;coord[0][1], band-&gt;coord[0][1]);\n\n                /* Compute P_y1 */\n                prec-&gt;coord[1][1] = prec-&gt;coord[1][0] +\n                                    (1 &lt;&lt; log2_band_prec_height);\n                prec-&gt;coord[1][1] = FFMIN(prec-&gt;coord[1][1], band-&gt;coord[1][1]);\n\n                prec-&gt;nb_codeblocks_width =\n                    ff_jpeg2000_ceildivpow2(prec-&gt;coord[0][1] -\n                                            prec-&gt;coord[0][0],\n                                            band-&gt;log2_cblk_width);\n                prec-&gt;nb_codeblocks_height =\n                    ff_jpeg2000_ceildivpow2(prec-&gt;coord[1][1] -\n                                            prec-&gt;coord[1][0],\n                                            band-&gt;log2_cblk_height);\n\n                /* Tag trees initialization */\n                prec-&gt;cblkincl =\n                    ff_jpeg2000_tag_tree_init(prec-&gt;nb_codeblocks_width,\n                                              prec-&gt;nb_codeblocks_height);\n                if (!prec-&gt;cblkincl)\n                    return AVERROR(ENOMEM);\n\n                prec-&gt;zerobits =\n                    ff_jpeg2000_tag_tree_init(prec-&gt;nb_codeblocks_width,\n                                              prec-&gt;nb_codeblocks_height);\n                if (!prec-&gt;zerobits)\n                    return AVERROR(ENOMEM);\n\n                prec-&gt;cblk = av_mallocz_array(prec-&gt;nb_codeblocks_width *\n                                              (uint64_t)prec-&gt;nb_codeblocks_height,\n                                              sizeof(*prec-&gt;cblk));\n                if (!prec-&gt;cblk)\n                    return AVERROR(ENOMEM);\n                for (cblkno = 0; cblkno &lt; prec-&gt;nb_codeblocks_width * prec-&gt;nb_codeblocks_height; cblkno++) {\n                    Jpeg2000Cblk *cblk = prec-&gt;cblk + cblkno;\n                    uint16_t Cx0, Cy0;\n\n                    /* Compute coordinates of codeblocks */\n                    /* Compute Cx0*/\n                    Cx0 = (prec-&gt;coord[0][0] &gt;&gt; band-&gt;log2_cblk_width) &lt;&lt; band-&gt;log2_cblk_width;\n                    Cx0 = Cx0 + ((cblkno % prec-&gt;nb_codeblocks_width)  &lt;&lt; band-&gt;log2_cblk_width);\n                    cblk-&gt;coord[0][0] = FFMAX(Cx0, prec-&gt;coord[0][0]);\n\n                    /* Compute Cy0*/\n                    Cy0 = (prec-&gt;coord[1][0] &gt;&gt; band-&gt;log2_cblk_height) &lt;&lt; band-&gt;log2_cblk_height;\n                    Cy0 = Cy0 + ((cblkno / prec-&gt;nb_codeblocks_width)   &lt;&lt; band-&gt;log2_cblk_height);\n                    cblk-&gt;coord[1][0] = FFMAX(Cy0, prec-&gt;coord[1][0]);\n\n                    /* Compute Cx1 */\n                    cblk-&gt;coord[0][1] = FFMIN(Cx0 + (1 &lt;&lt; band-&gt;log2_cblk_width),\n                                              prec-&gt;coord[0][1]);\n\n                    /* Compute Cy1 */\n                    cblk-&gt;coord[1][1] = FFMIN(Cy0 + (1 &lt;&lt; band-&gt;log2_cblk_height),\n                                              prec-&gt;coord[1][1]);\n                    /* Update code-blocks coordinates according sub-band position */\n                    if ((bandno + !!reslevelno) &amp; 1) {\n                        cblk-&gt;coord[0][0] += comp-&gt;reslevel[reslevelno-1].coord[0][1] -\n                                             comp-&gt;reslevel[reslevelno-1].coord[0][0];\n                        cblk-&gt;coord[0][1] += comp-&gt;reslevel[reslevelno-1].coord[0][1] -\n                                             comp-&gt;reslevel[reslevelno-1].coord[0][0];\n                    }\n                    if ((bandno + !!reslevelno) &amp; 2) {\n                        cblk-&gt;coord[1][0] += comp-&gt;reslevel[reslevelno-1].coord[1][1] -\n                                             comp-&gt;reslevel[reslevelno-1].coord[1][0];\n                        cblk-&gt;coord[1][1] += comp-&gt;reslevel[reslevelno-1].coord[1][1] -\n                                             comp-&gt;reslevel[reslevelno-1].coord[1][0];\n                    }\n\n                    cblk-&gt;zero      = 0;\n                    cblk-&gt;lblock    = 3;\n                    cblk-&gt;length    = 0;\n                    cblk-&gt;lengthinc = 0;\n                    cblk-&gt;npasses   = 0;\n                }\n            }\n        }\n    }\n    return 0;\n}',
 'static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const Quantum\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    "  Enter ReadOneJNGImage()");\n\n  image=mng_info-&gt;image;\n\n  if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           "  AcquireNextImage()");\n\n      AcquireNextImage(image_info,image,exception);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info-&gt;image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MagickPathExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]=\'\\0\';\n    (void) ConcatenateMagickString(type,"errr",MagickPathExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        "  Reading JNG chunk type %c%c%c%c, length: %.20g",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length &gt; PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,"CorruptImage");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");\n\n        for (i=0; i &lt; (ssize_t) length; i++)\n          chunk[i]=(unsigned char) ReadBlobByte(image);\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] &lt;&lt; 24) | (p[1] &lt;&lt; 16) |\n              (p[2] &lt;&lt; 8) | p[3]);\n            jng_height=(size_t) ((p[4] &lt;&lt; 24) | (p[5] &lt;&lt; 16) |\n              (p[6] &lt;&lt; 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\n                "NegativeOrZeroImageSize");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image-&gt;interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  "    jng_width:      %16lu,    jng_height:     %16lu\\n"\n                  "    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n"\n                  "    jng_image_compression_method:%3d",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  "    jng_image_interlace_method:  %3d"\n                  "    jng_alpha_sample_depth:      %3d",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  "    jng_alpha_compression_method:%3d\\n"\n                  "    jng_alpha_filter_method:     %3d\\n"\n                  "    jng_alpha_interlace_method:  %3d",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) &amp;&amp; (read_JSEP == MagickFalse) &amp;&amp;\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info,exception);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            "    Creating color_blob.");\n\n        (void) AcquireUniqueFilename(color_image-&gt;filename);\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info-&gt;ping == MagickFalse) &amp;&amp; (jng_color_type &gt;= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  "MemoryAllocationFailed");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info,exception);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  "MemoryAllocationFailed");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                "    Creating alpha_blob.");\n\n            (void) AcquireUniqueFilename(alpha_image-&gt;filename);\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    "    Writing IHDR chunk to alpha_blob.");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  "\\211PNG\\r\\n\\032\\n");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image-&gt;blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            "    Copying JDAT chunk data to color_blob.");\n\n        (void) WriteBlob(color_image,length,chunk);\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image-&gt;blob */\n\n        if (alpha_image != NULL &amp;&amp; image_info-&gt;ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                "    Copying IDAT chunk data to alpha_blob.");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image-&gt;blob */\n\n        if (alpha_image != NULL &amp;&amp; image_info-&gt;ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                "    Copying JDAA chunk data to alpha_blob.");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image-&gt;background_color.red=ScaleCharToQuantum(p[1]);\n            image-&gt;background_color.green=image-&gt;background_color.red;\n            image-&gt;background_color.blue=image-&gt;background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image-&gt;background_color.red=ScaleCharToQuantum(p[1]);\n            image-&gt;background_color.green=ScaleCharToQuantum(p[3]);\n            image-&gt;background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image-&gt;gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image-&gt;chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image-&gt;chromaticity.white_point.y=0.00001*mng_get_long(&amp;p[4]);\n            image-&gt;chromaticity.red_primary.x=0.00001*mng_get_long(&amp;p[8]);\n            image-&gt;chromaticity.red_primary.y=0.00001*mng_get_long(&amp;p[12]);\n            image-&gt;chromaticity.green_primary.x=0.00001*mng_get_long(&amp;p[16]);\n            image-&gt;chromaticity.green_primary.y=0.00001*mng_get_long(&amp;p[20]);\n            image-&gt;chromaticity.blue_primary.x=0.00001*mng_get_long(&amp;p[24]);\n            image-&gt;chromaticity.blue_primary.y=0.00001*mng_get_long(&amp;p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image-&gt;rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image-&gt;gamma=1.000f/2.200f;\n            image-&gt;chromaticity.red_primary.x=0.6400f;\n            image-&gt;chromaticity.red_primary.y=0.3300f;\n            image-&gt;chromaticity.green_primary.x=0.3000f;\n            image-&gt;chromaticity.green_primary.y=0.6000f;\n            image-&gt;chromaticity.blue_primary.x=0.1500f;\n            image-&gt;chromaticity.blue_primary.y=0.0600f;\n            image-&gt;chromaticity.white_point.x=0.3127f;\n            image-&gt;chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length &gt; 8)\n          {\n            image-&gt;page.x=(ssize_t) mng_get_long(p);\n            image-&gt;page.y=(ssize_t) mng_get_long(&amp;p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image-&gt;page.x/=10000;\n                image-&gt;page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length &gt; 8)\n          {\n            image-&gt;resolution.x=(double) mng_get_long(p);\n            image-&gt;resolution.y=(double) mng_get_long(&amp;p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image-&gt;units=PixelsPerCentimeterResolution;\n                image-&gt;resolution.x=image-&gt;resolution.x/100.0f;\n                image-&gt;resolution.y=image-&gt;resolution.y/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         alpha samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      "    Reading jng_image from color_blob.");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info-&gt;filename,MagickPathExtent,"%s",\n    color_image-&gt;filename);\n\n  color_image_info-&gt;ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image-&gt;filename);\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      "    Copying jng_image pixels to main image.");\n\n  image-&gt;rows=jng_height;\n  image-&gt;columns=jng_width;\n\n  status=SetImageExtent(image,image-&gt;columns,image-&gt;rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  for (y=0; y &lt; (ssize_t) image-&gt;rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image-&gt;columns,1,exception);\n    q=GetAuthenticPixels(image,0,y,image-&gt;columns,1,exception);\n    for (x=(ssize_t) image-&gt;columns; x != 0; x--)\n    {\n      SetPixelRed(image,GetPixelRed(jng_image,s),q);\n      SetPixelGreen(image,GetPixelGreen(jng_image,s),q);\n      SetPixelBlue(image,GetPixelBlue(jng_image,s),q);\n      q+=GetPixelChannels(image);\n      s+=GetPixelChannels(jng_image);\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info-&gt;ping == MagickFalse)\n    {\n     if (jng_color_type &gt;= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) CloseBlob(alpha_image);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             "    Reading alpha from alpha_blob.");\n\n         (void) FormatLocaleString(alpha_image_info-&gt;filename,MagickPathExtent,\n           "%s",alpha_image-&gt;filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y &lt; (ssize_t) image-&gt;rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image-&gt;columns,1,\n               exception);\n             q=GetAuthenticPixels(image,0,y,image-&gt;columns,1,exception);\n\n             if (image-&gt;alpha_trait != UndefinedPixelTrait)\n               for (x=(ssize_t) image-&gt;columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             else\n               for (x=(ssize_t) image-&gt;columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    image-&gt;alpha_trait=BlendPixelTrait;\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image-&gt;filename);\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info-&gt;mng_type == 0)\n    {\n      mng_info-&gt;mng_width=jng_width;\n      mng_info-&gt;mng_height=jng_height;\n    }\n\n  if (image-&gt;page.width == 0 &amp;&amp; image-&gt;page.height == 0)\n    {\n      image-&gt;page.width=jng_width;\n      image-&gt;page.height=jng_height;\n    }\n\n  if (image-&gt;page.x == 0 &amp;&amp; image-&gt;page.y == 0)\n    {\n      image-&gt;page.x=mng_info-&gt;x_off[mng_info-&gt;object_id];\n      image-&gt;page.y=mng_info-&gt;y_off[mng_info-&gt;object_id];\n    }\n\n  else\n    {\n      image-&gt;page.y=mng_info-&gt;y_off[mng_info-&gt;object_id];\n    }\n\n  mng_info-&gt;image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      "  exit ReadOneJNGImage()");\n\n  return(image);\n}',
 'void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir("acpi", NULL);\n\n\tacpi_custom_method_init();\n}',
 'static RList* entries(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinAddr* addr = NULL;\n\tpsxexe_header psxheader;\n\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(addr = R_NEW0 (RBinAddr))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (bf-&gt;buf, 0, (ut8*)&amp;psxheader, "8c17i", 1) != sizeof (psxexe_header)) {\n\t\teprintf ("PSXEXE Header truncated\\n");\n\t\tr_list_free (ret);\n\t\tfree (addr);\n\t\treturn NULL;\n\t}\n\n\taddr-&gt;paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;\n\taddr-&gt;vaddr = psxheader.pc0;\n\n\tr_list_append (ret, addr);\n\treturn ret;\n}',
 'static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\t/* unprotected vars, we dont care of overwrites */\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\n\t/* First check our per-socket dupack rate limit. */\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &amp;tp-&gt;last_oow_ack_time))\n\t\treturn;\n\n\t/* Then check the check host-wide RFC 5961 rate limit. */\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count &lt;= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}',
 'static ssize_t _epoll_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (!file || (iovcnt &amp;&amp; !iov) || iovcnt &lt; 0 || iovcnt &gt; OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &amp;buf, &amp;buf_size, &amp;data_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/writev.html\n     * for more detail.\n     */\n    if (data_size &gt; OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_writev_ocall(&amp;ret, file-&gt;host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed data_size.\n     */\n    if (ret &gt; (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}',
 'int64 CSteamNetworkConnectionBase::SNP_SendMessage( CSteamNetworkingMessage *pSendMessage, SteamNetworkingMicroseconds usecNow, bool *pbThinkImmediately )\n{\n\tint cbData = (int)pSendMessage-&gt;m_cbSize;\n\n\t// Assume we won\'t want to wake up immediately\n\tif ( pbThinkImmediately )\n\t\t*pbThinkImmediately = false;\n\n\t// Check if we\'re full\n\tif ( m_senderState.PendingBytesTotal() + cbData &gt; m_connectionConfig.m_SendBufferSize.Get() )\n\t{\n\t\tSpewWarningRateLimited( usecNow, "Connection already has %u bytes pending, cannot queue any more messages\\n", m_senderState.PendingBytesTotal() );\n\t\tpSendMessage-&gt;Release();\n\t\treturn -k_EResultLimitExceeded; \n\t}\n\n\t// Check if they try to send a really large message\n\tif ( cbData &gt; k_cbMaxUnreliableMsgSizeSend &amp;&amp; !( pSendMessage-&gt;m_nFlags &amp; k_nSteamNetworkingSend_Reliable )  )\n\t{\n\t\tSpewWarningRateLimited( usecNow, "Trying to send a very large (%d bytes) unreliable message.  Sending as reliable instead.\\n", cbData );\n\t\tpSendMessage-&gt;m_nFlags |= k_nSteamNetworkingSend_Reliable;\n\t}\n\n\tif ( pSendMessage-&gt;m_nFlags &amp; k_nSteamNetworkingSend_NoDelay )\n\t{\n\t\t// FIXME - need to check how much data is currently pending, and return\n\t\t// k_EResultIgnored if we think it\'s going to be a while before this\n\t\t// packet goes on the wire.\n\t}\n\n\t// First, accumulate tokens, and also limit to reasonable burst\n\t// if we weren\'t already waiting to send\n\tSNP_ClampSendRate();\n\tSNP_TokenBucket_Accumulate( usecNow );\n\n\t// Assign a message number\n\tpSendMessage-&gt;m_nMessageNumber = ++m_senderState.m_nLastSentMsgNum;\n\n\t// Reliable, or unreliable?\n\tif ( pSendMessage-&gt;m_nFlags &amp; k_nSteamNetworkingSend_Reliable )\n\t{\n\t\tpSendMessage-&gt;SNPSend_SetReliableStreamPos( m_senderState.m_nReliableStreamPos );\n\n\t\t// Generate the header\n\t\tbyte *hdr = pSendMessage-&gt;SNPSend_ReliableHeader();\n\t\thdr[0] = 0;\n\t\tbyte *hdrEnd = hdr+1;\n\t\tint64 nMsgNumGap = pSendMessage-&gt;m_nMessageNumber - m_senderState.m_nLastSendMsgNumReliable;\n\t\tAssert( nMsgNumGap &gt;= 1 );\n\t\tif ( nMsgNumGap &gt; 1 )\n\t\t{\n\t\t\thdrEnd = SerializeVarInt( hdrEnd, (uint64)nMsgNumGap );\n\t\t\thdr[0] |= 0x40;\n\t\t}\n\t\tif ( cbData &lt; 0x20 )\n\t\t{\n\t\t\thdr[0] |= (byte)cbData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thdr[0] |= (byte)( 0x20 | ( cbData &amp; 0x1f ) );\n\t\t\thdrEnd = SerializeVarInt( hdrEnd, cbData&gt;&gt;5U );\n\t\t}\n\t\tpSendMessage-&gt;m_cbSNPSendReliableHeader = hdrEnd - hdr;\n\n\t\t// Grow the total size of the message by the header\n\t\tpSendMessage-&gt;m_cbSize += pSendMessage-&gt;m_cbSNPSendReliableHeader;\n\n\t\t// Advance stream pointer\n\t\tm_senderState.m_nReliableStreamPos += pSendMessage-&gt;m_cbSize;\n\n\t\t// Update stats\n\t\t++m_senderState.m_nMessagesSentReliable;\n\t\tm_senderState.m_cbPendingReliable += pSendMessage-&gt;m_cbSize;\n\n\t\t// Remember last sent reliable message number, so we can know how to\n\t\t// encode the next one\n\t\tm_senderState.m_nLastSendMsgNumReliable = pSendMessage-&gt;m_nMessageNumber;\n\n\t\tAssert( pSendMessage-&gt;SNPSend_IsReliable() );\n\t}\n\telse\n\t{\n\t\tpSendMessage-&gt;SNPSend_SetReliableStreamPos( 0 );\n\t\tpSendMessage-&gt;m_cbSNPSendReliableHeader = 0;\n\n\t\t++m_senderState.m_nMessagesSentUnreliable;\n\t\tm_senderState.m_cbPendingUnreliable += pSendMessage-&gt;m_cbSize;\n\n\t\tAssert( !pSendMessage-&gt;SNPSend_IsReliable() );\n\t}\n\n\t// Add to pending list\n\tm_senderState.m_messagesQueued.push_back( pSendMessage );\n\tSpewVerboseGroup( m_connectionConfig.m_LogLevel_Message.Get(), "[%s] SendMessage %s: MsgNum=%lld sz=%d\\n",\n\t\t\t\t GetDescription(),\n\t\t\t\t pSendMessage-&gt;SNPSend_IsReliable() ? "RELIABLE" : "UNRELIABLE",\n\t\t\t\t (long long)pSendMessage-&gt;m_nMessageNumber,\n\t\t\t\t pSendMessage-&gt;m_cbSize );\n\n\t// Use Nagle?\n\t// We always set the Nagle timer, even if we immediately clear it.  This makes our clearing code simpler,\n\t// since we can always safely assume that once we find a message with the nagle timer cleared, all messages\n\t// queued earlier than this also have it cleared.\n\t// FIXME - Don\'t think this works if the configuration value is changing.  Since changing the\n\t// config value could violate the assumption that nagle times are increasing.  Probably not worth\n\t// fixing.\n\tpSendMessage-&gt;SNPSend_SetUsecNagle( usecNow + m_connectionConfig.m_NagleTime.Get() );\n\tif ( pSendMessage-&gt;m_nFlags &amp; k_nSteamNetworkingSend_NoNagle )\n\t\tm_senderState.ClearNagleTimers();\n\n\t// Save the message number.  The code below might end up deleting the message we just queued\n\tint64 result = pSendMessage-&gt;m_nMessageNumber;\n\n\t// Schedule wakeup at the appropriate time.  (E.g. right now, if we\'re ready to send, \n\t// or at the Nagle time, if Nagle is active.)\n\t//\n\t// NOTE: Right now we might not actually be capable of sending end to end data.\n\t// But that case is relatievly rare, and nothing will break if we try to right now.\n\t// On the other hand, just asking the question involved a virtual function call,\n\t// and it will return success most of the time, so let\'s not make the check here.\n\tif ( GetState() == k_ESteamNetworkingConnectionState_Connected )\n\t{\n\t\tSteamNetworkingMicroseconds usecNextThink = SNP_GetNextThinkTime( usecNow );\n\n\t\t// Ready to send now?\n\t\tif ( usecNextThink &gt; usecNow )\n\t\t{\n\n\t\t\t// We are rate limiting.  Spew about it?\n\t\t\tif ( m_senderState.m_messagesQueued.m_pFirst-&gt;SNPSend_UsecNagle() == 0 )\n\t\t\t{\n\t\t\t\tSpewVerbose( "[%s] RATELIM QueueTime is %.1fms, SendRate=%.1fk, BytesQueued=%d\\n", \n\t\t\t\t\tGetDescription(),\n\t\t\t\t\tm_senderState.CalcTimeUntilNextSend() * 1e-3,\n\t\t\t\t\tm_senderState.m_n_x * ( 1.0/1024.0),\n\t\t\t\t\tm_senderState.PendingBytesTotal()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Set a wakeup call.\n\t\t\tEnsureMinThinkTime( usecNextThink );\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\t// We\'re ready to send right now.  Check if we should!\n\t\t\tif ( pSendMessage-&gt;m_nFlags &amp; k_nSteamNetworkingSend_UseCurrentThread )\n\t\t\t{\n\n\t\t\t\t// We should send in this thread, before the API entry point\n\t\t\t\t// that the app used returns.  Is the caller gonna handle this?\n\t\t\t\tif ( pbThinkImmediately )\n\t\t\t\t{\n\t\t\t\t\t// Caller says they will handle it\n\t\t\t\t\t*pbThinkImmediately = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Caller wants us to just do it here.\n\t\t\t\t\tCheckConnectionStateAndSetNextThinkTime( usecNow );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Wake up the service thread ASAP to send this in the background thread\n\t\t\t\tSetNextThinkTimeASAP();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}',
 'do_mouse(\n    oparg_T\t*oap,\t\t// operator argument, can be NULL\n    int\t\tc,\t\t// K_LEFTMOUSE, etc\n    int\t\tdir,\t\t// Direction to \'put\' if necessary\n    long\tcount,\n    int\t\tfixindent)\t// PUT_FIXINDENT if fixing indent necessary\n{\n    static int\tdo_always = FALSE;\t// ignore \'mouse\' setting next time\n    static int\tgot_click = FALSE;\t// got a click some time back\n\n    int\t\twhich_button;\t// MOUSE_LEFT, _MIDDLE or _RIGHT\n    int\t\tis_click = FALSE; // If FALSE it\'s a drag or release event\n    int\t\tis_drag = FALSE;  // If TRUE it\'s a drag event\n    int\t\tjump_flags = 0;\t// flags for jump_to_mouse()\n    pos_T\tstart_visual;\n    int\t\tmoved;\t\t// Has cursor moved?\n    int\t\tin_status_line;\t// mouse in status line\n    static int\tin_tab_line = FALSE; // mouse clicked in tab line\n    int\t\tin_sep_line;\t// mouse in vertical separator line\n    int\t\tc1, c2;\n#if defined(FEAT_FOLDING)\n    pos_T\tsave_cursor;\n#endif\n    win_T\t*old_curwin = curwin;\n    static pos_T orig_cursor;\n    colnr_T\tleftcol, rightcol;\n    pos_T\tend_visual;\n    int\t\tdiff;\n    int\t\told_active = VIsual_active;\n    int\t\told_mode = VIsual_mode;\n    int\t\tregname;\n\n#if defined(FEAT_FOLDING)\n    save_cursor = curwin-&gt;w_cursor;\n#endif\n\n    // When GUI is active, always recognize mouse events, otherwise:\n    // - Ignore mouse event in normal mode if \'mouse\' doesn\'t include \'n\'.\n    // - Ignore mouse event in visual mode if \'mouse\' doesn\'t include \'v\'.\n    // - For command line and insert mode \'mouse\' is checked before calling\n    //\t do_mouse().\n    if (do_always)\n\tdo_always = FALSE;\n    else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n#endif\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\t\t    return FALSE;\n\t    }\n\t    else if (State == MODE_NORMAL &amp;&amp; !mouse_has(MOUSE_NORMAL))\n\t\treturn FALSE;\n\t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c), &amp;is_click, &amp;is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is the same mouse event then use that\n\t    // one. Speeds up dragging the status line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\t    // below need to come before the next character, do not do this\n\t    // when the current character was stuffed.\n\t    if (!KeyStuffed &amp;&amp; vpeekc() != NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col = mouse_col;\n\n\t\t// Need to get the character, peeking doesn\'t get the actual\n\t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\tvungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &amp;bevalexpr_due);\n\t    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n#endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped dragging the status or separator line.  The pointer is\n    // most likely still on the status or separator line.\n    if (!is_drag &amp;&amp; drag_status_line)\n    {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n    }\n    if (!is_drag &amp;&amp; drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release events if we didn\'t get a click.\n    if (is_click)\n\tgot_click = TRUE;\n    else\n    {\n\tif (!got_click)\t\t\t// didn\'t get click, ignore\n\t    return FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n    if (is_click &amp;&amp; (mod_mask &amp; MOD_MASK_CTRL) &amp;&amp; which_button == MOUSE_RIGHT)\n    {\n\tif (State &amp; MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count &gt; 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click = FALSE;\t\t// ignore drag&amp;release now\n\treturn FALSE;\n    }\n\n    // CTRL only works with left mouse button\n    if ((mod_mask &amp; MOD_MASK_CTRL) &amp;&amp; which_button != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag and release events, as well as\n    // multiple clicks and the middle mouse button.\n    // Accept shift-leftmouse drags when \'mousemodel\' is "popup.*".\n    if ((mod_mask &amp; (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\t\t\t     | MOD_MASK_META))\n\t    &amp;&amp; (!is_click\n\t\t|| (mod_mask &amp; MOD_MASK_MULTI_CLICK)\n\t\t|| which_button == MOUSE_MIDDLE)\n\t    &amp;&amp; !((mod_mask &amp; (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\t\t&amp;&amp; mouse_model_popup()\n\t\t&amp;&amp; which_button == MOUSE_LEFT)\n\t    &amp;&amp; !((mod_mask &amp; MOD_MASK_ALT)\n\t\t&amp;&amp; !mouse_model_popup()\n\t\t&amp;&amp; which_button == MOUSE_RIGHT)\n\t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement command for an operator\n    // (eg "d&lt;MOUSE&gt;"), or it is the middle button that is held down, ignore\n    // drag/release events.\n    if (!is_click &amp;&amp; which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname = oap-&gt;regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does a \'put\' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don\'t know what the user wanted\n\t    // to do. Go back to normal mode: Clear the operator and beep().\n\t    if (oap != NULL &amp;&amp; oap-&gt;op_type != OP_NOP)\n\t    {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual was active, yank the highlighted text and put it\n\t    // before the mouse pointer position.\n\t    // In Select mode replace the highlighted text with the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)"\\"+p");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff(\'y\');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\t\t}\n\t\tdo_always = TRUE;\t// ignore \'mouse\' setting next time\n\t\treturn FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if ((State &amp; MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert mode doesn\'t move the mouse, just insert the\n\t// contents of a register.  \'.\' register is special, can\'t insert that\n\t// with do_put().\n\t// Also paste at the cursor if the current mode isn\'t in \'mouse\' (only\n\t// happens for the GUI).\n\tif ((State &amp; MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t    if (regname == \'.\')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available &amp;&amp; regname == 0)\n\t\t    regname = \'*\';\n#endif\n\t\tif ((State &amp; REPLACE_FLAG) &amp;&amp; !yank_register_mline(regname))\n\t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname == 0 ? \'"\' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n    if (TabPageIdxs != NULL)  // only when initialized\n    {\n\t// Check for clicking in the tab page line.\n\tif (mouse_row == 0 &amp;&amp; firstwin-&gt;w_winrow &gt; 0)\n\t{\n\t    if (is_drag)\n\t    {\n\t\tif (in_tab_line)\n\t\t{\n\t\t    c1 = TabPageIdxs[mouse_col];\n\t\t    tabpage_move(c1 &lt;= 0 ? 9999 : c1 &lt; tabpage_index(curtab)\n\t\t\t\t\t\t\t\t    ? c1 - 1 : c1);\n\t\t}\n\t\treturn FALSE;\n\t    }\n\n\t    // click in a tab selects that tab page\n\t    if (is_click\n# ifdef FEAT_CMDWIN\n\t\t    &amp;&amp; cmdwin_type == 0\n# endif\n\t\t    &amp;&amp; mouse_col &lt; Columns)\n\t    {\n\t\tin_tab_line = TRUE;\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\tif (c1 &gt;= 0)\n\t\t{\n\t\t    if ((mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t    {\n\t\t\t// double click opens new page\n\t\t\tend_visual_mode_keep_button();\n\t\t\ttabpage_new();\n\t\t\ttabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Go to specified tab page, or next one if not clicking\n\t\t\t// on a label.\n\t\t\tgoto_tabpage(c1);\n\n\t\t\t// It\'s like clicking on the status line of a window.\n\t\t\tif (curwin != old_curwin)\n\t\t\t    end_visual_mode_keep_button();\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*tp;\n\n\t\t    // Close the current or specified tab page.\n\t\t    if (c1 == -999)\n\t\t\ttp = curtab;\n\t\t    else\n\t\t\ttp = find_tabpage(-c1);\n\t\t    if (tp == curtab)\n\t\t    {\n\t\t\tif (first_tabpage-&gt;tp_next != NULL)\n\t\t\t    tabpage_close(FALSE);\n\t\t    }\n\t\t    else if (tp != NULL)\n\t\t\ttabpage_close_other(tp, FALSE);\n\t\t}\n\t    }\n\t    return TRUE;\n\t}\n\telse if (is_drag &amp;&amp; in_tab_line)\n\t{\n\t    c1 = TabPageIdxs[mouse_col];\n\t    tabpage_move(c1 &lt;= 0 ? 9999 : c1 - 1);\n\t    return FALSE;\n\t}\n    }\n\n    // When \'mousemodel\' is "popup" or "popup_setpos", translate mouse events:\n    // right button up   -&gt; pop-up menu\n    // shift-left button -&gt; right button\n    // alt-left button   -&gt; alt-right button\n    if (mouse_model_popup())\n    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    &amp;&amp; !(mod_mask &amp; (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore right button release events, only shows the popup\n\t\t    // menu on the button down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore right button down and drag mouse events.  Windows\n\t\t    // only shows the popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n# endif\n# if defined(FEAT_GUI) &amp;&amp; defined(FEAT_TERM_POPUP_MENU)\n\t    else\n# endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore right button release events, only shows the popup\n\t\t// menu on the button down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem, "popup_setpos") == 0)\n\t    {\n\t\t// First set the cursor position before showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t    // selection or the current window (might have false\n\t\t    // negative here)\n\t\t    if (mouse_row &lt; curwin-&gt;w_winrow\n\t\t\t || mouse_row\n\t\t\t\t  &gt; (curwin-&gt;w_winrow + curwin-&gt;w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else if (get_fpos_of_mouse(&amp;m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin-&gt;w_cursor, VIsual)\n\t\t\t\t    &amp;&amp; (LT_POS(m_pos, curwin-&gt;w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\t\t\t\t|| (LT_POS(VIsual, curwin-&gt;w_cursor)\n\t\t\t\t    &amp;&amp; (LT_POS(m_pos, VIsual)\n\t\t\t\t      || LT_POS(curwin-&gt;w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t{\n\t\t\t    getvcols(curwin, &amp;curwin-&gt;w_cursor, &amp;VIsual,\n\t\t\t\t\t\t     &amp;leftcol, &amp;rightcol);\n\t\t\t    getvcol(curwin, &amp;m_pos, NULL, &amp;m_pos.col, NULL);\n\t\t\t    if (m_pos.col &lt; leftcol || m_pos.col &gt; rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags, NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t// ignore release events\n# endif\n\t    return (jump_flags &amp; CURSOR_MOVED) != 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\t\t\t\t&amp;&amp; (mod_mask &amp; (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button = MOUSE_RIGHT;\n\t    mod_mask &amp;= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State &amp; (MODE_NORMAL | MODE_INSERT))\n\t\t\t    &amp;&amp; !(mod_mask &amp; (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click &amp;&amp; VIsual_active)\n\t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t// cursor.\n\t\tif (LT_POS(curwin-&gt;w_cursor, VIsual))\n\t\t{\n\t\t    start_visual = curwin-&gt;w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\t    start_visual = VIsual;\n\t\t    end_visual = curwin-&gt;w_cursor;\n\t\t}\n\t    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending, ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag &amp;&amp; oap != NULL &amp;&amp; oap-&gt;op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap-&gt;motion_type = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n    if (!is_click &amp;&amp; !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &amp;(oap-&gt;inclusive), which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has no side effects.\n    if (jump_flags &amp; MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n    moved = (jump_flags &amp; CURSOR_MOVED);\n    in_status_line = (jump_flags &amp; IN_STATUS_LINE);\n    in_sep_line = (jump_flags &amp; IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n    if (isNetbeansBuffer(curbuf)\n\t\t\t    &amp;&amp; !(jump_flags &amp; (IN_STATUS_LINE | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping to another window, clear a pending operator.  That\'s a bit\n    // friendlier than beeping and not jumping to that window.\n    if (curwin != old_curwin &amp;&amp; oap != NULL &amp;&amp; oap-&gt;op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n    if (mod_mask == 0\n\t    &amp;&amp; !is_drag\n\t    &amp;&amp; (jump_flags &amp; (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))\n\t    &amp;&amp; which_button == MOUSE_LEFT)\n    {\n\t// open or close a fold at this line\n\tif (jump_flags &amp; MOUSE_FOLD_OPEN)\n\t    openFold(curwin-&gt;w_cursor.lnum, 1L);\n\telse\n\t    closeFold(curwin-&gt;w_cursor.lnum, 1L);\n\t// don\'t move the cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin-&gt;w_cursor = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) &amp;&amp; defined(FEAT_CMDWIN)\n    if ((jump_flags &amp; IN_OTHER_WIN) &amp;&amp; !VIsual_active &amp;&amp; clip_star.available)\n    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n    }\n#endif\n\n    // Set global flag that we are extending the Visual area with mouse\n    // dragging; temporarily minimize \'scrolloff\'.\n    if (VIsual_active &amp;&amp; is_drag &amp;&amp; get_scrolloff_value())\n    {\n\t// In the very first line, allow scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window, scroll down.\n    if (is_drag &amp;&amp; mouse_row &lt; 0 &amp;&amp; !in_status_line)\n    {\n\tscroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\t// right click in visual mode\n    {\n       // When ALT is pressed make Visual mode blockwise.\n       if (mod_mask &amp; MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t// that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\t{\n\t    getvcols(curwin, &amp;start_visual, &amp;end_visual, &amp;leftcol, &amp;rightcol);\n\t    if (curwin-&gt;w_curswant &gt; (leftcol + rightcol) / 2)\n\t\tend_visual.col = leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin-&gt;w_cursor.lnum &gt;=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual = curwin-&gt;w_cursor;\t    // save the cursor pos\n\t    curwin-&gt;w_cursor = end_visual;\n\t    coladvance(end_visual.col);\n\t    VIsual = curwin-&gt;w_cursor;\n\t    curwin-&gt;w_cursor = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the click is before the start of visual, change the start.\n\t    // If the click is after the end of visual, change the end.  If\n\t    // the click is inside the visual, change the closest side.\n\t    if (LT_POS(curwin-&gt;w_cursor, start_visual))\n\t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin-&gt;w_cursor))\n\t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t    if (curwin-&gt;w_cursor.col - start_visual.col &gt;\n\t\t\t\t    end_visual.col - curwin-&gt;w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\telse\n\t\t{\n\t\t    diff = (curwin-&gt;w_cursor.lnum - start_visual.lnum) -\n\t\t\t\t(end_visual.lnum - curwin-&gt;w_cursor.lnum);\n\n\t\t    if (diff &gt; 0)\t\t// closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff &lt; 0)\t// closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle line\n\t\t    {\n\t\t\tif (curwin-&gt;w_cursor.col &lt;\n\t\t\t\t\t(start_visual.col + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t    VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual mode started in insert mode, execute "CTRL-O"\n    else if ((State &amp; MODE_INSERT) &amp;&amp; VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click: Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef FEAT_CLIPBOARD\n\tif (clip_star.available &amp;&amp; regname == 0)\n\t    regname = \'*\';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\tif (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? \'[\' : \']\';\n\t    c2 = \'p\';\n\t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? \'p\' : \'P\';\n\t    c2 = NUL;\n\t}\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where the paste started, so in edit() Insstart can be set\n\t// to this position\n\tif (restart_edit != 0)\n\t    where_paste_started = curwin-&gt;w_cursor;\n\tdo_put(regname, NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n    // error under the mouse pointer.\n    else if (((mod_mask &amp; MOD_MASK_CTRL)\n\t\t|| (mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    &amp;&amp; bt_quickfix(curbuf))\n    {\n\tif (curwin-&gt;w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u *)".cc");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u *)".ll");\n\tgot_click = FALSE;\t\t// ignore drag&amp;release now\n    }\n#endif\n\n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n    // under the mouse pointer.\n    else if ((mod_mask &amp; MOD_MASK_CTRL) || (curbuf-&gt;b_help\n\t\t     &amp;&amp; (mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\tif (State &amp; MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\tgot_click = FALSE;\t\t// ignore drag&amp;release now\n    }\n\n    // Shift-Mouse click searches for the next occurrence of the word under\n    // the mouse pointer\n    else if ((mod_mask &amp; MOD_MASK_SHIFT))\n    {\n\tif ((State &amp; MODE_INSERT) || (VIsual_active &amp;&amp; VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff(\'*\');\n\telse\t// MOUSE_RIGHT\n\t    stuffcharReadbuff(\'#\');\n    }\n\n    // Handle double clicks, unless on status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) &amp;&amp; !drag_status_line)\n\t{\n\t    drag_status_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) &amp;&amp; !drag_sep_line)\n\t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if ((mod_mask &amp; MOD_MASK_MULTI_CLICK)\n\t\t\t\t       &amp;&amp; (State &amp; (MODE_NORMAL | MODE_INSERT))\n\t     &amp;&amp; mouse_has(MOUSE_VISUAL))\n    {\n\tif (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual = curwin-&gt;w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\tVIsual_reselect = TRUE;\n\t\t// start Select mode if \'selectmode\' contains "mouse"\n\t\tmay_start_select(\'o\');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with ALT pressed makes it blockwise.\n\t\tif (mod_mask &amp; MOD_MASK_ALT)\n\t\t    VIsual_mode = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = \'v\';\n\t    }\n\t    else if ((mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = \'V\';\n\t    else if ((mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode = Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end may still be the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double click selects a word or a block.\n\tif ((mod_mask &amp; MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t    if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white space) is\n\t\t// not a word character, try finding a match and select a (),\n\t\t// {} [], #if/#endif, etc. block.\n\t\tend_visual = curwin-&gt;w_cursor;\n\t\twhile (gc = gchar_pos(&amp;end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&amp;end_visual);\n\t\tif (oap != NULL)\n\t\t    oap-&gt;motion_type = MCHAR;\n\t\tif (oap != NULL\n\t\t\t&amp;&amp; VIsual_mode == \'v\'\n\t\t\t&amp;&amp; !vim_iswordc(gchar_pos(&amp;end_visual))\n\t\t\t&amp;&amp; EQUAL_POS(curwin-&gt;w_cursor, VIsual)\n\t\t\t&amp;&amp; (pos = findmatch(oap, NUL)) != NULL)\n\t\t{\n\t\t    curwin-&gt;w_cursor = *pos;\n\t\t    if (oap-&gt;motion_type == MLINE)\n\t\t\tVIsual_mode = \'V\';\n\t\t    else if (*p_sel == \'e\')\n\t\t    {\n\t\t\tif (LT_POS(curwin-&gt;w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\t\telse\n\t\t\t    ++curwin-&gt;w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (pos == NULL &amp;&amp; (is_click || is_drag))\n\t    {\n\t\t// When not found a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin-&gt;w_cursor, orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&amp;curwin-&gt;w_cursor);\n\t\t    find_end_of_word(&amp;VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&amp;VIsual);\n\t\t    if (*p_sel == \'e\' &amp;&amp; *ml_get_cursor() != NUL)\n\t\t\tcurwin-&gt;w_cursor.col +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&amp;curwin-&gt;w_cursor);\n\t\t}\n\t    }\n\t    curwin-&gt;w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else if (VIsual_active &amp;&amp; !old_active)\n    {\n\tif (mod_mask &amp; MOD_MASK_ALT)\n\t    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = \'v\';\n    }\n\n    // If Visual mode changed show it later.\n    if ((!VIsual_active &amp;&amp; old_active &amp;&amp; mode_displayed)\n\t    || (VIsual_active &amp;&amp; p_smd &amp;&amp; msg_silent == 0\n\t\t\t\t &amp;&amp; (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\n    return moved;\n}',
 'static char* cJSON_strdup( const char* str )\n{\n\tsize_t len;\n\tchar* copy;\n\n\tlen = strlen( str ) + 1;\n\tif ( ! ( copy = (char*) cJSON_malloc( len ) ) )\n\t\treturn 0;\n\tmemcpy( copy, str, len );\n\treturn copy;\n}',
 'TfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           TfLiteFullyConnectedParams* params, OpData* data,\n                           const TfLiteTensor* input,\n                           const TfLiteTensor* filter, const TfLiteTensor* bias,\n                           TfLiteTensor* output) {\n  int32_t input_offset = -input-&gt;params.zero_point;\n  int32_t filter_offset = -filter-&gt;params.zero_point;\n  int32_t output_offset = output-&gt;params.zero_point;\n  // Only the Pie path supports quantized models and float inputs/outputs.\n  if (input-&gt;type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/0);\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/1);\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/2);\n    TfLiteTensor* input_offsets = GetTemporary(context, node, /*index=*/3);\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/4);\n    return EvalHybrid(context, node, params, data, input, filter, bias,\n                      input_quantized, scaling_factors, accum_scratch, row_sums,\n                      input_offsets, output);\n  } else {\n    FullyConnectedParams op_params;\n    op_params.input_offset = input_offset;\n    op_params.weights_offset = filter_offset;\n    op_params.output_offset = output_offset;\n    op_params.output_multiplier = data-&gt;output_multiplier;\n    op_params.output_shift = data-&gt;output_shift;\n    op_params.quantized_activation_min = data-&gt;output_activation_min;\n    op_params.quantized_activation_max = data-&gt;output_activation_max;\n    op_params.lhs_cacheable = IsConstantTensor(filter);\n    op_params.rhs_cacheable = IsConstantTensor(input);\n    switch (output-&gt;type) {\n      case kTfLiteUInt8:\n        if (kernel_type == kReference) {\n          reference_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData&lt;uint8_t&gt;(input),\n              GetTensorShape(filter), GetTensorData&lt;uint8_t&gt;(filter),\n              GetTensorShape(bias), GetTensorData&lt;int32_t&gt;(bias),\n              GetTensorShape(output), GetTensorData&lt;uint8_t&gt;(output));\n        } else {\n          optimized_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData&lt;uint8_t&gt;(input),\n              GetTensorShape(filter), GetTensorData&lt;uint8_t&gt;(filter),\n              GetTensorShape(bias), GetTensorData&lt;int32_t&gt;(bias),\n              GetTensorShape(output), GetTensorData&lt;uint8_t&gt;(output),\n              CpuBackendContext::GetFromContext(context));\n        }\n        break;\n      case kTfLiteInt8:\n        FullyConnectedInt8&lt;kernel_type&gt;(\n            data, input, filter, bias, output,\n            CpuBackendContext::GetFromContext(context));\n        break;\n      case kTfLiteInt16:\n        if (input-&gt;type == kTfLiteInt16) {\n          FullyConnectedInt16&lt;kernel_type&gt;(data, input, filter, bias, output);\n        } else if (kernel_type == kReference) {\n          reference_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData&lt;uint8_t&gt;(input),\n              GetTensorShape(filter), GetTensorData&lt;uint8_t&gt;(filter),\n              GetTensorShape(bias), GetTensorData&lt;int32_t&gt;(bias),\n              GetTensorShape(output), GetTensorData&lt;int16_t&gt;(output));\n        } else {\n          optimized_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData&lt;uint8_t&gt;(input),\n              GetTensorShape(filter), GetTensorData&lt;uint8_t&gt;(filter),\n              GetTensorShape(bias), GetTensorData&lt;int32_t&gt;(bias),\n              GetTensorShape(output), GetTensorData&lt;int16_t&gt;(output),\n              CpuBackendContext::GetFromContext(context));\n        }\n        break;\n      default:\n        context-&gt;ReportError(context,\n                             "Quantized FullyConnected expects output data "\n                             "type uint8, int8 or int16");\n        return kTfLiteError;\n    }\n  }\n\n  return kTfLiteOk;\n}',
 "error_t httpClientSetMethod(HttpClientContext *context, const char_t *method)\n{\n   size_t m;\n   size_t n;\n   char_t *p;\n\n   //Check parameters\n   if(context == NULL || method == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   //Compute the length of the HTTP method\n   n = osStrlen(method);\n\n   //Make sure the length of the user name is acceptable\n   if(n == 0 || n &gt; HTTP_CLIENT_MAX_METHOD_LEN)\n      return ERROR_INVALID_LENGTH;\n\n   //Make sure the buffer contains a valid HTTP request\n   if(context-&gt;bufferLen &gt; HTTP_CLIENT_BUFFER_SIZE)\n      return ERROR_INVALID_SYNTAX;\n\n   //Properly terminate the string with a NULL character\n   context-&gt;buffer[context-&gt;bufferLen] = '\\0';\n\n   //The Request-Line begins with a method token\n   p = osStrchr(context-&gt;buffer, ' ');\n   //Any parsing error?\n   if(p == NULL)\n      return ERROR_INVALID_SYNTAX;\n\n   //Compute the length of the current method token\n   m = p - context-&gt;buffer;\n\n   //Make sure the buffer is large enough to hold the new HTTP request method\n   if((context-&gt;bufferLen + n - m) &gt; HTTP_CLIENT_BUFFER_SIZE)\n      return ERROR_BUFFER_OVERFLOW;\n\n   //Make room for the new method token\n   osMemmove(context-&gt;buffer + n, p, context-&gt;bufferLen + 1 - m);\n   //Copy the new method token\n   osStrncpy(context-&gt;buffer, method, n);\n\n   //Adjust the length of the request header\n   context-&gt;bufferLen = context-&gt;bufferLen + n - m;\n\n   //Save HTTP request method\n   osStrcpy(context-&gt;method, method);\n\n   //Successful processing\n   return NO_ERROR;\n}",
 '  void resizeTable(HeaderTable&amp; table, uint32_t newCapacity, uint32_t newMax) {\n    table.setCapacity(newCapacity);\n    // On resizing the table size (count of headers) remains the same or sizes\n    // down; can not size up\n    EXPECT_LE(table.size(), newMax);\n  }',
 '  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context-&gt;input(kFirstPartitionInputIndex);\n    if (row_partition_types_.empty()) {\n      return errors::InvalidArgument("No row_partition_types given.");\n    }\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar&lt;INDEX_TYPE&gt;()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            "Cannot handle VALUE_ROWIDS in first dimension.");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            "Cannot handle type ",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }',
 'static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    "  Enter ReadOneMNGImage()");\n\n  image=mng_info-&gt;image;\n\n  if (LocaleCompare(image_info-&gt;magick,"MNG") == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,"\\212MNG\\r\\n\\032\\n",8) != 0)\n        ThrowReaderException(CorruptImageError,"ImproperImageHeader");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i &lt; MNG_MAX_OBJECTS; i++)\n      {\n        mng_info-&gt;object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info-&gt;object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info-&gt;exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info-&gt;ticks_per_second=1UL*image-&gt;ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info-&gt;framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image-&gt;background_color;\n#endif\n  default_fb=mng_info-&gt;frame;\n  previous_fb=mng_info-&gt;frame;\n  do\n  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info-&gt;magick,"MNG") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]=\'\\0\';\n        (void) ConcatenateMagickString(type,"errr",MagickPathExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           "  Reading MNG chunk type %c%c%c%c, length: %.20g",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length &gt; PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,"CorruptImage");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n             MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\n                "MemoryAllocationFailed");\n\n            for (i=0; i &lt; (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info-&gt;jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,"JNGCompressNotSupported","`%s\'",image-&gt;filename);\n\n            mng_info-&gt;jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info-&gt;dhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,"DeltaPNGNotSupported","`%s\'",image-&gt;filename);\n\n            mng_info-&gt;dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                "  Skip to IEND.");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,"CorruptImage");\n              }\n\n            mng_info-&gt;mng_width=(size_t) ((p[0] &lt;&lt; 24) | (p[1] &lt;&lt; 16) |\n                (p[2] &lt;&lt; 8) | p[3]);\n\n            mng_info-&gt;mng_height=(size_t) ((p[4] &lt;&lt; 24) | (p[5] &lt;&lt; 16) |\n                (p[6] &lt;&lt; 8) | p[7]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  "  MNG width: %.20g",(double) mng_info-&gt;mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  "  MNG height: %.20g",(double) mng_info-&gt;mng_height);\n              }\n\n            p+=8;\n            mng_info-&gt;ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info-&gt;ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image-&gt;ticks_per_second/\n                mng_info-&gt;ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) &amp;&amp; ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) &amp;&amp; ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return((Image *) NULL);\n\n                image=SyncNextImageInList(image);\n                mng_info-&gt;image=image;\n              }\n\n            if ((mng_info-&gt;mng_width &gt; 65535L) ||\n                (mng_info-&gt;mng_height &gt; 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,"WidthOrHeightExceedsLimit");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n              "%.20gx%.20g+0+0",(double) mng_info-&gt;mng_width,(double)\n              mng_info-&gt;mng_height);\n\n            mng_info-&gt;frame.left=0;\n            mng_info-&gt;frame.right=(ssize_t) mng_info-&gt;mng_width;\n            mng_info-&gt;frame.top=0;\n            mng_info-&gt;frame.bottom=(ssize_t) mng_info-&gt;mng_height;\n            mng_info-&gt;clip=default_fb=previous_fb=mng_info-&gt;frame;\n\n            for (i=0; i &lt; MNG_MAX_OBJECTS; i++)\n              mng_info-&gt;object_clip[i]=mng_info-&gt;frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3)\n              {\n                final_delay=(png_uint_32) mng_get_long(&amp;p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&amp;p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image-&gt;iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  "    repeat=%d,  final_delay=%.20g,  iterations=%.20g",\n                  repeat,(double) final_delay, (double) image-&gt;iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,"DEFI chunk found in MNG-VLC datastream","`%s\'",\n                image-&gt;filename);\n\n            if (length &lt; 2)\n              {\n                if (chunk)\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,"CorruptImage");\n              }\n\n            object_id=(p[0] &lt;&lt; 8) | p[1];\n\n            if (mng_type == 2 &amp;&amp; object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,"Nonzero object_id in MNG-LC datastream","`%s\'",\n                image-&gt;filename);\n\n            if (object_id &gt; MNG_MAX_OBJECTS)\n              {\n                /*\n                  Instead of using a warning we should allocate a larger\n                  MngInfo structure and continue.\n                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  CoderError,"object id too large","`%s\'",image-&gt;filename);\n                object_id=MNG_MAX_OBJECTS;\n              }\n\n            if (mng_info-&gt;exists[object_id])\n              if (mng_info-&gt;frozen[object_id])\n                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                  (void) ThrowMagickException(exception,\n                    GetMagickModule(),CoderError,\n                    "DEFI cannot redefine a frozen MNG object","`%s\'",\n                    image-&gt;filename);\n                  continue;\n                }\n\n            mng_info-&gt;exists[object_id]=MagickTrue;\n\n            if (length &gt; 2)\n              mng_info-&gt;invisible[object_id]=p[2];\n\n            /*\n              Extract object offset info.\n            */\n            if (length &gt; 11)\n              {\n                mng_info-&gt;x_off[object_id]=(ssize_t) ((p[4] &lt;&lt; 24) |\n                    (p[5] &lt;&lt; 16) | (p[6] &lt;&lt; 8) | p[7]);\n\n                mng_info-&gt;y_off[object_id]=(ssize_t) ((p[8] &lt;&lt; 24) |\n                    (p[9] &lt;&lt; 16) | (p[10] &lt;&lt; 8) | p[11]);\n\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      "  x_off[%d]: %.20g,  y_off[%d]: %.20g",\n                      object_id,(double) mng_info-&gt;x_off[object_id],\n                      object_id,(double) mng_info-&gt;y_off[object_id]);\n                  }\n              }\n\n            /*\n              Extract object clipping info.\n            */\n            if (length &gt; 27)\n              mng_info-&gt;object_clip[object_id]=mng_read_box(mng_info-&gt;frame,0,\n                &amp;p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info-&gt;have_global_bkgd=MagickFalse;\n\n            if (length &gt; 5)\n              {\n                mng_info-&gt;mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] &lt;&lt; 8) | p[1]));\n\n                mng_info-&gt;mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] &lt;&lt; 8) | p[3]));\n\n                mng_info-&gt;mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] &lt;&lt; 8) | p[5]));\n\n                mng_info-&gt;have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length &gt; 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back &amp;&amp; length &gt; 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] &lt;&lt; 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] &lt;&lt; 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] &lt;&lt; 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length &gt; 8)\n              mng_background_object=(p[7] &lt;&lt; 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length &amp;&amp; (length &lt; 769))\n              {\n                if (mng_info-&gt;global_plte == (png_colorp) NULL)\n                  mng_info-&gt;global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info-&gt;global_plte));\n\n                for (i=0; i &lt; (ssize_t) (length/3); i++)\n                {\n                  mng_info-&gt;global_plte[i].red=p[3*i];\n                  mng_info-&gt;global_plte[i].green=p[3*i+1];\n                  mng_info-&gt;global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info-&gt;global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i &lt; 256; i++)\n            {\n              mng_info-&gt;global_plte[i].red=i;\n              mng_info-&gt;global_plte[i].green=i;\n              mng_info-&gt;global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info-&gt;global_plte_length=256;\n#endif\n            else\n              mng_info-&gt;global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length &gt; 0 &amp;&amp; length &lt; 257)\n              for (i=0; i &lt; (ssize_t) length; i++)\n                mng_info-&gt;global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i &lt; 256; i++)\n              mng_info-&gt;global_trns[i]=255;\n#endif\n            mng_info-&gt;global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info-&gt;global_gamma=((float) igamma)*0.00001;\n                mng_info-&gt;have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info-&gt;have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info-&gt;global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info-&gt;global_chrm.white_point.y=0.00001*mng_get_long(&amp;p[4]);\n                mng_info-&gt;global_chrm.red_primary.x=0.00001*mng_get_long(&amp;p[8]);\n                mng_info-&gt;global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&amp;p[12]);\n                mng_info-&gt;global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&amp;p[16]);\n                mng_info-&gt;global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&amp;p[20]);\n                mng_info-&gt;global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&amp;p[24]);\n                mng_info-&gt;global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&amp;p[28]);\n                mng_info-&gt;have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info-&gt;have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info-&gt;global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info-&gt;have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info-&gt;have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,"FRAM chunk found in MNG-VLC datastream","`%s\'",\n                image-&gt;filename);\n\n            if ((mng_info-&gt;framing_mode == 2) || (mng_info-&gt;framing_mode == 4))\n              image-&gt;delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length != 0)\n              if (p[0])\n                mng_info-&gt;framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                "    Framing_mode=%d",mng_info-&gt;framing_mode);\n\n            if (length &gt; 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p &amp;&amp; ((p-chunk) &lt; (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) &lt; (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay)\n                      {\n                        frame_delay=1UL*image-&gt;ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info-&gt;ticks_per_second != 0)\n                          frame_delay/=mng_info-&gt;ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            "    Framing_delay=%.20g",(double) frame_delay);\n                      }\n\n                    if (change_timeout)\n                      {\n                        frame_timeout=1UL*image-&gt;ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info-&gt;ticks_per_second != 0)\n                          frame_timeout/=mng_info-&gt;ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            "    Framing_timeout=%.20g",(double) frame_timeout);\n                      }\n\n                    if (change_clipping)\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&amp;p[1]);\n                        p+=17;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            "    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info-&gt;clip=fb;\n            mng_info-&gt;clip=mng_minimum_box(fb,mng_info-&gt;frame);\n\n            subframe_width=(size_t) (mng_info-&gt;clip.right\n               -mng_info-&gt;clip.left);\n\n            subframe_height=(size_t) (mng_info-&gt;clip.bottom\n               -mng_info-&gt;clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                "   subframe_width=%.20g, subframe_height=%.20g",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers &amp;&amp; (mng_info-&gt;framing_mode == 4) &amp;&amp;\n                (subframe_width) &amp;&amp; (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info-&gt;image=image;\n\n                if (term_chunk_found)\n                  {\n                    image-&gt;start_loop=MagickTrue;\n                    image-&gt;iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image-&gt;start_loop=MagickFalse;\n\n                image-&gt;columns=subframe_width;\n                image-&gt;rows=subframe_height;\n                image-&gt;page.width=subframe_width;\n                image-&gt;page.height=subframe_height;\n                image-&gt;page.x=mng_info-&gt;clip.left;\n                image-&gt;page.y=mng_info-&gt;clip.top;\n                image-&gt;background_color=mng_background_color;\n                image-&gt;alpha_trait=UndefinedPixelTrait;\n                image-&gt;delay=0;\n                (void) SetImageBackgroundColor(image,exception);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    "  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g",\n                    (double) mng_info-&gt;clip.left,\n                    (double) mng_info-&gt;clip.right,\n                    (double) mng_info-&gt;clip.top,\n                    (double) mng_info-&gt;clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length &gt; 3)\n              {\n                first_object=(p[0] &lt;&lt; 8) | p[1];\n                last_object=(p[2] &lt;&lt; 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i &lt;= (int) last_object; i++)\n                {\n                  if (mng_info-&gt;exists[i] &amp;&amp; !mng_info-&gt;frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info-&gt;object_clip[i];\n                      if ((p-chunk) &lt; (ssize_t) (length-17))\n                        mng_info-&gt;object_clip[i]=\n                           mng_read_box(box,(char) p[0],&amp;p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i &lt; MNG_MAX_OBJECTS; i++)\n              if (mng_info-&gt;exists[i])\n                {\n                 mng_info-&gt;frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info-&gt;ob[i] != (MngBuffer *) NULL)\n                    mng_info-&gt;ob[i]-&gt;frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i &lt; MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j &lt; (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] &lt;&lt; 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length &gt; 3)\n            {\n              first_object=(p[0] &lt;&lt; 8) | p[1];\n              last_object=(p[2] &lt;&lt; 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object; i &lt;= (ssize_t) last_object; i++)\n              {\n                if ((i &lt; 0) || (i &gt;= MNG_MAX_OBJECTS))\n                  continue;\n\n                if (mng_info-&gt;exists[i] &amp;&amp; !mng_info-&gt;frozen[i] &amp;&amp;\n                    (p-chunk) &lt; (ssize_t) (length-8))\n                  {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info-&gt;x_off[i];\n                    old_pair.b=mng_info-&gt;y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&amp;p[1]);\n                    mng_info-&gt;x_off[i]=new_pair.a;\n                    mng_info-&gt;y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length &gt; 4)\n              {\n                loop_level=chunk[0];\n                mng_info-&gt;loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&amp;chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    "  LOOP level %.20g has %.20g iterations ",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info-&gt;loop_jump[loop_level]=TellBlob(image);\n                    mng_info-&gt;loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info-&gt;loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length &gt; 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop &gt; 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info-&gt;loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info-&gt;loop_active[loop_level] == 1)\n                      {\n                        mng_info-&gt;loop_count[loop_level]--;\n                        mng_info-&gt;loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          "  ENDL: LOOP level %.20g has %.20g remaining iters",\n                            (double) loop_level,(double)\n                            mng_info-&gt;loop_count[loop_level]);\n\n                        if (mng_info-&gt;loop_count[loop_level] != 0)\n                          {\n                            offset=\n                              SeekBlob(image,mng_info-&gt;loop_jump[loop_level],\n                              SEEK_SET);\n\n                            if (offset &lt; 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  "ImproperImageHeader");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info-&gt;loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i &lt; loop_level; i++)\n                              if (mng_info-&gt;loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info-&gt;clon_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,"CLON is not implemented yet","`%s\'",\n                image-&gt;filename);\n\n            mng_info-&gt;clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length &gt; 1)\n              magn_first=(p[0] &lt;&lt; 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length &gt; 3)\n              magn_last=(p[2] &lt;&lt; 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info-&gt;magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     "MAGN is not implemented yet for nonzero objects",\n                     "`%s\'",image-&gt;filename);\n\n                   mng_info-&gt;magn_warning++;\n                }\n#endif\n            if (length &gt; 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length &gt; 6)\n              magn_mx=(p[5] &lt;&lt; 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length &gt; 8)\n              magn_my=(p[7] &lt;&lt; 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length &gt; 10)\n              magn_ml=(p[9] &lt;&lt; 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length &gt; 12)\n              magn_mr=(p[11] &lt;&lt; 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length &gt; 14)\n              magn_mt=(p[13] &lt;&lt; 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length &gt; 16)\n              magn_mb=(p[15] &lt;&lt; 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length &gt; 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx &gt; 5 || magn_methy &gt; 5)\n              if (mng_info-&gt;magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     "Unknown MAGN method in MNG datastream","`%s\'",\n                     image-&gt;filename);\n\n                   mng_info-&gt;magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info-&gt;magn_mb=magn_mb;\n                mng_info-&gt;magn_ml=magn_ml;\n                mng_info-&gt;magn_mr=magn_mr;\n                mng_info-&gt;magn_mt=magn_mt;\n                mng_info-&gt;magn_mx=magn_mx;\n                mng_info-&gt;magn_my=magn_my;\n                mng_info-&gt;magn_methx=magn_methx;\n                mng_info-&gt;magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info-&gt;past_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,"PAST is not implemented yet","`%s\'",\n                image-&gt;filename);\n\n            mng_info-&gt;past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info-&gt;show_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,"SHOW is not implemented yet","`%s\'",\n                image-&gt;filename);\n\n            mng_info-&gt;show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length &lt; 4)\n              mng_info-&gt;have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info-&gt;global_sbit.gray=p[0];\n                mng_info-&gt;global_sbit.red=p[0];\n                mng_info-&gt;global_sbit.green=p[1];\n                mng_info-&gt;global_sbit.blue=p[2];\n                mng_info-&gt;global_sbit.alpha=p[3];\n                mng_info-&gt;have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length &gt; 8)\n              {\n                mng_info-&gt;global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info-&gt;global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&amp;p[4]);\n                mng_info-&gt;global_phys_unit_type=p[8];\n                mng_info-&gt;have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info-&gt;have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info-&gt;phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,"pHYg is not implemented.","`%s\'",image-&gt;filename);\n\n            mng_info-&gt;phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info-&gt;basi_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,"BASI is not implemented yet","`%s\'",\n                image-&gt;filename);\n\n            mng_info-&gt;basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            basi_width=(size_t) ((p[0] &lt;&lt; 24) | (p[1] &lt;&lt; 16) |\n               (p[2] &lt;&lt; 8) | p[3]);\n            basi_height=(size_t) ((p[4] &lt;&lt; 24) | (p[5] &lt;&lt; 16) |\n               (p[6] &lt;&lt; 8) | p[7]);\n            basi_color_type=p[8];\n            basi_compression_method=p[9];\n            basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n            if (length &gt; 11)\n              basi_red=(p[12] &lt;&lt; 8) &amp; p[13];\n\n            else\n              basi_red=0;\n\n            if (length &gt; 13)\n              basi_green=(p[14] &lt;&lt; 8) &amp; p[15];\n\n            else\n              basi_green=0;\n\n            if (length &gt; 15)\n              basi_blue=(p[16] &lt;&lt; 8) &amp; p[17];\n\n            else\n              basi_blue=0;\n\n            if (length &gt; 17)\n              basi_alpha=(p[18] &lt;&lt; 8) &amp; p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length &gt; 19)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            &amp;&amp; memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            "  Processing %c%c%c%c chunk",type[0],type[1],type[2],type[3]);\n\n        mng_info-&gt;exists[object_id]=MagickTrue;\n        mng_info-&gt;viewable[object_id]=MagickTrue;\n\n        if (mng_info-&gt;invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                "  Skipping invisible object");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length &lt; 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,"ImproperImageHeader");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&amp;p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers &amp;&amp; mng_type &amp;&amp; first_mng_object)\n          {\n            if ((mng_info-&gt;clip.left &gt; 0) || (mng_info-&gt;clip.top &gt; 0) ||\n                (image_width &lt; mng_info-&gt;mng_width) ||\n                (mng_info-&gt;clip.right &lt; (ssize_t) mng_info-&gt;mng_width) ||\n                (image_height &lt; mng_info-&gt;mng_height) ||\n                (mng_info-&gt;clip.bottom &lt; (ssize_t) mng_info-&gt;mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info-&gt;image=image;\n\n                if (term_chunk_found)\n                  {\n                    image-&gt;start_loop=MagickTrue;\n                    image-&gt;iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image-&gt;start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image-&gt;delay=0;\n                image-&gt;columns=mng_info-&gt;mng_width;\n                image-&gt;rows=mng_info-&gt;mng_height;\n                image-&gt;page.width=mng_info-&gt;mng_width;\n                image-&gt;page.height=mng_info-&gt;mng_height;\n                image-&gt;page.x=0;\n                image-&gt;page.y=0;\n                image-&gt;background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    "  Inserted transparent background layer, W=%.20g, H=%.20g",\n                    (double) mng_info-&gt;mng_width,(double) mng_info-&gt;mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven\'t already inserted one.\n        */\n        if (insert_layers &amp;&amp; (mng_info-&gt;framing_mode == 3) &amp;&amp;\n                (subframe_width) &amp;&amp; (subframe_height) &amp;&amp; (simplicity == 0 ||\n                (simplicity &amp; 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image,exception);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info-&gt;image=image;\n\n            if (term_chunk_found)\n              {\n                image-&gt;start_loop=MagickTrue;\n                image-&gt;iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image-&gt;start_loop=MagickFalse;\n\n            image-&gt;delay=0;\n            image-&gt;columns=subframe_width;\n            image-&gt;rows=subframe_height;\n            image-&gt;page.width=subframe_width;\n            image-&gt;page.height=subframe_height;\n            image-&gt;page.x=mng_info-&gt;clip.left;\n            image-&gt;page.y=mng_info-&gt;clip.top;\n            image-&gt;background_color=mng_background_color;\n            image-&gt;alpha_trait=UndefinedPixelTrait;\n            (void) SetImageBackgroundColor(image,exception);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                "  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g",\n                (double) mng_info-&gt;clip.left,(double) mng_info-&gt;clip.right,\n                (double) mng_info-&gt;clip.top,(double) mng_info-&gt;clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info-&gt;image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image-&gt;start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image-&gt;start_loop=MagickFalse;\n\n        if (mng_info-&gt;framing_mode == 1 || mng_info-&gt;framing_mode == 3)\n          {\n            image-&gt;delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image-&gt;delay=0;\n\n        image-&gt;page.width=mng_info-&gt;mng_width;\n        image-&gt;page.height=mng_info-&gt;mng_height;\n        image-&gt;page.x=mng_info-&gt;x_off[object_id];\n        image-&gt;page.y=mng_info-&gt;y_off[object_id];\n        image-&gt;iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk\'s length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            "  Seeking back to beginning of %c%c%c%c chunk",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset &lt; 0)\n          ThrowReaderException(CorruptImageError,"ImproperImageHeader");\n      }\n\n    mng_info-&gt;image=image;\n    mng_info-&gt;mng_type=mng_type;\n    mng_info-&gt;object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            "exit ReadJNGImage() with error");\n\n        return((Image *) NULL);\n      }\n\n    if (image-&gt;columns == 0 || image-&gt;rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info-&gt;image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info-&gt;magn_methx || mng_info-&gt;magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                "  Processing MNG MAGN chunk");\n\n            if (mng_info-&gt;magn_methx == 1)\n              {\n                magnified_width=mng_info-&gt;magn_ml;\n\n                if (image-&gt;columns &gt; 1)\n                   magnified_width += mng_info-&gt;magn_mr;\n\n                if (image-&gt;columns &gt; 2)\n                   magnified_width += (png_uint_32)\n                      ((image-&gt;columns-2)*(mng_info-&gt;magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image-&gt;columns;\n\n                if (image-&gt;columns &gt; 1)\n                   magnified_width += mng_info-&gt;magn_ml-1;\n\n                if (image-&gt;columns &gt; 2)\n                   magnified_width += mng_info-&gt;magn_mr-1;\n\n                if (image-&gt;columns &gt; 3)\n                   magnified_width += (png_uint_32)\n                      ((image-&gt;columns-3)*(mng_info-&gt;magn_mx-1));\n              }\n\n            if (mng_info-&gt;magn_methy == 1)\n              {\n                magnified_height=mng_info-&gt;magn_mt;\n\n                if (image-&gt;rows &gt; 1)\n                   magnified_height += mng_info-&gt;magn_mb;\n\n                if (image-&gt;rows &gt; 2)\n                   magnified_height += (png_uint_32)\n                      ((image-&gt;rows-2)*(mng_info-&gt;magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image-&gt;rows;\n\n                if (image-&gt;rows &gt; 1)\n                   magnified_height += mng_info-&gt;magn_mt-1;\n\n                if (image-&gt;rows &gt; 2)\n                   magnified_height += mng_info-&gt;magn_mb-1;\n\n                if (image-&gt;rows &gt; 3)\n                   magnified_height += (png_uint_32)\n                      ((image-&gt;rows-3)*(mng_info-&gt;magn_my-1));\n              }\n\n            if (magnified_height &gt; image-&gt;rows ||\n                magnified_width &gt; image-&gt;columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                Quantum\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register Quantum\n                  *n,\n                  *q;\n\n                register ssize_t\n                  x;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    "    Allocate magnified image");\n\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image-&gt;columns=magnified_width;\n                large_image-&gt;rows=magnified_height;\n\n                magn_methx=mng_info-&gt;magn_methx;\n                magn_methy=mng_info-&gt;magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH &gt; 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y &lt; (ssize_t) image-&gt;rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image-&gt;columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image-&gt;columns-1; x &gt;= 0; x--)\n                       {\n                          SetPixelRed(image,ScaleQuantumToShort(\n                            GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n                            GetPixelGreen(image,q)),q);\n                          SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n                          SetPixelAlpha(image,ScaleQuantumToShort(\n                            GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image-&gt;alpha_trait != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\n                else\n                  {\n                    large_image-&gt;background_color.alpha=OpaqueAlpha;\n                    (void) SetImageBackgroundColor(large_image,exception);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    "    Magnify the rows to %.20g",\n                    (double) large_image-&gt;rows);\n                m=(ssize_t) mng_info-&gt;magn_mt;\n                yy=0;\n                length=(size_t) GetPixelChannels(image)*image-&gt;columns;\n                next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (Quantum *) NULL) ||\n                    (next == (Quantum *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       "MemoryAllocationFailed");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image-&gt;columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y &lt; (ssize_t) image-&gt;rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info-&gt;magn_mt;\n\n                  else if (magn_methy &gt; 1 &amp;&amp; y == (ssize_t) image-&gt;rows-2)\n                    m=(ssize_t) mng_info-&gt;magn_mb;\n\n                  else if (magn_methy &lt;= 1 &amp;&amp; y == (ssize_t) image-&gt;rows-1)\n                    m=(ssize_t) mng_info-&gt;magn_mb;\n\n                  else if (magn_methy &gt; 1 &amp;&amp; y == (ssize_t) image-&gt;rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info-&gt;magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y &lt; (ssize_t) image-&gt;rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image-&gt;columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i &lt; m; i++, yy++)\n                  {\n                    register Quantum\n                      *pixels;\n\n                    assert(yy &lt; (ssize_t) large_image-&gt;rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image-&gt;columns,\n                      1,exception);\n                    q+=(large_image-&gt;columns-image-&gt;columns)*\n                      GetPixelChannels(large_image);\n\n                    for (x=(ssize_t) image-&gt;columns-1; x &gt;= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image-&gt;storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy &lt;= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(large_image,GetPixelGreen(image,\n                             pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n                             pixels),q);\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRed(large_image,GetPixelRed(image,\n                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                 pixels),q);\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n                              SetPixelGreen(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n                              SetPixelBlue(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\n                              if (image-&gt;alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n                                    (2*i*(GetPixelAlpha(image,n)\n                                    -GetPixelAlpha(image,pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i &lt;= ((m+1) &lt;&lt; 1))\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                              else\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    n),q);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i &lt;= ((m+1) &lt;&lt; 1))\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n                                    pixels),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,\n                                    pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n                                    pixels),q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n                                    q);\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n                                 (GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n                      pixels+=GetPixelChannels(image);\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n                next=(Quantum *) RelinquishMagickMemory(next);\n\n                length=image-&gt;columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    "    Delete original image");\n\n                DeleteImageFromList(&amp;image);\n\n                image=large_image;\n\n                mng_info-&gt;image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    "    Magnify the columns to %.20g",\n                    (double) image-&gt;columns);\n\n                for (y=0; y &lt; (ssize_t) image-&gt;rows; y++)\n                {\n                  register Quantum\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image-&gt;columns,1,exception);\n                  pixels=q+(image-&gt;columns-length)*GetPixelChannels(image);\n                  n=pixels+GetPixelChannels(image);\n\n                  for (x=(ssize_t) (image-&gt;columns-length);\n                    x &lt; (ssize_t) image-&gt;columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel() */\n\n                    if (x == (ssize_t) (image-&gt;columns-length))\n                      m=(ssize_t) mng_info-&gt;magn_ml;\n\n                    else if (magn_methx &gt; 1 &amp;&amp; x == (ssize_t) image-&gt;columns-2)\n                      m=(ssize_t) mng_info-&gt;magn_mr;\n\n                    else if (magn_methx &lt;= 1 &amp;&amp;\n                        x == (ssize_t) image-&gt;columns-1)\n                      m=(ssize_t) mng_info-&gt;magn_mr;\n\n                    else if (magn_methx &gt; 1 &amp;&amp; x == (ssize_t) image-&gt;columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info-&gt;magn_mx;\n\n                    for (i=0; i &lt; m; i++)\n                    {\n                      if (magn_methx &lt;= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelChannel() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(image,(QM) ((2*i*(\n                                 GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM) ((2*i*(\n                                 GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\n                              SetPixelBlue(image,(QM) ((2*i*(\n                                 GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n                              if (image-&gt;alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(image,(QM) ((2*i*(\n                                   GetPixelAlpha(image,n)\n                                   -GetPixelAlpha(image,pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i &lt;= ((m+1) &lt;&lt; 1))\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,pixels)+0,q);\n                              }\n                              else\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,n)+0,q);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i &lt;= ((m+1) &lt;&lt; 1))\n                          {\n                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n                             SetPixelGreen(image,GetPixelGreen(image,\n                                 pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,\n                                 pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(image,GetPixelRed(image,n),q);\n                             SetPixelGreen(image,GetPixelGreen(image,n),q);\n                             SetPixelBlue(image,GetPixelBlue(image,n),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelAlpha(image,\n                                 (QM) ((2*i*( GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                    n+=GetPixelChannels(image);\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH &gt; 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y &lt; (ssize_t) image-&gt;rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image-&gt;columns,1,\n                       exception);\n\n                     for (x=(ssize_t) image-&gt;columns-1; x &gt;= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n                          GetPixelRed(image,q)),q);\n                        SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n                        SetPixelBlue(image,ScaleShortToQuantum(\n                          GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n                          GetPixelAlpha(image,q)),q);\n                        q+=GetPixelChannels(image);\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    "  Finished MAGN processing");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info-&gt;image_box.left+mng_info-&gt;x_off[object_id];\n        crop_box.right=mng_info-&gt;image_box.right+mng_info-&gt;x_off[object_id];\n        crop_box.top=mng_info-&gt;image_box.top+mng_info-&gt;y_off[object_id];\n        crop_box.bottom=mng_info-&gt;image_box.bottom+mng_info-&gt;y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info-&gt;clip);\n        crop_box=mng_minimum_box(crop_box,mng_info-&gt;frame);\n        crop_box=mng_minimum_box(crop_box,mng_info-&gt;object_clip[object_id]);\n        if ((crop_box.left != (mng_info-&gt;image_box.left\n            +mng_info-&gt;x_off[object_id])) ||\n            (crop_box.right != (mng_info-&gt;image_box.right\n            +mng_info-&gt;x_off[object_id])) ||\n            (crop_box.top != (mng_info-&gt;image_box.top\n            +mng_info-&gt;y_off[object_id])) ||\n            (crop_box.bottom != (mng_info-&gt;image_box.bottom\n            +mng_info-&gt;y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                "  Crop the PNG image");\n\n            if ((crop_box.left &lt; crop_box.right) &amp;&amp;\n                (crop_box.top &lt; crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info-&gt;x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info-&gt;y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image-&gt;page.width=image-&gt;columns;\n                image-&gt;page.height=image-&gt;rows;\n                image-&gt;page.x=0;\n                image-&gt;page.y=0;\n                im=CropImage(image,&amp;crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image-&gt;columns=im-&gt;columns;\n                    image-&gt;rows=im-&gt;rows;\n                    im=DestroyImage(im);\n                    image-&gt;page.width=image-&gt;columns;\n                    image-&gt;page.height=image-&gt;rows;\n                    image-&gt;page.x=crop_box.left;\n                    image-&gt;page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image-&gt;columns=1;\n                image-&gt;rows=1;\n                image-&gt;colors=2;\n                (void) SetImageBackgroundColor(image,exception);\n                image-&gt;page.width=1;\n                image-&gt;page.height=1;\n                image-&gt;page.x=0;\n                image-&gt;page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info-&gt;image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH &gt; 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy.\n       */\n      if (image-&gt;depth &gt; 16)\n         image-&gt;depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH &gt; 8)\n      if (image-&gt;depth &gt; 8)\n        {\n          /* To do: fill low byte properly */\n          image-&gt;depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception) != MagickFalse)\n         image-&gt;depth = 8;\n#endif\n\n      if (image_info-&gt;number_scenes != 0)\n        {\n          if (mng_info-&gt;scenes_found &gt;\n             (ssize_t) (image_info-&gt;first_scene+image_info-&gt;number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          "  Finished reading image datastream.");\n\n  } while (LocaleCompare(image_info-&gt;magick,"MNG") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      "  Finished reading all image datastreams.");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers &amp;&amp; !mng_info-&gt;image_found &amp;&amp; (mng_info-&gt;mng_width) &amp;&amp;\n       (mng_info-&gt;mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          "  No images found.  Inserting a background layer.");\n\n      if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  "  Allocation failed, returning NULL.");\n\n              return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n        }\n      image-&gt;columns=mng_info-&gt;mng_width;\n      image-&gt;rows=mng_info-&gt;mng_height;\n      image-&gt;page.width=mng_info-&gt;mng_width;\n      image-&gt;page.height=mng_info-&gt;mng_height;\n      image-&gt;page.x=0;\n      image-&gt;page.y=0;\n      image-&gt;background_color=mng_background_color;\n      image-&gt;alpha_trait=UndefinedPixelTrait;\n\n      if (image_info-&gt;ping == MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n      mng_info-&gt;image_found++;\n    }\n#endif\n  image-&gt;iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image-&gt;start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count &gt; 10*mng_info-&gt;image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),"  No beginning");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,"Linked list is corrupted, beginning of list not found",\n          "`%s\'",image_info-&gt;filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),"  Corrupt list");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,"Linked list is corrupted; next_image is NULL","`%s\'",\n          image_info-&gt;filename);\n      }\n  }\n\n  if (mng_info-&gt;ticks_per_second &amp;&amp; mng_info-&gt;image_found &gt; 1 &amp;&amp;\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            "  First image null");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,"image-&gt;next for first image is NULL but shouldn\'t be.",\n        "`%s\'",image_info-&gt;filename);\n    }\n\n  if (mng_info-&gt;image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          "  No visible images found.");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,"No visible images in file","`%s\'",image_info-&gt;filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info-&gt;ticks_per_second)\n    final_delay=1UL*MagickMax(image-&gt;ticks_per_second,1L)*\n            final_delay/mng_info-&gt;ticks_per_second;\n\n  else\n    image-&gt;start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image-&gt;delay)\n        final_image_delay=image-&gt;delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay &lt; final_image_delay)\n    final_delay=final_image_delay;\n\n  image-&gt;delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        "  image-&gt;delay=%.20g, final_delay=%.20g",(double) image-&gt;delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        "  Before coalesce:");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        "    scene 0 delay=%.20g",(double) image-&gt;delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          "    scene %.20g delay=%.20g",(double) scene++,\n          (double) image-&gt;delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          "  Coalesce Images");\n\n      scene=image-&gt;scene;\n      next_image=CoalesceImages(image,exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next-&gt;page.width=mng_info-&gt;mng_width;\n         next-&gt;page.height=mng_info-&gt;mng_height;\n         next-&gt;page.x=0;\n         next-&gt;page.y=0;\n         next-&gt;scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next-&gt;delay == 0)\n           {\n             scene--;\n             next_image-&gt;previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next-&gt;previous-&gt;next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image-&gt;dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        "  After coalesce:");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        "    scene 0 delay=%.20g dispose=%.20g",(double) image-&gt;delay,\n        (double) image-&gt;dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          "    scene %.20g delay=%.20g dispose=%.20g",(double) scene++,\n          (double) image-&gt;delay,(double) image-&gt;dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      "  exit ReadOneMNGImage();");\n\n  return(image);\n}',
 'int snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol,\n\t\t    bool add_on_replace)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int count;\n\tunsigned int idx;\n\tstruct snd_kcontrol *old;\n\tint ret;\n\n\tif (!kcontrol)\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!card || !kcontrol-&gt;info)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tid = kcontrol-&gt;id;\n\tdown_write(&amp;card-&gt;controls_rwsem);\n\told = snd_ctl_find_id(card, &amp;id);\n\tif (!old) {\n\t\tif (add_on_replace)\n\t\t\tgoto add;\n\t\tup_write(&amp;card-&gt;controls_rwsem);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tret = snd_ctl_remove(card, old);\n\tif (ret &lt; 0) {\n\t\tup_write(&amp;card-&gt;controls_rwsem);\n\t\tgoto error;\n\t}\nadd:\n\tif (snd_ctl_find_hole(card, kcontrol-&gt;count) &lt; 0) {\n\t\tup_write(&amp;card-&gt;controls_rwsem);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&amp;kcontrol-&gt;list, &amp;card-&gt;controls);\n\tcard-&gt;controls_count += kcontrol-&gt;count;\n\tkcontrol-&gt;id.numid = card-&gt;last_numid + 1;\n\tcard-&gt;last_numid += kcontrol-&gt;count;\n\tcount = kcontrol-&gt;count;\n\tup_write(&amp;card-&gt;controls_rwsem);\n\tfor (idx = 0; idx &lt; count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &amp;id);\n\treturn 0;\n\nerror:\n\tsnd_ctl_free_one(kcontrol);\n\treturn ret;\n}',
 'R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {\n\t// XXX this pending is wrong and too expensive\n\tint pending = len - offset;\n\tconst ut8 *a_buf = offset + buf;\n\tut8 *attr_buf = (ut8 *) calloc (pending + 1, 1);\n\tif (!attr_buf) {\n\t\teprintf ("Unable to allocate enough bytes (0x%04"PFMT64x\n\t\t\t") to read in the attribute.\\n", sz);\n\t\treturn attr_buf;\n\t}\n\tmemcpy (attr_buf, a_buf, pending); // sz+1);\n\treturn attr_buf;\n}',
 'Network::TransportSocketFactoryPtr XfccIntegrationTest::createClientSslContext(bool mtls) {\n  const std::string yaml_tls = R"EOF(\ncommon_tls_context:\n  validation_context:\n    trusted_ca:\n      filename: {{ test_rundir }}/test/config/integration/certs/cacert.pem\n    match_typed_subject_alt_names:\n    - san_type: URI\n      matcher:\n        exact: "spiffe://lyft.com/backend-team"\n    - san_type: DNS\n      matcher:\n        exact: "lyft.com"\n    - san_type: DNS\n      matcher:\n        exact: "www.lyft.com"\n)EOF";\n\n  const std::string yaml_mtls = R"EOF(\ncommon_tls_context:\n  validation_context:\n    trusted_ca:\n      filename: {{ test_rundir }}/test/config/integration/certs/cacert.pem\n    match_typed_subject_alt_names:\n    - san_type: URI\n      matcher:\n        exact: "spiffe://lyft.com/backend-team"\n    - san_type: DNS\n      matcher:\n        exact: "lyft.com"\n    - san_type: DNS\n      matcher:\n       exact: "www.lyft.com"\n  tls_certificates:\n    certificate_chain:\n      filename: {{ test_rundir }}/test/config/integration/certs/clientcert.pem\n    private_key:\n      filename: {{ test_rundir }}/test/config/integration/certs/clientkey.pem\n)EOF";\n\n  std::string target;\n  if (mtls) {\n    target = yaml_mtls;\n  } else {\n    target = yaml_tls;\n  }\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext config;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(target), config);\n  auto cfg = std::make_unique&lt;Extensions::TransportSockets::Tls::ClientContextConfigImpl&gt;(\n      config, factory_context_);\n  static auto* client_stats_store = new Stats::TestIsolatedStoreImpl();\n  return Network::TransportSocketFactoryPtr{\n      new Extensions::TransportSockets::Tls::ClientSslSocketFactory(\n          std::move(cfg), *context_manager_, *client_stats_store)};\n}\n\nNetwork::TransportSocketFactoryPtr XfccIntegrationTest::createUpstreamSslContext() {\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  auto* common_tls_context = tls_context.mutable_common_tls_context();\n  auto* tls_cert = common_tls_context-&gt;add_tls_certificates();\n  tls_cert-&gt;mutable_certificate_chain()-&gt;set_filename(\n      TestEnvironment::runfilesPath("test/config/integration/certs/upstreamcert.pem"));\n  tls_cert-&gt;mutable_private_key()-&gt;set_filename(\n      TestEnvironment::runfilesPath("test/config/integration/certs/upstreamkey.pem"));\n\n  auto cfg = std::make_unique&lt;Extensions::TransportSockets::Tls::ServerContextConfigImpl&gt;(\n      tls_context, factory_context_);\n  static Stats::Scope* upstream_stats_store = new Stats::TestIsolatedStoreImpl();\n  return std::make_unique&lt;Extensions::TransportSockets::Tls::ServerSslSocketFactory&gt;(\n      std::move(cfg), *context_manager_, *upstream_stats_store, std::vector&lt;std::string&gt;{});\n}\n\nNetwork::ClientConnectionPtr XfccIntegrationTest::makeTcpClientConnection() {\n  Network::Address::InstanceConstSharedPtr address =\n      Network::Utility::resolveUrl("tcp://" + Network::Test::getLoopbackAddressUrlString(version_) +\n                                   ":" + std::to_string(lookupPort("http")));\n  return dispatcher_-&gt;createClientConnection(address, Network::Address::InstanceConstSharedPtr(),\n                                             Network::Test::createRawBufferSocket(), nullptr);\n}',
 'void ksz9131Tick(NetInterface *interface)\n{\n   uint16_t value;\n   bool_t linkState;\n\n   //No external interrupt line driver?\n   if(interface-&gt;extIntDriver == NULL)\n   {\n      //Read basic status register\n      value = ksz9131ReadPhyReg(interface, KSZ9131_BMSR);\n      //Retrieve current link state\n      linkState = (value &amp; KSZ9131_BMSR_LINK_STATUS) ? TRUE : FALSE;\n\n      //Link up event?\n      if(linkState &amp;&amp; !interface-&gt;linkState)\n      {\n         //Set event flag\n         interface-&gt;phyEvent = TRUE;\n         //Notify the TCP/IP stack of the event\n         osSetEvent(&amp;netEvent);\n      }\n      //Link down event?\n      else if(!linkState &amp;&amp; interface-&gt;linkState)\n      {\n         //Set event flag\n         interface-&gt;phyEvent = TRUE;\n         //Notify the TCP/IP stack of the event\n         osSetEvent(&amp;netEvent);\n      }\n   }\n}',
 "_gnutls_x509_verify_certificate (const gnutls_x509_crt_t * certificate_list,\n\t\t\t\t int clist_size,\n\t\t\t\t const gnutls_x509_crt_t * trusted_cas,\n\t\t\t\t int tcas_size,\n\t\t\t\t const gnutls_x509_crl_t * CRLs,\n\t\t\t\t int crls_size, unsigned int flags)\n{\n  int i = 0, ret;\n  unsigned int status = 0, output;\n\n  if (clist_size &gt; 1)\n    {\n      /* Check if the last certificate in the path is self signed.\n       * In that case ignore it (a certificate is trusted only if it\n       * leads to a trusted party by us, not the server's).\n       *\n       * This prevents from verifying self signed certificates against\n       * themselves. This (although not bad) caused verification\n       * failures on some root self signed certificates that use the\n       * MD2 algorithm.\n       */\n      if (gnutls_x509_crt_check_issuer (certificate_list[clist_size - 1],\n\t\t\t\t\tcertificate_list[clist_size - 1]) &gt; 0)\n\t{\n\t  clist_size--;\n\t}\n    }\n\n  /* We want to shorten the chain by removing the cert that matches\n   * one of the certs we trust and all the certs after that i.e. if\n   * cert chain is A signed-by B signed-by C signed-by D (signed-by\n   * self-signed E but already removed above), and we trust B, remove\n   * B, C and D. */\n  if (!(flags &amp; GNUTLS_VERIFY_DO_NOT_ALLOW_SAME))\n    {\n      for (i = 0; i &lt; clist_size; i++)\n\t{\n\t  int j;\n\n\t  for (j = 0; j &lt; tcas_size; j++)\n\t    {\n\t      if (check_if_same_cert (certificate_list[i],\n\t\t\t\t      trusted_cas[j]) == 0)\n\t\t{\n\t\t  clist_size = i;\n\t\t  break;\n\t\t}\n\t    }\n\t  /* clist_size may have been changed which gets out of loop */\n\t}\n    }\n\n  if (clist_size == 0)\n    /* The certificate is already present in the trusted certificate list.\n     * Nothing to verify. */\n    return status;\n\n  /* Verify the last certificate in the certificate path\n   * against the trusted CA certificate list.\n   *\n   * If no CAs are present returns CERT_INVALID. Thus works\n   * in self signed etc certificates.\n   */\n  ret = _gnutls_verify_certificate2 (certificate_list[clist_size - 1],\n\t\t\t\t     trusted_cas, tcas_size, flags, &amp;output);\n  if (ret == 0)\n    {\n      /* if the last certificate in the certificate\n       * list is invalid, then the certificate is not\n       * trusted.\n       */\n      gnutls_assert ();\n      status |= output;\n      status |= GNUTLS_CERT_INVALID;\n      return status;\n    }\n\n  /* Check for revoked certificates in the chain\n   */\n#ifdef ENABLE_PKI\n  for (i = 0; i &lt; clist_size; i++)\n    {\n      ret = gnutls_x509_crt_check_revocation (certificate_list[i],\n\t\t\t\t\t      CRLs, crls_size);\n      if (ret == 1)\n\t{\t\t\t/* revoked */\n\t  status |= GNUTLS_CERT_REVOKED;\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }\n#endif\n\n  /* Check activation/expiration times\n   */\n  if (!(flags &amp; GNUTLS_VERIFY_DISABLE_TIME_CHECKS))\n    {\n      time_t t, now = time (0);\n\n      for (i = 0; i &lt; clist_size; i++)\n\t{\n\t  t = gnutls_x509_crt_get_activation_time (certificate_list[i]);\n\t  if (t == (time_t) - 1 || now &lt; t)\n\t    {\n\t      status |= GNUTLS_CERT_NOT_ACTIVATED;\n\t      status |= GNUTLS_CERT_INVALID;\n\t      return status;\n\t    }\n\n\t  t = gnutls_x509_crt_get_expiration_time (certificate_list[i]);\n\t  if (t == (time_t) - 1 || now &gt; t)\n\t    {\n\t      status |= GNUTLS_CERT_EXPIRED;\n\t      status |= GNUTLS_CERT_INVALID;\n\t      return status;\n\t    }\n\t}\n    }\n\n  /* Verify the certificate path (chain)\n   */\n  for (i = clist_size - 1; i &gt; 0; i--)\n    {\n      if (i - 1 &lt; 0)\n\tbreak;\n\n      /* note that here we disable this V1 CA flag. So that no version 1\n       * certificates can exist in a supplied chain.\n       */\n      if (!(flags &amp; GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT))\n\tflags &amp;= ~(GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);\n      if ((ret =\n\t   _gnutls_verify_certificate2 (certificate_list[i - 1],\n\t\t\t\t\t&amp;certificate_list[i], 1, flags,\n\t\t\t\t\tNULL)) == 0)\n\t{\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }\n\n  return 0;\n}",
 'void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row = 0; row &lt; raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col &lt; raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 &gt;&gt; (3 - pana_bits(2));\n      if (nonz[i &amp; 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i &amp; 1] -= 0x80 &lt;&lt; sh) &lt; 0 || sh == 4)\n            pred[i &amp; 1] &amp;= ~((~0u) &lt;&lt; sh);\n          pred[i &amp; 1] += j &lt;&lt; sh;\n        }\n      }\n      else if ((nonz[i &amp; 1] = pana_bits(8)) || i &gt; 11)\n        pred[i &amp; 1] = nonz[i &amp; 1] &lt;&lt; 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col &amp; 1]) &gt; 4098 &amp;&amp; col &lt; width &amp;&amp; row &lt; height)\n        derror();\n    }\n  }\n}',
 'static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) &gt; VALUE_MAXLEN) {\n\t\tpr_err("Value for notunderstood key \\"%s\\" exceeds %d,"\n\t\t\t" protocol error.\\n", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err("Unable to allocate memory for"\n\t\t\t" struct iscsi_extra_response.\\n");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&amp;extra_response-&gt;er_list);\n\n\tstrncpy(extra_response-&gt;key, key, strlen(key) + 1);\n\tstrncpy(extra_response-&gt;value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&amp;extra_response-&gt;er_list,\n\t\t\t&amp;param_list-&gt;extra_response_list);\n\treturn 0;\n}',
 'rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_ioctl_data *miidata = if_mii(rq);\n\n\tphy_addr = np-&gt;phy_addr;\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmiidata-&gt;phy_id = phy_addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tmiidata-&gt;val_out = mii_read (dev, phy_addr, miidata-&gt;reg_num);\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmii_write (dev, phy_addr, miidata-&gt;reg_num, miidata-&gt;val_in);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}',
 'sds genRedisInfoString(void) {\n    sds info;\n    time_t uptime = time(NULL)-server.stat_starttime;\n    int j;\n    char hmem[64];\n    struct rusage self_ru, c_ru;\n\n    getrusage(RUSAGE_SELF, &amp;self_ru);\n    getrusage(RUSAGE_CHILDREN, &amp;c_ru);\n\n    bytesToHuman(hmem,zmalloc_used_memory());\n    info = sdscatprintf(sdsempty(),\n        "redis_version:%s\\r\\n"\n        "redis_git_sha1:%s\\r\\n"\n        "redis_git_dirty:%d\\r\\n"\n        "arch_bits:%s\\r\\n"\n        "multiplexing_api:%s\\r\\n"\n        "process_id:%ld\\r\\n"\n        "uptime_in_seconds:%ld\\r\\n"\n        "uptime_in_days:%ld\\r\\n"\n        "lru_clock:%ld\\r\\n"\n        "used_cpu_sys:%.2f\\r\\n"\n        "used_cpu_user:%.2f\\r\\n"\n        "used_cpu_sys_childrens:%.2f\\r\\n"\n        "used_cpu_user_childrens:%.2f\\r\\n"\n        "connected_clients:%d\\r\\n"\n        "connected_slaves:%d\\r\\n"\n        "blocked_clients:%d\\r\\n"\n        "used_memory:%zu\\r\\n"\n        "used_memory_human:%s\\r\\n"\n        "used_memory_rss:%zu\\r\\n"\n        "mem_fragmentation_ratio:%.2f\\r\\n"\n        "use_tcmalloc:%d\\r\\n"\n        "loading:%d\\r\\n"\n        "aof_enabled:%d\\r\\n"\n        "changes_since_last_save:%lld\\r\\n"\n        "bgsave_in_progress:%d\\r\\n"\n        "last_save_time:%ld\\r\\n"\n        "bgrewriteaof_in_progress:%d\\r\\n"\n        "total_connections_received:%lld\\r\\n"\n        "total_commands_processed:%lld\\r\\n"\n        "expired_keys:%lld\\r\\n"\n        "evicted_keys:%lld\\r\\n"\n        "keyspace_hits:%lld\\r\\n"\n        "keyspace_misses:%lld\\r\\n"\n        "hash_max_zipmap_entries:%zu\\r\\n"\n        "hash_max_zipmap_value:%zu\\r\\n"\n        "pubsub_channels:%ld\\r\\n"\n        "pubsub_patterns:%u\\r\\n"\n        "ds_enabled:%d\\r\\n"\n        "role:%s\\r\\n"\n        ,REDIS_VERSION,\n        redisGitSHA1(),\n        strtol(redisGitDirty(),NULL,10) &gt; 0,\n        (sizeof(long) == 8) ? "64" : "32",\n        aeGetApiName(),\n        (long) getpid(),\n        uptime,\n        uptime/(3600*24),\n        (unsigned long) server.lruclock,\n        (float)self_ru.ru_utime.tv_sec+(float)self_ru.ru_utime.tv_usec/1000000,\n        (float)self_ru.ru_stime.tv_sec+(float)self_ru.ru_stime.tv_usec/1000000,\n        (float)c_ru.ru_utime.tv_sec+(float)c_ru.ru_utime.tv_usec/1000000,\n        (float)c_ru.ru_stime.tv_sec+(float)c_ru.ru_stime.tv_usec/1000000,\n        listLength(server.clients)-listLength(server.slaves),\n        listLength(server.slaves),\n        server.bpop_blocked_clients,\n        zmalloc_used_memory(),\n        hmem,\n        zmalloc_get_rss(),\n        zmalloc_get_fragmentation_ratio(),\n#ifdef USE_TCMALLOC\n        1,\n#else\n        0,\n#endif\n        server.loading,\n        server.appendonly,\n        server.dirty,\n        server.bgsavechildpid != -1,\n        server.lastsave,\n        server.bgrewritechildpid != -1,\n        server.stat_numconnections,\n        server.stat_numcommands,\n        server.stat_expiredkeys,\n        server.stat_evictedkeys,\n        server.stat_keyspace_hits,\n        server.stat_keyspace_misses,\n        server.hash_max_zipmap_entries,\n        server.hash_max_zipmap_value,\n        dictSize(server.pubsub_channels),\n        listLength(server.pubsub_patterns),\n        server.ds_enabled != 0,\n        server.masterhost == NULL ? "master" : "slave"\n    );\n    if (server.masterhost) {\n        info = sdscatprintf(info,\n            "master_host:%s\\r\\n"\n            "master_port:%d\\r\\n"\n            "master_link_status:%s\\r\\n"\n            "master_last_io_seconds_ago:%d\\r\\n"\n            "master_sync_in_progress:%d\\r\\n"\n            ,server.masterhost,\n            server.masterport,\n            (server.replstate == REDIS_REPL_CONNECTED) ?\n                "up" : "down",\n            server.master ? ((int)(time(NULL)-server.master-&gt;lastinteraction)) : -1,\n            server.replstate == REDIS_REPL_TRANSFER\n        );\n\n        if (server.replstate == REDIS_REPL_TRANSFER) {\n            info = sdscatprintf(info,\n                "master_sync_left_bytes:%ld\\r\\n"\n                "master_sync_last_io_seconds_ago:%d\\r\\n"\n                ,(long)server.repl_transfer_left,\n                (int)(time(NULL)-server.repl_transfer_lastio)\n            );\n        }\n    }\n    if (server.ds_enabled) {\n        lockThreadedIO();\n        info = sdscatprintf(info,\n            "cache_max_memory:%llu\\r\\n"\n            "cache_blocked_clients:%lu\\r\\n"\n            ,(unsigned long long) server.cache_max_memory,\n            (unsigned long) server.cache_blocked_clients\n        );\n        unlockThreadedIO();\n    }\n    if (server.loading) {\n        double perc;\n        time_t eta, elapsed;\n        off_t remaining_bytes = server.loading_total_bytes-\n                                server.loading_loaded_bytes;\n\n        perc = ((double)server.loading_loaded_bytes /\n               server.loading_total_bytes) * 100;\n\n        elapsed = time(NULL)-server.loading_start_time;\n        if (elapsed == 0) {\n            eta = 1; /* A fake 1 second figure if we don\'t have enough info */\n        } else {\n            eta = (elapsed*remaining_bytes)/server.loading_loaded_bytes;\n        }\n\n        info = sdscatprintf(info,\n            "loading_start_time:%ld\\r\\n"\n            "loading_total_bytes:%llu\\r\\n"\n            "loading_loaded_bytes:%llu\\r\\n"\n            "loading_loaded_perc:%.2f\\r\\n"\n            "loading_eta_seconds:%ld\\r\\n"\n            ,(unsigned long) server.loading_start_time,\n            (unsigned long long) server.loading_total_bytes,\n            (unsigned long long) server.loading_loaded_bytes,\n            perc,\n            eta\n        );\n    }\n    for (j = 0; j &lt; server.dbnum; j++) {\n        long long keys, vkeys;\n\n        keys = dictSize(server.db[j].dict);\n        vkeys = dictSize(server.db[j].expires);\n        if (keys || vkeys) {\n            info = sdscatprintf(info, "db%d:keys=%lld,expires=%lld\\r\\n",\n                j, keys, vkeys);\n        }\n    }\n    return info;\n}',
 "str2special(\n    char_u\t**sp,\n    int\t\tfrom)\t// TRUE for lhs of mapping\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\n\t// Try to un-escape a multi-byte character.  Return the un-escaped\n\t// string if it is a multi-byte character.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n\n    c = *str;\n    if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t// special key\n\t    special = TRUE;\n    }\n\n    if (has_mbyte &amp;&amp; !IS_SPECIAL(c) &amp;&amp; MB_BYTE2LEN(c) &gt; 1)\n    {\n\tchar_u\t*p;\n\n\t*sp = str;\n\t// Try to un-escape a multi-byte character after modifiers.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    // Since 'special' is TRUE the multi-byte character 'c' will be\n\t    // processed by get_special_key_name()\n\t    c = (*mb_ptr2char)(p);\n\telse\n\t    // illegal byte\n\t    *sp = str + 1;\n    }\n    else\n\t// single-byte character or illegal byte\n\t*sp = str + 1;\n\n    // Make special keys and C0 control characters in &lt;&gt; form, also &lt;M-Space&gt;.\n    // Use &lt;Space&gt; only for lhs of a mapping.\n    if (special || c &lt; ' ' || (from &amp;&amp; c == ' '))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}",
 'u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu64 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport &lt;&lt; 16) + (__force u16)dport;\n\thash[3] = keyptr-&gt;secret[11];\n\n\tseq = half_md4_transform(hash, keyptr-&gt;secret);\n\tseq |= ((u64)keyptr-&gt;count) &lt;&lt; (32 - HASH_BITS);\n\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &amp;= (1ull &lt;&lt; 48) - 1;\n\n\treturn seq;\n}',
 'initialise_banding(fz_context *ctx, render_details *render, int color)\n{\n\tsize_t min_band_mem;\n\tint bpp, h, w, reps;\n\n\trender-&gt;colorspace = output_cs;\n\trender-&gt;format = output_format;\n#if GREY_FALLBACK != 0\n\tif (color == 0)\n\t{\n\t\tif (render-&gt;colorspace == CS_RGB)\n\t\t{\n\t\t\t/* Fallback from PPM to PGM */\n\t\t\trender-&gt;colorspace = CS_GRAY;\n\t\t\trender-&gt;format = OUT_PGM;\n\t\t}\n\t\telse if (render-&gt;colorspace == CS_CMYK)\n\t\t{\n\t\t\trender-&gt;colorspace = CS_GRAY;\n\t\t\tif (render-&gt;format == OUT_PKM)\n\t\t\t\trender-&gt;format = OUT_PBM;\n\t\t\telse\n\t\t\t\trender-&gt;format = OUT_PGM;\n\t\t}\n\t}\n#endif\n\n\tswitch (render-&gt;colorspace)\n\t{\n\tcase CS_GRAY:\n\t\tbpp = 1;\n\t\tbreak;\n\tcase CS_RGB:\n\t\tbpp = 2;\n\t\tbreak;\n\tdefault:\n\tcase CS_CMYK:\n\t\tbpp = 3;\n\t\tbreak;\n\t}\n\n\tw = render-&gt;ibounds.x1 - render-&gt;ibounds.x0;\n\tmin_band_mem = (size_t)bpp * w * min_band_height;\n\tif (min_band_mem &gt; 0)\n\t\treps = (int)(max_band_memory / min_band_mem);\n\tif (min_band_mem == 0 || reps &lt; 1)\n\t\treps = 1;\n\n\t/* Adjust reps to even out the work between threads */\n\tif (render-&gt;num_workers &gt; 0)\n\t{\n\t\tint runs, num_bands;\n\t\th = render-&gt;ibounds.y1 - render-&gt;ibounds.y0;\n\t\tnum_bands = (h + min_band_height - 1) / min_band_height;\n\t\t/* num_bands = number of min_band_height bands */\n\t\truns = (num_bands + reps-1) / reps;\n\t\t/* runs = number of worker runs of reps min_band_height bands */\n\t\truns = ((runs + render-&gt;num_workers - 1) / render-&gt;num_workers) * render-&gt;num_workers;\n\t\t/* runs = number of worker runs rounded up to make use of all our threads */\n\t\treps = (num_bands + runs - 1) / runs;\n\t}\n\n\trender-&gt;band_height_multiple = reps;\n\trender-&gt;bands_rendered = 0;\n\n\tif (output_format == OUT_PGM || output_format == OUT_PPM)\n\t{\n\t\trender-&gt;bander = fz_new_pnm_band_writer(ctx, out);\n\t\trender-&gt;n = output_format == OUT_PGM ? 1 : 3;\n\t}\n\telse if (output_format == OUT_PAM)\n\t{\n\t\trender-&gt;bander = fz_new_pam_band_writer(ctx, out);\n\t\trender-&gt;n = 4;\n\t}\n\telse if (output_format == OUT_PBM)\n\t{\n\t\trender-&gt;bander = fz_new_pbm_band_writer(ctx, out);\n\t\trender-&gt;n = 1;\n\t}\n\telse if (output_format == OUT_PKM)\n\t{\n\t\trender-&gt;bander = fz_new_pkm_band_writer(ctx, out);\n\t\trender-&gt;n = 4;\n\t}\n}',
 'initialise_banding(fz_context *ctx, render_details *render, int color)\n{\n\tsize_t min_band_mem;\n\tint bpp, h, w, reps;\n\n\trender-&gt;colorspace = output_cs;\n\trender-&gt;format = output_format;\n#if GREY_FALLBACK != 0\n\tif (color == 0)\n\t{\n\t\tif (render-&gt;colorspace == CS_RGB)\n\t\t{\n\t\t\t/* Fallback from PPM to PGM */\n\t\t\trender-&gt;colorspace = CS_GRAY;\n\t\t\trender-&gt;format = OUT_PGM;\n\t\t}\n\t\telse if (render-&gt;colorspace == CS_CMYK)\n\t\t{\n\t\t\trender-&gt;colorspace = CS_GRAY;\n\t\t\tif (render-&gt;format == OUT_PKM)\n\t\t\t\trender-&gt;format = OUT_PBM;\n\t\t\telse\n\t\t\t\trender-&gt;format = OUT_PGM;\n\t\t}\n\t}\n#endif\n\n\tswitch (render-&gt;colorspace)\n\t{\n\tcase CS_GRAY:\n\t\tbpp = 1;\n\t\tbreak;\n\tcase CS_RGB:\n\t\tbpp = 2;\n\t\tbreak;\n\tdefault:\n\tcase CS_CMYK:\n\t\tbpp = 3;\n\t\tbreak;\n\t}\n\n\tw = render-&gt;ibounds.x1 - render-&gt;ibounds.x0;\n\tmin_band_mem = (size_t)bpp * w * min_band_height;\n\treps = (int)(max_band_memory / min_band_mem);\n\tif (reps &lt; 1)\n\t\treps = 1;\n\n\t/* Adjust reps to even out the work between threads */\n\tif (render-&gt;num_workers &gt; 0)\n\t{\n\t\tint runs, num_bands;\n\t\th = render-&gt;ibounds.y1 - render-&gt;ibounds.y0;\n\t\tnum_bands = (h + min_band_height - 1) / min_band_height;\n\t\t/* num_bands = number of min_band_height bands */\n\t\truns = (num_bands + reps-1) / reps;\n\t\t/* runs = number of worker runs of reps min_band_height bands */\n\t\truns = ((runs + render-&gt;num_workers - 1) / render-&gt;num_workers) * render-&gt;num_workers;\n\t\t/* runs = number of worker runs rounded up to make use of all our threads */\n\t\treps = (num_bands + runs - 1) / runs;\n\t}\n\n\trender-&gt;band_height_multiple = reps;\n\trender-&gt;bands_rendered = 0;\n\n\tif (output_format == OUT_PGM || output_format == OUT_PPM)\n\t{\n\t\trender-&gt;bander = fz_new_pnm_band_writer(ctx, out);\n\t\trender-&gt;n = output_format == OUT_PGM ? 1 : 3;\n\t}\n\telse if (output_format == OUT_PAM)\n\t{\n\t\trender-&gt;bander = fz_new_pam_band_writer(ctx, out);\n\t\trender-&gt;n = 4;\n\t}\n\telse if (output_format == OUT_PBM)\n\t{\n\t\trender-&gt;bander = fz_new_pbm_band_writer(ctx, out);\n\t\trender-&gt;n = 1;\n\t}\n\telse if (output_format == OUT_PKM)\n\t{\n\t\trender-&gt;bander = fz_new_pkm_band_writer(ctx, out);\n\t\trender-&gt;n = 4;\n\t}\n}',
 'bool recovery_cipher_abort(void)\n{\n    recovery_started = false;\n\n    if (awaiting_character) {\n        awaiting_character = false;\n        return true;\n    }\n    return false;\n}',
 'jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf("error: cannot get box\\n");\n\t\tgoto error;\n\t}\n\tif (box-&gt;type != JP2_BOX_JP) {\n\t\tjas_eprintf("error: expecting signature box\\n");\n\t\tgoto error;\n\t}\n\tif (box-&gt;data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf("incorrect magic number\\n");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box-&gt;type != JP2_BOX_FTYP) {\n\t\tjas_eprintf("expecting file type box\\n");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() &gt;= 1) {\n\t\t\tjas_eprintf("got box type %s\\n", box-&gt;info-&gt;name);\n\t\t}\n\t\tswitch (box-&gt;type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec-&gt;ihdr) {\n\t\t\t\tdec-&gt;ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec-&gt;bpcc) {\n\t\t\t\tdec-&gt;bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec-&gt;cdef) {\n\t\t\t\tdec-&gt;cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec-&gt;pclr) {\n\t\t\t\tdec-&gt;pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec-&gt;cmap) {\n\t\t\t\tdec-&gt;cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec-&gt;colr) {\n\t\t\t\tdec-&gt;colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf("error: no code stream found\\n");\n\t\tgoto error;\n\t}\n\n\tif (!(dec-&gt;image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf("error: cannot decode code stream\\n");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec-&gt;ihdr) {\n\t\tjas_eprintf("error: missing IHDR box\\n");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec-&gt;ihdr-&gt;data.ihdr.numcmpts != JAS_CAST(uint,\n\t  jas_image_numcmpts(dec-&gt;image))) {\n\t\tjas_eprintf("warning: number of components mismatch\\n");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec-&gt;image)) {\n\t\tjas_eprintf("error: no components\\n");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec-&gt;image, 0);\n\tfor (i = 1; i &lt; JAS_CAST(uint, jas_image_numcmpts(dec-&gt;image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec-&gt;image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype &amp;&amp; dec-&gt;ihdr-&gt;data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype &amp;&amp; dec-&gt;ihdr-&gt;data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf("warning: component data type mismatch\\n");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec-&gt;ihdr-&gt;data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf("error: unsupported compression type\\n");\n\t\tgoto error;\n\t}\n\n\tif (dec-&gt;bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec-&gt;bpcc-&gt;data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(\n\t\t  dec-&gt;image))) {\n\t\t\tjas_eprintf("warning: number of components mismatch\\n");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i &lt; JAS_CAST(uint, jas_image_numcmpts(dec-&gt;image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec-&gt;image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec-&gt;bpcc-&gt;data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf("warning: component data type mismatch\\n");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf("warning: superfluous BPCC box\\n");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec-&gt;colr) {\n\t\tjas_eprintf("error: no COLR box\\n");\n\t\tgoto error;\n\t}\n\n\tswitch (dec-&gt;colr-&gt;data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec-&gt;image, jp2_getcs(&amp;dec-&gt;colr-&gt;data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec-&gt;colr-&gt;data.colr.iccp,\n\t\t  dec-&gt;colr-&gt;data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf("error: failed to parse ICC profile\\n");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &amp;icchdr);\n\t\tjas_eprintf("ICC Profile CS %08x\\n", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec-&gt;image, fromiccpcs(icchdr.colorspc));\n\t\tdec-&gt;image-&gt;cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec-&gt;image-&gt;cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec-&gt;cmap &amp;&amp; !dec-&gt;pclr) {\n\t\tjas_eprintf("warning: missing PCLR box or superfluous CMAP box\\n");\n\t\tjp2_box_destroy(dec-&gt;cmap);\n\t\tdec-&gt;cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec-&gt;cmap &amp;&amp; dec-&gt;pclr) {\n\t\tjas_eprintf("warning: missing CMAP box or superfluous PCLR box\\n");\n\t\tjp2_box_destroy(dec-&gt;pclr);\n\t\tdec-&gt;pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec-&gt;numchans = dec-&gt;cmap ? dec-&gt;cmap-&gt;data.cmap.numchans :\n\t  JAS_CAST(uint, jas_image_numcmpts(dec-&gt;image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec-&gt;cmap) {\n\t\tfor (i = 0; i &lt; dec-&gt;numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec-&gt;cmap-&gt;data.cmap.ents[i].cmptno &gt;= JAS_CAST(uint,\n\t\t\t  jas_image_numcmpts(dec-&gt;image))) {\n\t\t\t\tjas_eprintf("error: invalid component number in CMAP box\\n");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec-&gt;cmap-&gt;data.cmap.ents[i].pcol &gt;=\n\t\t\t  dec-&gt;pclr-&gt;data.pclr.numchans) {\n\t\t\t\tjas_eprintf("error: invalid CMAP LUT index\\n");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec-&gt;chantocmptlut = jas_alloc2(dec-&gt;numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf("error: no memory\\n");\n\t\tgoto error;\n\t}\n\n\tif (!dec-&gt;cmap) {\n\t\tfor (i = 0; i &lt; dec-&gt;numchans; ++i) {\n\t\t\tdec-&gt;chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &amp;dec-&gt;cmap-&gt;data.cmap;\n\t\tpclrd = &amp;dec-&gt;pclr-&gt;data.pclr;\n\t\tcdefd = &amp;dec-&gt;cdef-&gt;data.cdef;\n\t\tfor (channo = 0; channo &lt; cmapd-&gt;numchans; ++channo) {\n\t\t\tcmapent = &amp;cmapd-&gt;ents[channo];\n\t\t\tif (cmapent-&gt;map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec-&gt;chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent-&gt;map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_alloc2(pclrd-&gt;numlutents, sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i &lt; pclrd-&gt;numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd-&gt;lutdata[cmapent-&gt;pcol + i * pclrd-&gt;numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec-&gt;image);\n\t\t\t\tjas_image_depalettize(dec-&gt;image, cmapent-&gt;cmptno,\n\t\t\t\t  pclrd-&gt;numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd-&gt;bpc[cmapent-&gt;pcol]), newcmptno);\n\t\t\t\tdec-&gt;chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec-&gt;cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec-&gt;image, newcmptno, jp2_getct(jas_image_clrspc(dec-&gt;image), cdefent-&gt;type, cdefent-&gt;assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec-&gt;image, newcmptno, jp2_getct(jas_image_clrspc(dec-&gt;image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i &lt; JAS_CAST(uint, jas_image_numcmpts(dec-&gt;image)); ++i) {\n\t\tjas_image_setcmpttype(dec-&gt;image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec-&gt;cdef) {\n\t\tfor (i = 0; i &lt; dec-&gt;numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec-&gt;cdef-&gt;data.cdef.ents[i].channo &gt;= dec-&gt;numchans) {\n\t\t\t\tjas_eprintf("error: invalid channel number in CDEF box\\n");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec-&gt;image,\n\t\t\t  dec-&gt;chantocmptlut[dec-&gt;cdef-&gt;data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec-&gt;image),\n\t\t\t  dec-&gt;cdef-&gt;data.cdef.ents[i].type,\n\t\t\t  dec-&gt;cdef-&gt;data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i &lt; dec-&gt;numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec-&gt;image, dec-&gt;chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec-&gt;image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec-&gt;image); i &gt; 0; --i) {\n\t\tif (jas_image_cmpttype(dec-&gt;image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec-&gt;image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec-&gt;image)) {\n\t\tjas_eprintf("error: no components\\n");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf("no of components is %d\\n", jas_image_numcmpts(dec-&gt;image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec-&gt;image;\n\tdec-&gt;image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}',
 'av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n{\n    const unsigned high_bit_depth = avctx-&gt;bits_per_raw_sample &gt; 8;\n\n    if (avctx-&gt;lowres==1) {\n        c-&gt;idct_put  = ff_jref_idct4_put;\n        c-&gt;idct_add  = ff_jref_idct4_add;\n        c-&gt;idct      = ff_j_rev_dct4;\n        c-&gt;perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx-&gt;lowres==2) {\n        c-&gt;idct_put  = ff_jref_idct2_put;\n        c-&gt;idct_add  = ff_jref_idct2_add;\n        c-&gt;idct      = ff_j_rev_dct2;\n        c-&gt;perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx-&gt;lowres==3) {\n        c-&gt;idct_put  = ff_jref_idct1_put;\n        c-&gt;idct_add  = ff_jref_idct1_add;\n        c-&gt;idct      = ff_j_rev_dct1;\n        c-&gt;perm_type = FF_IDCT_PERM_NONE;\n    } else {\n        if (avctx-&gt;bits_per_raw_sample == 10 || avctx-&gt;bits_per_raw_sample == 9) {\n            /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n               However, it only uses idct_put */\n            if (c-&gt;mpeg4_studio_profile)\n                c-&gt;idct_put              = ff_simple_idct_put_int32_10bit;\n            else {\n                c-&gt;idct_put              = ff_simple_idct_put_int16_10bit;\n                c-&gt;idct_add              = ff_simple_idct_add_int16_10bit;\n                c-&gt;idct                  = ff_simple_idct_int16_10bit;\n            }\n            c-&gt;perm_type             = FF_IDCT_PERM_NONE;\n        } else if (avctx-&gt;bits_per_raw_sample == 12) {\n            c-&gt;idct_put              = ff_simple_idct_put_int16_12bit;\n            c-&gt;idct_add              = ff_simple_idct_add_int16_12bit;\n            c-&gt;idct                  = ff_simple_idct_int16_12bit;\n            c-&gt;perm_type             = FF_IDCT_PERM_NONE;\n        } else {\n            if (avctx-&gt;idct_algo == FF_IDCT_INT) {\n                c-&gt;idct_put  = ff_jref_idct_put;\n                c-&gt;idct_add  = ff_jref_idct_add;\n                c-&gt;idct      = ff_j_rev_dct;\n                c-&gt;perm_type = FF_IDCT_PERM_LIBMPEG2;\n#if CONFIG_FAANIDCT\n            } else if (avctx-&gt;idct_algo == FF_IDCT_FAAN) {\n                c-&gt;idct_put  = ff_faanidct_put;\n                c-&gt;idct_add  = ff_faanidct_add;\n                c-&gt;idct      = ff_faanidct;\n                c-&gt;perm_type = FF_IDCT_PERM_NONE;\n#endif /* CONFIG_FAANIDCT */\n            } else { // accurate/default\n                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */\n                c-&gt;idct_put  = ff_simple_idct_put_int16_8bit;\n                c-&gt;idct_add  = ff_simple_idct_add_int16_8bit;\n                c-&gt;idct      = ff_simple_idct_int16_8bit;\n                c-&gt;perm_type = FF_IDCT_PERM_NONE;\n            }\n        }\n    }\n\n    c-&gt;put_pixels_clamped        = ff_put_pixels_clamped_c;\n    c-&gt;put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c-&gt;add_pixels_clamped        = ff_add_pixels_clamped_c;\n\n    if (CONFIG_MPEG4_DECODER &amp;&amp; avctx-&gt;idct_algo == FF_IDCT_XVID)\n        ff_xvid_idct_init(c, avctx);\n\n    if (ARCH_AARCH64)\n        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);\n    if (ARCH_ALPHA)\n        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);\n    if (ARCH_ARM)\n        ff_idctdsp_init_arm(c, avctx, high_bit_depth);\n    if (ARCH_PPC)\n        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);\n    if (ARCH_X86)\n        ff_idctdsp_init_x86(c, avctx, high_bit_depth);\n    if (ARCH_MIPS)\n        ff_idctdsp_init_mips(c, avctx, high_bit_depth);\n\n    ff_init_scantable_permutation(c-&gt;idct_permutation,\n                                  c-&gt;perm_type);\n}',
 'static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\n\tclient-&gt;auth_user = client-&gt;db-&gt;auth_user;\n\t/* have to fetch user info from db */\n\tclient-&gt;pool = get_pool(client-&gt;db, client-&gt;db-&gt;auth_user);\n\tif (!find_server(client)) {\n\t\tclient-&gt;wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, "Doing auth_conn query");\n\tclient-&gt;wait_for_user_conn = false;\n\tclient-&gt;wait_for_user = true;\n\tif (!sbuf_pause(&amp;client-&gt;sbuf)) {\n\t\trelease_server(client-&gt;link);\n\t\tdisconnect_client(client, true, "pause failed");\n\t\treturn;\n\t}\n\tclient-&gt;link-&gt;ready = 0;\n\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client-&gt;link);\n\t\tpktbuf_free(buf);\n\t\t/*\n\t\t * Should do instead:\n\t\t *   res = pktbuf_send_queued(buf, client-&gt;link);\n\t\t * but that needs better integration with SBuf.\n\t\t */\n\t}\n\tif (!res)\n\t\tdisconnect_server(client-&gt;link, false, "unable to send login query");\n}',
 'QPDFObjectHandle::parseContentStream_internal(PointerHolder&lt;Buffer&gt; stream_data,\n                                              std::string const&amp; description,\n                                              ParserCallbacks* callbacks)\n{\n    size_t length = stream_data-&gt;getSize();\n    PointerHolder&lt;InputSource&gt; input =\n        new BufferInputSource(description, stream_data.getPointer());\n    QPDFTokenizer tokenizer;\n    tokenizer.allowEOF();\n    bool empty = false;\n    while (static_cast&lt;size_t&gt;(input-&gt;tell()) &lt; length)\n    {\n        QPDFObjectHandle obj =\n            parseInternal(input, "content", tokenizer, empty,\n                          0, 0, false, false, true);\n        if (! obj.isInitialized())\n        {\n            // EOF\n            break;\n        }\n\n        callbacks-&gt;handleObject(obj);\n        if (obj.isOperator() &amp;&amp; (obj.getOperatorValue() == "ID"))\n        {\n            // Discard next character; it is the space after ID that\n            // terminated the token.  Read until end of inline image.\n            char ch;\n            input-&gt;read(&amp;ch, 1);\n            char buf[4];\n            memset(buf, \'\\0\', sizeof(buf));\n            bool done = false;\n            std::string inline_image;\n            while (! done)\n            {\n                if (input-&gt;read(&amp;ch, 1) == 0)\n                {\n                    QTC::TC("qpdf", "QPDFObjectHandle EOF in inline image");\n                    throw QPDFExc(qpdf_e_damaged_pdf, input-&gt;getName(),\n                                  "stream data", input-&gt;tell(),\n                                  "EOF found while reading inline image");\n                }\n                inline_image += ch;\n                memmove(buf, buf + 1, sizeof(buf) - 1);\n                buf[sizeof(buf) - 1] = ch;\n                if (strchr(" \\t\\n\\v\\f\\r", buf[0]) &amp;&amp;\n                    (buf[1] == \'E\') &amp;&amp;\n                    (buf[2] == \'I\') &amp;&amp;\n                    strchr(" \\t\\n\\v\\f\\r", buf[3]))\n                {\n                    // We\'ve found an EI operator.\n                    done = true;\n                    input-&gt;seek(-3, SEEK_CUR);\n                    for (int i = 0; i &lt; 4; ++i)\n                    {\n                        if (inline_image.length() &gt; 0)\n                        {\n                            inline_image.erase(inline_image.length() - 1);\n                        }\n                    }\n                }\n            }\n            QTC::TC("qpdf", "QPDFObjectHandle inline image token");\n            callbacks-&gt;handleObject(\n                QPDFObjectHandle::newInlineImage(inline_image));\n        }\n    }\n}',
 'Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id&amp; out) const\n{\n  std::string image_type = m_heif_file-&gt;get_item_type(id);\n  if (image_type=="grid" ||\n      image_type=="iden" ||\n      image_type=="iovl") {\n    auto iref_box = m_heif_file-&gt;get_iref_box();\n    if (!iref_box) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   "Derived image does not reference any other image items");\n    }\n\n    std::vector&lt;heif_item_id&gt; image_references = iref_box-&gt;get_references(id, fourcc("dimg"));\n\n    // TODO: check whether this really can be recursive (e.g. overlay of grid images)\n\n    if (image_references.empty()) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   "Derived image does not reference any other image items");\n    }\n    else {\n      return get_id_of_non_virtual_child_image(image_references[0], out);\n    }\n  }\n  else {\n    out = id;\n    return Error::Ok;\n  }\n}',
 'l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, "%s", tok2str(l2tp_authentype2str,\n\t\t\t     "AuthType-#%u", EXTRACT_16BITS(ptr))));\n}',
 'static int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      const unsigned char *dev_wwn)\n{\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\n\tif (!se_dev-&gt;dev_attrib.emulate_3pc) {\n\t\tpr_debug("XCOPY: emulate_3pc disabled on se_dev %p\\n", se_dev);\n\t\treturn 0;\n\t}\n\n\tmemset(&amp;tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &amp;tmp_dev_wwn[0]);\n\n\trc = memcmp(&amp;tmp_dev_wwn[0], dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0) {\n\t\tpr_debug("XCOPY: skip non-matching: %*ph\\n",\n\t\t\t XCOPY_NAA_IEEE_REGEX_LEN, tmp_dev_wwn);\n\t\treturn 0;\n\t}\n\tpr_debug("XCOPY 0xe4: located se_dev: %p\\n", se_dev);\n\n\treturn 1;\n}',
 'static int download(struct SPDBDownloader *pd) {\n\tSPDBDownloaderOpt *opt = pd-&gt;opt;\n\tint res = 0;\n\tint cmd_ret;\n\n\tif (!opt-&gt;dbg_file || !*opt-&gt;dbg_file) {\n\t\t// no pdb debug file\n\t\treturn 0;\n\t}\n\n\tchar *abspath_to_file = r_str_newf ("%s%s%s%s%s%s%s",\n\t\topt-&gt;symbol_store_path, R_SYS_DIR,\n\t\topt-&gt;dbg_file, R_SYS_DIR,\n\t\topt-&gt;guid, R_SYS_DIR,\n\t\topt-&gt;dbg_file);\n\n\tif (r_file_exists (abspath_to_file)) {\n\t\teprintf ("File already downloaded.\\n");\n\t\tfree (abspath_to_file);\n\t\treturn 1;\n\t}\n\n\tif (checkExtract () || opt-&gt;extract == 0) {\n\t\tchar *extractor_cmd = NULL;\n\t\tchar *archive_name = strdup (opt-&gt;dbg_file);\n\t\tarchive_name[strlen (archive_name) - 1] = \'_\';\n\t\tchar *abspath_to_archive = r_str_newf ("%s%s%s%s%s%s%s",\n\t\t\topt-&gt;symbol_store_path, R_SYS_DIR,\n\t\t\topt-&gt;dbg_file, R_SYS_DIR,\n\t\t\topt-&gt;guid, R_SYS_DIR,\n\t\t\tarchive_name);\n\n\t\teprintf ("Attempting to download compressed pdb in %s\\n", abspath_to_archive);\n\t\tchar *abs_arch_esc = r_str_escape_sh (abspath_to_archive);\n#if __WINDOWS__\n\t\tchar *abs_file_esc = r_str_escape_sh (abspath_to_file);\n\t\t// expand %1 %2\n\t\t// %1 - absolute path to archive\n\t\t// %2 - absolute path to file that will be dearchive\n\t\textractor_cmd = r_str_newf ("expand \\"%s\\" \\"%s\\"", abs_arch_esc, abs_file_esc);\n\t\tfree (abs_file_esc);\n#else\n\t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n\t\tchar *abs_dir_esc = r_str_escape_sh (abspath_to_dir);\n\t\t// cabextract -d %1 %2\n\t\t// %1 - path to directory where to extract all files from cab archive\n\t\t// %2 - absolute path to cab archive\n\t\textractor_cmd = r_str_newf ("cabextract -d \\"%s\\" \\"%s\\"", abs_arch_esc, abs_dir_esc);\n\t\tfree (abs_dir_esc);\n\t\tfree (abspath_to_dir);\n#endif\n\t\tfree (abs_arch_esc);\n\t\tres = download_and_write (opt, archive_name);\n\n\t\tif (opt-&gt;extract &gt; 0 &amp;&amp; res) {\n\t\t\teprintf ("Attempting to decompress pdb\\n");\n\t\t\tif (res &amp;&amp; ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {\n\t\t\t\teprintf ("cab extractor exited with error %d\\n", cmd_ret);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tr_file_rm (abspath_to_archive);\n\t\t}\n\t\tfree (archive_name);\n\t\tfree (abspath_to_archive);\n\t}\n\tif (res == 0) {\n\t\teprintf ("Falling back to uncompressed pdb\\n");\n\t\teprintf ("Attempting to download uncompressed pdb in %s\\n", abspath_to_file);\n\t\tres = download_and_write (opt, opt-&gt;dbg_file);\n\t}\n\tfree (abspath_to_file);\n\treturn res;\n}',
 '\tvoid initialize(const string &amp;path, bool owner) {\n\t\tTRACE_POINT();\n\t\tthis-&gt;path  = path;\n\t\tthis-&gt;owner = owner;\n\t\t\n\t\t/* Create the server instance directory. We only need to write to this\n\t\t * directory for these reasons:\n\t\t * 1. Initial population of structure files (structure_version.txt, instance.pid).\n\t\t * 2. Creating/removing a generation directory.\n\t\t * 3. Removing the entire server instance directory (after all\n\t\t *    generations are removed).\n\t\t *\n\t\t * 1 and 2 are done by the helper server during initialization and before lowering\n\t\t * privilege. 3 is done during helper server shutdown by a cleanup process that\'s\n\t\t * running as the same user the helper server was running as before privilege\n\t\t * lowering.\n\t\t * Therefore, we make the directory only writable by the user the helper server\n\t\t * was running as before privilege is lowered. Everybody else has read and execute\n\t\t * rights though, because we want admin tools to be able to list the available\n\t\t * generations no matter what user they\'re running as.\n\t\t */\n\t\tmakeDirTree(path, "u=rwx,g=rx,o=rx");\n\t}',
 'hufDecode\n    (const Int64 * \thcode,\t// i : encoding table\n     const HufDec * \thdecod,\t// i : decoding table\n     const char* \tin,\t// i : compressed input buffer\n     int\t\tni,\t// i : input size (in bits)\n     int\t\trlc,\t// i : run-length code\n     int\t\tno,\t// i : expected output size (in bytes)\n     unsigned short*\tout)\t//  o: uncompressed output buffer\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; // input byte size\n\n    //\n    // Loop on input bytes\n    //\n\n    while (in &lt; ie)\n    {\n\tgetChar (c, lc, in);\n\n\t//\n\t// Access decoding table\n\t//\n\n\twhile (lc &gt;= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c &gt;&gt; (lc-HUF_DECBITS)) &amp; HUF_DECMASK];\n\n\t    if (pl.len)\n\t    {\n\t\t//\n\t\t// Get short code\n\t\t//\n\n\t\tlc -= pl.len;\n\n\t\tif ( lc &lt; 0 )\n\t\t{\n\t\t\tinvalidCode(); // code length too long\n\t\t}\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); // wrong code\n\n\t\t//\n\t\t// Search long code\n\t\t//\n\n\t\tint j;\n\n\t\tfor (j = 0; j &lt; pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\n\t\t    while (lc &lt; l &amp;&amp; in &lt; ie)\t// get more bits\n\t\t\tgetChar (c, lc, in);\n\n\t\t    if (lc &gt;= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c &gt;&gt; (lc - l)) &amp; ((Int64(1) &lt;&lt; l) - 1)))\n\t\t\t{\n\t\t\t    //\n\t\t\t    // Found : get long code\n\t\t\t    //\n\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); // Not found\n\t    }\n\t}\n    }\n\n    //\n    // Get remaining (short) codes\n    //\n\n    int i = (8 - ni) &amp; 7;\n    c &gt;&gt;= i;\n    lc -= i;\n\n    while (lc &gt; 0)\n    {\n\tconst HufDec pl = hdecod[(c &lt;&lt; (HUF_DECBITS - lc)) &amp; HUF_DECMASK];\n\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n            if ( lc &lt; 0 )\n            {\n   \t        invalidCode(); // code length too long\n            }\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); // wrong (long) code\n\t}\n    }\n\n    if (out - outb != no)\n\tnotEnoughData ();\n}',
 'int read_filesystem_tables_4()\n{\n\tlong long directory_table_end, table_start;\n\n\tif(read_xattrs_from_disk(fd, &amp;sBlk.s, no_xattrs, &amp;table_start) == 0)\n\t\treturn FALSE;\n\n\tif(read_uids_guids(&amp;table_start) == FALSE)\n\t\treturn FALSE;\n\n\tif(parse_exports_table(&amp;table_start) == FALSE)\n\t\treturn FALSE;\n\n\tif(read_fragment_table(&amp;directory_table_end) == FALSE)\n\t\treturn FALSE;\n\n\tif(read_inode_table(sBlk.s.inode_table_start,\n\t\t\t\tsBlk.s.directory_table_start) == FALSE)\n\t\treturn FALSE;\n\n\tif(read_directory_table(sBlk.s.directory_table_start,\n\t\t\t\tdirectory_table_end) == FALSE)\n\t\treturn FALSE;\n\n\tif(no_xattrs)\n\t\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n\n\treturn TRUE;\n}',
 'spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}',
 'exif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\n\tentry-&gt;tag        = exif_get_short (d + offset + 0, data-&gt;priv-&gt;order);\n\tentry-&gt;format     = exif_get_short (d + offset + 2, data-&gt;priv-&gt;order);\n\tentry-&gt;components = exif_get_long  (d + offset + 4, data-&gt;priv-&gt;order);\n\n\t/* FIXME: should use exif_tag_get_name_in_ifd here but entry-&gt;parent \n\t * has not been set yet\n\t */\n\texif_log (data-&gt;priv-&gt;log, EXIF_LOG_CODE_DEBUG, "ExifData",\n\t\t  "Loading entry 0x%x (\'%s\')...", entry-&gt;tag,\n\t\t  exif_tag_get_name (entry-&gt;tag));\n\n\t/* {0,1,2,4,8} x { 0x00000000 .. 0xffffffff } \n\t *   -&gt; { 0x000000000 .. 0x7fffffff8 } */\n\ts = exif_format_get_size(entry-&gt;format) * entry-&gt;components;\n\tif ((s &lt; entry-&gt;components) || (s == 0)){\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s &gt; 4)\n\t\tdoff = exif_get_long (d + offset + 8, data-&gt;priv-&gt;order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif ((doff + s &lt; doff) || (doff + s &lt; s) || (doff + s &gt; size)) {\n\t\texif_log (data-&gt;priv-&gt;log, EXIF_LOG_CODE_DEBUG, "ExifData",\n\t\t\t\t  "Tag data past end of buffer (%u &gt; %u)", doff+s, size);\t\n\t\treturn 0;\n\t}\n\n\tentry-&gt;data = exif_data_alloc (data, s);\n\tif (entry-&gt;data) {\n\t\tentry-&gt;size = s;\n\t\tmemcpy (entry-&gt;data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data-&gt;priv-&gt;log, "ExifData", s);\n\t\treturn 0;\n\t}\n\n\t/* If this is the MakerNote, remember the offset */\n\tif (entry-&gt;tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry-&gt;data) {\n\t\t\texif_log (data-&gt;priv-&gt;log, EXIF_LOG_CODE_DEBUG, "ExifData",\n\t\t\t\t\t  "MakerNote found with empty data");\t\n\t\t} else if (entry-&gt;size &gt; 6) {\n\t\t\texif_log (data-&gt;priv-&gt;log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, "ExifData",\n\t\t\t\t\t       "MakerNote found (%02x %02x %02x %02x "\n\t\t\t\t\t       "%02x %02x %02x...).",\n\t\t\t\t\t       entry-&gt;data[0], entry-&gt;data[1], entry-&gt;data[2],\n\t\t\t\t\t       entry-&gt;data[3], entry-&gt;data[4], entry-&gt;data[5],\n\t\t\t\t\t       entry-&gt;data[6]);\n\t\t}\n\t\tdata-&gt;priv-&gt;offset_mnote = doff;\n\t}\n\treturn 1;\n}',
 'int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct au1100fb_device *fbdev;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tvma-&gt;vm_page_prot = pgprot_noncached(vma-&gt;vm_page_prot);\n\tpgprot_val(vma-&gt;vm_page_prot) |= (6 &lt;&lt; 9); //CCA=6\n\n\treturn vm_iomap_memory(vma, fbdev-&gt;fb_phys, fbdev-&gt;fb_len);\n}',
 'AP4_VisualSampleEntry::ReadFields(AP4_ByteStream&amp; stream)\n{\n    // sample entry\n    AP4_Result result = AP4_SampleEntry::ReadFields(stream);\n    if (result &lt; 0) return result;\n\n    // read fields from this class\n    stream.ReadUI16(m_Predefined1);\n    stream.ReadUI16(m_Reserved2);\n    stream.Read(m_Predefined2, sizeof(m_Predefined2));\n    stream.ReadUI16(m_Width);\n    stream.ReadUI16(m_Height);\n    stream.ReadUI32(m_HorizResolution);\n    stream.ReadUI32(m_VertResolution);\n    stream.ReadUI32(m_Reserved3);\n    stream.ReadUI16(m_FrameCount);\n\n    AP4_UI08 compressor_name[33];\n    compressor_name[32] = 0;\n    stream.Read(compressor_name, 32);\n    AP4_UI08 name_length = compressor_name[0];\n    if (name_length &lt; 32) {\n        compressor_name[name_length+1] = 0; // force null termination\n        m_CompressorName = (const char*)(&amp;compressor_name[1]);\n    }\n\n    stream.ReadUI16(m_Depth);\n    stream.ReadUI16(m_Predefined3);\n\n    return AP4_SUCCESS;\n}',
 'void pef7071EventHandler(NetInterface *interface)\n{\n   uint16_t status;\n\n   //Read status register\n   status = pef7071ReadPhyReg(interface, PEF7071_STAT);\n\n   //Link is up?\n   if((status &amp; PEF7071_STAT_LS) != 0)\n   {\n      //Read MII status register\n      status = pef7071ReadPhyReg(interface, PEF7071_MIISTAT);\n\n      //Check current speed\n      switch(status &amp; PEF7071_MIISTAT_SPEED)\n      {\n      //10BASE-T\n      case PEF7071_MIISTAT_SPEED_TEN:\n         interface-&gt;linkSpeed = NIC_LINK_SPEED_10MBPS;\n         break;\n      //100BASE-TX\n      case PEF7071_MIISTAT_SPEED_FAST:\n         interface-&gt;linkSpeed = NIC_LINK_SPEED_100MBPS;\n         break;\n      //1000BASE-T\n      case PEF7071_MIISTAT_SPEED_GIGA:\n         interface-&gt;linkSpeed = NIC_LINK_SPEED_1GBPS;\n         break;\n      //Unknown speed\n      default:\n         //Debug message\n         TRACE_WARNING("Invalid speed\\r\\n");\n         break;\n      }\n\n      //Check current duplex mode\n      if((status &amp; PEF7071_MIISTAT_DPX) != 0)\n      {\n         interface-&gt;duplexMode = NIC_FULL_DUPLEX_MODE;\n      }\n      else\n      {\n         interface-&gt;duplexMode = NIC_HALF_DUPLEX_MODE;\n      }\n\n      //Update link state\n      interface-&gt;linkState = TRUE;\n\n      //Adjust MAC configuration parameters for proper operation\n      interface-&gt;nicDriver-&gt;updateMacConfig(interface);\n   }\n   else\n   {\n      //Update link state\n      interface-&gt;linkState = FALSE;\n   }\n\n   //Process link state change event\n   nicNotifyLinkChange(interface);\n}',
 'static void sas_revalidate_domain(struct work_struct *work)\n{\n\tint res = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev-&gt;port;\n\tstruct sas_ha_struct *ha = port-&gt;ha;\n\tstruct domain_device *ddev = port-&gt;port_dev;\n\n\t/* prevent revalidation from finding sata links in recovery */\n\tmutex_lock(&amp;ha-&gt;disco_mutex);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &amp;ha-&gt;state)) {\n\t\tSAS_DPRINTK("REVALIDATION DEFERRED on port %d, pid:%d\\n",\n\t\t\t    port-&gt;id, task_pid_nr(current));\n\t\tgoto out;\n\t}\n\n\tclear_bit(DISCE_REVALIDATE_DOMAIN, &amp;port-&gt;disc.pending);\n\n\tSAS_DPRINTK("REVALIDATING DOMAIN on port %d, pid:%d\\n", port-&gt;id,\n\t\t    task_pid_nr(current));\n\n\tif (ddev &amp;&amp; (ddev-&gt;dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     ddev-&gt;dev_type == SAS_EDGE_EXPANDER_DEVICE))\n\t\tres = sas_ex_revalidate_domain(ddev);\n\n\tSAS_DPRINTK("done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\\n",\n\t\t    port-&gt;id, task_pid_nr(current), res);\n out:\n\tmutex_unlock(&amp;ha-&gt;disco_mutex);\n\n\tsas_destruct_devices(port);\n\tsas_destruct_ports(port);\n\tsas_probe_devices(port);\n}',
 'ast_for_import_stmt(struct compiling *c, const node *n)\n{\n    /*\n      import_stmt: import_name | import_from\n      import_name: \'import\' dotted_as_names\n      import_from: \'from\' ((\'.\' | \'...\')* dotted_name | (\'.\' | \'...\')+)\n                   \'import\' (\'*\' | \'(\' import_as_names \')\' | import_as_names)\n    */\n    int lineno;\n    int col_offset;\n    int i;\n    asdl_seq *aliases;\n\n    REQ(n, import_stmt);\n    lineno = LINENO(n);\n    col_offset = n-&gt;n_col_offset;\n    n = CHILD(n, 0);\n    if (TYPE(n) == import_name) {\n        n = CHILD(n, 1);\n        REQ(n, dotted_as_names);\n        aliases = _Py_asdl_seq_new((NCH(n) + 1) / 2, c-&gt;c_arena);\n        if (!aliases)\n                return NULL;\n        for (i = 0; i &lt; NCH(n); i += 2) {\n            alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);\n            if (!import_alias)\n                return NULL;\n            asdl_seq_SET(aliases, i / 2, import_alias);\n        }\n        // Even though n is modified above, the end position is not changed\n        return Import(aliases, lineno, col_offset,\n                      n-&gt;n_end_lineno, n-&gt;n_end_col_offset, c-&gt;c_arena);\n    }\n    else if (TYPE(n) == import_from) {\n        int n_children;\n        int idx, ndots = 0;\n        const node *n_copy = n;\n        alias_ty mod = NULL;\n        identifier modname = NULL;\n\n       /* Count the number of dots (for relative imports) and check for the\n          optional module name */\n        for (idx = 1; idx &lt; NCH(n); idx++) {\n            if (TYPE(CHILD(n, idx)) == dotted_name) {\n                mod = alias_for_import_name(c, CHILD(n, idx), 0);\n                if (!mod)\n                    return NULL;\n                idx++;\n                break;\n            } else if (TYPE(CHILD(n, idx)) == ELLIPSIS) {\n                /* three consecutive dots are tokenized as one ELLIPSIS */\n                ndots += 3;\n                continue;\n            } else if (TYPE(CHILD(n, idx)) != DOT) {\n                break;\n            }\n            ndots++;\n        }\n        idx++; /* skip over the \'import\' keyword */\n        switch (TYPE(CHILD(n, idx))) {\n        case STAR:\n            /* from ... import * */\n            n = CHILD(n, idx);\n            n_children = 1;\n            break;\n        case LPAR:\n            /* from ... import (x, y, z) */\n            n = CHILD(n, idx + 1);\n            n_children = NCH(n);\n            break;\n        case import_as_names:\n            /* from ... import x, y, z */\n            n = CHILD(n, idx);\n            n_children = NCH(n);\n            if (n_children % 2 == 0) {\n                ast_error(c, n,\n                          "trailing comma not allowed without"\n                          " surrounding parentheses");\n                return NULL;\n            }\n            break;\n        default:\n            ast_error(c, n, "Unexpected node-type in from-import");\n            return NULL;\n        }\n\n        aliases = _Py_asdl_seq_new((n_children + 1) / 2, c-&gt;c_arena);\n        if (!aliases)\n            return NULL;\n\n        /* handle "from ... import *" special b/c there\'s no children */\n        if (TYPE(n) == STAR) {\n            alias_ty import_alias = alias_for_import_name(c, n, 1);\n            if (!import_alias)\n                return NULL;\n            asdl_seq_SET(aliases, 0, import_alias);\n        }\n        else {\n            for (i = 0; i &lt; NCH(n); i += 2) {\n                alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);\n                if (!import_alias)\n                    return NULL;\n                asdl_seq_SET(aliases, i / 2, import_alias);\n            }\n        }\n        if (mod != NULL)\n            modname = mod-&gt;name;\n        return ImportFrom(modname, aliases, ndots, lineno, col_offset,\n                          n_copy-&gt;n_end_lineno, n_copy-&gt;n_end_col_offset,\n                          c-&gt;c_arena);\n    }\n    PyErr_Format(PyExc_SystemError,\n                 "unknown import statement: starts with command \'%s\'",\n                 STR(CHILD(n, 0)));\n    return NULL;\n}',
 '    bool PamBackend::start(const QString &amp;user) {\n        bool result;\n\n        QString service = QStringLiteral("sddm");\n\n        if (user == QStringLiteral("sddm") &amp;&amp; m_greeter)\n            service = QStringLiteral("sddm-greeter");\n        else if (m_app-&gt;session()-&gt;path().isEmpty())\n            service = QStringLiteral("sddm-check");\n        else if (m_autologin)\n            service = QStringLiteral("sddm-autologin");\n        result = m_pam-&gt;start(service, user);\n\n        if (!result)\n            m_app-&gt;error(m_pam-&gt;errorString(), Auth::ERROR_INTERNAL);\n\n        return result;\n    }',
 'RemoteFsDevice::RemoteFsDevice(MusicLibraryModel *m, const Details &amp;d)\n    : FsDevice(m, d.name, createUdi(d.name))\n    , mountToken(0)\n    , currentMountStatus(false)\n    , details(d)\n    , proc(0)\n    , mounterIface(0)\n    , messageSent(false)\n{\n//    details.path=Utils::fixPath(details.path);\n    setup();\n    icn=MonoIcon::icon(details.isLocalFile()\n                       ? FontAwesome::foldero\n                       : constSshfsProtocol==details.url.scheme()\n                         ? FontAwesome::linux_os\n                         : FontAwesome::windows, Utils::monoIconColor());\n}',
 'int vis_emul(struct pt_regs *regs, unsigned int insn)\n{\n\tunsigned long pc = regs-&gt;tpc;\n\tunsigned int opf;\n\n\tBUG_ON(regs-&gt;tstate &amp; TSTATE_PRIV);\n\n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n\n\tif (test_thread_flag(TIF_32BIT))\n\t\tpc = (u32)pc;\n\n\tif (get_user(insn, (u32 __user *) pc))\n\t\treturn -EFAULT;\n\n\tsave_and_clear_fpu();\n\n\topf = (insn &amp; VIS_OPF_MASK) &gt;&gt; VIS_OPF_SHIFT;\n\tswitch (opf) {\n\tdefault:\n\t\treturn -EINVAL;\n\n\t/* Pixel Formatting Instructions.  */\n\tcase FPACK16_OPF:\n\tcase FPACK32_OPF:\n\tcase FPACKFIX_OPF:\n\tcase FEXPAND_OPF:\n\tcase FPMERGE_OPF:\n\t\tpformat(regs, insn, opf);\n\t\tbreak;\n\n\t/* Partitioned Multiply Instructions  */\n\tcase FMUL8x16_OPF:\n\tcase FMUL8x16AU_OPF:\n\tcase FMUL8x16AL_OPF:\n\tcase FMUL8SUx16_OPF:\n\tcase FMUL8ULx16_OPF:\n\tcase FMULD8SUx16_OPF:\n\tcase FMULD8ULx16_OPF:\n\t\tpmul(regs, insn, opf);\n\t\tbreak;\n\n\t/* Pixel Compare Instructions  */\n\tcase FCMPGT16_OPF:\n\tcase FCMPGT32_OPF:\n\tcase FCMPLE16_OPF:\n\tcase FCMPLE32_OPF:\n\tcase FCMPNE16_OPF:\n\tcase FCMPNE32_OPF:\n\tcase FCMPEQ16_OPF:\n\tcase FCMPEQ32_OPF:\n\t\tpcmp(regs, insn, opf);\n\t\tbreak;\n\n\t/* Edge Handling Instructions  */\n\tcase EDGE8_OPF:\n\tcase EDGE8N_OPF:\n\tcase EDGE8L_OPF:\n\tcase EDGE8LN_OPF:\n\tcase EDGE16_OPF:\n\tcase EDGE16N_OPF:\n\tcase EDGE16L_OPF:\n\tcase EDGE16LN_OPF:\n\tcase EDGE32_OPF:\n\tcase EDGE32N_OPF:\n\tcase EDGE32L_OPF:\n\tcase EDGE32LN_OPF:\n\t\tedge(regs, insn, opf);\n\t\tbreak;\n\n\t/* Pixel Component Distance  */\n\tcase PDIST_OPF:\n\t\tpdist(regs, insn);\n\t\tbreak;\n\n\t/* Three-Dimensional Array Addressing Instructions  */\n\tcase ARRAY8_OPF:\n\tcase ARRAY16_OPF:\n\tcase ARRAY32_OPF:\n\t\tarray(regs, insn, opf);\n\t\tbreak;\n\n\t/* Byte Mask and Shuffle Instructions  */\n\tcase BMASK_OPF:\n\t\tbmask(regs, insn);\n\t\tbreak;\n\n\tcase BSHUFFLE_OPF:\n\t\tbshuffle(regs, insn);\n\t\tbreak;\n\t}\n\n\tregs-&gt;tpc = regs-&gt;tnpc;\n\tregs-&gt;tnpc += 4;\n\treturn 0;\n}',
 'RawTile TileManager::getRegion( unsigned int res, int seq, int ang, int layers, unsigned int x, unsigned int y, unsigned int width, unsigned int height ){\n\n  // If our image type can directly handle region compositing, simply return that\n  if( image-&gt;regionDecoding() ){\n    if( loglevel &gt;= 3 ){\n      *logfile &lt;&lt; "TileManager getRegion :: requesting region directly from image" &lt;&lt; endl;\n    }\n    return image-&gt;getRegion( seq, ang, res, layers, x, y, width, height );\n  }\n\n  // Otherwise do the compositing ourselves\n\n  // The tile size of the source tile\n  unsigned int src_tile_width = image-&gt;getTileWidth();\n  unsigned int src_tile_height = image-&gt;getTileHeight();\n\n  // The tile size of the destination tile\n  unsigned int dst_tile_width = src_tile_width;\n  unsigned int dst_tile_height = src_tile_height;\n\n  // The basic tile size ie. not the current tile\n  unsigned int basic_tile_width = src_tile_width;\n  unsigned int basic_tile_height = src_tile_height;\n\n  int num_res = image-&gt;getNumResolutions();\n  unsigned int im_width = image-&gt;image_widths[num_res-res-1];\n  unsigned int im_height = image-&gt;image_heights[num_res-res-1];\n\n  unsigned int rem_x = im_width % src_tile_width;\n  unsigned int rem_y = im_height % src_tile_height;\n\n  // The number of tiles in each direction\n  unsigned int ntlx = (im_width / src_tile_width) + (rem_x == 0 ? 0 : 1);\n  unsigned int ntly = (im_height / src_tile_height) + (rem_y == 0 ? 0 : 1);\n\n  // Start and end tiles and pixel offsets\n  unsigned int startx, endx, starty, endy, xoffset, yoffset;\n\n\n  if( ! ( x==0 &amp;&amp; y==0 &amp;&amp; width==im_width &amp;&amp; height==im_height ) ){\n    // Calculate the start tiles\n    startx = (unsigned int) ( x / src_tile_width );\n    starty = (unsigned int) ( y / src_tile_height );\n    xoffset = x % src_tile_width;\n    yoffset = y % src_tile_height;\n\n    endx = (unsigned int) ceil( (float)(width + x) / (float)src_tile_width );\n    endy = (unsigned int) ceil( (float)(height + y) / (float)src_tile_height );\n\n    if( loglevel &gt;= 3 ){\n      *logfile &lt;&lt; "TileManager getRegion :: Total tiles in image: " &lt;&lt; ntlx &lt;&lt; "x" &lt;&lt; ntly &lt;&lt; " tiles" &lt;&lt; endl\n\t       &lt;&lt; "TileManager getRegion :: Tile start: " &lt;&lt; startx &lt;&lt; "," &lt;&lt; starty &lt;&lt; " with offset: "\n\t       &lt;&lt; xoffset &lt;&lt; "," &lt;&lt; yoffset &lt;&lt; endl\n\t       &lt;&lt; "TileManager getRegion :: Tile end: " &lt;&lt; endx-1 &lt;&lt; "," &lt;&lt; endy-1 &lt;&lt; endl;\n    }\n  }\n  else{\n    startx = starty = xoffset = yoffset = 0;\n    endx = ntlx;\n    endy = ntly;\n  }\n\n\n  unsigned int channels = image-&gt;getNumChannels();\n  unsigned int bpc = image-&gt;getNumBitsPerPixel();\n  SampleType sampleType = image-&gt;getSampleType();\n\n  // Assume 1 bit data has been unpacked to 8 bits per channel\n  if( bpc == 1 ) bpc = 8;\n\n  // Create an empty tile with the correct dimensions\n  RawTile region( 0, res, seq, ang, width, height, channels, bpc );\n  region.dataLength = width * height * channels * (bpc/8);\n  region.sampleType = sampleType;\n\n  // Allocate memory for the region\n  if( bpc == 8 ) region.data = new unsigned char[width*height*channels];\n  else if( bpc == 16 ) region.data = new unsigned short[width*height*channels];\n  else if( bpc == 32 &amp;&amp; sampleType == FIXEDPOINT ) region.data = new int[width*height*channels];\n  else if( bpc == 32 &amp;&amp; sampleType == FLOATINGPOINT ) region.data = new float[width*height*channels];\n\n  unsigned int current_height = 0;\n\n  // Decode the image strip by strip\n  for( unsigned int i=starty; i&lt;endy; i++ ){\n\n    unsigned int buffer_index = 0;\n\n    // Keep track of the current pixel boundary horizontally. ie. only up\n    //  to the beginning of the current tile boundary.\n    unsigned int current_width = 0;\n\n    for( unsigned int j=startx; j&lt;endx; j++ ){\n\n      // Time the tile retrieval\n      if( loglevel &gt;= 3 ) tile_timer.start();\n\n      // Get an uncompressed tile\n      RawTile rawtile = this-&gt;getTile( res, (i*ntlx) + j, seq, ang, layers, UNCOMPRESSED );\n\n      if( loglevel &gt;= 5 ){\n\t*logfile &lt;&lt; "TileManager getRegion :: Tile access time " &lt;&lt; tile_timer.getTime() &lt;&lt; " microseconds for tile "\n\t\t &lt;&lt; (i*ntlx) + j &lt;&lt; " at resolution " &lt;&lt; res &lt;&lt; endl;\n      }\n\n\n      // Only print this out once per image\n      if( (loglevel &gt;= 5) &amp;&amp; (i==starty) &amp;&amp; (j==starty) ){\n\t*logfile &lt;&lt; "TileManager getRegion :: Tile data is " &lt;&lt; rawtile.channels &lt;&lt; " channels, "\n\t\t &lt;&lt; rawtile.bpc &lt;&lt; " bits per channel" &lt;&lt; endl;\n      }\n\n      // Set the tile width and height to be that of the source tile - Use the rawtile data\n      // because if we take a tile from cache the image pointer will not necessarily be pointing\n      // to the the current tile\n      src_tile_width = rawtile.width;\n      src_tile_height = rawtile.height;\n      dst_tile_width = src_tile_width;\n      dst_tile_height = src_tile_height;\n\n      // Variables for the pixel offset within the current tile\n      unsigned int xf = 0;\n      unsigned int yf = 0;\n\n      // If our viewport has been set, we need to modify our start\n      // and end points on the source image\n      if( !( x==0 &amp;&amp; y==0 &amp;&amp; width==im_width &amp;&amp; height==im_height ) ){\n\n\tunsigned int remainder;  // Remaining pixels in the final row or column\n\n\tif( j == startx ){\n\t  // Calculate the width used in the current tile\n\t  // If there is only 1 tile, the width is just the view width\n\t  if( j &lt; endx - 1 ) dst_tile_width = src_tile_width - xoffset;\n\t  else dst_tile_width = width;\n\t  xf = xoffset;\n\t}\n\telse if( j == endx-1 ){\n\t  // If this is the final row, calculate the remaining number of pixels\n\t  remainder = (width+x) % basic_tile_width;\n\t  if( remainder != 0 ) dst_tile_width = remainder;\n\t}\n\n\tif( i == starty ){\n\t  // Calculate the height used in the current row of tiles\n\t  // If there is only 1 row the height is just the view height\n\t  if( i &lt; endy - 1 ) dst_tile_height = src_tile_height - yoffset;\n\t  else dst_tile_height = height;\n\t  yf = yoffset;\n\t}\n\telse if( i == endy-1 ){\n\t  // If this is the final row, calculate the remaining number of pixels\n\t  remainder = (height+y) % basic_tile_height;\n\t  if( remainder != 0 ) dst_tile_height = remainder;\n\t}\n\n\tif( loglevel &gt;= 5 ){\n\t  *logfile &lt;&lt; "TileManager getRegion :: destination tile width: " &lt;&lt; dst_tile_width\n\t\t   &lt;&lt; ", tile height: " &lt;&lt; dst_tile_height &lt;&lt; endl;\n\t}\n      }\n\n\n      // Copy our tile data into the appropriate part of the strip memory\n      // one whole tile width at a time\n      for( unsigned int k=0; k&lt;dst_tile_height; k++ ){\n\n\tbuffer_index = (current_width*channels) + (k*width*channels) + (current_height*width*channels);\n\tunsigned int inx = ((k+yf)*rawtile.width*channels) + (xf*channels);\n\n\t// Simply copy the line of data across\n\tif( bpc == 8 ){\n\t  unsigned char* ptr = (unsigned char*) rawtile.data;\n\t  unsigned char* buf = (unsigned char*) region.data;\n\t  memcpy( &amp;buf[buffer_index], &amp;ptr[inx], dst_tile_width*channels );\n\t}\n\telse if( bpc ==  16 ){\n\t  unsigned short* ptr = (unsigned short*) rawtile.data;\n\t  unsigned short* buf = (unsigned short*) region.data;\n\t  memcpy( &amp;buf[buffer_index], &amp;ptr[inx], dst_tile_width*channels*2 );\n\t}\n\telse if( bpc == 32 &amp;&amp; sampleType == FIXEDPOINT ){\n\t  unsigned int* ptr = (unsigned int*) rawtile.data;\n\t  unsigned int* buf = (unsigned int*) region.data;\n\t  memcpy( &amp;buf[buffer_index], &amp;ptr[inx], dst_tile_width*channels*4 );\n\t}\n\telse if( bpc == 32 &amp;&amp; sampleType == FLOATINGPOINT ){\n\t  float* ptr = (float*) rawtile.data;\n\t  float* buf = (float*) region.data;\n\t  memcpy( &amp;buf[buffer_index], &amp;ptr[inx], dst_tile_width*channels*4 );\n\t}\n      }\n\n      current_width += dst_tile_width;\n    }\n\n    current_height += dst_tile_height;\n\n  }\n\n  return region;\n\n}',
 'static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,\n\t\t\t const void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus-&gt;usb, usb_sndctrlpipe(pegasus-&gt;usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, buf, size, 100);\n\tif (ret &lt; 0)\n\t\tnetif_dbg(pegasus, drv, pegasus-&gt;net,\n\t\t\t  "%s returned %d\\n", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}',
 '  StringSanMatcher(int general_name_type, envoy::type::matcher::v3::StringMatcher matcher)\n      : general_name_type_(general_name_type), matcher_(matcher) {}',
 'void svhandler_flash_erase_sector(void) {\n  uint8_t sector = _param_1;\n\n  // Verify requested sector is allowed.\n  if (!allow_svhandler_flash_sector_num(sector)) return;\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Erase the sector.\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n\n  // Return flash status.\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &amp;= ~FLASH_CR_PG;\n\n  // lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}',
 '  QUInt16() : value(0) {}',
 'ast2obj_withitem(void* _o)\n{\n    withitem_ty o = (withitem_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(withitem_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_expr(o-&gt;context_expr);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &amp;PyId_context_expr, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o-&gt;optional_vars);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &amp;PyId_optional_vars, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}',
 'static int process_line(URLContext *h, char *line, int line_count,\n                        int *new_location)\n{\n    HTTPContext *s = h-&gt;priv_data;\n    const char *auto_method =  h-&gt;flags &amp; AVIO_FLAG_READ ? "POST" : "GET";\n    char *tag, *p, *end, *method, *resource, *version;\n    int ret;\n\n    /* end of header */\n    if (line[0] == \'\\0\') {\n        s-&gt;end_header = 1;\n        return 0;\n    }\n\n    p = line;\n    if (line_count == 0) {\n        if (s-&gt;is_connected_server) {\n            // HTTP method\n            method = p;\n            while (*p &amp;&amp; !av_isspace(*p))\n                p++;\n            *(p++) = \'\\0\';\n            av_log(h, AV_LOG_TRACE, "Received method: %s\\n", method);\n            if (s-&gt;method) {\n                if (av_strcasecmp(s-&gt;method, method)) {\n                    av_log(h, AV_LOG_ERROR, "Received and expected HTTP method do not match. (%s expected, %s received)\\n",\n                           s-&gt;method, method);\n                    return ff_http_averror(400, AVERROR(EIO));\n                }\n            } else {\n                // use autodetected HTTP method to expect\n                av_log(h, AV_LOG_TRACE, "Autodetected %s HTTP method\\n", auto_method);\n                if (av_strcasecmp(auto_method, method)) {\n                    av_log(h, AV_LOG_ERROR, "Received and autodetected HTTP method did not match "\n                           "(%s autodetected %s received)\\n", auto_method, method);\n                    return ff_http_averror(400, AVERROR(EIO));\n                }\n                if (!(s-&gt;method = av_strdup(method)))\n                    return AVERROR(ENOMEM);\n            }\n\n            // HTTP resource\n            while (av_isspace(*p))\n                p++;\n            resource = p;\n            while (!av_isspace(*p))\n                p++;\n            *(p++) = \'\\0\';\n            av_log(h, AV_LOG_TRACE, "Requested resource: %s\\n", resource);\n            if (!(s-&gt;resource = av_strdup(resource)))\n                return AVERROR(ENOMEM);\n\n            // HTTP version\n            while (av_isspace(*p))\n                p++;\n            version = p;\n            while (*p &amp;&amp; !av_isspace(*p))\n                p++;\n            *p = \'\\0\';\n            if (av_strncasecmp(version, "HTTP/", 5)) {\n                av_log(h, AV_LOG_ERROR, "Malformed HTTP version string.\\n");\n                return ff_http_averror(400, AVERROR(EIO));\n            }\n            av_log(h, AV_LOG_TRACE, "HTTP version string: %s\\n", version);\n        } else {\n            while (!av_isspace(*p) &amp;&amp; *p != \'\\0\')\n                p++;\n            while (av_isspace(*p))\n                p++;\n            s-&gt;http_code = strtol(p, &amp;end, 10);\n\n            av_log(h, AV_LOG_TRACE, "http_code=%d\\n", s-&gt;http_code);\n\n            if ((ret = check_http_code(h, s-&gt;http_code, end)) &lt; 0)\n                return ret;\n        }\n    } else {\n        while (*p != \'\\0\' &amp;&amp; *p != \':\')\n            p++;\n        if (*p != \':\')\n            return 1;\n\n        *p  = \'\\0\';\n        tag = line;\n        p++;\n        while (av_isspace(*p))\n            p++;\n        if (!av_strcasecmp(tag, "Location")) {\n            if ((ret = parse_location(s, p)) &lt; 0)\n                return ret;\n            *new_location = 1;\n        } else if (!av_strcasecmp(tag, "Content-Length") &amp;&amp; s-&gt;filesize == -1) {\n            s-&gt;filesize = strtoll(p, NULL, 10);\n        } else if (!av_strcasecmp(tag, "Content-Range")) {\n            parse_content_range(h, p);\n        } else if (!av_strcasecmp(tag, "Accept-Ranges") &amp;&amp;\n                   !strncmp(p, "bytes", 5) &amp;&amp;\n                   s-&gt;seekable == -1) {\n            h-&gt;is_streamed = 0;\n        } else if (!av_strcasecmp(tag, "Transfer-Encoding") &amp;&amp;\n                   !av_strncasecmp(p, "chunked", 7)) {\n            s-&gt;filesize  = -1;\n            s-&gt;chunksize = 0;\n        } else if (!av_strcasecmp(tag, "WWW-Authenticate")) {\n            ff_http_auth_handle_header(&amp;s-&gt;auth_state, tag, p);\n        } else if (!av_strcasecmp(tag, "Authentication-Info")) {\n            ff_http_auth_handle_header(&amp;s-&gt;auth_state, tag, p);\n        } else if (!av_strcasecmp(tag, "Proxy-Authenticate")) {\n            ff_http_auth_handle_header(&amp;s-&gt;proxy_auth_state, tag, p);\n        } else if (!av_strcasecmp(tag, "Connection")) {\n            if (!strcmp(p, "close"))\n                s-&gt;willclose = 1;\n        } else if (!av_strcasecmp(tag, "Server")) {\n            if (!av_strcasecmp(p, "AkamaiGHost")) {\n                s-&gt;is_akamai = 1;\n            } else if (!av_strncasecmp(p, "MediaGateway", 12)) {\n                s-&gt;is_mediagateway = 1;\n            }\n        } else if (!av_strcasecmp(tag, "Content-Type")) {\n            av_free(s-&gt;mime_type);\n            s-&gt;mime_type = av_strdup(p);\n        } else if (!av_strcasecmp(tag, "Set-Cookie")) {\n            if (parse_cookie(s, p, &amp;s-&gt;cookie_dict))\n                av_log(h, AV_LOG_WARNING, "Unable to parse \'%s\'\\n", p);\n        } else if (!av_strcasecmp(tag, "Icy-MetaInt")) {\n            s-&gt;icy_metaint = strtoll(p, NULL, 10);\n        } else if (!av_strncasecmp(tag, "Icy-", 4)) {\n            if ((ret = parse_icy(s, tag, p)) &lt; 0)\n                return ret;\n        } else if (!av_strcasecmp(tag, "Content-Encoding")) {\n            if ((ret = parse_content_encoding(h, p)) &lt; 0)\n                return ret;\n        }\n    }\n    return 1;\n}',
 'bool ZlibInStream::decompress(bool wait)\n{\n  if (!underlying)\n    throw Exception("ZlibInStream overrun: no underlying stream");\n\n  zs-&gt;next_out = (U8*)end;\n  zs-&gt;avail_out = start + bufSize - end;\n\n  size_t n = underlying-&gt;check(1, 1, wait);\n  if (n == 0) return false;\n  zs-&gt;next_in = (U8*)underlying-&gt;getptr();\n  zs-&gt;avail_in = underlying-&gt;getend() - underlying-&gt;getptr();\n  if (zs-&gt;avail_in &gt; bytesIn)\n    zs-&gt;avail_in = bytesIn;\n\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception("ZlibInStream: inflate failed");\n  }\n\n  bytesIn -= zs-&gt;next_in - underlying-&gt;getptr();\n  end = zs-&gt;next_out;\n  underlying-&gt;setptr(zs-&gt;next_in);\n  return true;\n}',
 'TfLiteStatus PrepareAny(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &amp;input));\n  TF_LITE_ENSURE_TYPES_EQ(context, input-&gt;type, kTfLiteBool);\n  return PrepareSimple(context, node);\n}',
 'svcauth_gss_accept_sec_context(struct svc_req *rqst,\n\t\t\t       struct rpc_gss_init_res *gr)\n{\n\tstruct svc_rpc_gss_data\t*gd;\n\tstruct rpc_gss_cred\t*gc;\n\tgss_buffer_desc\t\t recv_tok, seqbuf;\n\tgss_OID\t\t\t mech;\n\tOM_uint32\t\t maj_stat = 0, min_stat = 0, ret_flags, seq;\n\n\tlog_debug("in svcauth_gss_accept_context()");\n\n\tgd = SVCAUTH_PRIVATE(rqst-&gt;rq_xprt-&gt;xp_auth);\n\tgc = (struct rpc_gss_cred *)rqst-&gt;rq_clntcred;\n\tmemset(gr, 0, sizeof(*gr));\n\n\t/* Deserialize arguments. */\n\tmemset(&amp;recv_tok, 0, sizeof(recv_tok));\n\n\tif (!svc_getargs(rqst-&gt;rq_xprt, xdr_rpc_gss_init_args,\n\t\t\t (caddr_t)&amp;recv_tok))\n\t\treturn (FALSE);\n\n\tgr-&gt;gr_major = gss_accept_sec_context(&amp;gr-&gt;gr_minor,\n\t\t\t\t\t      &amp;gd-&gt;ctx,\n\t\t\t\t\t      svcauth_gss_creds,\n\t\t\t\t\t      &amp;recv_tok,\n\t\t\t\t\t      GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t      &amp;gd-&gt;client_name,\n\t\t\t\t\t      &amp;mech,\n\t\t\t\t\t      &amp;gr-&gt;gr_token,\n\t\t\t\t\t      &amp;ret_flags,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      NULL);\n\n\tsvc_freeargs(rqst-&gt;rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&amp;recv_tok);\n\n\tlog_status("accept_sec_context", gr-&gt;gr_major, gr-&gt;gr_minor);\n\tif (gr-&gt;gr_major != GSS_S_COMPLETE &amp;&amp;\n\t    gr-&gt;gr_major != GSS_S_CONTINUE_NEEDED) {\n\t\tbadauth(gr-&gt;gr_major, gr-&gt;gr_minor, rqst-&gt;rq_xprt);\n\t\tgd-&gt;ctx = GSS_C_NO_CONTEXT;\n\t\tgoto errout;\n\t}\n\t/*\n\t * ANDROS: krb5 mechglue returns ctx of size 8 - two pointers,\n\t * one to the mechanism oid, one to the internal_ctx_id\n\t */\n\tif ((gr-&gt;gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) {\n\t\tfprintf(stderr, "svcauth_gss_accept_context: out of memory\\n");\n\t\tgoto errout;\n\t}\n\tmemcpy(gr-&gt;gr_ctx.value, gd-&gt;ctx, sizeof(gss_union_ctx_id_desc));\n\tgr-&gt;gr_ctx.length = sizeof(gss_union_ctx_id_desc);\n\n\t/* gr-&gt;gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */\n\tgr-&gt;gr_win = sizeof(gd-&gt;seqmask) * 8;\n\n\t/* Save client info. */\n\tgd-&gt;sec.mech = mech;\n\tgd-&gt;sec.qop = GSS_C_QOP_DEFAULT;\n\tgd-&gt;sec.svc = gc-&gt;gc_svc;\n\tgd-&gt;seq = gc-&gt;gc_seq;\n\tgd-&gt;win = gr-&gt;gr_win;\n\n\tif (gr-&gt;gr_major == GSS_S_COMPLETE) {\n#ifdef SPKM\n\t\t/* spkm3: no src_name (anonymous) */\n\t\tif(!g_OID_equal(gss_mech_spkm3, mech)) {\n#endif\n\t\t    maj_stat = gss_display_name(&amp;min_stat, gd-&gt;client_name,\n\t\t\t\t\t    &amp;gd-&gt;cname, &amp;gd-&gt;sec.mech);\n#ifdef SPKM\n\t\t}\n#endif\n\t\tif (maj_stat != GSS_S_COMPLETE) {\n\t\t\tlog_status("display_name", maj_stat, min_stat);\n\t\t\tgoto errout;\n\t\t}\n#ifdef DEBUG\n#ifdef HAVE_HEIMDAL\n\t\tlog_debug("accepted context for %.*s with "\n\t\t\t  "&lt;mech {} qop %d, svc %d&gt;",\n\t\t\t  gd-&gt;cname.length, (char *)gd-&gt;cname.value,\n\t\t\t  gd-&gt;sec.qop, gd-&gt;sec.svc);\n#else\n\t\t{\n\t\t\tgss_buffer_desc mechname;\n\n\t\t\tgss_oid_to_str(&amp;min_stat, mech, &amp;mechname);\n\n\t\t\tlog_debug("accepted context for %.*s with "\n\t\t\t\t  "&lt;mech %.*s, qop %d, svc %d&gt;",\n\t\t\t\t  gd-&gt;cname.length, (char *)gd-&gt;cname.value,\n\t\t\t\t  mechname.length, (char *)mechname.value,\n\t\t\t\t  gd-&gt;sec.qop, gd-&gt;sec.svc);\n\n\t\t\tgss_release_buffer(&amp;min_stat, &amp;mechname);\n\t\t}\n#endif\n#endif /* DEBUG */\n\t\tseq = htonl(gr-&gt;gr_win);\n\t\tseqbuf.value = &amp;seq;\n\t\tseqbuf.length = sizeof(seq);\n\n\t\tgss_release_buffer(&amp;min_stat, &amp;gd-&gt;checksum);\n\t\tmaj_stat = gss_sign(&amp;min_stat, gd-&gt;ctx, GSS_C_QOP_DEFAULT,\n\t\t\t\t    &amp;seqbuf, &amp;gd-&gt;checksum);\n\n\t\tif (maj_stat != GSS_S_COMPLETE) {\n\t\t\tgoto errout;\n\t\t}\n\n\n\t\trqst-&gt;rq_xprt-&gt;xp_verf.oa_flavor = RPCSEC_GSS;\n\t\trqst-&gt;rq_xprt-&gt;xp_verf.oa_base = gd-&gt;checksum.value;\n\t\trqst-&gt;rq_xprt-&gt;xp_verf.oa_length = gd-&gt;checksum.length;\n\t}\n\treturn (TRUE);\nerrout:\n\tgss_release_buffer(&amp;min_stat, &amp;gr-&gt;gr_token);\n\treturn (FALSE);\n}',
 'static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n{\n\tbool answer = false;\n\tchar *c2, *task_cg;\n\tsize_t target_len, task_len;\n\n\tif (strcmp(cg, "/") == 0)\n\t\treturn true;\n\n\tc2 = get_pid_cgroup(pid, contrl);\n\n\tif (!c2)\n\t\treturn false;\n\n\ttask_cg = c2 + 1;\n\ttarget_len = strlen(cg);\n\ttask_len = strlen(task_cg);\n\tif (strcmp(cg, task_cg) == 0) {\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len &lt; task_len) {\n\t\t/* looking up a parent dir */\n\t\tif (strncmp(task_cg, cg, target_len) == 0 &amp;&amp; task_cg[target_len] == \'/\')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len &gt; task_len) {\n\t\t/* looking up a child dir */\n\t\tif (strncmp(task_cg, cg, task_len) == 0 &amp;&amp; cg[task_len] == \'/\')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\nout:\n\tfree(c2);\n\treturn answer;\n}',
 'static int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd-&gt;id = CMD_SET_CTRL_MODE;\n\tcmd-&gt;len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd-&gt;u.ctrl_mode.tid = 0xff;\n\tcmd-&gt;u.ctrl_mode.channel = priv-&gt;channel;\n\n\tif (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LISTENONLY)\n\t\tcmd-&gt;u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd-&gt;u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\n\trc = kvaser_usb_send_cmd(priv-&gt;dev, cmd, cmd-&gt;len);\n\n\tkfree(cmd);\n\treturn rc;\n}',
 'static int dbConnect(char *host, char *user, char *passwd)\n{\n  DBUG_ENTER("dbConnect");\n  if (verbose)\n  {\n    fprintf(stderr, "# Connecting to %s...\\n", host ? host : "localhost");\n  }\n  mysql_init(&amp;mysql_connection);\n  if (opt_compress)\n    mysql_options(&amp;mysql_connection, MYSQL_OPT_COMPRESS, NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&amp;mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&amp;mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&amp;mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n#endif\n  if (opt_protocol)\n    mysql_options(&amp;mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&amp;opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&amp;mysql_connection, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) &amp;&amp; !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&amp;mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n\n  if (opt_plugin_dir &amp;&amp; *opt_plugin_dir)\n    mysql_options(&amp;mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n\n  if (opt_default_auth &amp;&amp; *opt_default_auth)\n    mysql_options(&amp;mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);\n\n  mysql_options(&amp;mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(&amp;mysql_connection, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(&amp;mysql_connection, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 "program_name", "mysqlcheck");\n  if (!(sock = mysql_real_connect(&amp;mysql_connection, host, user, passwd,\n         NULL, opt_mysql_port, opt_mysql_unix_port, 0)))\n  {\n    DBerror(&amp;mysql_connection, "when trying to connect");\n    DBUG_RETURN(1);\n  }\n  mysql_connection.reconnect= 1;\n  DBUG_RETURN(0);\n} /* dbConnect */',
 'int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n\n    options_defaults();\n    section=&amp;new_service_options;\n    if(options_file(configuration_file, type, &amp;section))\n        return 1;\n    if(init_section(1, &amp;section))\n        return 1;\n\n    s_log(LOG_NOTICE, "Configuration successful");\n    return 0;\n}',
 'static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client-&gt;context-&gt;rdp;\n\n\tswitch (rdp-&gt;state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp-&gt;nego-&gt;selected_protocol &amp; PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&amp;client-&gt;identity, &amp;(rdp-&gt;nego-&gt;transport-&gt;credssp-&gt;identity));\n\t\t\t\tIFCALLRET(client-&gt;Logon, client-&gt;authenticated, client, &amp;client-&gt;identity, TRUE);\n\t\t\t\tcredssp_free(rdp-&gt;nego-&gt;transport-&gt;credssp);\n\t\t\t\trdp-&gt;nego-&gt;transport-&gt;credssp = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client-&gt;Logon, client-&gt;authenticated, client, &amp;client-&gt;identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp-&gt;settings-&gt;DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp-&gt;state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client-&gt;Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) &lt; 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, "Invalid state %d\\n", rdp-&gt;state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}',
 "name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 &gt; length) goto err; memcpy(&amp;t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 &gt; length) goto err; memcpy(&amp;t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j &gt;= length) goto err; x = packet[j++]; } while (0)\n\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n\n\t/* Normally, names are a series of length prefixed strings terminated */\n\t/* with a length of 0 (the lengths are u8's &lt; 63). */\n\t/* However, the length can start with a pair of 1 bits and that */\n\t/* means that the next 14 bits are a pointer within the current */\n\t/* packet. */\n\n\tfor (;;) {\n\t\tu8 label_len;\n\t\tGET8(label_len);\n\t\tif (!label_len) break;\n\t\tif (label_len &amp; 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end &lt; 0) name_end = j;\n\t\t\tj = (((int)label_len &amp; 0x3f) &lt;&lt; 8) + ptr_low;\n\t\t\t/* Make sure that the target offset is in-bounds. */\n\t\t\tif (j &lt; 0 || j &gt;= length) return -1;\n\t\t\t/* If we've jumped more times than there are characters in the\n\t\t\t * message, we must have a loop. */\n\t\t\tif (++ptr_count &gt; length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len &gt; 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 &gt;= end) return -1;\n\t\t\t*cp++ = '.';\n\t\t}\n\t\tif (cp + label_len &gt;= end) return -1;\n\t\tif (j + label_len &gt; length) return -1;\n\t\tmemcpy(cp, packet + j, label_len);\n\t\tcp += label_len;\n\t\tj += label_len;\n\t}\n\tif (cp &gt;= end) return -1;\n\t*cp = '\\0';\n\tif (name_end &lt; 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}",
 'MONGO_EXPORT void *bson_malloc( size_t size ) {\n    void *p;\n    p = bson_malloc_func( size );\n    bson_fatal_msg( !!p, "malloc() failed" );\n    return p;\n}',
 'static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, "%s", "pcomp");\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &amp;rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}',
 "void carray2Hex(const unsigned char *d, uint64_t _len, char *_hexArray,\n                uint64_t _hexArrayLen) {\n\n    CHECK_STATE(d);\n    CHECK_STATE(_hexArray);\n\n    char hexval[16] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    CHECK_STATE(_hexArrayLen &gt; 2 * _len);\n\n    for (int j = 0; j &lt; _len; j++) {\n        _hexArray[j * 2] = hexval[((d[j] &gt;&gt; 4) &amp; 0xF)];\n        _hexArray[j * 2 + 1] = hexval[(d[j]) &amp; 0x0F];\n    }\n\n    _hexArray[_len * 2] = 0;\n}",
 'main(int argc, char **argv)\n{\n\tconst char *safepath = "/bin:/sbin:/usr/bin:/usr/sbin:"\n\t    "/usr/local/bin:/usr/local/sbin";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n#ifdef __OpenBSD__\n\tchar mypwbuf[_PW_BUF_LEN], targpwbuf[_PW_BUF_LEN];\n#else\n\tchar *mypwbuf = NULL, *targpwbuf = NULL;\n#endif\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n#ifdef USE_BSD_AUTH\n\tchar *login_style = NULL;\n#endif\n\n\tsetprogname("doas");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n#ifdef USE_BSD_AUTH\n# define OPTSTRING "a:C:Lnsu:"\n#else\n# define OPTSTRING "+C:Lnsu:"\n#endif\n\n\twhile ((ch = getopt(argc, argv, OPTSTRING)) != -1) {\n\t\tswitch (ch) {\n#ifdef USE_BSD_AUTH\n\t\tcase \'a\':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase \'C\':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase \'L\':\n#if defined(USE_BSD_AUTH)\n\t\t\ti = open("/dev/tty", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i == -1);\n#elif defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase \'u\':\n\t\t\tif (parseuid(optarg, &amp;target) != 0)\n\t\t\t\terrx(1, "unknown user");\n\t\t\tbreak;\n\t\tcase \'n\':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase \'s\':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag &amp;&amp; !argc) || (sflag &amp;&amp; argc))\n\t\tusage();\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(uid, &amp;mypwstore, mypwbuf, sizeof(mypwbuf), &amp;mypw);\n\tif (rv != 0)\n\t\terr(1, "getpwuid_r failed");\n#else\n\tfor (size_t sz = 1024; sz &lt;= 16*1024; sz *= 2) {\n\t\tmypwbuf = reallocarray(mypwbuf, sz, sizeof (char));\n\t\tif (mypwbuf == NULL)\n\t\t\terrx(1, "can\'t allocate mypwbuf");\n\t\trv = getpwuid_r(uid, &amp;mypwstore, mypwbuf, sz, &amp;mypw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, "getpwuid_r failed");\n#endif\n\tif (mypw == NULL)\n\t\terrx(1, "no passwd entry for self");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, "can\'t get groups");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv("SHELL");\n\t\tif (sh == NULL || *sh == \'\\0\') {\n\t\t\tshargv[0] = mypw-&gt;pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, "not installed setuid");\n\n\tparseconfig("/etc/doas.conf", 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i &lt; argc; i++) {\n\t\tif (strlcat(cmdline, " ", sizeof(cmdline)) &gt;= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) &gt;= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &amp;rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    "failed command for %s: %s", mypw-&gt;pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(__OpenBSD__) || defined(USE_SHADOW)\n\tif (!(rule-&gt;options &amp; NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, "Authorization required");\n\n# ifdef __OpenBSD__\n\t\tauthuser(mypw-&gt;pw_name, login_style, rule-&gt;options &amp; PERSIST);\n# else\n\t\tshadowauth(mypw-&gt;pw_name, rule-&gt;options &amp; PERSIST);\n# endif\n\t}\n\n# ifdef __OpenBSD__\n\tif (pledge("stdio rpath getpw exec id", NULL) == -1)\n\t\terr(1, "pledge");\n# endif\n\n#elif !defined(USE_PAM)\n\t(void) nflag;\n\tif (!(rule-&gt;options &amp; NOPASS)) {\n\t\terrx(1, "Authorization required");\n\t}\n#endif /* !(__OpenBSD__ || USE_SHADOW) &amp;&amp; !USE_PAM */\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(target, &amp;targpwstore, targpwbuf, sizeof(targpwbuf), &amp;targpw);\n\tif (rv != 0)\n\t\terrx(1, "no passwd entry for target");\n#else\n\tfor (size_t sz = 1024; sz &lt;= 16*1024; sz *= 2) {\n\t\ttargpwbuf = reallocarray(targpwbuf, sz, sizeof (char));\n\t\tif (targpwbuf == NULL)\n\t\t\terrx(1, "can\'t allocate targpwbuf");\n\t\trv = getpwuid_r(target, &amp;targpwstore, targpwbuf, sz, &amp;targpw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, "getpwuid_r failed");\n#endif\n\tif (targpw == NULL)\n\t\terr(1, "getpwuid_r failed");\n\n#if defined(USE_PAM)\n\tpamauth(targpw-&gt;pw_name, mypw-&gt;pw_name, !nflag, rule-&gt;options &amp; NOPASS,\n\t    rule-&gt;options &amp; PERSIST);\n#endif\n\n#ifdef HAVE_SETUSERCONTEXT\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPATH |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, "failed to set user context for target");\n#else\n\tif (setresgid(targpw-&gt;pw_gid, targpw-&gt;pw_gid, targpw-&gt;pw_gid) != 0)\n\t\terr(1, "setresgid");\n\tif (initgroups(targpw-&gt;pw_name, targpw-&gt;pw_gid) != 0)\n\t\terr(1, "initgroups");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, "setresuid");\n#endif\n\n#ifdef __OpenBSD__\n\tif (pledge("stdio rpath exec", NULL) == -1)\n\t\terr(1, "pledge");\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = "(failed)";\n\telse\n\t\tcwd = cwdpath;\n\n#ifdef __OpenBSD__\n\tif (pledge("stdio exec", NULL) == -1)\n\t\terr(1, "pledge");\n#endif\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, "%s ran command %s as %s from %s",\n\t    mypw-&gt;pw_name, cmdline, targpw-&gt;pw_name, cwd);\n\n\tenvp = prepenv(rule, mypw, targpw);\n\n\tif (rule-&gt;cmd) {\n\t\t/* do this again after setusercontext reset it */\n\t\tif (setenv("PATH", safepath, 1) == -1)\n\t\t\terr(1, "failed to set PATH \'%s\'", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, "%s: command not found", cmd);\n\terr(1, "%s", cmd);\n}',
 'PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &amp;tif-&gt;tif_dir;\n\n\t/* In a really sneaky (and really incorrect, and untruthful, and\n\t * troublesome, and error-prone) maneuver that completely goes against\n\t * the spirit of TIFF, and breaks TIFF, on close, we covertly\n\t * modify both bitspersample and sampleformat in the directory to\n\t * indicate 8-bit linear.  This way, the decode "just works" even for\n\t * readers that don\'t know about PixarLog, or how to set\n\t * the PIXARLOGDATFMT pseudo-tag.\n\t */\n\ttd-&gt;td_bitspersample = 8;\n\ttd-&gt;td_sampleformat = SAMPLEFORMAT_UINT;\n}',
 'unsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size &gt; 0) ? *size : strlen(buf);\n\tif (len &lt;= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tsize_t l = 0;\n\n\tdo {\n\t\tptr += strspn(ptr, "\\r\\n\\t ");\n\t\tif (*ptr == \'\\0\' || ptr &gt;= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tl = strcspn(ptr, "\\r\\n\\t ");\n\t\tif (l &gt; 3 &amp;&amp; ptr+l &lt;= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}',
 'get_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)\n{\n    static gpols_ret                ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gpols_ret, &amp;ret);\n\n    if ((ret.code = new_server_handle(arg-&gt;api_version, rqstp, &amp;handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle-&gt;api_version;\n\n    if (setup_gss_names(rqstp, &amp;client_name, &amp;service_name) &lt; 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg-&gt;exp;\n    if (prime_arg == NULL)\n        prime_arg = "*";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle-&gt;context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST, NULL, NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth("kadm5_get_policies", prime_arg,\n                   &amp;client_name, &amp;service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_policies((void *)handle,\n                                       arg-&gt;exp, &amp;ret.pols,\n                                       &amp;ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle-&gt;context, ret.code);\n\n        log_done("kadm5_get_policies", prime_arg, errmsg,\n                 &amp;client_name, &amp;service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle-&gt;context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&amp;minor_stat, &amp;client_name);\n    gss_release_buffer(&amp;minor_stat, &amp;service_name);\n    free_server_handle(handle);\n    return &amp;ret;\n}',
 'static int sd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct gendisk *disk = bdev-&gt;bd_disk;\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdp = sdkp-&gt;device;\n\tvoid __user *p = (void __user *)arg;\n\tint error;\n    \n\tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, "sd_ioctl: disk=%s, "\n\t\t\t\t    "cmd=0x%x\\n", disk-&gt;disk_name, cmd));\n\n\terror = scsi_verify_blk_ioctl(bdev, cmd);\n\tif (error &lt; 0)\n\t\treturn error;\n\n\t/*\n\t * If we are in the middle of error recovery, don\'t let anyone\n\t * else try and use this device.  Also, if error recovery fails, it\n\t * may try and take the device offline, in which case all further\n\t * access to the device is prohibited.\n\t */\n\terror = scsi_nonblockable_ioctl(sdp, cmd, p,\n\t\t\t\t\t(mode &amp; FMODE_NDELAY) != 0);\n\tif (!scsi_block_when_processing_errors(sdp) || !error)\n\t\tgoto out;\n\n\t/*\n\t * Send SCSI addressing ioctls directly to mid level, send other\n\t * ioctls to block level and then onto mid level if they can\'t be\n\t * resolved.\n\t */\n\tswitch (cmd) {\n\t\tcase SCSI_IOCTL_GET_IDLUN:\n\t\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = scsi_cmd_blk_ioctl(bdev, mode, cmd, p);\n\t\t\tif (error != -ENOTTY)\n\t\t\t\tbreak;\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t}\nout:\n\treturn error;\n}',
 "error_t ipStringToAddr(const char_t *str, IpAddr *ipAddr)\n{\n   error_t error;\n\n#if (IPV6_SUPPORT == ENABLED)\n   //IPv6 address?\n   if(strchr(str, ':'))\n   {\n      //IPv6 addresses are 16-byte long\n      ipAddr-&gt;length = sizeof(Ipv6Addr);\n      //Convert the string to IPv6 address\n      error = ipv6StringToAddr(str, &amp;ipAddr-&gt;ipv6Addr);\n   }\n   else\n#endif\n#if (IPV4_SUPPORT == ENABLED)\n   //IPv4 address?\n   if(strchr(str, '.'))\n   {\n      //IPv4 addresses are 4-byte long\n      ipAddr-&gt;length = sizeof(Ipv4Addr);\n      //Convert the string to IPv4 address\n      error = ipv4StringToAddr(str, &amp;ipAddr-&gt;ipv4Addr);\n   }\n   else\n#endif\n   //Invalid IP address?\n   {\n      //Report an error\n      error = ERROR_FAILURE;\n   }\n\n   //Return status code\n   return error;\n}",
 'uint16_t dm9000ReadPhyReg(uint8_t address)\n{\n   //Write PHY register address\n   dm9000WriteReg(DM9000_REG_EPAR, 0x40 | address);\n\n   //Start the read operation\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS | EPCR_ERPRR);\n   //PHY access is still in progress?\n   while((dm9000ReadReg(DM9000_REG_EPCR) &amp; EPCR_ERRE) != 0)\n   {\n   }\n\n   //Clear command register\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS);\n   //Wait 5us minimum\n   usleep(5);\n\n   //Return register value\n   return (dm9000ReadReg(DM9000_REG_EPDRH) &lt;&lt; 8) | dm9000ReadReg(DM9000_REG_EPDRL);\n}',
 'struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\n\tif (dst == NULL &amp;&amp; (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tsk_setup_caps(newsk, dst);\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet-&gt;inet_daddr\t= ireq-&gt;rmt_addr;\n\tnewinet-&gt;inet_rcv_saddr = ireq-&gt;loc_addr;\n\tnewinet-&gt;inet_saddr\t= ireq-&gt;loc_addr;\n\tnewinet-&gt;opt\t   = ireq-&gt;opt;\n\tireq-&gt;opt\t   = NULL;\n\tnewinet-&gt;mc_index  = inet_iif(skb);\n\tnewinet-&gt;mc_ttl\t   = ip_hdr(skb)-&gt;ttl;\n\tnewinet-&gt;inet_id   = jiffies;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) &lt; 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}',
 'static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &amp;__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\n\tfor (i = 0; i &lt; ppmu-&gt;n_counter; ++i) {\n\t\tevent = cpuhw-&gt;event[i];\n\n\t\tval = read_pmc(i);\n\t\tif ((int)val &lt; 0) {\n\t\t\tif (event) {\n\t\t\t\t/* event has overflowed */\n\t\t\t\tfound = 1;\n\t\t\t\trecord_and_restart(event, val, regs);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Disabled counter is negative,\n\t\t\t\t * reset it just in case.\n\t\t\t\t */\n\t\t\t\twrite_pmc(i, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* PMM will keep counters frozen until we return from the interrupt. */\n\tmtmsr(mfmsr() | MSR_PMM);\n\tmtpmr(PMRN_PMGC0, PMGC0_PMIE | PMGC0_FCECE);\n\tisync();\n\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}',
 'static int connect_to_master(THD* thd, MYSQL* mysql, Master_info* mi,\n                             bool reconnect, bool suppress_warnings)\n{\n  int slave_was_killed= 0;\n  int last_errno= -2;                           // impossible error\n  ulong err_count=0;\n  char llbuff[22];\n  char password[MAX_PASSWORD_LENGTH + 1];\n  int password_size= sizeof(password);\n  DBUG_ENTER("connect_to_master");\n  set_slave_max_allowed_packet(thd, mysql);\n#ifndef DBUG_OFF\n  mi-&gt;events_until_exit = disconnect_slave_event_count;\n#endif\n  ulong client_flag= CLIENT_REMEMBER_OPTIONS;\n  if (opt_slave_compressed_protocol)\n    client_flag=CLIENT_COMPRESS;                /* We will use compression */\n\n  mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, (char *) &amp;slave_net_timeout);\n  mysql_options(mysql, MYSQL_OPT_READ_TIMEOUT, (char *) &amp;slave_net_timeout);\n\n  if (mi-&gt;bind_addr[0])\n  {\n    DBUG_PRINT("info",("bind_addr: %s", mi-&gt;bind_addr));\n    mysql_options(mysql, MYSQL_OPT_BIND, mi-&gt;bind_addr);\n  }\n\n#ifdef HAVE_OPENSSL\n  if (mi-&gt;ssl)\n  {\n    mysql_ssl_set(mysql,\n                  mi-&gt;ssl_key[0]?mi-&gt;ssl_key:0,\n                  mi-&gt;ssl_cert[0]?mi-&gt;ssl_cert:0,\n                  mi-&gt;ssl_ca[0]?mi-&gt;ssl_ca:0,\n                  mi-&gt;ssl_capath[0]?mi-&gt;ssl_capath:0,\n                  mi-&gt;ssl_cipher[0]?mi-&gt;ssl_cipher:0);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, \n                  mi-&gt;ssl_crl[0] ? mi-&gt;ssl_crl : 0);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, \n                  mi-&gt;ssl_crlpath[0] ? mi-&gt;ssl_crlpath : 0);\n    mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                  &amp;mi-&gt;ssl_verify_server_cert);\n  }\n#endif\n\n  mysql_options(mysql, MYSQL_SET_CHARSET_NAME, default_charset_info-&gt;csname);\n  /* This one is not strictly needed but we have it here for completeness */\n  mysql_options(mysql, MYSQL_SET_CHARSET_DIR, (char *) charsets_dir);\n\n  if (mi-&gt;is_start_plugin_auth_configured())\n  {\n    DBUG_PRINT("info", ("Slaving is using MYSQL_DEFAULT_AUTH %s",\n                        mi-&gt;get_start_plugin_auth()));\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, mi-&gt;get_start_plugin_auth());\n  }\n  \n  if (mi-&gt;is_start_plugin_dir_configured())\n  {\n    DBUG_PRINT("info", ("Slaving is using MYSQL_PLUGIN_DIR %s",\n                        mi-&gt;get_start_plugin_dir()));\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, mi-&gt;get_start_plugin_dir());\n  }\n  /* Set MYSQL_PLUGIN_DIR in case master asks for an external authentication plugin */\n  else if (opt_plugin_dir_ptr &amp;&amp; *opt_plugin_dir_ptr)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir_ptr);\n  \n  if (!mi-&gt;is_start_user_configured())\n    sql_print_warning("%s", ER(ER_INSECURE_CHANGE_MASTER));\n\n  if (mi-&gt;get_password(password, &amp;password_size))\n  {\n    mi-&gt;report(ERROR_LEVEL, ER_SLAVE_FATAL_ERROR,\n               ER(ER_SLAVE_FATAL_ERROR),\n               "Unable to configure password when attempting to "\n               "connect to the master server. Connection attempt "\n               "terminated.");\n    DBUG_RETURN(1);\n  }\n\n  const char* user= mi-&gt;get_user();\n  if (user == NULL || user[0] == 0)\n  {\n    mi-&gt;report(ERROR_LEVEL, ER_SLAVE_FATAL_ERROR,\n               ER(ER_SLAVE_FATAL_ERROR),\n               "Invalid (empty) username when attempting to "\n               "connect to the master server. Connection attempt "\n               "terminated.");\n    DBUG_RETURN(1);\n  }\n\n  while (!(slave_was_killed = io_slave_killed(thd,mi))\n         &amp;&amp; (reconnect ? mysql_reconnect(mysql) != 0 :\n             mysql_real_connect(mysql, mi-&gt;host, user,\n                                password, 0, mi-&gt;port, 0, client_flag) == 0))\n  {\n    /*\n       SHOW SLAVE STATUS will display the number of retries which\n       would be real retry counts instead of mi-&gt;retry_count for\n       each connection attempt by \'Last_IO_Error\' entry.\n    */\n    last_errno=mysql_errno(mysql);\n    suppress_warnings= 0;\n    mi-&gt;report(ERROR_LEVEL, last_errno,\n               "error %s to master \'%s@%s:%d\'"\n               " - retry-time: %d  retries: %lu",\n               (reconnect ? "reconnecting" : "connecting"),\n               mi-&gt;get_user(), mi-&gt;host, mi-&gt;port,\n               mi-&gt;connect_retry, err_count + 1);\n    /*\n      By default we try forever. The reason is that failure will trigger\n      master election, so if the user did not set mi-&gt;retry_count we\n      do not want to have election triggered on the first failure to\n      connect\n    */\n    if (++err_count == mi-&gt;retry_count)\n    {\n      slave_was_killed=1;\n      break;\n    }\n    slave_sleep(thd, mi-&gt;connect_retry, io_slave_killed, mi);\n  }\n\n  if (!slave_was_killed)\n  {\n    mi-&gt;clear_error(); // clear possible left over reconnect error\n    if (reconnect)\n    {\n      if (!suppress_warnings)\n        sql_print_information("Slave: connected to master \'%s@%s:%d\',\\\nreplication resumed in log \'%s\' at position %s", mi-&gt;get_user(),\n                              mi-&gt;host, mi-&gt;port,\n                              mi-&gt;get_io_rpl_log_name(),\n                              llstr(mi-&gt;get_master_log_pos(),llbuff));\n    }\n    else\n    {\n      query_logger.general_log_print(thd, COM_CONNECT_OUT, "%s@%s:%d",\n                                     mi-&gt;get_user(), mi-&gt;host, mi-&gt;port);\n    }\n\n    thd-&gt;set_active_vio(mysql-&gt;net.vio);\n  }\n  mysql-&gt;reconnect= 1;\n  DBUG_PRINT("exit",("slave_was_killed: %d", slave_was_killed));\n  DBUG_RETURN(slave_was_killed);\n}',
 'static Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info-&gt;signature == MagickCoreSignature);\n  if (image_info-&gt;debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",\n      image_info-&gt;filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception-&gt;signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,"wb");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,"UnableToCreateTemporaryFile");\n  length=fwrite("\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000",1,10,file);\n  length=fwrite("\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000",1,12,file);\n  length=fwrite("\\000\\001\\004\\000\\001\\000\\000\\000",1,8,file);\n  length=WriteLSBLong(file,image-&gt;columns);\n  length=fwrite("\\001\\001\\004\\000\\001\\000\\000\\000",1,8,file);\n  length=WriteLSBLong(file,image-&gt;rows);\n  length=fwrite("\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000",1,12,file);\n  length=fwrite("\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000",1,12,file);\n  length=fwrite("\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000",1,12,file);\n  length=fwrite("\\021\\001\\003\\000\\001\\000\\000\\000",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite("\\022\\001\\003\\000\\001\\000\\000\\000",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info-&gt;orientation);\n  length=fwrite("\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000",1,12,file);\n  length=fwrite("\\026\\001\\004\\000\\001\\000\\000\\000",1,8,file);\n  length=WriteLSBLong(file,image-&gt;rows);\n  length=fwrite("\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite("\\032\\001\\005\\000\\001\\000\\000\\000",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite("\\033\\001\\005\\000\\001\\000\\000\\000",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite("\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000",1,12,file);\n  length=fwrite("\\000\\000\\000\\000",1,4,file);\n  length=WriteLSBLong(file,(long) image-&gt;resolution.x);\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info-&gt;filename,MagickPathExtent,"%s",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image-&gt;filename,image_info-&gt;filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image-&gt;magick_filename,image_info-&gt;filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image-&gt;magick,"GROUP4",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}',
 "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -&gt; B, the other from B -&gt; A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe-&gt;readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ipipe-&gt;nrbufs &amp;&amp; !ipipe-&gt;writers)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Cannot make any progress, because either the input\n\t\t * pipe is empty or the output pipe is full.\n\t\t */\n\t\tif (!ipipe-&gt;nrbufs || opipe-&gt;nrbufs &gt;= opipe-&gt;buffers) {\n\t\t\t/* Already processed some buffers, break */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags &amp; SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We raced with another reader/writer and haven't\n\t\t\t * managed to process any buffers.  A zero return\n\t\t\t * value means EOF, so retry instead.\n\t\t\t */\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = ipipe-&gt;bufs + ipipe-&gt;curbuf;\n\t\tnbuf = (opipe-&gt;curbuf + opipe-&gt;nrbufs) &amp; (opipe-&gt;buffers - 1);\n\t\tobuf = opipe-&gt;bufs + nbuf;\n\n\t\tif (len &gt;= ibuf-&gt;len) {\n\t\t\t/*\n\t\t\t * Simply move the whole buffer from ipipe to opipe\n\t\t\t */\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf-&gt;ops = NULL;\n\t\t\topipe-&gt;nrbufs++;\n\t\t\tipipe-&gt;curbuf = (ipipe-&gt;curbuf + 1) &amp; (ipipe-&gt;buffers - 1);\n\t\t\tipipe-&gt;nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf-&gt;flags &amp;= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf-&gt;len = len;\n\t\t\topipe-&gt;nrbufs++;\n\t\t\tibuf-&gt;offset += obuf-&gt;len;\n\t\t\tibuf-&gt;len -= obuf-&gt;len;\n\t\t}\n\t\tret += obuf-&gt;len;\n\t\tlen -= obuf-&gt;len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret &gt; 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}",
 'int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL &amp; ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred-&gt;user;\n\tuid = from_kuid(cred-&gt;user_ns, user-&gt;uid);\n\n\tkenter("%p{%u}", user, uid);\n\n\tif (user-&gt;uid_keyring &amp;&amp; user-&gt;session_keyring) {\n\t\tkleave(" = 0 [exist]");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&amp;key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user-&gt;uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, "_uid.%u", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user-&gt;uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, "_uid_ses.%u", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user-&gt;uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret &lt; 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser-&gt;uid_keyring = uid_keyring;\n\t\tuser-&gt;session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&amp;key_user_keyring_mutex);\n\tkleave(" = 0");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&amp;key_user_keyring_mutex);\n\tkleave(" = %d", ret);\n\treturn ret;\n}',
 'handle_associated_event(struct cpu_hw_events *cpuc,\n\tint idx, struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event *event = cpuc-&gt;events[idx];\n\tstruct hw_perf_event *hwc = &amp;event-&gt;hw;\n\n\tmipspmu_event_update(event, hwc, idx);\n\tdata-&gt;period = event-&gt;hw.last_period;\n\tif (!mipspmu_event_set_period(event, hwc, idx))\n\t\treturn;\n\n\tif (perf_event_overflow(event, 0, data, regs))\n\t\tmipspmu-&gt;disable_event(idx);\n}',
 'header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tpsf-&gt;header.ptr [psf-&gt;header.indx++] = x ;\n\tpsf-&gt;header.ptr [psf-&gt;header.indx++] = (x &gt;&gt; 8) ;\n\tpsf-&gt;header.ptr [psf-&gt;header.indx++] = (x &gt;&gt; 16) ;\n\tpsf-&gt;header.ptr [psf-&gt;header.indx++] = (x &gt;&gt; 24) ;\n\tpsf-&gt;header.ptr [psf-&gt;header.indx++] = (x &gt;&gt; 32) ;\n\tpsf-&gt;header.ptr [psf-&gt;header.indx++] = (x &gt;&gt; 40) ;\n\tpsf-&gt;header.ptr [psf-&gt;header.indx++] = (x &gt;&gt; 48) ;\n\tpsf-&gt;header.ptr [psf-&gt;header.indx++] = (x &gt;&gt; 56) ;\n} /* header_put_le_8byte */',
 'static ssize_t _hostfs_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || !iov || iovcnt &lt; 0 || iovcnt &gt; OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &amp;buf, &amp;buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_writev_ocall(&amp;ret, file-&gt;host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}',
 'static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct ems_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &amp;netdev-&gt;stats;\n\tstruct can_frame *cf = (struct can_frame *)skb-&gt;data;\n\tstruct ems_cpc_msg *msg;\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN\n\t\t\t+ sizeof(struct cpc_can_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(dev-&gt;udev, size, GFP_ATOMIC, &amp;urb-&gt;transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, "No memory left for USB buffer\\n");\n\t\tusb_free_urb(urb);\n\t\tgoto nomem;\n\t}\n\n\tmsg = (struct ems_cpc_msg *)&amp;buf[CPC_HEADER_SIZE];\n\n\tmsg-&gt;msg.can_msg.id = cpu_to_le32(cf-&gt;can_id &amp; CAN_ERR_MASK);\n\tmsg-&gt;msg.can_msg.length = cf-&gt;len;\n\n\tif (cf-&gt;can_id &amp; CAN_RTR_FLAG) {\n\t\tmsg-&gt;type = cf-&gt;can_id &amp; CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;\n\n\t\tmsg-&gt;length = CPC_CAN_MSG_MIN_SIZE;\n\t} else {\n\t\tmsg-&gt;type = cf-&gt;can_id &amp; CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;\n\n\t\tfor (i = 0; i &lt; cf-&gt;len; i++)\n\t\t\tmsg-&gt;msg.can_msg.msg[i] = cf-&gt;data[i];\n\n\t\tmsg-&gt;length = CPC_CAN_MSG_MIN_SIZE + cf-&gt;len;\n\t}\n\n\tfor (i = 0; i &lt; MAX_TX_URBS; i++) {\n\t\tif (dev-&gt;tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &amp;dev-&gt;tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * May never happen! When this happens we\'d more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context) {\n\t\tusb_free_coherent(dev-&gt;udev, size, buf, urb-&gt;transfer_dma);\n\t\tusb_free_urb(urb);\n\n\t\tnetdev_warn(netdev, "couldn\'t find free context\\n");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcontext-&gt;dev = dev;\n\tcontext-&gt;echo_index = i;\n\n\tusb_fill_bulk_urb(urb, dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, 2), buf,\n\t\t\t  size, ems_usb_write_bulk_callback, context);\n\turb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &amp;dev-&gt;tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context-&gt;echo_index, 0);\n\n\tatomic_inc(&amp;dev-&gt;active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context-&gt;echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev-&gt;udev, size, buf, urb-&gt;transfer_dma);\n\t\tdev_kfree_skb(skb);\n\n\t\tatomic_dec(&amp;dev-&gt;active_tx_urbs);\n\n\t\tif (err == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_warn(netdev, "failed tx_urb %d\\n", err);\n\n\t\t\tstats-&gt;tx_dropped++;\n\t\t}\n\t} else {\n\t\tnetif_trans_update(netdev);\n\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&amp;dev-&gt;active_tx_urbs) &gt;= MAX_TX_URBS ||\n\t\t    dev-&gt;free_slots &lt; CPC_TX_QUEUE_TRIGGER_LOW) {\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\n\t/*\n\t * Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats-&gt;tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}',
 'PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n\n  SgxParams *const sgx_params =\n      reinterpret_cast&lt;SgxParams *&gt;(untrusted_cache-&gt;Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        "UntrustedCall: sgx_param should be in untrusted memory");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache-&gt;Free(sgx_params); });\n  sgx_params-&gt;input_size = 0;\n  sgx_params-&gt;input = nullptr;\n  if (input) {\n    sgx_params-&gt;input_size = input-&gt;MessageSize();\n    if (sgx_params-&gt;input_size &gt; 0) {\n      // Allocate and copy data to |input_buffer|.\n      sgx_params-&gt;input = untrusted_cache-&gt;Malloc(sgx_params-&gt;input_size);\n      const void *input_pointer = sgx_params-&gt;input;\n      uint64_t input_size = sgx_params-&gt;input_size;\n      if (!TrustedPrimitives::IsOutsideEnclave(input_pointer, input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            "UntrustedCall: sgx_param input should be in untrusted memory");\n      }\n      input-&gt;Serialize(const_cast&lt;void *&gt;(input_pointer));\n    }\n  }\n  sgx_params-&gt;output_size = 0;\n  sgx_params-&gt;output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&amp;ret, untrusted_selector, sgx_params));\n  if (sgx_params-&gt;input) {\n    untrusted_cache-&gt;Free(const_cast&lt;void *&gt;(sgx_params-&gt;input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params-&gt;output,\n                                           sgx_params-&gt;output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        "UntrustedCall: sgx_param output should be in untrusted memory");\n  }\n  if (sgx_params-&gt;output) {\n    // For the results obtained in |output_buffer|, copy them to |output|\n    // before freeing the buffer.\n    output-&gt;Deserialize(sgx_params-&gt;output, sgx_params-&gt;output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params-&gt;output);\n  }\n  return PrimitiveStatus::OkStatus();\n}',
 'int ssl3_get_key_exchange(SSL *s)\n\t{\n#ifndef OPENSSL_NO_RSA\n\tunsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];\n#endif\n\tEVP_MD_CTX md_ctx;\n\tunsigned char *param,*p;\n\tint al,j,ok;\n\tlong i,param_len,n,alg_k,alg_a;\n\tEVP_PKEY *pkey=NULL;\n\tconst EVP_MD *md = NULL;\n#ifndef OPENSSL_NO_RSA\n\tRSA *rsa=NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n\tDH *dh=NULL;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tEC_KEY *ecdh = NULL;\n\tBN_CTX *bn_ctx = NULL;\n\tEC_POINT *srvr_ecpoint = NULL;\n\tint curve_nid = 0;\n\tint encoded_pt_len = 0;\n#endif\n\n\t/* use same message size as in ssl3_get_certificate_request()\n\t * as ServerKeyExchange message may be skipped */\n\tn=s-&gt;method-&gt;ssl_get_message(s,\n\t\tSSL3_ST_CR_KEY_EXCH_A,\n\t\tSSL3_ST_CR_KEY_EXCH_B,\n\t\t-1,\n\t\ts-&gt;max_cert_list,\n\t\t&amp;ok);\n\tif (!ok) return((int)n);\n\n\tif (s-&gt;s3-&gt;tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\n\t\t{\n#ifndef OPENSSL_NO_PSK\n\t\t/* In plain PSK ciphersuite, ServerKeyExchange can be\n\t\t   omitted if no identity hint is sent. Set\n\t\t   session-&gt;sess_cert anyway to avoid problems\n\t\t   later.*/\n\t\tif (s-&gt;s3-&gt;tmp.new_cipher-&gt;algorithm_mkey &amp; SSL_kPSK)\n\t\t\t{\n\t\t\ts-&gt;session-&gt;sess_cert=ssl_sess_cert_new();\n\t\t\tif (s-&gt;ctx-&gt;psk_identity_hint)\n\t\t\t\tOPENSSL_free(s-&gt;ctx-&gt;psk_identity_hint);\n\t\t\ts-&gt;ctx-&gt;psk_identity_hint = NULL;\n\t\t\t}\n#endif\n\t\ts-&gt;s3-&gt;tmp.reuse_message=1;\n\t\treturn(1);\n\t\t}\n\n\tparam=p=(unsigned char *)s-&gt;init_msg;\n\tif (s-&gt;session-&gt;sess_cert != NULL)\n\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tif (s-&gt;session-&gt;sess_cert-&gt;peer_rsa_tmp != NULL)\n\t\t\t{\n\t\t\tRSA_free(s-&gt;session-&gt;sess_cert-&gt;peer_rsa_tmp);\n\t\t\ts-&gt;session-&gt;sess_cert-&gt;peer_rsa_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_DH\n\t\tif (s-&gt;session-&gt;sess_cert-&gt;peer_dh_tmp)\n\t\t\t{\n\t\t\tDH_free(s-&gt;session-&gt;sess_cert-&gt;peer_dh_tmp);\n\t\t\ts-&gt;session-&gt;sess_cert-&gt;peer_dh_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDH\n\t\tif (s-&gt;session-&gt;sess_cert-&gt;peer_ecdh_tmp)\n\t\t\t{\n\t\t\tEC_KEY_free(s-&gt;session-&gt;sess_cert-&gt;peer_ecdh_tmp);\n\t\t\ts-&gt;session-&gt;sess_cert-&gt;peer_ecdh_tmp=NULL;\n\t\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\ts-&gt;session-&gt;sess_cert=ssl_sess_cert_new();\n\t\t}\n\n\t/* Total length of the parameters including the length prefix */\n\tparam_len=0;\n\n\talg_k=s-&gt;s3-&gt;tmp.new_cipher-&gt;algorithm_mkey;\n\talg_a=s-&gt;s3-&gt;tmp.new_cipher-&gt;algorithm_auth;\n\tEVP_MD_CTX_init(&amp;md_ctx);\n\n\tal=SSL_AD_DECODE_ERROR;\n\n#ifndef OPENSSL_NO_PSK\n\tif (alg_k &amp; SSL_kPSK)\n\t\t{\n\t\tchar tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];\n\n\t\tparam_len = 2;\n\t\tif (param_len &gt; n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\t/* Store PSK identity hint for later use, hint is used\n\t\t * in ssl3_send_client_key_exchange.  Assume that the\n\t\t * maximum length of a PSK identity hint can be as\n\t\t * long as the maximum length of a PSK identity. */\n\t\tif (i &gt; PSK_MAX_IDENTITY_LEN)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_DATA_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\t/* If received PSK identity hint contains NULL\n\t\t * characters, the hint is truncated from the first\n\t\t * NULL. p may not be ending with NULL, so create a\n\t\t * NULL-terminated string. */\n\t\tmemcpy(tmp_id_hint, p, i);\n\t\tmemset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);\n\t\tif (s-&gt;ctx-&gt;psk_identity_hint != NULL)\n\t\t\tOPENSSL_free(s-&gt;ctx-&gt;psk_identity_hint);\n\t\ts-&gt;ctx-&gt;psk_identity_hint = BUF_strdup(tmp_id_hint);\n\t\tif (s-&gt;ctx-&gt;psk_identity_hint == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n\t\t\tgoto f_err;\n\t\t\t}\t   \n\n\t\tp+=i;\n\t\tn-=param_len;\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n\tif (alg_k &amp; SSL_kSRP)\n\t\t{\n\t\tparam_len = 2;\n\t\tif (param_len &gt; n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s-&gt;srp_ctx.N=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (2 &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s-&gt;srp_ctx.g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (1 &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 1;\n\n\t\ti = (unsigned int)(p[0]);\n\t\tp++;\n\n\t\tif (i &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s-&gt;srp_ctx.s=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s-&gt;srp_ctx.B=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!srp_verify_server_param(s, &amp;al))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n/* We must check if there is a certificate */\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a &amp; SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s-&gt;session-&gt;sess_cert-&gt;peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a &amp; SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s-&gt;session-&gt;sess_cert-&gt;peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_SRP */\n#ifndef OPENSSL_NO_RSA\n\tif (alg_k &amp; SSL_kRSA)\n\t\t{\n\t\tif ((rsa=RSA_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len &gt; n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa-&gt;n=BN_bin2bn(p,i,rsa-&gt;n)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa-&gt;e=BN_bin2bn(p,i,rsa-&gt;e)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\t/* this should be because we are using an export cipher */\n\t\tif (alg_a &amp; SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s-&gt;session-&gt;sess_cert-&gt;peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts-&gt;session-&gt;sess_cert-&gt;peer_rsa_tmp=rsa;\n\t\trsa=NULL;\n\t\t}\n#else /* OPENSSL_NO_RSA */\n\tif (0)\n\t\t;\n#endif\n#ifndef OPENSSL_NO_DH\n\telse if (alg_k &amp; SSL_kDHE)\n\t\t{\n\t\tif ((dh=DH_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len &gt; n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh-&gt;p=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh-&gt;g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i &gt; n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh-&gt;pub_key=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!ssl_security(s, SSL_SECOP_TMP_DH,\n\t\t\t\t\t\tDH_security_bits(dh), 0, dh))\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a &amp; SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s-&gt;session-&gt;sess_cert-&gt;peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a &amp; SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s-&gt;session-&gt;sess_cert-&gt;peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t/* else anonymous DH, so no certificate or pkey. */\n\n\t\ts-&gt;session-&gt;sess_cert-&gt;peer_dh_tmp=dh;\n\t\tdh=NULL;\n\t\t}\n\telse if ((alg_k &amp; SSL_kDHr) || (alg_k &amp; SSL_kDHd))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_ECDH\n\telse if (alg_k &amp; SSL_kECDHE)\n\t\t{\n\t\tEC_GROUP *ngroup;\n\t\tconst EC_GROUP *group;\n\n\t\tif ((ecdh=EC_KEY_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Extract elliptic curve parameters and the\n\t\t * server\'s ephemeral ECDH public key.\n\t\t * Keep accumulating lengths of various components in\n\t\t * param_len and make sure it never exceeds n.\n\t\t */\n\n\t\t/* XXX: For now we only support named (not generic) curves\n\t\t * and the ECParameters in this case is just three bytes. We\n\t\t * also need one byte for the length of the encoded point\n\t\t */\n\t\tparam_len=4;\n\t\tif (param_len &gt; n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t/* Check curve is one of our preferences, if not server has\n\t\t * sent an invalid curve. ECParameters is 3 bytes.\n\t\t */\n\t\tif (!tls1_check_curve(s, p, 3))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) \n\t\t\t{\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tngroup = EC_GROUP_new_by_curve_name(curve_nid);\n\t\tif (ngroup == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (EC_KEY_set_group(ecdh, ngroup) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tEC_GROUP_free(ngroup);\n\n\t\tgroup = EC_KEY_get0_group(ecdh);\n\n\t\tif (SSL_C_IS_EXPORT(s-&gt;s3-&gt;tmp.new_cipher) &amp;&amp;\n\t\t    (EC_GROUP_get_degree(group) &gt; 163))\n\t\t\t{\n\t\t\tal=SSL_AD_EXPORT_RESTRICTION;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tp+=3;\n\n\t\t/* Next, get the encoded ECPoint */\n\t\tif (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\n\t\t    ((bn_ctx = BN_CTX_new()) == NULL))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tencoded_pt_len = *p;  /* length of encoded point */\n\t\tp+=1;\n\n\t\tif ((encoded_pt_len &gt; n - param_len) ||\n\t\t    (EC_POINT_oct2point(group, srvr_ecpoint, \n\t\t\tp, encoded_pt_len, bn_ctx) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += encoded_pt_len;\n\n\t\tn-=param_len;\n\t\tp+=encoded_pt_len;\n\n\t\t/* The ECC/TLS specification does not mention\n\t\t * the use of DSA to sign ECParameters in the server\n\t\t * key exchange message. We do support RSA and ECDSA.\n\t\t */\n\t\tif (0) ;\n#ifndef OPENSSL_NO_RSA\n\t\telse if (alg_a &amp; SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s-&gt;session-&gt;sess_cert-&gt;peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\telse if (alg_a &amp; SSL_aECDSA)\n\t\t\tpkey=X509_get_pubkey(s-&gt;session-&gt;sess_cert-&gt;peer_pkeys[SSL_PKEY_ECC].x509);\n#endif\n\t\t/* else anonymous ECDH, so no certificate or pkey. */\n\t\tEC_KEY_set_public_key(ecdh, srvr_ecpoint);\n\t\ts-&gt;session-&gt;sess_cert-&gt;peer_ecdh_tmp=ecdh;\n\t\tecdh=NULL;\n\t\tBN_CTX_free(bn_ctx);\n\t\tbn_ctx = NULL;\n\t\tEC_POINT_free(srvr_ecpoint);\n\t\tsrvr_ecpoint = NULL;\n\t\t}\n\telse if (alg_k)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_ECDH */\n\n\n\t/* p points to the next byte, there are \'n\' bytes left */\n\n\t/* if it was signed, check the signature */\n\tif (pkey != NULL)\n\t\t{\n\t\tif (SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint rv;\n\t\t\tif (2 &gt; n)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\trv = tls12_check_peer_sigalg(&amp;md, s, p, pkey);\n\t\t\tif (rv == -1)\n\t\t\t\tgoto err;\n\t\t\telse if (rv == 0)\n\t\t\t\t{\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, "USING TLSv1.2 HASH %s\\n", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\telse\n\t\t\tmd = EVP_sha1();\n\n\t\tif (2 &gt; n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tj=EVP_PKEY_size(pkey);\n\n\t\t/* Check signature length. If n is 0 then signature is empty */\n\t\tif ((i != n) || (n &gt; j) || (n &lt;= 0))\n\t\t\t{\n\t\t\t/* wrong packet length */\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (pkey-&gt;type == EVP_PKEY_RSA &amp;&amp; !SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint num;\n\t\t\tunsigned int size;\n\n\t\t\tj=0;\n\t\t\tq=md_buf;\n\t\t\tfor (num=2; num &gt; 0; num--)\n\t\t\t\t{\n\t\t\t\tEVP_MD_CTX_set_flags(&amp;md_ctx,\n\t\t\t\t\tEVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n\t\t\t\tEVP_DigestInit_ex(&amp;md_ctx,(num == 2)\n\t\t\t\t\t?s-&gt;ctx-&gt;md5:s-&gt;ctx-&gt;sha1, NULL);\n\t\t\t\tEVP_DigestUpdate(&amp;md_ctx,&amp;(s-&gt;s3-&gt;client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&amp;md_ctx,&amp;(s-&gt;s3-&gt;server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&amp;md_ctx,param,param_len);\n\t\t\t\tEVP_DigestFinal_ex(&amp;md_ctx,q,&amp;size);\n\t\t\t\tq+=size;\n\t\t\t\tj+=size;\n\t\t\t\t}\n\t\t\ti=RSA_verify(NID_md5_sha1, md_buf, j, p, n,\n\t\t\t\t\t\t\t\tpkey-&gt;pkey.rsa);\n\t\t\tif (i &lt; 0)\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n#endif\n\t\t\t{\n\t\t\tEVP_VerifyInit_ex(&amp;md_ctx, md, NULL);\n\t\t\tEVP_VerifyUpdate(&amp;md_ctx,&amp;(s-&gt;s3-&gt;client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&amp;md_ctx,&amp;(s-&gt;s3-&gt;server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&amp;md_ctx,param,param_len);\n\t\t\tif (EVP_VerifyFinal(&amp;md_ctx,p,(int)n,pkey) &lt;= 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\t/* aNULL, aSRP or kPSK do not need public keys */\n\t\tif (!(alg_a &amp; (SSL_aNULL|SSL_aSRP)) &amp;&amp; !(alg_k &amp; SSL_kPSK))\n\t\t\t{\n\t\t\t/* Might be wrong key type, check it */\n\t\t\tif (ssl3_check_cert_and_algorithm(s))\n\t\t\t\t/* Otherwise this shouldn\'t happen */\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t/* still data left over */\n\t\tif (n != 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\tEVP_PKEY_free(pkey);\n\tEVP_MD_CTX_cleanup(&amp;md_ctx);\n\treturn(1);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\tEVP_PKEY_free(pkey);\n#ifndef OPENSSL_NO_RSA\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n#endif\n#ifndef OPENSSL_NO_DH\n\tif (dh != NULL)\n\t\tDH_free(dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tBN_CTX_free(bn_ctx);\n\tEC_POINT_free(srvr_ecpoint);\n\tif (ecdh != NULL)\n\t\tEC_KEY_free(ecdh);\n#endif\n\tEVP_MD_CTX_cleanup(&amp;md_ctx);\n\treturn(-1);\n\t}',
 'do_page_fault(struct pt_regs *regs, unsigned long error_code)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tunsigned long address;\n\tstruct mm_struct *mm;\n\tint fault;\n\tint write = error_code &amp; PF_WRITE;\n\tunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE |\n\t\t\t\t\t(write ? FAULT_FLAG_WRITE : 0);\n\n\ttsk = current;\n\tmm = tsk-&gt;mm;\n\n\t/* Get the faulting address: */\n\taddress = read_cr2();\n\n\t/*\n\t * Detect and handle instructions that would cause a page fault for\n\t * both a tracked kernel page and a userspace page.\n\t */\n\tif (kmemcheck_active(regs))\n\t\tkmemcheck_hide(regs);\n\tprefetchw(&amp;mm-&gt;mmap_sem);\n\n\tif (unlikely(kmmio_fault(regs, address)))\n\t\treturn;\n\n\t/*\n\t * We fault-in kernel-space virtual memory on-demand. The\n\t * \'reference\' page table is init_mm.pgd.\n\t *\n\t * NOTE! We MUST NOT take any locks for this case. We may\n\t * be in an interrupt or a critical region, and should\n\t * only copy the information from the master page table,\n\t * nothing more.\n\t *\n\t * This verifies that the fault happens in kernel space\n\t * (error_code &amp; 4) == 0, and that the fault was not a\n\t * protection error (error_code &amp; 9) == 0.\n\t */\n\tif (unlikely(fault_in_kernel_space(address))) {\n\t\tif (!(error_code &amp; (PF_RSVD | PF_USER | PF_PROT))) {\n\t\t\tif (vmalloc_fault(address) &gt;= 0)\n\t\t\t\treturn;\n\n\t\t\tif (kmemcheck_fault(regs, address, error_code))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/* Can handle a stale RO-&gt;RW TLB: */\n\t\tif (spurious_fault(error_code, address))\n\t\t\treturn;\n\n\t\t/* kprobes don\'t want to hook the spurious faults: */\n\t\tif (notify_page_fault(regs))\n\t\t\treturn;\n\t\t/*\n\t\t * Don\'t take the mm semaphore here. If we fixup a prefetch\n\t\t * fault we could otherwise deadlock:\n\t\t */\n\t\tbad_area_nosemaphore(regs, error_code, address);\n\n\t\treturn;\n\t}\n\n\t/* kprobes don\'t want to hook the spurious faults: */\n\tif (unlikely(notify_page_fault(regs)))\n\t\treturn;\n\t/*\n\t * It\'s safe to allow irq\'s after cr2 has been saved and the\n\t * vmalloc fault has been handled.\n\t *\n\t * User-mode registers count as a user access even for any\n\t * potential system fault or CPU buglet:\n\t */\n\tif (user_mode_vm(regs)) {\n\t\tlocal_irq_enable();\n\t\terror_code |= PF_USER;\n\t} else {\n\t\tif (regs-&gt;flags &amp; X86_EFLAGS_IF)\n\t\t\tlocal_irq_enable();\n\t}\n\n\tif (unlikely(error_code &amp; PF_RSVD))\n\t\tpgtable_bad(regs, error_code, address);\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\n\t/*\n\t * If we\'re in an interrupt, have no user context or are running\n\t * in an atomic region then we must not take the fault:\n\t */\n\tif (unlikely(in_atomic() || !mm)) {\n\t\tbad_area_nosemaphore(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t/*\n\t * When running in the kernel we expect faults to occur only to\n\t * addresses in user space.  All other faults represent errors in\n\t * the kernel and should generate an OOPS.  Unfortunately, in the\n\t * case of an erroneous fault occurring in a code path which already\n\t * holds mmap_sem we will deadlock attempting to validate the fault\n\t * against the address space.  Luckily the kernel only validly\n\t * references user space from well defined areas of code, which are\n\t * listed in the exceptions table.\n\t *\n\t * As the vast majority of faults will be valid we will only perform\n\t * the source reference check when there is a possibility of a\n\t * deadlock. Attempt to lock the address space, if we cannot we then\n\t * validate the source. If this is invalid we can skip the address\n\t * space check, thus avoiding the deadlock:\n\t */\n\tif (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) {\n\t\tif ((error_code &amp; PF_USER) == 0 &amp;&amp;\n\t\t    !search_exception_tables(regs-&gt;ip)) {\n\t\t\tbad_area_nosemaphore(regs, error_code, address);\n\t\t\treturn;\n\t\t}\nretry:\n\t\tdown_read(&amp;mm-&gt;mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in\n\t\t * which case we\'ll have missed the might_sleep() from\n\t\t * down_read():\n\t\t */\n\t\tmight_sleep();\n\t}\n\n\tvma = find_vma(mm, address);\n\tif (unlikely(!vma)) {\n\t\tbad_area(regs, error_code, address);\n\t\treturn;\n\t}\n\tif (likely(vma-&gt;vm_start &lt;= address))\n\t\tgoto good_area;\n\tif (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) {\n\t\tbad_area(regs, error_code, address);\n\t\treturn;\n\t}\n\tif (error_code &amp; PF_USER) {\n\t\t/*\n\t\t * Accessing the stack below %sp is always a bug.\n\t\t * The large cushion allows instructions like enter\n\t\t * and pusha to work. ("enter $65535, $31" pushes\n\t\t * 32 pointers and then decrements %sp by 65535.)\n\t\t */\n\t\tif (unlikely(address + 65536 + 32 * sizeof(unsigned long) &lt; regs-&gt;sp)) {\n\t\t\tbad_area(regs, error_code, address);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (unlikely(expand_stack(vma, address))) {\n\t\tbad_area(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t/*\n\t * Ok, we have a good vm_area for this memory access, so\n\t * we can handle it..\n\t */\ngood_area:\n\tif (unlikely(access_error(error_code, vma))) {\n\t\tbad_area_access_error(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t/*\n\t * If for any reason at all we couldn\'t handle the fault,\n\t * make sure we exit gracefully rather than endlessly redo\n\t * the fault:\n\t */\n\tfault = handle_mm_fault(mm, vma, address, flags);\n\n\tif (unlikely(fault &amp; (VM_FAULT_RETRY|VM_FAULT_ERROR))) {\n\t\tif (mm_fault_error(regs, error_code, address, fault))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Major/minor page fault accounting is only done on the\n\t * initial attempt. If we go through a retry, it is extremely\n\t * likely that the page will be found in page cache at that point.\n\t */\n\tif (flags &amp; FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault &amp; VM_FAULT_MAJOR) {\n\t\t\ttsk-&gt;maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t\t      regs, address);\n\t\t} else {\n\t\t\ttsk-&gt;min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t\t      regs, address);\n\t\t}\n\t\tif (fault &amp; VM_FAULT_RETRY) {\n\t\t\t/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk\n\t\t\t * of starvation. */\n\t\t\tflags &amp;= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tcheck_v8086_mode(regs, address, tsk);\n\n\tup_read(&amp;mm-&gt;mmap_sem);\n}',
 'bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\treturn ns_capable(ns, cap) &amp;&amp; kuid_has_mapping(ns, inode-&gt;i_uid);\n}',
 'kdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data-&gt;length;\n    req_data.data = (char *)pa_data-&gt;contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&amp;req_data, s4u_x509_user);\n    if (code) {\n        *status = "DECODE_PA_S4U_X509_USER";\n        return code;\n    }\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &amp;req_data,\n                                         request-&gt;nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = "INVALID_S4U2SELF_CHECKSUM";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)-&gt;user_id.user) == 0 ||\n        (*s4u_x509_user)-&gt;user_id.subject_cert.length != 0) {\n        *status = "INVALID_S4U2SELF_REQUEST";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}',
 'TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &amp;input));\n\n  switch (input-&gt;type) {\n    case kTfLiteFloat32:\n      return EvalImpl&lt;kernel_type, kTfLiteFloat32&gt;(context, node);\n    case kTfLiteUInt8:\n      return EvalImpl&lt;kernel_type, kTfLiteUInt8&gt;(context, node);\n    case kTfLiteInt8:\n      return EvalImpl&lt;kernel_type, kTfLiteInt8&gt;(context, node);\n    case kTfLiteInt16:\n      return EvalImpl&lt;kernel_type, kTfLiteInt16&gt;(context, node);\n    default:\n      TF_LITE_KERNEL_LOG(context, "Type %s not currently supported.",\n                         TfLiteTypeGetName(input-&gt;type));\n      return kTfLiteError;\n  }\n}',
 'static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin-&gt;buf-&gt;buf + (ut32)sec-&gt;payload_data;\n\tut32 len =  sec-&gt;payload_len;\n\tut32 count = sec-&gt;count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i &lt; len &amp;&amp; r &lt; count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &amp;ptr-&gt;index, &amp;i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &amp;i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr-&gt;offset.len = n;\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &amp;ptr-&gt;size, &amp;i))) {\t\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr-&gt;data = sec-&gt;payload_data + i;\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}',
 "auth_line_is_begin (guint8 *line)\n{\n  guint8 next_char;\n\n  if (!g_str_has_prefix ((char *)line, AUTH_BEGIN))\n    return FALSE;\n\n  /* dbus-daemon accepts either nothing, or a whitespace followed by anything as end of auth */\n  next_char = line[strlen (AUTH_BEGIN)];\n  return (next_char == 0 ||\n          next_char == ' ' ||\n          next_char == '\\t');\n}",
 'int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\n\thfs_dbg(ACL_MOD, "[%s]: ino %lu\\n", __func__, inode-&gt;i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode-&gt;i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl-&gt;a_count);\n\t\tif (unlikely(size &gt; HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&amp;init_user_ns, acl, value, size);\n\t\tif (unlikely(err &lt; 0))\n\t\t\tgoto end_set_acl;\n\t}\n\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\n\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn err;\n}',
 'void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}',
 'static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize &gt;= 60 &amp;&amp; rdesc[39] == 0x2a &amp;&amp; rdesc[40] == 0xf5 &amp;&amp;\n\t\t\trdesc[41] == 0x00 &amp;&amp; rdesc[59] == 0x26 &amp;&amp;\n\t\t\trdesc[60] == 0xf9 &amp;&amp; rdesc[61] == 0x00) {\n\t\thid_info(hdev, "fixing up Petalynx Maxter Remote report descriptor\\n");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}',
 'ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tint error = 0;\n\n\tBUFFER_TRACE(bh, "get_write_access");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\n\tlock_buffer(bh);\n\tif (BHDR(bh)-&gt;h_refcount == cpu_to_le32(1)) {\n\t\t__u32 hash = le32_to_cpu(BHDR(bh)-&gt;h_hash);\n\n\t\tea_bdebug(bh, "refcount now=0; freeing");\n\t\t/*\n\t\t * This must happen under buffer lock for\n\t\t * ext4_xattr_block_set() to reliably detect freed block\n\t\t */\n\t\tmb2_cache_entry_delete_block(EXT4_GET_MB_CACHE(inode), hash,\n\t\t\t\t\t     bh-&gt;b_blocknr);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&amp;BHDR(bh)-&gt;h_refcount, -1);\n\t\t/*\n\t\t * Beware of this ugliness: Releasing of xattr block references\n\t\t * from different inodes can race and so we have to protect\n\t\t * from a race where someone else frees the block (and releases\n\t\t * its journal_head) before we are done dirtying the buffer. In\n\t\t * nojournal mode this race is harmless and we actually cannot\n\t\t * call ext4_handle_dirty_xattr_block() with locked buffer as\n\t\t * that function can call sync_dirty_buffer() so for that case\n\t\t * we handle the dirtying after unlocking the buffer.\n\t\t */\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode-&gt;i_sb), 1));\n\t\tea_bdebug(bh, "refcount now=%d; releasing",\n\t\t\t  le32_to_cpu(BHDR(bh)-&gt;h_refcount));\n\t}\nout:\n\text4_std_error(inode-&gt;i_sb, error);\n\treturn;\n}',
 'static inline bool unconditional(const struct ipt_entry *e)\n{\n\tstatic const struct ipt_ip uncond;\n\n\treturn e-&gt;target_offset == sizeof(struct ipt_entry) &amp;&amp;\n\t       memcmp(&amp;e-&gt;ip, &amp;uncond, sizeof(uncond)) == 0;\n#undef FWINV\n}',
 'int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\tstruct ext4_extent *newext, int flag)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex, *fex;\n\tstruct ext4_extent *nearex; /* nearest extent */\n\tstruct ext4_ext_path *npath = NULL;\n\tint depth, len, err;\n\text4_lblk_t next;\n\tunsigned uninitialized = 0;\n\n\tBUG_ON(ext4_ext_get_actual_len(newext) == 0);\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tBUG_ON(path[depth].p_hdr == NULL);\n\n\t/* try to insert block into found extent and return */\n\tif (ex &amp;&amp; !(flag &amp; EXT4_GET_BLOCKS_PRE_IO)\n\t\t&amp;&amp; ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug("append [%d]%d block to %d:[%d]%d (from %llu)\\n",\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tle32_to_cpu(ex-&gt;ee_block),\n\t\t\t\text4_ext_is_uninitialized(ex),\n\t\t\t\text4_ext_get_actual_len(ex), ext_pblock(ex));\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * ext4_can_extents_be_merged should have checked that either\n\t\t * both extents are uninitialized, or both aren\'t. Thus we\n\t\t * need to check only one of them here.\n\t\t */\n\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\tuninitialized = 1;\n\t\tex-&gt;ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\tif (uninitialized)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\teh = path[depth].p_hdr;\n\t\tnearex = ex;\n\t\tgoto merge;\n\t}\n\nrepeat:\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh-&gt;eh_entries) &lt; le16_to_cpu(eh-&gt;eh_max))\n\t\tgoto has_space;\n\n\t/* probably next leaf has space for us? */\n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = ext4_ext_next_leaf_block(inode, path);\n\tif (le32_to_cpu(newext-&gt;ee_block) &gt; le32_to_cpu(fex-&gt;ee_block)\n\t    &amp;&amp; next != EXT_MAX_BLOCK) {\n\t\text_debug("next leaf block - %d\\n", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_ext_find_extent(inode, next, NULL);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath-&gt;p_depth != path-&gt;p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh-&gt;eh_entries) &lt; le16_to_cpu(eh-&gt;eh_max)) {\n\t\t\text_debug("next leaf isnt full(%d)\\n",\n\t\t\t\t  le16_to_cpu(eh-&gt;eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto repeat;\n\t\t}\n\t\text_debug("next leaf has no free space(%d,%d)\\n",\n\t\t\t  le16_to_cpu(eh-&gt;eh_entries), le16_to_cpu(eh-&gt;eh_max));\n\t}\n\n\t/*\n\t * There is no free space in the found leaf.\n\t * We\'re gonna add a new leaf in the tree.\n\t */\n\terr = ext4_ext_create_new_leaf(handle, inode, path, newext);\n\tif (err)\n\t\tgoto cleanup;\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\nhas_space:\n\tnearex = path[depth].p_ext;\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (!nearex) {\n\t\t/* there is no extent in this leaf, create first one */\n\t\text_debug("first extent in the leaf: %d:%llu:[%d]%d\\n",\n\t\t\t\tle32_to_cpu(newext-&gt;ee_block),\n\t\t\t\text_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext));\n\t\tpath[depth].p_ext = EXT_FIRST_EXTENT(eh);\n\t} else if (le32_to_cpu(newext-&gt;ee_block)\n\t\t\t   &gt; le32_to_cpu(nearex-&gt;ee_block)) {\n/*\t\tBUG_ON(newext-&gt;ee_block == nearex-&gt;ee_block); */\n\t\tif (nearex != EXT_LAST_EXTENT(eh)) {\n\t\t\tlen = EXT_MAX_EXTENT(eh) - nearex;\n\t\t\tlen = (len - 1) * sizeof(struct ext4_extent);\n\t\t\tlen = len &lt; 0 ? 0 : len;\n\t\t\text_debug("insert %d:%llu:[%d]%d after: nearest 0x%p, "\n\t\t\t\t\t"move %d from 0x%p to 0x%p\\n",\n\t\t\t\t\tle32_to_cpu(newext-&gt;ee_block),\n\t\t\t\t\text_pblock(newext),\n\t\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\t\tmemmove(nearex + 2, nearex + 1, len);\n\t\t}\n\t\tpath[depth].p_ext = nearex + 1;\n\t} else {\n\t\tBUG_ON(newext-&gt;ee_block == nearex-&gt;ee_block);\n\t\tlen = (EXT_MAX_EXTENT(eh) - nearex) * sizeof(struct ext4_extent);\n\t\tlen = len &lt; 0 ? 0 : len;\n\t\text_debug("insert %d:%llu:[%d]%d before: nearest 0x%p, "\n\t\t\t\t"move %d from 0x%p to 0x%p\\n",\n\t\t\t\tle32_to_cpu(newext-&gt;ee_block),\n\t\t\t\text_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\tmemmove(nearex + 1, nearex, len);\n\t\tpath[depth].p_ext = nearex;\n\t}\n\n\tle16_add_cpu(&amp;eh-&gt;eh_entries, 1);\n\tnearex = path[depth].p_ext;\n\tnearex-&gt;ee_block = newext-&gt;ee_block;\n\text4_ext_store_pblock(nearex, ext_pblock(newext));\n\tnearex-&gt;ee_len = newext-&gt;ee_len;\n\nmerge:\n\t/* try to merge extents to the right */\n\tif (!(flag &amp; EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t/* try to merge extents to the left */\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\ncleanup:\n\tif (npath) {\n\t\text4_ext_drop_refs(npath);\n\t\tkfree(npath);\n\t}\n\text4_ext_invalidate_cache(inode);\n\treturn err;\n}',
 'bool jas_image_cmpt_domains_same(jas_image_t *image)\n{\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_cmpt_t *cmpt0;\n\n\tcmpt0 = image-&gt;cmpts_[0];\n\tfor (cmptno = 1; cmptno &lt; image-&gt;numcmpts_; ++cmptno) {\n\t\tcmpt = image-&gt;cmpts_[cmptno];\n\t\tif (cmpt-&gt;tlx_ != cmpt0-&gt;tlx_ || cmpt-&gt;tly_ != cmpt0-&gt;tly_ ||\n\t\t  cmpt-&gt;hstep_ != cmpt0-&gt;hstep_ || cmpt-&gt;vstep_ != cmpt0-&gt;vstep_ ||\n\t\t  cmpt-&gt;width_ != cmpt0-&gt;width_ || cmpt-&gt;height_ != cmpt0-&gt;height_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}',
 'static inline bool isMountable(const RemoteFsDevice::Details &amp;d)\n{\n    return RemoteFsDevice::constSshfsProtocol==d.url.scheme();\n}',
 'static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    AC3HeaderInfo *hdr = NULL;\n    struct eac3_info *info;\n    int num_blocks, ret;\n\n    if (!track-&gt;eac3_priv &amp;&amp; !(track-&gt;eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track-&gt;eac3_priv;\n\n    if (avpriv_ac3_parse_header(&amp;hdr, pkt-&gt;data, pkt-&gt;size) &lt; 0) {\n        /* drop the packets until we see a good one */\n        if (!track-&gt;entry) {\n            av_log(mov, AV_LOG_WARNING, "Dropping invalid packet from start of the stream\\n");\n            ret = 0;\n        } else\n            ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    info-&gt;data_rate = FFMAX(info-&gt;data_rate, hdr-&gt;bit_rate / 1000);\n    num_blocks = hdr-&gt;num_blocks;\n\n    if (!info-&gt;ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr-&gt;bitstream_id &lt;= 10 &amp;&amp; hdr-&gt;substreamid != 0) {\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr-&gt;frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr-&gt;substreamid &gt; info-&gt;num_ind_sub + 1) {\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n\n            if (hdr-&gt;substreamid == info-&gt;num_ind_sub + 1) {\n                //info-&gt;num_ind_sub++;\n                avpriv_request_sample(track-&gt;par, "Multiple independent substreams");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            } else if (hdr-&gt;substreamid &lt; info-&gt;num_ind_sub ||\n                       hdr-&gt;substreamid == 0 &amp;&amp; info-&gt;substream[0].bsid) {\n                info-&gt;ec3_done = 1;\n                goto concatenate;\n            }\n        } else {\n            if (hdr-&gt;substreamid != 0) {\n                avpriv_request_sample(mov-&gt;fc, "Multiple non EAC3 independent substreams");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            }\n        }\n\n        /* fill the info needed for the "dec3" atom */\n        info-&gt;substream[hdr-&gt;substreamid].fscod = hdr-&gt;sr_code;\n        info-&gt;substream[hdr-&gt;substreamid].bsid  = hdr-&gt;bitstream_id;\n        info-&gt;substream[hdr-&gt;substreamid].bsmod = hdr-&gt;bitstream_mode;\n        info-&gt;substream[hdr-&gt;substreamid].acmod = hdr-&gt;channel_mode;\n        info-&gt;substream[hdr-&gt;substreamid].lfeon = hdr-&gt;lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt-&gt;size != hdr-&gt;frame_size) {\n            int cumul_size = hdr-&gt;frame_size;\n            int parent = hdr-&gt;substreamid;\n\n            while (cumul_size != pkt-&gt;size) {\n                GetBitContext gbc;\n                int i;\n                ret = avpriv_ac3_parse_header(&amp;hdr, pkt-&gt;data + cumul_size, pkt-&gt;size - cumul_size);\n                if (ret &lt; 0)\n                    goto end;\n                if (hdr-&gt;frame_type != EAC3_FRAME_TYPE_DEPENDENT) {\n                    ret = AVERROR(EINVAL);\n                    goto end;\n                }\n                info-&gt;substream[parent].num_dep_sub++;\n                ret /= 8;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                init_get_bits8(&amp;gbc, pkt-&gt;data + cumul_size + ret, pkt-&gt;size - cumul_size - ret);\n                /* skip bsid */\n                skip_bits(&amp;gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i &lt; (hdr-&gt;channel_mode ? 1 : 2); i++) {\n                    skip_bits(&amp;gbc, 5); // skip dialog normalization\n                    if (get_bits1(&amp;gbc)) {\n                        skip_bits(&amp;gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&amp;gbc))\n                    info-&gt;substream[parent].chan_loc |= (get_bits(&amp;gbc, 16) &gt;&gt; 5) &amp; 0x1f;\n                else\n                    info-&gt;substream[parent].chan_loc |= hdr-&gt;channel_mode;\n                cumul_size += hdr-&gt;frame_size;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info-&gt;num_blocks &amp;&amp; num_blocks == 6) {\n        ret = pkt-&gt;size;\n        goto end;\n    }\n    else if (info-&gt;num_blocks + num_blocks &gt; 6) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    if (!info-&gt;num_blocks) {\n        ret = av_packet_ref(&amp;info-&gt;pkt, pkt);\n        if (!ret)\n            info-&gt;num_blocks = num_blocks;\n        goto end;\n    } else {\n        if ((ret = av_grow_packet(&amp;info-&gt;pkt, pkt-&gt;size)) &lt; 0)\n            goto end;\n        memcpy(info-&gt;pkt.data + info-&gt;pkt.size - pkt-&gt;size, pkt-&gt;data, pkt-&gt;size);\n        info-&gt;num_blocks += num_blocks;\n        info-&gt;pkt.duration += pkt-&gt;duration;\n        if ((ret = av_copy_packet_side_data(&amp;info-&gt;pkt, pkt)) &lt; 0)\n            goto end;\n        if (info-&gt;num_blocks != 6)\n            goto end;\n        av_packet_unref(pkt);\n        av_packet_move_ref(pkt, &amp;info-&gt;pkt);\n        info-&gt;num_blocks = 0;\n    }\n    ret = pkt-&gt;size;\n\nend:\n    av_free(hdr);\n\n    return ret;\n}',
 'decode_unicode_with_escapes(struct compiling *c, const node *n, const char *s,\n                            size_t len)\n{\n    PyObject *v, *u;\n    char *buf;\n    char *p;\n    const char *end;\n    const char *first_invalid_escape;\n\n    /* check for integer overflow */\n    if (len &gt; SIZE_MAX / 6)\n        return NULL;\n    /* "ä" (2 bytes) may become "\\U000000E4" (10 bytes), or 1:5\n       "\\ä" (3 bytes) may become "\\u005c\\U000000E4" (16 bytes), or ~1:6 */\n    u = PyBytes_FromStringAndSize((char *)NULL, len * 6);\n    if (u == NULL)\n        return NULL;\n    p = buf = PyBytes_AsString(u);\n    end = s + len;\n    while (s &lt; end) {\n        if (*s == \'\\\\\') {\n            *p++ = *s++;\n            if (s &gt;= end || *s &amp; 0x80) {\n                strcpy(p, "u005c");\n                p += 5;\n                if (s &gt;= end)\n                    break;\n            }\n        }\n        if (*s &amp; 0x80) { /* XXX inefficient */\n            PyObject *w;\n            int kind;\n            void *data;\n            Py_ssize_t len, i;\n            w = decode_utf8(c, &amp;s, end);\n            if (w == NULL) {\n                Py_DECREF(u);\n                return NULL;\n            }\n            kind = PyUnicode_KIND(w);\n            data = PyUnicode_DATA(w);\n            len = PyUnicode_GET_LENGTH(w);\n            for (i = 0; i &lt; len; i++) {\n                Py_UCS4 chr = PyUnicode_READ(kind, data, i);\n                sprintf(p, "\\\\U%08x", chr);\n                p += 10;\n            }\n            /* Should be impossible to overflow */\n            assert(p - buf &lt;= PyBytes_GET_SIZE(u));\n            Py_DECREF(w);\n        } else {\n            *p++ = *s++;\n        }\n    }\n    len = p - buf;\n    s = buf;\n\n    v = _PyUnicode_DecodeUnicodeEscape(s, len, NULL, &amp;first_invalid_escape);\n\n    if (v != NULL &amp;&amp; first_invalid_escape != NULL) {\n        if (warn_invalid_escape_sequence(c, n, *first_invalid_escape) &lt; 0) {\n            /* We have not decref u before because first_invalid_escape points\n               inside u. */\n            Py_XDECREF(u);\n            Py_DECREF(v);\n            return NULL;\n        }\n    }\n    Py_XDECREF(u);\n    return v;\n}',
 'void usage(const char *progname)\n{\n    const char* progname_real; /* contains the real name of the program */\n                               /*  (without path) */\n\n    progname_real = strrchr(progname, \'/\');\n\n    if (progname_real == NULL) /* no path in progname: use progname */\n    {\n        progname_real = progname;\n    }\n    else\n    {\n        progname_real++;\n    }\n\n    fprintf(stderr,\n            "\\nusage: %s {-e|-d} [ { -p &lt;password&gt; | -k &lt;keyfile&gt; } ] { [-o "\n            "&lt;output filename&gt;] &lt;file&gt; | &lt;file&gt; [&lt;file&gt; ...] }\\n\\n",\n            progname_real);\n}',
 'TfLiteStatus ReluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node-&gt;user_data != nullptr);\n  ReluOpData* data = static_cast&lt;ReluOpData*&gt;(node-&gt;user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n\n  if (input-&gt;type == kTfLiteInt8) {\n    CalculateReluOpData&lt;int8_t&gt;(input, output, data);\n  } else if (input-&gt;type == kTfLiteUInt8) {\n    CalculateReluOpData&lt;uint8_t&gt;(input, output, data);\n  }\n\n  return kTfLiteOk;\n}',
 "SecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,\n                                                      uint16_t devNonce, uint8_t* encJoinAccept,\n                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,\n                                                      uint8_t* versionMinor )\n{\n    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Check that frame size isn't bigger than a JoinAccept with CFList size\n    if( encJoinAcceptSize &gt; LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )\n    {\n        return SECURE_ELEMENT_ERROR_BUF_SIZE;\n    }\n\n    // Determine decryption key\n    KeyIdentifier_t encKeyID = NWK_KEY;\n\n    if( joinReqType != JOIN_REQ )\n    {\n        encKeyID = J_S_ENC_KEY;\n    }\n\n    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );\n\n    // Decrypt JoinAccept, skip MHDR\n    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,\n                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_FAIL_ENCRYPT;\n    }\n\n    *versionMinor = ( ( decJoinAccept[11] &amp; 0x80 ) == 0x80 ) ? 1 : 0;\n\n    uint32_t mic = 0;\n\n    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] &lt;&lt; 0 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] &lt;&lt; 8 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] &lt;&lt; 16 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] &lt;&lt; 24 );\n\n    //  - Header buffer to be used for MIC computation\n    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]\n    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]\n\n    // Verify mic\n    if( *versionMinor == 0 )\n    {\n        // For LoRaWAN 1.0.x\n        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |\n        //   CFListType)\n        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=\n            SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#if( USE_LRWAN_1_1_X_CRYPTO == 1 )\n    else if( *versionMinor == 1 )\n    {\n        uint8_t  micHeader11[JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n        uint16_t bufItr                                          = 0;\n\n        micHeader11[bufItr++] = ( uint8_t ) joinReqType;\n\n        memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );\n        bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;\n\n        micHeader11[bufItr++] = devNonce &amp; 0xFF;\n        micHeader11[bufItr++] = ( devNonce &gt;&gt; 8 ) &amp; 0xFF;\n\n        // For LoRaWAN 1.1.x and later:\n        //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |\n        //   DLSettings | RxDelay | CFList | CFListType)\n        // Prepare the msg for integrity check (adding JoinReqType, JoinEUI and DevNonce)\n        uint8_t localBuffer[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n\n        memcpy1( localBuffer, micHeader11, JOIN_ACCEPT_MIC_COMPUTATION_OFFSET );\n        memcpy1( localBuffer + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - 1, decJoinAccept, encJoinAcceptSize );\n\n        if( SecureElementVerifyAesCmac( localBuffer,\n                                        encJoinAcceptSize + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET -\n                                            LORAMAC_MHDR_FIELD_SIZE - LORAMAC_MIC_FIELD_SIZE,\n                                        mic, J_S_INT_KEY ) != SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#endif\n    else\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;\n    }\n\n    return SECURE_ELEMENT_SUCCESS;\n}",
 'error_t coapClientSetRxBlockSize(CoapClientRequest *request, uint_t blockSize)\n{\n   //Make sure the CoAP request handle is valid\n   if(request == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   //Acquire exclusive access to the CoAP client context\n   osAcquireMutex(&amp;request-&gt;context-&gt;mutex);\n\n   //Set RX block size\n   if(blockSize == 16)\n   {\n      request-&gt;rxBlockSzx = COAP_BLOCK_SIZE_16;\n   }\n   else if(blockSize == 32)\n   {\n      request-&gt;rxBlockSzx = COAP_BLOCK_SIZE_32;\n   }\n   else if(blockSize == 64)\n   {\n      request-&gt;rxBlockSzx = COAP_BLOCK_SIZE_64;\n   }\n   else if(blockSize == 128)\n   {\n      request-&gt;rxBlockSzx = COAP_BLOCK_SIZE_128;\n   }\n   else if(blockSize == 256)\n   {\n      request-&gt;rxBlockSzx = COAP_BLOCK_SIZE_256;\n   }\n   else if(blockSize == 512)\n   {\n      request-&gt;rxBlockSzx = COAP_BLOCK_SIZE_512;\n   }\n   else\n   {\n      request-&gt;rxBlockSzx = COAP_BLOCK_SIZE_1024;\n   }\n\n   //Ensure the block size is acceptable\n   if(request-&gt;rxBlockSzx &gt; coapClientGetMaxBlockSize())\n   {\n      request-&gt;rxBlockSzx = coapClientGetMaxBlockSize();\n   }\n\n   //Release exclusive access to the CoAP client context\n   osReleaseMutex(&amp;request-&gt;context-&gt;mutex);\n\n   //Successful processing\n   return NO_ERROR;\n}',
 'char* HexOutStream::binToHexStr(const char* data, int length) {\n  char* buffer = new char[length*2+1];\n  for (int i=0; i&lt;length; i++) {\n    buffer[i*2] = intToHex((data[i] &gt;&gt; 4) &amp; 15);\n    buffer[i*2+1] = intToHex((data[i] &amp; 15));\n    if (!buffer[i*2] || !buffer[i*2+1]) {\n      delete [] buffer;\n      return 0;\n    }\n  }\n  buffer[length*2] = 0;\n  return buffer;\n}',
 'PUBLIC void mprDefaultLogHandler(cchar *tags, int level, cchar *msg)\n{\n    MprFile     *file;\n    char        tbuf[128];\n    static int  check = 0;\n\n    if ((file = MPR-&gt;logFile) == 0) {\n        return;\n    }\n    if (MPR-&gt;logBackup &amp;&amp; MPR-&gt;logSize &amp;&amp; (check++ % 1000) == 0) {\n        backupLog();\n    }\n    if (tags &amp;&amp; *tags) {\n        if (MPR-&gt;flags &amp; MPR_LOG_DETAILED) {\n            fmt(tbuf, sizeof(tbuf), "%s %d %s, ", mprGetDate(MPR_LOG_DATE), level, tags);\n            mprWriteFileString(file, tbuf);\n        } else if (MPR-&gt;flags &amp; MPR_LOG_TAGGED) {\n            if (schr(tags, \' \')) {\n                tags = ssplit(sclone(tags), " ", NULL);\n            }\n            if (!isupper((uchar) *tags)) {\n                tags = stitle(tags);\n            }\n            mprWriteFileFmt(file, "%12s ", sfmt("[%s]", tags));\n        }\n    }\n    mprWriteFileString(file, msg);\n    mprWriteFileString(file, "\\n");\n#if ME_MPR_OSLOG\n    if (level == 0) {\n        mprWriteToOsLog(sfmt("%s: %d %s: %s", MPR-&gt;name, level, tags, msg), level);\n    }\n#endif\n}',
 'struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&amp;pack-&gt;attrs);\n\tpack-&gt;hdr.ver = ver;\n\tpack-&gt;hdr.T = 1;\n\tpack-&gt;hdr.L = 1;\n\tpack-&gt;hdr.S = 1;\n\tmemcpy(&amp;pack-&gt;addr, addr, sizeof(*addr));\n\tpack-&gt;hide_avps = H;\n\tpack-&gt;secret = secret;\n\tpack-&gt;secret_len = secret_len;\n\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pack;\n}',
 "xmlIsStreaming(xmlValidCtxtPtr ctxt) {\n    xmlParserCtxtPtr pctxt;\n\n    if (ctxt == NULL)\n        return(0);\n    /*\n     * These magic values are also abused to detect whether we're validating\n     * while parsing a document. In this case, userData points to the parser\n     * context.\n     */\n    if ((ctxt-&gt;finishDtd != XML_CTXT_FINISH_DTD_0) &amp;&amp;\n        (ctxt-&gt;finishDtd != XML_CTXT_FINISH_DTD_1))\n        return(0);\n    pctxt = ctxt-&gt;userData;\n    return(pctxt-&gt;parseMode == XML_PARSE_READER);\n}",
 'int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu-&gt;arch.emulate_ctxt;\n\tint r;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu-&gt;stat.insn_emulation;\n\n\treturn r;\n}',
 'static Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Interp *interp = tree-&gt;opts.interp;\n    Jsi_Obj *obj = (Jsi_Obj*)data;\n    int n;\n    if (!hPtr-&gt;f.bits.dontenum) {\n        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);\n        if (!cp || !isdigit(*cp))\n            return JSI_OK;\n        n = (int)strtol(cp, &amp;ep, 0);\n        if (n&lt;0 || (uint)n &gt;= interp-&gt;maxArrayList)\n            return JSI_OK;\n        hPtr-&gt;f.bits.isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, obj, n) &lt;= 0) \n            return Jsi_LogError("too long");\n        obj-&gt;arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n       // obj-&gt;arrCnt++;\n    }\n    return JSI_OK;\n}',
 "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\n\tmemset(&amp;u_ent, 0, sizeof(u_ent));\n\tif (copy_from_user(&amp;u_ent.id, &amp;uent-&gt;id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent-&gt;id;\n\tif (ent-&gt;name) {\n\t\tstrncpy(u_ent.name, ent-&gt;name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent-&gt;type;\n\tu_ent.revision = ent-&gt;revision;\n\tu_ent.flags = ent-&gt;flags;\n\tu_ent.group_id = ent-&gt;group_id;\n\tu_ent.pads = ent-&gt;num_pads;\n\tu_ent.links = ent-&gt;num_links - ent-&gt;num_backlinks;\n\tmemcpy(&amp;u_ent.raw, &amp;ent-&gt;info, sizeof(ent-&gt;info));\n\tif (copy_to_user(uent, &amp;u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
 "int bad_format(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n\n            /* line cannot end with percent char */\n            if (*ptr == '\\0')\n                return 1;\n            /* '%s', '%S' and '%%' are allowed */\n            if (*ptr == 's' || *ptr == 'S' || *ptr == '%')\n                ptr++;\n            /* %c is allowed (but use only with vdef!) */\n            else if (*ptr == 'c') {\n                ptr++;\n                n = 1;\n            }\n\n            /* or else '% 6.2lf' and such are allowed */\n            else {\n                /* optional padding character */\n                if (*ptr == ' ' || *ptr == '+' || *ptr == '-')\n                    ptr++;\n                /* This should take care of 'm.n' with all three optional */\n                while (*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9')\n                    ptr++;\n                if (*ptr == '.')\n                    ptr++;\n                while (*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9')\n                    ptr++;\n                /* Either 'le', 'lf' or 'lg' must follow here */\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'e' || *ptr == 'f' || *ptr == 'g')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n\n    return (n != 1);\n}",
 'static void nalm_dump(FILE * trace, char *data, u32 data_size)\n{\n\tGF_BitStream *bs;\n\n\tBool rle, large_size;\n\tu32 entry_count;\n\n\tif (!data) {\n\t\tfprintf(trace, "&lt;NALUMap rle=\\"\\" large_size=\\"\\"&gt;\\n");\n\t\tfprintf(trace, "&lt;NALUMapEntry NALU_startNumber=\\"\\" groupID=\\"\\"/&gt;\\n");\n\t\tfprintf(trace, "&lt;/NALUMap&gt;\\n");\n\t\treturn;\n\t}\n\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tgf_bs_read_int(bs, 6);\n\tlarge_size = gf_bs_read_int(bs, 1);\n\trle = gf_bs_read_int(bs, 1);\n\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\tfprintf(trace, "&lt;NALUMap rle=\\"%d\\" large_size=\\"%d\\"&gt;\\n", rle, large_size);\n\n\twhile (entry_count) {\n\t\tu32 ID;\n\t\tfprintf(trace, "&lt;NALUMapEntry ");\n\t\tif (rle) {\n\t\t\tu32 start_num = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tfprintf(trace, "NALU_startNumber=\\"%d\\" ", start_num);\n\t\t}\n\t\tID = gf_bs_read_u16(bs);\n\t\tfprintf(trace, "groupID=\\"%d\\"/&gt;\\n", ID);\n\t\tentry_count--;\n\t}\n\tgf_bs_del(bs);\n\tfprintf(trace, "&lt;/NALUMap&gt;\\n");\n\treturn;\n}',
 'static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\ttu = file-&gt;private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\n\t\tif (tu-&gt;timeri)\t/* too late */\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\ttu-&gt;tread = xarg ? 1 : 0;\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}',
 'TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // TODO(ahentz): these two checks would make the new implementation\n  // incompatible with some existing models, where params is not specified. It\n  // is OK not to have them because toco would have set input and output types\n  // to match the parameters.\n  // auto* params = reinterpret_cast&lt;TfLiteCastParams*&gt;(node-&gt;builtin_data);\n  // TF_LITE_ENSURE_EQ(context, input-&gt;type, params-&gt;in_data_type);\n  // TF_LITE_ENSURE_EQ(context, output-&gt;type, params-&gt;out_data_type);\n\n  return context-&gt;ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input-&gt;dims));\n}',
 'static int gs_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct gs_usb *dev;\n\tint rc = -ENOMEM;\n\tunsigned int icount, i;\n\tstruct gs_host_config *hconf;\n\tstruct gs_device_config *dconf;\n\n\thconf = kmalloc(sizeof(*hconf), GFP_KERNEL);\n\tif (!hconf)\n\t\treturn -ENOMEM;\n\n\thconf-&gt;byte_order = 0x0000beef;\n\n\t/* send host config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_HOST_FORMAT,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf-&gt;altsetting[0].desc.bInterfaceNumber,\n\t\t\t     hconf,\n\t\t\t     sizeof(*hconf),\n\t\t\t     1000);\n\n\tkfree(hconf);\n\n\tif (rc &lt; 0) {\n\t\tdev_err(&amp;intf-&gt;dev, "Couldn\'t send data format (err=%d)\\n",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tdconf = kmalloc(sizeof(*dconf), GFP_KERNEL);\n\tif (!dconf)\n\t\treturn -ENOMEM;\n\n\t/* read device config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_DEVICE_CONFIG,\n\t\t\t     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf-&gt;altsetting[0].desc.bInterfaceNumber,\n\t\t\t     dconf,\n\t\t\t     sizeof(*dconf),\n\t\t\t     1000);\n\tif (rc &lt; 0) {\n\t\tdev_err(&amp;intf-&gt;dev, "Couldn\'t get device config: (err=%d)\\n",\n\t\t\trc);\n\t\tkfree(dconf);\n\t\treturn rc;\n\t}\n\n\ticount = dconf-&gt;icount + 1;\n\tdev_info(&amp;intf-&gt;dev, "Configuring for %d interfaces\\n", icount);\n\n\tif (icount &gt; GS_MAX_INTF) {\n\t\tdev_err(&amp;intf-&gt;dev,\n\t\t\t"Driver cannot handle more that %d CAN interfaces\\n",\n\t\t\tGS_MAX_INTF);\n\t\tkfree(dconf);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tkfree(dconf);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_usb_anchor(&amp;dev-&gt;rx_submitted);\n\n\tatomic_set(&amp;dev-&gt;active_channels, 0);\n\n\tusb_set_intfdata(intf, dev);\n\tdev-&gt;udev = interface_to_usbdev(intf);\n\n\tfor (i = 0; i &lt; icount; i++) {\n\t\tdev-&gt;canch[i] = gs_make_candev(i, intf, dconf);\n\t\tif (IS_ERR_OR_NULL(dev-&gt;canch[i])) {\n\t\t\t/* save error code to return later */\n\t\t\trc = PTR_ERR(dev-&gt;canch[i]);\n\n\t\t\t/* on failure destroy previously created candevs */\n\t\t\ticount = i;\n\t\t\tfor (i = 0; i &lt; icount; i++)\n\t\t\t\tgs_destroy_candev(dev-&gt;canch[i]);\n\n\t\t\tusb_kill_anchored_urbs(&amp;dev-&gt;rx_submitted);\n\t\t\tkfree(dconf);\n\t\t\tkfree(dev);\n\t\t\treturn rc;\n\t\t}\n\t\tdev-&gt;canch[i]-&gt;parent = dev;\n\t}\n\n\tkfree(dconf);\n\n\treturn 0;\n}',
 'enum nss_status _nss_mymachines_getgrnam_r(\n                const char *name,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t gid;\n        size_t l;\n        int r;\n\n        assert(name);\n        assert(gr);\n\n        p = startswith(name, "vg-");\n        if (!p)\n                goto not_found;\n\n        e = strrchr(p, \'-\');\n        if (!e || e == p)\n                goto not_found;\n\n        if (e - p &gt; HOST_NAME_MAX - 1)  /* -1 for the last dash */\n                goto not_found;\n\n        r = parse_gid(e + 1, &amp;gid);\n        if (r &lt; 0)\n                goto not_found;\n\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n\n        r = sd_bus_open_system(&amp;bus);\n        if (r &lt; 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               "org.freedesktop.machine1",\n                               "/org/freedesktop/machine1",\n                               "org.freedesktop.machine1.Manager",\n                               "MapFromMachineGroup",\n                               &amp;error,\n                               &amp;reply,\n                               "su",\n                               machine, (uint32_t) gid);\n        if (r &lt; 0) {\n                if (sd_bus_error_has_name(&amp;error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, "u", &amp;mapped);\n        if (r &lt; 0)\n                goto fail;\n\n        l = sizeof(char*) + strlen(name) + 1;\n        if (buflen &lt; l) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        memzero(buffer, sizeof(char*));\n        strcpy(buffer + sizeof(char*), name);\n\n        gr-&gt;gr_name = buffer + sizeof(char*);\n        gr-&gt;gr_gid = gid;\n        gr-&gt;gr_passwd = (char*) "*"; /* locked */\n        gr-&gt;gr_mem = (char**) buffer;\n\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\n\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\n\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}',
 'trustedGetBlsPubKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t key_len,\n                       char *bls_pub_key) {\n    LOG_DEBUG(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(bls_pub_key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    SAFE_CHAR_BUF(skey_hex, ECDSA_SKEY_LEN);\n\n    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2("AES decrypt failed %d");\n\n    skey_hex[ECDSA_SKEY_LEN - 1] = 0;\n\n    status = calc_bls_public_key(skey_hex, bls_pub_key);\n\n    CHECK_STATUS("could not calculate bls public key");\n\n    SET_SUCCESS\n    static uint64_t counter = 0;\n    clean:\n    if (counter % 1000 == 0) {\n        LOG_INFO(__FUNCTION__);\n        LOG_INFO("Thousand SGX calls completed");\n    }\n\n    counter++;\n}',
 'static void parseServerLog(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprTicks    timestamp;\n    cchar       *location;\n    ssize       size;\n    int         level, anew, backup;\n\n    if (mprGetCmdlineLogging()) {\n        mprLog("warn http config", 4, "Already logging. Ignoring log configuration");\n        return;\n    }\n    location = mprGetJson(prop, "location");\n    level = (int) stoi(mprGetJson(prop, "level"));\n    backup = (int) stoi(mprGetJson(prop, "backup"));\n    anew = smatch(mprGetJson(prop, "anew"), "true");\n    size = (ssize) httpGetNumber(mprGetJson(prop, "size"));\n    timestamp = httpGetNumber(mprGetJson(prop, "timestamp"));\n\n    if (size &lt; HTTP_TRACE_MIN_LOG_SIZE) {\n        size = HTTP_TRACE_MIN_LOG_SIZE;\n    }\n    if (location == 0) {\n        httpParseError(route, "Missing location");\n        return;\n    }\n    if (!smatch(location, "stdout") &amp;&amp; !smatch(location, "stderr")) {\n        location = httpMakePath(route, 0, location);\n    }\n    mprSetLogBackup(size, backup, anew ? MPR_LOG_ANEW : 0);\n\n    if (mprStartLogging(location, 0) &lt; 0) {\n        httpParseError(route, "Cannot write to error log: %s", location);\n        return;\n    }\n    mprSetLogLevel(level);\n    mprLogConfig();\n    if (timestamp) {\n        httpSetTimestamp(timestamp);\n    }\n}',
 'static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata-&gt;state;\n\tstruct nfs_inode *nfsi = NFS_I(state-&gt;inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata-&gt;o_arg.open_flags &amp; (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&amp;state-&gt;owner-&gt;so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&amp;state-&gt;owner-&gt;so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&amp;state-&gt;owner-&gt;so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi-&gt;delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\t/* Save the delegation */\n\t\tmemcpy(stateid.data, delegation-&gt;stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state-&gt;inode, state-&gt;owner-&gt;so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\n\t\t/* Try to update the stateid using the delegation */\n\t\tif (update_open_stateid(state, NULL, &amp;stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&amp;state-&gt;count);\n\treturn state;\n}',
 'static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\n\tparam.reg_strict = info-&gt;attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info-&gt;attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo-&gt;attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\n\tif (info-&gt;attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info-&gt;attrs[HWSIM_ATTR_CHANNELS]);\n\n\tif (info-&gt;attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\n\tif (info-&gt;attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, "%.*s",\n\t\t\t\t   nla_len(info-&gt;attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info-&gt;attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\n\tif (info-&gt;attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels &gt; 1);\n\n\tif (info-&gt;attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info-&gt;attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n\n\tif (info-&gt;attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n\t\tu32 idx = nla_get_u32(info-&gt;attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\n\t\tif (idx &gt;= ARRAY_SIZE(hwsim_world_regdom_custom))\n\t\t\treturn -EINVAL;\n\t\tparam.regd = hwsim_world_regdom_custom[idx];\n\t}\n\n\tret = mac80211_hwsim_new_radio(info, &amp;param);\n\tkfree(hwname);\n\treturn ret;\n}',
 'int cg_write(const char *path, const char *buf, size_t size, off_t offset,\n\t     struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *localbuf = NULL;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *f = (struct file_info *)fi-&gt;fh;\n\tbool r;\n\n\tif (f-&gt;type != LXC_TYPE_CGFILE) {\n\t\tfprintf(stderr, "Internal error: directory cache info used in cg_write\\n");\n\t\treturn -EIO;\n\t}\n\n\tif (offset)\n\t\treturn 0;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tlocalbuf = alloca(size+1);\n\tlocalbuf[size] = \'\\0\';\n\tmemcpy(localbuf, buf, size);\n\n\tif ((k = cgfs_get_key(f-&gt;controller, f-&gt;cgroup, f-&gt;file)) == NULL) {\n\t\tsize = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!fc_may_access(fc, f-&gt;controller, f-&gt;cgroup, f-&gt;file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(f-&gt;file, "tasks") == 0 ||\n\t\t\tstrcmp(f-&gt;file, "/tasks") == 0 ||\n\t\t\tstrcmp(f-&gt;file, "/cgroup.procs") == 0 ||\n\t\t\tstrcmp(f-&gt;file, "cgroup.procs") == 0)\n\t\t// special case - we have to translate the pids\n\t\tr = do_write_pids(fc-&gt;pid, f-&gt;controller, f-&gt;cgroup, f-&gt;file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f-&gt;controller, f-&gt;cgroup, f-&gt;file, localbuf);\n\n\tif (!r)\n\t\tsize = -EINVAL;\n\nout:\n\tfree_key(k);\n\treturn size;\n}',
 'void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans-&gt;fs_info;\n\tstruct btrfs_transaction *cur_trans = trans-&gt;transaction;\n\n\tif (!trans-&gt;chunk_bytes_reserved)\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&amp;trans-&gt;new_bgs));\n\n\tbtrfs_block_rsv_release(fs_info, &amp;fs_info-&gt;chunk_block_rsv,\n\t\t\t\ttrans-&gt;chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans-&gt;chunk_bytes_reserved, &amp;cur_trans-&gt;chunk_bytes_reserved);\n\tcond_wake_up(&amp;cur_trans-&gt;chunk_reserve_wait);\n\ttrans-&gt;chunk_bytes_reserved = 0;\n}',
 '    bool CFontFileType1::RemovePfbMarkers()\n    {\n        bool bSuccess = true;\n\n        int nBlockType = 0;\n        int nBlockLen  = 0;\n        int nChar = 0;\n\n        unsigned char *sBuffer = NULL;\n        int nBufLen = 0;\n\n        while ( nBlockType != PFB_DONE )\n        {\n            while ( 0 == nBlockLen )\n            {\n                nChar = ReadU8( &amp;bSuccess );\n                if ( !bSuccess )\n                    return false;\n\n                nBlockType = ReadU8( &amp;bSuccess );\n                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType &amp;&amp; PFB_BINARY != nBlockType &amp;&amp; PFB_DONE != nBlockType ) )\n                    return false;\n\n                if ( PFB_DONE == nBlockType )\n                    break;\n\n                nBlockLen = ReadU32LE( &amp;bSuccess );\n                if ( !bSuccess )\n                    return false;\n            }\n\n            // Читаем сам блок данных\n            if ( nBlockLen &gt; 0 )\n            {\n                if ( !sBuffer )\n                {\n                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );\n                    if ( !sBuffer )\n                        return false;\n                }\n                else\n                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );\n\n                Read( sBuffer + nBufLen, nBlockLen );\n                nBufLen += nBlockLen;\n            }\n            nBlockLen = 0;\n        }\n\n        if ( m_bFreeFileData )\n            MemUtilsFree( m_sFile );\n\n        m_bFreeFileData = true;\n        m_sFile         = (unsigned char*)sBuffer;\n        m_sFileData     = m_sFile;\n        m_nLen          = nBufLen;\n        m_nPos          = 0;\n\n        return true;\n    }',
 'snmp_message_decode(snmp_packet_t *snmp_packet, snmp_header_t *header, snmp_varbind_t *varbinds)\n{\n  uint8_t type, len, i;\n\n  if(!snmp_ber_decode_type(snmp_packet, &amp;type)) {\n    LOG_DBG("Could not decode type\\n");\n    return 0;\n  }\n\n  if(type != BER_DATA_TYPE_SEQUENCE) {\n    LOG_DBG("Invalid type\\n");\n    return 0;\n  }\n\n  if(!snmp_ber_decode_length(snmp_packet, &amp;len)) {\n    LOG_DBG("Could not decode length\\n");\n    return 0;\n  }\n\n  if(!snmp_ber_decode_integer(snmp_packet, &amp;header-&gt;version)) {\n    LOG_DBG("Could not decode version\\n");\n    return 0;\n  }\n\n  switch(header-&gt;version) {\n  case SNMP_VERSION_1:\n  case SNMP_VERSION_2C:\n    break;\n  default:\n    LOG_DBG("Invalid version\\n");\n    return 0;\n  }\n\n  if(!snmp_ber_decode_string_len_buffer(snmp_packet, &amp;header-&gt;community.community, &amp;header-&gt;community.length)) {\n    LOG_DBG("Could not decode community\\n");\n    return 0;\n  }\n\n  if(!snmp_ber_decode_type(snmp_packet, &amp;header-&gt;pdu_type)) {\n    LOG_DBG("Could not decode pdu type\\n");\n    return 0;\n  }\n\n  switch(header-&gt;pdu_type) {\n  case BER_DATA_TYPE_PDU_GET_REQUEST:\n  case BER_DATA_TYPE_PDU_GET_NEXT_REQUEST:\n  case BER_DATA_TYPE_PDU_GET_RESPONSE:\n  case BER_DATA_TYPE_PDU_SET_REQUEST:\n  case BER_DATA_TYPE_PDU_GET_BULK:\n    break;\n  default:\n    LOG_DBG("Invalid version\\n");\n    return 0;\n  }\n\n  if(!snmp_ber_decode_length(snmp_packet, &amp;len)) {\n    LOG_DBG("Could not decode length\\n");\n    return 0;\n  }\n\n  if(!snmp_ber_decode_integer(snmp_packet, &amp;header-&gt;request_id)) {\n    LOG_DBG("Could not decode request id\\n");\n    return 0;\n  }\n\n  switch(header-&gt;pdu_type) {\n  case BER_DATA_TYPE_PDU_GET_BULK:\n    if(!snmp_ber_decode_integer(snmp_packet, &amp;header-&gt;non_repeaters)) {\n      LOG_DBG("Could not decode non repeaters\\n");\n      return 0;\n    }\n\n    if(!snmp_ber_decode_integer(snmp_packet, &amp;header-&gt;max_repetitions)) {\n      LOG_DBG("Could not decode max repetition\\n");\n      return 0;\n    }\n    break;\n  default:\n    if(!snmp_ber_decode_integer(snmp_packet, &amp;header-&gt;error_status)) {\n      LOG_DBG("Could not decode error status\\n");\n      return 0;\n    }\n\n    if(!snmp_ber_decode_integer(snmp_packet, &amp;header-&gt;error_index)) {\n      LOG_DBG("Could not decode error index\\n");\n      return 0;\n    }\n    break;\n  }\n\n  if(!snmp_ber_decode_type(snmp_packet, &amp;type)) {\n    LOG_DBG("Could not decode type\\n");\n    return 0;\n  }\n\n  if(type != BER_DATA_TYPE_SEQUENCE) {\n    LOG_DBG("Invalid type\\n");\n    return 0;\n  }\n\n  if(!snmp_ber_decode_length(snmp_packet, &amp;len)) {\n    LOG_DBG("Could not decode length\\n");\n    return 0;\n  }\n\n  for(i = 0; snmp_packet-&gt;used &gt; 0; ++i) {\n    if(i &gt;= SNMP_MAX_NR_VALUES) {\n      LOG_DBG("OID\'s overflow\\n");\n      return 0;\n    }\n\n    if(!snmp_ber_decode_type(snmp_packet, &amp;type)) {\n      LOG_DBG("Could not decode type\\n");\n      return 0;\n    }\n\n    if(type != BER_DATA_TYPE_SEQUENCE) {\n      LOG_DBG("Invalid (%X) type\\n", type);\n      return 0;\n    }\n\n    if(!snmp_ber_decode_length(snmp_packet, &amp;len)) {\n      LOG_DBG("Could not decode length\\n");\n      return 0;\n    }\n\n    if(!snmp_ber_decode_oid(snmp_packet, &amp;varbinds[i].oid)) {\n      LOG_DBG("Could not decode oid\\n");\n      return 0;\n    }\n\n    varbinds[i].value_type = *snmp_packet-&gt;in;\n\n    switch(varbinds[i].value_type) {\n    case BER_DATA_TYPE_INTEGER:\n      if(!snmp_ber_decode_integer(snmp_packet, &amp;varbinds[i].value.integer)) {\n        LOG_DBG("Could not decode integer type\\n");\n        return 0;\n      }\n      break;\n    case BER_DATA_TYPE_TIMETICKS:\n      if(!snmp_ber_decode_timeticks(snmp_packet, &amp;varbinds[i].value.integer)) {\n        LOG_DBG("Could not decode timeticks type\\n");\n        return 0;\n      }\n      break;\n    case BER_DATA_TYPE_OCTET_STRING:\n      if(!snmp_ber_decode_string_len_buffer(snmp_packet, &amp;varbinds[i].value.string.string, &amp;varbinds[i].value.string.length)) {\n        LOG_DBG("Could not decode octed string type\\n");\n        return 0;\n      }\n      break;\n    case BER_DATA_TYPE_NULL:\n      if(!snmp_ber_decode_null(snmp_packet)) {\n        LOG_DBG("Could not decode null type\\n");\n        return 0;\n      }\n      break;\n    default:\n      LOG_DBG("Invalid varbind type\\n");\n      return 0;\n    }\n  }\n\n  return 1;\n}',
 'mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n\n  mrb_get_args(mrb, "o", &amp;orig);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n\n  DATA_TYPE(copy) = &amp;mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, "@buf"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, "@buf"), buf);\n\n  fptr_copy-&gt;fd = mrb_dup(mrb, fptr_orig-&gt;fd, &amp;failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy-&gt;fd);\n\n  if (fptr_orig-&gt;fd2 != -1) {\n    fptr_copy-&gt;fd2 = mrb_dup(mrb, fptr_orig-&gt;fd2, &amp;failed);\n    if (failed) {\n      close(fptr_copy-&gt;fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy-&gt;fd2);\n  }\n\n  fptr_copy-&gt;pid = fptr_orig-&gt;pid;\n  fptr_copy-&gt;readable = fptr_orig-&gt;readable;\n  fptr_copy-&gt;writable = fptr_orig-&gt;writable;\n  fptr_copy-&gt;sync = fptr_orig-&gt;sync;\n  fptr_copy-&gt;is_socket = fptr_orig-&gt;is_socket;\n\n  return copy;\n}',
 's32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n\tu32 pps_id;\n\n\tsi-&gt;irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, "irap_or_gdr_pic");\n\tsi-&gt;non_ref_pic = gf_bs_read_int_log(bs, 1, "non_ref_pic");\n\tif (si-&gt;irap_or_gdr_pic)\n\t\tsi-&gt;gdr_pic = gf_bs_read_int_log(bs, 1, "gdr_pic");\n\tif ((si-&gt;inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, "inter_slice_allowed_flag")))\n\t\tsi-&gt;intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, "intra_slice_allowed_flag");\n\n\tpps_id = gf_bs_read_ue_log(bs, "pps_id");\n\tif (pps_id &gt;= 64)\n\t\treturn -1;\n\tsi-&gt;pps = &amp;vvc-&gt;pps[pps_id];\n\tsi-&gt;sps = &amp;vvc-&gt;sps[si-&gt;pps-&gt;sps_id];\n\tsi-&gt;poc_lsb = gf_bs_read_int_log(bs, si-&gt;sps-&gt;log2_max_poc_lsb, "poc_lsb");\n\n\tsi-&gt;recovery_point_valid = 0;\n\tsi-&gt;gdr_recovery_count = 0;\n\tif (si-&gt;gdr_pic) {\n\t\tsi-&gt;recovery_point_valid = 1;\n\t\tsi-&gt;gdr_recovery_count = gf_bs_read_ue_log(bs, "gdr_recovery_count");\n\t}\n\tgf_bs_read_int_log(bs, si-&gt;sps-&gt;ph_num_extra_bits, "ph_extra_bits");\n\n\tif (si-&gt;sps-&gt;poc_msb_cycle_flag) {\n\t\tif ( (si-&gt;poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, "poc_msb_cycle_present_flag"))) {\n\t\t\tsi-&gt;poc_msb_cycle = gf_bs_read_int_log(bs, si-&gt;sps-&gt;poc_msb_cycle_len, "poc_msb_cycle");\n\t\t}\n\t}\n\n\treturn 0;\n}',
 'static int er_supported(ERContext *s)\n{\n    if(s-&gt;avctx-&gt;hwaccel &amp;&amp; s-&gt;avctx-&gt;hwaccel-&gt;decode_slice           ||\n       !s-&gt;cur_pic.f                                                  ||\n       s-&gt;cur_pic.field_picture\n    )\n        return 0;\n    return 1;\n}',
 "static int userns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct user_namespace *user_ns = ns;\n\tstruct cred *cred;\n\n\t/* Don't allow gaining capabilities by reentering\n\t * the same user namespace.\n\t */\n\tif (user_ns == current_user_ns())\n\t\treturn -EINVAL;\n\n\t/* Threaded processes may not enter a different user namespace */\n\tif (atomic_read(&amp;current-&gt;mm-&gt;mm_users) &gt; 1)\n\t\treturn -EINVAL;\n\n\tif (current-&gt;fs-&gt;users != 1)\n\t\treturn -EINVAL;\n\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tput_user_ns(cred-&gt;user_ns);\n\tset_cred_user_ns(cred, get_user_ns(user_ns));\n\n\treturn commit_creds(cred);\n}",
 'static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)\n{\n\tstruct file *filp;\n\tint ret;\n\n\t/* If the open_intent is for execute, we have an extra check to make */\n\tif (nd-&gt;intent.open.flags &amp; FMODE_EXEC) {\n\t\tret = nfs_may_open(state-&gt;inode,\n\t\t\t\tstate-&gt;owner-&gt;so_cred,\n\t\t\t\tnd-&gt;intent.open.flags);\n\t\tif (ret &lt; 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path-&gt;dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx-&gt;state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, nd-&gt;intent.open.flags);\n\treturn ret;\n}',
 "init_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc &gt; 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc &lt;= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}",
 'static int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf("jpc_dec_decodecblks failed\\n");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile-&gt;tcomps; compno &lt; dec-&gt;numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &amp;tile-&gt;cp-&gt;ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp-&gt;rlvls; rlvlno &lt; tcomp-&gt;numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl-&gt;bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl-&gt;bands;\n\t\t\t  bandno &lt; rlvl-&gt;numbands; ++bandno, ++band) {\n\t\t\t\tif (!band-&gt;data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band-&gt;data, band-&gt;roishift, ccp-&gt;roishift -\n\t\t\t\t  band-&gt;roishift, band-&gt;numbps);\n\t\t\t\tif (tile-&gt;realmode) {\n\t\t\t\t\tjas_matrix_asl(band-&gt;data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band-&gt;data, band-&gt;absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile-&gt;tcomps; compno &lt; dec-&gt;numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &amp;tile-&gt;cp-&gt;ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp-&gt;tsfb, tcomp-&gt;data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile-&gt;cp-&gt;mctid) {\n\tcase JPC_MCT_RCT:\n\t\tif (dec-&gt;numcomps &lt; 3) {\n\t\t\tjas_eprintf("RCT requires at least three components\\n");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec-&gt;image)) {\n\t\t\tjas_eprintf("RCT requires all components have the same domain\\n");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_irct(tile-&gt;tcomps[0].data, tile-&gt;tcomps[1].data,\n\t\t  tile-&gt;tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tif (dec-&gt;numcomps &lt; 3) {\n\t\t\tjas_eprintf("ICT requires at least three components\\n");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec-&gt;image)) {\n\t\t\tjas_eprintf("RCT requires all components have the same domain\\n");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_iict(tile-&gt;tcomps[0].data, tile-&gt;tcomps[1].data,\n\t\t  tile-&gt;tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile-&gt;realmode) {\n\t\tfor (compno = 0, tcomp = tile-&gt;tcomps; compno &lt; dec-&gt;numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i &lt; jas_matrix_numrows(tcomp-&gt;data); ++i) {\n\t\t\t\tfor (j = 0; j &lt; jas_matrix_numcols(tcomp-&gt;data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp-&gt;data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp-&gt;data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile-&gt;tcomps, cmpt = dec-&gt;cmpts; compno &lt;\n\t  dec-&gt;numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt-&gt;sgnd ? 0 : (1 &lt;&lt; (cmpt-&gt;prec - 1));\n\t\tfor (i = 0; i &lt; jas_matrix_numrows(tcomp-&gt;data); ++i) {\n\t\t\tfor (j = 0; j &lt; jas_matrix_numcols(tcomp-&gt;data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp-&gt;data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile-&gt;tcomps, cmpt = dec-&gt;cmpts; compno &lt;\n\t  dec-&gt;numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt-&gt;sgnd ? (-(1 &lt;&lt; (cmpt-&gt;prec - 1))) : (0);\n\t\tmx = cmpt-&gt;sgnd ? ((1 &lt;&lt; (cmpt-&gt;prec - 1)) - 1) : ((1 &lt;&lt;\n\t\t  cmpt-&gt;prec) - 1);\n\t\tjas_matrix_clip(tcomp-&gt;data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile-&gt;tcomps, cmpt = dec-&gt;cmpts; compno &lt;\n\t  dec-&gt;numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec-&gt;image, compno, tcomp-&gt;xstart -\n\t\t  JPC_CEILDIV(dec-&gt;xstart, cmpt-&gt;hstep), tcomp-&gt;ystart -\n\t\t  JPC_CEILDIV(dec-&gt;ystart, cmpt-&gt;vstep), jas_matrix_numcols(\n\t\t  tcomp-&gt;data), jas_matrix_numrows(tcomp-&gt;data), tcomp-&gt;data)) {\n\t\t\tjas_eprintf("write component failed\\n");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}',
 '  Status CalculateOutputIndexValueRowID(\n      const RowPartitionTensor&amp; value_rowids,\n      const vector&lt;INDEX_TYPE&gt;&amp; parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector&lt;INDEX_TYPE&gt;* result) {\n    const INDEX_TYPE index_size = value_rowids.size();\n    result-&gt;reserve(index_size);\n    if (index_size == 0) {\n      return Status::OK();\n    }\n\n    INDEX_TYPE current_output_column = 0;\n    INDEX_TYPE current_value_rowid = value_rowids(0);\n\n    if (current_value_rowid &gt;= parent_output_index.size()) {\n      return errors::InvalidArgument(\n          "Got current_value_rowid=", current_value_rowid,\n          " which is not less than ", parent_output_index.size());\n    }\n\n    INDEX_TYPE current_output_index = parent_output_index[current_value_rowid];\n    result-&gt;push_back(current_output_index);\n    for (INDEX_TYPE i = 1; i &lt; index_size; ++i) {\n      INDEX_TYPE next_value_rowid = value_rowids(i);\n      if (next_value_rowid == current_value_rowid) {\n        if (current_output_index &gt;= 0) {\n          ++current_output_column;\n          if (current_output_column &lt; output_size) {\n            current_output_index += output_index_multiplier;\n          } else {\n            current_output_index = -1;\n          }\n        }\n      } else {\n        current_output_column = 0;\n        current_value_rowid = next_value_rowid;\n\n        if (next_value_rowid &gt;= parent_output_index.size()) {\n          return errors::InvalidArgument(\n              "Got next_value_rowid=", next_value_rowid,\n              " which is not less than ", parent_output_index.size());\n        }\n\n        current_output_index = parent_output_index[next_value_rowid];\n      }\n      result-&gt;push_back(current_output_index);\n    }\n\n    if (result-&gt;size() != value_rowids.size()) {\n      return errors::InvalidArgument("Invalid row ids.");\n    }\n\n    return Status::OK();\n  }',
 'void HeaderMapImpl::subtractSize(uint64_t size) {\n  if (cached_byte_size_.has_value()) {\n    ASSERT(cached_byte_size_ &gt;= size);\n    cached_byte_size_.value() -= size;\n  }\n}',
 'static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tunsigned int *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\n\tfield_type = iw_get_ui16_e(&amp;e-&gt;d[tag_pos+2],e-&gt;endian);\n\tvalue_count = iw_get_ui32_e(&amp;e-&gt;d[tag_pos+4],e-&gt;endian);\n\n\tif(value_count!=1) return 0;\n\n\tif(field_type==3) { // SHORT (uint16)\n\t\t*pv = iw_get_ui16_e(&amp;e-&gt;d[tag_pos+8],e-&gt;endian);\n\t\treturn 1;\n\t}\n\telse if(field_type==4) { // LONG (uint32)\n\t\t*pv = iw_get_ui32_e(&amp;e-&gt;d[tag_pos+8],e-&gt;endian);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}',
 'void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart,\n  int ystart, int xend, int yend)\n{\n\tjas_matrix_bindsub(s, s1, ystart - s1-&gt;ystart_, xstart - s1-&gt;xstart_,\n\t  yend - s1-&gt;ystart_ - 1, xend - s1-&gt;xstart_ - 1);\n}',
 'rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)\n{\n    rpm_mode_t fmode = rpmfilesFMode(fi, ix);\n    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);\n    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);\n    const char * fn = rpmfilesFN(fi, ix);\n    struct stat sb;\n    rpmVerifyAttrs vfy = RPMVERIFY_NONE;\n\n    /*\n     * Check to see if the file was installed - if not pretend all is OK.\n     */\n    switch (rpmfilesFState(fi, ix)) {\n    case RPMFILE_STATE_NETSHARED:\n    case RPMFILE_STATE_NOTINSTALLED:\n\tgoto exit;\n\tbreak;\n    case RPMFILE_STATE_REPLACED:\n\t/* For replaced files we can only verify if it exists at all */\n\tflags = RPMVERIFY_LSTATFAIL;\n\tbreak;\n    case RPMFILE_STATE_WRONGCOLOR:\n\t/*\n\t * Files with wrong color are supposed to share some attributes\n\t * with the actually installed file - verify what we can.\n\t */\n\tflags &amp;= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\n\t\t   RPMVERIFY_MTIME | RPMVERIFY_RDEV);\n\tbreak;\n    case RPMFILE_STATE_NORMAL:\n    /* File from a non-installed package, try to verify nevertheless */\n    case RPMFILE_STATE_MISSING:\n\tbreak;\n    }\n\n    if (fn == NULL || lstat(fn, &amp;sb) != 0) {\n\tvfy |= RPMVERIFY_LSTATFAIL;\n\tgoto exit;\n    }\n\n    /* If we expected a directory but got a symlink to one, follow the link */\n    if (S_ISDIR(fmode) &amp;&amp; S_ISLNK(sb.st_mode) &amp;&amp; stat(fn, &amp;sb) != 0) {\n\tvfy |= RPMVERIFY_LSTATFAIL;\n\tgoto exit;\n    }\n\n    /* Links have no mode, other types have no linkto */\n    if (S_ISLNK(sb.st_mode))\n\tflags &amp;= ~(RPMVERIFY_MODE);\n    else\n\tflags &amp;= ~(RPMVERIFY_LINKTO);\n\n    /* Not all attributes of non-regular files can be verified */\n    if (!S_ISREG(sb.st_mode))\n\tflags &amp;= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\n\t\t   RPMVERIFY_MTIME | RPMVERIFY_CAPS);\n\n    /* Content checks of %ghost files are meaningless. */\n    if (fileAttrs &amp; RPMFILE_GHOST)\n\tflags &amp;= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\n\t\t   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);\n\n    /* Don\'t verify any features in omitMask. */\n    flags &amp;= ~(omitMask | RPMVERIFY_FAILURES);\n\n\n    if (flags &amp; RPMVERIFY_FILEDIGEST) {\n\tconst unsigned char *digest; \n\tint algo;\n\tsize_t diglen;\n\n\t/* XXX If --nomd5, then prelinked library sizes are not corrected. */\n\tif ((digest = rpmfilesFDigest(fi, ix, &amp;algo, &amp;diglen))) {\n\t    unsigned char fdigest[diglen];\n\t    rpm_loff_t fsize;\n\n\t    if (rpmDoDigest(algo, fn, 0, fdigest, &amp;fsize)) {\n\t\tvfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);\n\t    } else {\n\t\tsb.st_size = fsize;\n\t\tif (memcmp(fdigest, digest, diglen))\n\t\t    vfy |= RPMVERIFY_FILEDIGEST;\n\t    }\n\t} else {\n\t    vfy |= RPMVERIFY_FILEDIGEST;\n\t} \n    } \n\n    if (flags &amp; RPMVERIFY_LINKTO) {\n\tchar linkto[1024+1];\n\tint size = 0;\n\n\tif ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)\n\t    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);\n\telse {\n\t    const char * flink = rpmfilesFLink(fi, ix);\n\t    linkto[size] = \'\\0\';\n\t    if (flink == NULL || !rstreq(linkto, flink))\n\t\tvfy |= RPMVERIFY_LINKTO;\n\t}\n    } \n\n    if (flags &amp; RPMVERIFY_FILESIZE) {\n\tif (sb.st_size != rpmfilesFSize(fi, ix))\n\t    vfy |= RPMVERIFY_FILESIZE;\n    } \n\n    if (flags &amp; RPMVERIFY_MODE) {\n\trpm_mode_t metamode = fmode;\n\trpm_mode_t filemode;\n\n\t/*\n\t * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)\n\t * need the (rpm_mode_t) cast here. \n\t */\n\tfilemode = (rpm_mode_t)sb.st_mode;\n\n\t/*\n\t * Comparing the type of %ghost files is meaningless, but perms are OK.\n\t */\n\tif (fileAttrs &amp; RPMFILE_GHOST) {\n\t    metamode &amp;= ~0xf000;\n\t    filemode &amp;= ~0xf000;\n\t}\n\n\tif (metamode != filemode)\n\t    vfy |= RPMVERIFY_MODE;\n\n#if WITH_ACL\n\t/*\n\t * For now, any non-default acl\'s on a file is a difference as rpm\n\t * cannot have set them.\n\t */\n\tacl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);\n\tif (facl) {\n\t    if (acl_equiv_mode(facl, NULL) == 1) {\n\t\tvfy |= RPMVERIFY_MODE;\n\t    }\n\t    acl_free(facl);\n\t}\n#endif \n    }\n\n    if (flags &amp; RPMVERIFY_RDEV) {\n\tif (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)\n\t || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))\n\t{\n\t    vfy |= RPMVERIFY_RDEV;\n\t} else if (S_ISDEV(fmode) &amp;&amp; S_ISDEV(sb.st_mode)) {\n\t    rpm_rdev_t st_rdev = (sb.st_rdev &amp; 0xffff);\n\t    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) &amp; 0xffff);\n\t    if (st_rdev != frdev)\n\t\tvfy |= RPMVERIFY_RDEV;\n\t} \n    }\n\n#if WITH_CAP\n    if (flags &amp; RPMVERIFY_CAPS) {\n\t/*\n \t * Empty capability set ("=") is not exactly the same as no\n \t * capabilities at all but suffices for now... \n \t */\n\tcap_t cap, fcap;\n\tcap = cap_from_text(rpmfilesFCaps(fi, ix));\n\tif (!cap) {\n\t    cap = cap_from_text("=");\n\t}\n\tfcap = cap_get_file(fn);\n\tif (!fcap) {\n\t    fcap = cap_from_text("=");\n\t}\n\t\n\tif (cap_compare(cap, fcap) != 0)\n\t    vfy |= RPMVERIFY_CAPS;\n\n\tcap_free(fcap);\n\tcap_free(cap);\n    }\n#endif\n\n    if ((flags &amp; RPMVERIFY_MTIME) &amp;&amp; (sb.st_mtime != rpmfilesFMtime(fi, ix))) {\n\tvfy |= RPMVERIFY_MTIME;\n    }\n\n    if (flags &amp; RPMVERIFY_USER) {\n\tconst char * name = rpmugUname(sb.st_uid);\n\tconst char * fuser = rpmfilesFUser(fi, ix);\n\tuid_t uid;\n\tint namematch = 0;\n\tint idmatch = 0;\n\n\tif (name &amp;&amp; fuser)\n\t   namematch =  rstreq(name, fuser);\n\tif (fuser &amp;&amp; rpmugUid(fuser, &amp;uid) == 0)\n\t    idmatch = (uid == sb.st_uid);\n\n\tif (namematch != idmatch) {\n\t    rpmlog(RPMLOG_WARNING,\n\t\t    _("Duplicate username or UID for user %s\\n"), fuser);\n\t}\n\n\tif (!(namematch || idmatch))\n\t    vfy |= RPMVERIFY_USER;\n    }\n\n    if (flags &amp; RPMVERIFY_GROUP) {\n\tconst char * name = rpmugGname(sb.st_gid);\n\tconst char * fgroup = rpmfilesFGroup(fi, ix);\n\tgid_t gid;\n\tint namematch = 0;\n\tint idmatch = 0;\n\n\tif (name &amp;&amp; fgroup)\n\t    namematch = rstreq(name, fgroup);\n\tif (fgroup &amp;&amp; rpmugGid(fgroup, &amp;gid) == 0)\n\t    idmatch = (gid == sb.st_gid);\n\n\tif (namematch != idmatch) {\n\t    rpmlog(RPMLOG_WARNING,\n\t\t    _("Duplicate groupname or GID for group %s\\n"), fgroup);\n\t}\n\n\tif (!(namematch || idmatch))\n\t    vfy |= RPMVERIFY_GROUP;\n    }\n\nexit:\n    return vfy;\n}',
 'pci_lintr_assert(struct pci_vdev *dev)\n{\n\tassert(dev-&gt;lintr.pin &gt; 0);\n\n\tpthread_mutex_lock(&amp;dev-&gt;lintr.lock);\n\tif (dev-&gt;lintr.state == IDLE) {\n\t\tif (pci_lintr_permitted(dev)) {\n\t\t\tdev-&gt;lintr.state = ASSERTED;\n\t\t\tpci_irq_assert(dev);\n\t\t} else\n\t\t\tdev-&gt;lintr.state = PENDING;\n\t}\n\tpthread_mutex_unlock(&amp;dev-&gt;lintr.lock);\n}',
 'error_t ssiProcessExecCommand(HttpConnection *connection, const char_t *tag, size_t length)\n{\n   char_t *separator;\n   char_t *attribute;\n   char_t *value;\n\n   //First, check whether CGI is supported by the server\n   if(connection-&gt;settings-&gt;cgiCallback == NULL)\n      return ERROR_INVALID_TAG;\n\n   //Discard invalid SSI directives\n   if(length &lt; 4 || length &gt;= HTTP_SERVER_BUFFER_SIZE)\n      return ERROR_INVALID_TAG;\n\n   //Skip the SSI exec command (4 bytes)\n   osMemcpy(connection-&gt;buffer, tag + 4, length - 4);\n   //Ensure the resulting string is NULL-terminated\n   connection-&gt;buffer[length - 4] = \'\\0\';\n\n   //Check whether a separator is present\n   separator = strchr(connection-&gt;buffer, \'=\');\n   //Separator not found?\n   if(!separator)\n      return ERROR_INVALID_TAG;\n\n   //Split the tag\n   *separator = \'\\0\';\n\n   //Get attribute name and value\n   attribute = strTrimWhitespace(connection-&gt;buffer);\n   value = strTrimWhitespace(separator + 1);\n\n   //Remove leading simple or double quote\n   if(value[0] == \'\\\'\' || value[0] == \'\\"\')\n      value++;\n\n   //Get the length of the attribute value\n   length = osStrlen(value);\n\n   //Remove trailing simple or double quote\n   if(length &gt; 0)\n   {\n      if(value[length - 1] == \'\\\'\' || value[length - 1] == \'\\"\')\n         value[length - 1] = \'\\0\';\n   }\n\n   //Enforce attribute name\n   if(osStrcasecmp(attribute, "cgi") &amp;&amp; osStrcasecmp(attribute, "cmd") &amp;&amp; osStrcasecmp(attribute, "cmd_argument"))\n      return ERROR_INVALID_TAG;\n   //Check the length of the CGI parameter\n   if(osStrlen(value) &gt; HTTP_SERVER_CGI_PARAM_MAX_LEN)\n      return ERROR_INVALID_TAG;\n\n   //The scratch buffer may be altered by the user-defined callback.\n   //So the CGI parameter must be copied prior to function invocation\n   osStrcpy(connection-&gt;cgiParam, value);\n\n   //Invoke user-defined callback\n   return connection-&gt;settings-&gt;cgiCallback(connection, connection-&gt;cgiParam);\n}',
 'error_t enc624j600SoftReset(NetInterface *interface)\n{\n   //Wait for the SPI interface to be ready\n   do\n   {\n      //Write 0x1234 to EUDAST\n      enc624j600WriteReg(interface, ENC624J600_REG_EUDAST, 0x1234);\n      //Read back register and check contents\n   } while(enc624j600ReadReg(interface, ENC624J600_REG_EUDAST) != 0x1234);\n\n   //Poll CLKRDY and wait for it to become set\n   while((enc624j600ReadReg(interface, ENC624J600_REG_ESTAT) &amp; ESTAT_CLKRDY) == 0)\n   {\n   }\n\n   //Issue a system reset command by setting ETHRST\n   enc624j600SetBit(interface, ENC624J600_REG_ECON2, ECON2_ETHRST);\n   //Wait at least 25us for the reset to take place\n   sleep(1);\n\n   //Read EUDAST to confirm that the system reset took place.\n   //EUDAST should have reverted back to its reset default\n   if(enc624j600ReadReg(interface, ENC624J600_REG_EUDAST) != 0x0000)\n   {\n      return ERROR_FAILURE;\n   }\n\n   //Wait at least 256us for the PHY registers and PHY\n   //status bits to become available\n   sleep(1);\n\n   //The controller is now ready to accept further commands\n   return NO_ERROR;\n}',
 'bool DecodeResourceHandleList(std::unique_ptr&lt;port::StringListDecoder&gt; d,\n                              ResourceHandle* ps, int64_t n) {\n  std::vector&lt;uint32&gt; sizes(n);\n  if (!d-&gt;ReadSizes(&amp;sizes)) return false;\n\n  ResourceHandleProto proto;\n  for (int i = 0; i &lt; n; ++i) {\n    if (!proto.ParseFromArray(d-&gt;Data(sizes[i]), sizes[i])) {\n      return false;\n    }\n    ps[i].FromProto(proto);\n  }\n  return true;\n}',
 'crm_remote_tcp_connect(const char *host, int port)\n{\n    struct addrinfo *res;\n    struct addrinfo *rp;\n    struct addrinfo hints;\n    const char *server = host;\n    int ret_ga;\n    int sock;\n\n    /* getaddrinfo */\n    memset(&amp;hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_CANONNAME;\n\n    crm_debug("Looking up %s", server);\n    ret_ga = getaddrinfo(server, NULL, &amp;hints, &amp;res);\n    if (ret_ga) {\n        crm_err("getaddrinfo: %s", gai_strerror(ret_ga));\n        return -1;\n    }\n\n    if (!res || !res-&gt;ai_addr) {\n        crm_err("getaddrinfo failed");\n        return -1;\n    }\n\n    for (rp = res; rp != NULL; rp = rp-&gt;ai_next) {\n        struct sockaddr *addr = rp-&gt;ai_addr;\n        int flag = 0;\n        if (!addr) {\n            continue;\n        }\n\n        if (rp-&gt;ai_canonname) {\n            server = res-&gt;ai_canonname;\n        }\n        crm_debug("Got address %s for %s", server, host);\n\n        /* create socket */\n        sock = socket(rp-&gt;ai_family, SOCK_STREAM, IPPROTO_TCP);\n        if (sock == -1) {\n            crm_err("Socket creation failed for remote client connection.");\n            continue;\n        }\n        if (addr-&gt;sa_family == AF_INET6) {\n            struct sockaddr_in6 *addr_in = (struct sockaddr_in6 *) addr;\n            addr_in-&gt;sin6_port = htons(port);\n        } else {\n            struct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n            addr_in-&gt;sin_port = htons(port);\n            crm_info("Attempting to connect to remote server at %s:%d", inet_ntoa(addr_in-&gt;sin_addr), port);\n        }\n\n        if (connect(sock, rp-&gt;ai_addr, rp-&gt;ai_addrlen) == 0) {\n            if ((flag = fcntl(sock, F_GETFL)) &gt;= 0) {\n                if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) &lt; 0) {\n                    crm_err( "fcntl() write failed");\n                    close(sock);\n                    sock = -1;\n                    continue;\n                }\n            }\n            break;                  /* Success */\n        }\n\n        close(sock);\n        sock = -1;\n    }\n    freeaddrinfo(res);\n\n    return sock;\n}',
 'static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\n\tbuf = (void *)src_parm-&gt;u.pointer.u.linear_addr;\n\tlen = src_parm-&gt;u.pointer.size;\n\tcopy_in = src_parm-&gt;type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\n\tif (len &gt; VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\n\t*bounce_buf_ret = bounce_buf;\n\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}',
 'create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &amp;ret);\n\n    if ((ret.code = new_server_handle(arg-&gt;api_version, rqstp, &amp;handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle-&gt;api_version;\n\n    if (setup_gss_names(rqstp, &amp;client_name, &amp;service_name) &lt; 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg-&gt;rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle-&gt;context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth("kadm5_create_policy", prime_arg,\n                   &amp;client_name, &amp;service_name, rqstp);\n\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &amp;arg-&gt;rec,\n                                       arg-&gt;mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle-&gt;context, ret.code);\n\n        log_done("kadm5_create_policy",\n                 ((prime_arg == NULL) ? "(null)" : prime_arg), errmsg,\n                 &amp;client_name, &amp;service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle-&gt;context, errmsg);\n    }\n    gss_release_buffer(&amp;minor_stat, &amp;client_name);\n    gss_release_buffer(&amp;minor_stat, &amp;service_name);\nexit_func:\n    free_server_handle(handle);\n    return &amp;ret;\n}',
 'ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)\n{\n\tint32\t\tlen;\n\tchar\t   *buf;\n\tProtocolVersion proto;\n\tMemoryContext oldcontext;\n\n\tpq_startmsgread();\n\n\t/*\n\t * Grab the first byte of the length word separately, so that we can tell\n\t * whether we have no data at all or an incomplete packet.  (This might\n\t * sound inefficient, but it\'s not really, because of buffering in\n\t * pqcomm.c.)\n\t */\n\tif (pq_getbytes((char *) &amp;len, 1) == EOF)\n\t{\n\t\t/*\n\t\t * If we get no data at all, don\'t clutter the log with a complaint;\n\t\t * such cases often occur for legitimate reasons.  An example is that\n\t\t * we might be here after responding to NEGOTIATE_SSL_CODE, and if the\n\t\t * client didn\'t like our response, it\'ll probably just drop the\n\t\t * connection.  Service-monitoring software also often just opens and\n\t\t * closes a connection without sending anything.  (So do port\n\t\t * scanners, which may be less benign, but it\'s not really our job to\n\t\t * notice those.)\n\t\t */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (pq_getbytes(((char *) &amp;len) + 1, 3) == EOF)\n\t{\n\t\t/* Got a partial length word, so bleat about that */\n\t\tif (!ssl_done &amp;&amp; !gss_done)\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg("incomplete startup packet")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tlen = pg_ntoh32(len);\n\tlen -= 4;\n\n\tif (len &lt; (int32) sizeof(ProtocolVersion) ||\n\t\tlen &gt; MAX_STARTUP_PACKET_LENGTH)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg("invalid length of startup packet")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * Allocate space to hold the startup packet, plus one extra byte that\'s\n\t * initialized to be zero.  This ensures we will have null termination of\n\t * all strings inside the packet.\n\t */\n\tbuf = palloc(len + 1);\n\tbuf[len] = \'\\0\';\n\n\tif (pq_getbytes(buf, len) == EOF)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg("incomplete startup packet")));\n\t\treturn STATUS_ERROR;\n\t}\n\tpq_endmsgread();\n\n\t/*\n\t * The first field is either a protocol version number or a special\n\t * request code.\n\t */\n\tport-&gt;proto = proto = pg_ntoh32(*((ProtocolVersion *) buf));\n\n\tif (proto == CANCEL_REQUEST_CODE)\n\t{\n\t\tprocessCancelRequest(port, buf);\n\t\t/* Not really an error, but we don\'t want to proceed further */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (proto == NEGOTIATE_SSL_CODE &amp;&amp; !ssl_done)\n\t{\n\t\tchar\t\tSSLok;\n\n#ifdef USE_SSL\n\t\t/* No SSL when disabled or on Unix sockets */\n\t\tif (!LoadedSSL || IS_AF_UNIX(port-&gt;laddr.addr.ss_family))\n\t\t\tSSLok = \'N\';\n\t\telse\n\t\t\tSSLok = \'S\';\t\t/* Support for SSL */\n#else\n\t\tSSLok = \'N\';\t\t\t/* No support for SSL */\n#endif\n\nretry1:\n\t\tif (send(port-&gt;sock, &amp;SSLok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto retry1;\t/* if interrupted, just retry */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg("failed to send SSL negotiation response: %m")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef USE_SSL\n\t\tif (SSLok == \'S\' &amp;&amp; secure_open_server(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * At this point we should have no data already buffered.  If we do,\n\t\t * it was received before we performed the SSL handshake, so it wasn\'t\n\t\t * encrypted and indeed may have been injected by a man-in-the-middle.\n\t\t * We report this case to the client.\n\t\t */\n\t\tif (pq_buffer_has_data())\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg("received unencrypted data after SSL request"),\n\t\t\t\t\t errdetail("This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.")));\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another SSL negotiation request, and a GSS request should only\n\t\t * follow if SSL was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, true, SSLok == \'S\');\n\t}\n\telse if (proto == NEGOTIATE_GSS_CODE &amp;&amp; !gss_done)\n\t{\n\t\tchar\t\tGSSok = \'N\';\n\n#ifdef ENABLE_GSS\n\t\t/* No GSSAPI encryption when on Unix socket */\n\t\tif (!IS_AF_UNIX(port-&gt;laddr.addr.ss_family))\n\t\t\tGSSok = \'G\';\n#endif\n\n\t\twhile (send(port-&gt;sock, &amp;GSSok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg("failed to send GSSAPI negotiation response: %m")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef ENABLE_GSS\n\t\tif (GSSok == \'G\' &amp;&amp; secure_open_gssapi(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * At this point we should have no data already buffered.  If we do,\n\t\t * it was received before we performed the GSS handshake, so it wasn\'t\n\t\t * encrypted and indeed may have been injected by a man-in-the-middle.\n\t\t * We report this case to the client.\n\t\t */\n\t\tif (pq_buffer_has_data())\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg("received unencrypted data after GSSAPI encryption request"),\n\t\t\t\t\t errdetail("This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.")));\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another GSS negotiation request, and an SSL request should only\n\t\t * follow if GSS was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, GSSok == \'G\', true);\n\t}\n\n\t/* Could add additional special packet types here */\n\n\t/*\n\t * Set FrontendProtocol now so that ereport() knows what format to send if\n\t * we fail during startup.\n\t */\n\tFrontendProtocol = proto;\n\n\t/* Check that the major protocol version is in range. */\n\tif (PG_PROTOCOL_MAJOR(proto) &lt; PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||\n\t\tPG_PROTOCOL_MAJOR(proto) &gt; PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg("unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u",\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),\n\t\t\t\t\t\tPG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));\n\n\t/*\n\t * Now fetch parameters out of startup packet and save them into the Port\n\t * structure.  All data structures attached to the Port struct must be\n\t * allocated in TopMemoryContext so that they will remain available in a\n\t * running backend (even after PostmasterContext is destroyed).  We need\n\t * not worry about leaking this storage on failure, since we aren\'t in the\n\t * postmaster process anymore.\n\t */\n\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Handle protocol version 3 startup packet */\n\t{\n\t\tint32\t\toffset = sizeof(ProtocolVersion);\n\t\tList\t   *unrecognized_protocol_options = NIL;\n\n\t\t/*\n\t\t * Scan packet body for name/option pairs.  We can assume any string\n\t\t * beginning within the packet body is null-terminated, thanks to\n\t\t * zeroing extra byte above.\n\t\t */\n\t\tport-&gt;guc_options = NIL;\n\n\t\twhile (offset &lt; len)\n\t\t{\n\t\t\tchar\t   *nameptr = buf + offset;\n\t\t\tint32\t\tvaloffset;\n\t\t\tchar\t   *valptr;\n\n\t\t\tif (*nameptr == \'\\0\')\n\t\t\t\tbreak;\t\t\t/* found packet terminator */\n\t\t\tvaloffset = offset + strlen(nameptr) + 1;\n\t\t\tif (valoffset &gt;= len)\n\t\t\t\tbreak;\t\t\t/* missing value, will complain below */\n\t\t\tvalptr = buf + valoffset;\n\n\t\t\tif (strcmp(nameptr, "database") == 0)\n\t\t\t\tport-&gt;database_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, "user") == 0)\n\t\t\t\tport-&gt;user_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, "options") == 0)\n\t\t\t\tport-&gt;cmdline_options = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, "replication") == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Due to backward compatibility concerns the replication\n\t\t\t\t * parameter is a hybrid beast which allows the value to be\n\t\t\t\t * either boolean or the string \'database\'. The latter\n\t\t\t\t * connects to a specific database which is e.g. required for\n\t\t\t\t * logical decoding while.\n\t\t\t\t */\n\t\t\t\tif (strcmp(valptr, "database") == 0)\n\t\t\t\t{\n\t\t\t\t\tam_walsender = true;\n\t\t\t\t\tam_db_walsender = true;\n\t\t\t\t}\n\t\t\t\telse if (!parse_bool(valptr, &amp;am_walsender))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg("invalid value for parameter \\"%s\\": \\"%s\\"",\n\t\t\t\t\t\t\t\t\t"replication",\n\t\t\t\t\t\t\t\t\tvalptr),\n\t\t\t\t\t\t\t errhint("Valid values are: \\"false\\", 0, \\"true\\", 1, \\"database\\".")));\n\t\t\t}\n\t\t\telse if (strncmp(nameptr, "_pq_.", 5) == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Any option beginning with _pq_. is reserved for use as a\n\t\t\t\t * protocol-level option, but at present no such options are\n\t\t\t\t * defined.\n\t\t\t\t */\n\t\t\t\tunrecognized_protocol_options =\n\t\t\t\t\tlappend(unrecognized_protocol_options, pstrdup(nameptr));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Assume it\'s a generic GUC option */\n\t\t\t\tport-&gt;guc_options = lappend(port-&gt;guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(nameptr));\n\t\t\t\tport-&gt;guc_options = lappend(port-&gt;guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(valptr));\n\n\t\t\t\t/*\n\t\t\t\t * Copy application_name to port if we come across it.  This\n\t\t\t\t * is done so we can log the application_name in the\n\t\t\t\t * connection authorization message.  Note that the GUC would\n\t\t\t\t * be used but we haven\'t gone through GUC setup yet.\n\t\t\t\t */\n\t\t\t\tif (strcmp(nameptr, "application_name") == 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *tmp_app_name = pstrdup(valptr);\n\n\t\t\t\t\tpg_clean_ascii(tmp_app_name);\n\n\t\t\t\t\tport-&gt;application_name = tmp_app_name;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = valoffset + strlen(valptr) + 1;\n\t\t}\n\n\t\t/*\n\t\t * If we didn\'t find a packet terminator exactly at the end of the\n\t\t * given packet length, complain.\n\t\t */\n\t\tif (offset != len - 1)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg("invalid startup packet layout: expected terminator as last byte")));\n\n\t\t/*\n\t\t * If the client requested a newer protocol version or if the client\n\t\t * requested any protocol options we didn\'t recognize, let them know\n\t\t * the newest minor protocol version we do support and the names of\n\t\t * any unrecognized options.\n\t\t */\n\t\tif (PG_PROTOCOL_MINOR(proto) &gt; PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST) ||\n\t\t\tunrecognized_protocol_options != NIL)\n\t\t\tSendNegotiateProtocolVersion(unrecognized_protocol_options);\n\t}\n\n\t/* Check a user name was given. */\n\tif (port-&gt;user_name == NULL || port-&gt;user_name[0] == \'\\0\')\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t errmsg("no PostgreSQL user name specified in startup packet")));\n\n\t/* The database defaults to the user name. */\n\tif (port-&gt;database_name == NULL || port-&gt;database_name[0] == \'\\0\')\n\t\tport-&gt;database_name = pstrdup(port-&gt;user_name);\n\n\tif (Db_user_namespace)\n\t{\n\t\t/*\n\t\t * If user@, it is a global user, remove \'@\'. We only want to do this\n\t\t * if there is an \'@\' at the end and no earlier in the user string or\n\t\t * they may fake as a local user of another database attaching to this\n\t\t * database.\n\t\t */\n\t\tif (strchr(port-&gt;user_name, \'@\') ==\n\t\t\tport-&gt;user_name + strlen(port-&gt;user_name) - 1)\n\t\t\t*strchr(port-&gt;user_name, \'@\') = \'\\0\';\n\t\telse\n\t\t{\n\t\t\t/* Append \'@\' and dbname */\n\t\t\tport-&gt;user_name = psprintf("%s@%s", port-&gt;user_name, port-&gt;database_name);\n\t\t}\n\t}\n\n\t/*\n\t * Truncate given database and user names to length of a Postgres name.\n\t * This avoids lookup failures when overlength names are given.\n\t */\n\tif (strlen(port-&gt;database_name) &gt;= NAMEDATALEN)\n\t\tport-&gt;database_name[NAMEDATALEN - 1] = \'\\0\';\n\tif (strlen(port-&gt;user_name) &gt;= NAMEDATALEN)\n\t\tport-&gt;user_name[NAMEDATALEN - 1] = \'\\0\';\n\n\tif (am_walsender)\n\t\tMyBackendType = B_WAL_SENDER;\n\telse\n\t\tMyBackendType = B_BACKEND;\n\n\t/*\n\t * Normal walsender backends, e.g. for streaming replication, are not\n\t * connected to a particular database. But walsenders used for logical\n\t * replication need to connect to a specific database. We allow streaming\n\t * replication commands to be issued even if connected to a database as it\n\t * can make sense to first make a basebackup and then stream changes\n\t * starting from that.\n\t */\n\tif (am_walsender &amp;&amp; !am_db_walsender)\n\t\tport-&gt;database_name[0] = \'\\0\';\n\n\t/*\n\t * Done putting stuff in TopMemoryContext.\n\t */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * If we\'re going to reject the connection due to database state, say so\n\t * now instead of wasting cycles on an authentication exchange. (This also\n\t * allows a pg_ping utility to be written.)\n\t */\n\tswitch (port-&gt;canAcceptConnections)\n\t{\n\t\tcase CAC_STARTUP:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg("the database system is starting up")));\n\t\t\tbreak;\n\t\tcase CAC_NOTCONSISTENT:\n\t\t\tif (EnableHotStandby)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg("the database system is not yet accepting connections"),\n\t\t\t\t\t\t errdetail("Consistent recovery state has not been yet reached.")));\n\t\t\telse\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg("the database system is not accepting connections"),\n\t\t\t\t\t\t errdetail("Hot standby mode is disabled.")));\n\t\t\tbreak;\n\t\tcase CAC_SHUTDOWN:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg("the database system is shutting down")));\n\t\t\tbreak;\n\t\tcase CAC_RECOVERY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg("the database system is in recovery mode")));\n\t\t\tbreak;\n\t\tcase CAC_TOOMANY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg("sorry, too many clients already")));\n\t\t\tbreak;\n\t\tcase CAC_SUPERUSER:\n\t\t\t/* OK for now, will check in InitPostgres */\n\t\t\tbreak;\n\t\tcase CAC_OK:\n\t\t\tbreak;\n\t}\n\n\treturn STATUS_OK;\n}',
 'static INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block)\n{\n\tOPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32) = 00;\n\tOPJ_UINT32 compno, resno, bandno, precno, cblkno;\n\topj_tcp_t * l_tcp = 00;\n\topj_cp_t * l_cp = 00;\n\topj_tcd_tile_t * l_tile = 00;\n\topj_tccp_t *l_tccp = 00;\n\topj_tcd_tilecomp_t *l_tilec = 00;\n\topj_image_comp_t * l_image_comp = 00;\n\topj_tcd_resolution_t *l_res = 00;\n\topj_tcd_band_t *l_band = 00;\n\topj_stepsize_t * l_step_size = 00;\n\topj_tcd_precinct_t *l_current_precinct = 00;\n\topj_image_t *l_image = 00;\n\tOPJ_UINT32 p,q;\n\tOPJ_UINT32 l_level_no;\n\tOPJ_UINT32 l_pdx, l_pdy;\n\tOPJ_UINT32 l_gain;\n\tOPJ_INT32 l_x0b, l_y0b;\n\t/* extent of precincts , top left, bottom right**/\n\tOPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;\n\t/* number of precinct for a resolution */\n\tOPJ_UINT32 l_nb_precincts;\n\t/* room needed to store l_nb_precinct precinct for a resolution */\n\tOPJ_UINT32 l_nb_precinct_size;\n\t/* number of code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks;\n\t/* room needed to store l_nb_code_blocks code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks_size;\n\t/* size of data for a tile */\n\tOPJ_UINT32 l_data_size;\n\t\n\tl_cp = p_tcd-&gt;cp;\n\tl_tcp = &amp;(l_cp-&gt;tcps[p_tile_no]);\n\tl_tile = p_tcd-&gt;tcd_image-&gt;tiles;\n\tl_tccp = l_tcp-&gt;tccps;\n\tl_tilec = l_tile-&gt;comps;\n\tl_image = p_tcd-&gt;image;\n\tl_image_comp = p_tcd-&gt;image-&gt;comps;\n\t\n\tp = p_tile_no % l_cp-&gt;tw;       /* tile coordinates */\n\tq = p_tile_no / l_cp-&gt;tw;\n\t/*fprintf(stderr, "Tile coordinate = %d,%d\\n", p, q);*/\n\t\n\t/* 4 borders of the tile rescale on the image if necessary */\n\tl_tile-&gt;x0 = opj_int_max((OPJ_INT32)(l_cp-&gt;tx0 + p * l_cp-&gt;tdx), (OPJ_INT32)l_image-&gt;x0);\n\tl_tile-&gt;y0 = opj_int_max((OPJ_INT32)(l_cp-&gt;ty0 + q * l_cp-&gt;tdy), (OPJ_INT32)l_image-&gt;y0);\n\tl_tile-&gt;x1 = opj_int_min((OPJ_INT32)(l_cp-&gt;tx0 + (p + 1) * l_cp-&gt;tdx), (OPJ_INT32)l_image-&gt;x1);\n\tl_tile-&gt;y1 = opj_int_min((OPJ_INT32)(l_cp-&gt;ty0 + (q + 1) * l_cp-&gt;tdy), (OPJ_INT32)l_image-&gt;y1);\n\t/* testcase 1888.pdf.asan.35.988 */\n\tif (l_tccp-&gt;numresolutions == 0) {\n\t\tfprintf(stderr, "tiles require at least one resolution\\n");\n\t\treturn OPJ_FALSE;\n\t}\n\t/*fprintf(stderr, "Tile border = %d,%d,%d,%d\\n", l_tile-&gt;x0, l_tile-&gt;y0,l_tile-&gt;x1,l_tile-&gt;y1);*/\n\t\n\t/*tile-&gt;numcomps = image-&gt;numcomps; */\n\tfor (compno = 0; compno &lt; l_tile-&gt;numcomps; ++compno) {\n\t\t/*fprintf(stderr, "compno = %d/%d\\n", compno, l_tile-&gt;numcomps);*/\n\t\tl_image_comp-&gt;resno_decoded = 0;\n\t\t/* border of each l_tile component (global) */\n\t\tl_tilec-&gt;x0 = opj_int_ceildiv(l_tile-&gt;x0, (OPJ_INT32)l_image_comp-&gt;dx);\n\t\tl_tilec-&gt;y0 = opj_int_ceildiv(l_tile-&gt;y0, (OPJ_INT32)l_image_comp-&gt;dy);\n\t\tl_tilec-&gt;x1 = opj_int_ceildiv(l_tile-&gt;x1, (OPJ_INT32)l_image_comp-&gt;dx);\n\t\tl_tilec-&gt;y1 = opj_int_ceildiv(l_tile-&gt;y1, (OPJ_INT32)l_image_comp-&gt;dy);\n\t\t/*fprintf(stderr, "\\tTile compo border = %d,%d,%d,%d\\n", l_tilec-&gt;x0, l_tilec-&gt;y0,l_tilec-&gt;x1,l_tilec-&gt;y1);*/\n\t\t\n\t\t/* compute l_data_size with overflow check */\n\t\tl_data_size = (OPJ_UINT32)(l_tilec-&gt;x1 - l_tilec-&gt;x0);\n\t\tif ((((OPJ_UINT32)-1) / l_data_size) &lt; (OPJ_UINT32)(l_tilec-&gt;y1 - l_tilec-&gt;y0)) {\n\t\t\t/* TODO event */\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)(l_tilec-&gt;y1 - l_tilec-&gt;y0);\n\t\t\n\t\tif ((((OPJ_UINT32)-1) / (OPJ_UINT32)sizeof(OPJ_UINT32)) &lt; l_data_size) {\n\t\t\t/* TODO event */\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)sizeof(OPJ_UINT32);\n\t\tl_tilec-&gt;numresolutions = l_tccp-&gt;numresolutions;\n\t\tif (l_tccp-&gt;numresolutions &lt; l_cp-&gt;m_specific_param.m_dec.m_reduce) {\n\t\t\tl_tilec-&gt;minimum_num_resolutions = 1;\n\t\t}\n\t\telse {\n\t\t\tl_tilec-&gt;minimum_num_resolutions = l_tccp-&gt;numresolutions - l_cp-&gt;m_specific_param.m_dec.m_reduce;\n\t\t}\n\t\t\n\t\tl_tilec-&gt;data_size_needed = l_data_size;\n\t\tif (p_tcd-&gt;m_is_decoder &amp;&amp; !opj_alloc_tile_component_data(l_tilec)) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\tl_data_size = l_tilec-&gt;numresolutions * (OPJ_UINT32)sizeof(opj_tcd_resolution_t);\n\t\t\n\t\tif (l_tilec-&gt;resolutions == 00) {\n\t\t\tl_tilec-&gt;resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);\n\t\t\tif (! l_tilec-&gt;resolutions ) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\t/*fprintf(stderr, "\\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\\n",l_data_size);*/\n\t\t\tl_tilec-&gt;resolutions_size = l_data_size;\n\t\t\tmemset(l_tilec-&gt;resolutions,0,l_data_size);\n\t\t}\n\t\telse if (l_data_size &gt; l_tilec-&gt;resolutions_size) {\n\t\t\topj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(l_tilec-&gt;resolutions, l_data_size);\n\t\t\tif (! new_resolutions) {\n\t\t\t\t/* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to tile resolutions\\n");                                                                                         */\n\t\t\t\tfprintf(stderr, "Not enough memory to tile resolutions\\n");\n\t\t\t\topj_free(l_tilec-&gt;resolutions);\n\t\t\t\tl_tilec-&gt;resolutions = NULL;\n\t\t\t\tl_tilec-&gt;resolutions_size = 0;\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\tl_tilec-&gt;resolutions = new_resolutions;\n\t\t\t/*fprintf(stderr, "\\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\\n", l_tilec-&gt;resolutions_size, l_data_size);*/\n\t\t\tmemset(((OPJ_BYTE*) l_tilec-&gt;resolutions)+l_tilec-&gt;resolutions_size,0,l_data_size - l_tilec-&gt;resolutions_size);\n\t\t\tl_tilec-&gt;resolutions_size = l_data_size;\n\t\t}\n\t\t\n\t\tl_level_no = l_tilec-&gt;numresolutions - 1;\n\t\tl_res = l_tilec-&gt;resolutions;\n\t\tl_step_size = l_tccp-&gt;stepsizes;\n\t\tif (l_tccp-&gt;qmfbid == 0) {\n\t\t\tl_gain_ptr = &amp;opj_dwt_getgain_real;\n\t\t}\n\t\telse {\n\t\t\tl_gain_ptr  = &amp;opj_dwt_getgain;\n\t\t}\n\t\t/*fprintf(stderr, "\\tlevel_no=%d\\n",l_level_no);*/\n\t\t\n\t\tfor (resno = 0; resno &lt; l_tilec-&gt;numresolutions; ++resno) {\n\t\t\t/*fprintf(stderr, "\\t\\tresno = %d/%d\\n", resno, l_tilec-&gt;numresolutions);*/\n\t\t\tOPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;\n\t\t\tOPJ_UINT32 cbgwidthexpn, cbgheightexpn;\n\t\t\tOPJ_UINT32 cblkwidthexpn, cblkheightexpn;\n\t\t\t\n\t\t\t/* border for each resolution level (global) */\n\t\t\tl_res-&gt;x0 = opj_int_ceildivpow2(l_tilec-&gt;x0, (OPJ_INT32)l_level_no);\n\t\t\tl_res-&gt;y0 = opj_int_ceildivpow2(l_tilec-&gt;y0, (OPJ_INT32)l_level_no);\n\t\t\tl_res-&gt;x1 = opj_int_ceildivpow2(l_tilec-&gt;x1, (OPJ_INT32)l_level_no);\n\t\t\tl_res-&gt;y1 = opj_int_ceildivpow2(l_tilec-&gt;y1, (OPJ_INT32)l_level_no);\n\t\t\t/*fprintf(stderr, "\\t\\t\\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\\n", l_res-&gt;x0, l_res-&gt;y0, l_res-&gt;x1, l_res-&gt;y1);*/\n\t\t\t/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */\n\t\t\tl_pdx = l_tccp-&gt;prcw[resno];\n\t\t\tl_pdy = l_tccp-&gt;prch[resno];\n\t\t\t/*fprintf(stderr, "\\t\\t\\tpdx=%d, pdy=%d\\n", l_pdx, l_pdy);*/\n\t\t\t/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n\t\t\tl_tl_prc_x_start = opj_int_floordivpow2(l_res-&gt;x0, (OPJ_INT32)l_pdx) &lt;&lt; l_pdx;\n\t\t\tl_tl_prc_y_start = opj_int_floordivpow2(l_res-&gt;y0, (OPJ_INT32)l_pdy) &lt;&lt; l_pdy;\n\t\t\tl_br_prc_x_end = opj_int_ceildivpow2(l_res-&gt;x1, (OPJ_INT32)l_pdx) &lt;&lt; l_pdx;\n\t\t\tl_br_prc_y_end = opj_int_ceildivpow2(l_res-&gt;y1, (OPJ_INT32)l_pdy) &lt;&lt; l_pdy;\n\t\t\t/*fprintf(stderr, "\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n\t\t\t\n\t\t\tl_res-&gt;pw = (l_res-&gt;x0 == l_res-&gt;x1) ? 0 : (OPJ_UINT32)((l_br_prc_x_end - l_tl_prc_x_start) &gt;&gt; l_pdx);\n\t\t\tl_res-&gt;ph = (l_res-&gt;y0 == l_res-&gt;y1) ? 0 : (OPJ_UINT32)((l_br_prc_y_end - l_tl_prc_y_start) &gt;&gt; l_pdy);\n\t\t\t/*fprintf(stderr, "\\t\\t\\tres_pw=%d, res_ph=%d\\n", l_res-&gt;pw, l_res-&gt;ph );*/\n\t\t\t\n\t\t\tl_nb_precincts = l_res-&gt;pw * l_res-&gt;ph;\n\t\t\tl_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\t\t\tif (resno == 0) {\n\t\t\t\ttlcbgxstart = l_tl_prc_x_start;\n\t\t\t\ttlcbgystart = l_tl_prc_y_start;\n\t\t\t\t/*brcbgxend = l_br_prc_x_end;*/\n\t\t\t\t/* brcbgyend = l_br_prc_y_end;*/\n\t\t\t\tcbgwidthexpn = l_pdx;\n\t\t\t\tcbgheightexpn = l_pdy;\n\t\t\t\tl_res-&gt;numbands = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);\n\t\t\t\ttlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);\n\t\t\t\t/*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/\n\t\t\t\t/*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/\n\t\t\t\tcbgwidthexpn = l_pdx - 1;\n\t\t\t\tcbgheightexpn = l_pdy - 1;\n\t\t\t\tl_res-&gt;numbands = 3;\n\t\t\t}\n\t\t\t\n\t\t\tcblkwidthexpn = opj_uint_min(l_tccp-&gt;cblkw, cbgwidthexpn);\n\t\t\tcblkheightexpn = opj_uint_min(l_tccp-&gt;cblkh, cbgheightexpn);\n\t\t\tl_band = l_res-&gt;bands;\n\t\t\t\n\t\t\tfor (bandno = 0; bandno &lt; l_res-&gt;numbands; ++bandno) {\n\t\t\t\tOPJ_INT32 numbps;\n\t\t\t\t/*fprintf(stderr, "\\t\\t\\tband_no=%d/%d\\n", bandno, l_res-&gt;numbands );*/\n\t\t\t\t\n\t\t\t\tif (resno == 0) {\n\t\t\t\t\tl_band-&gt;bandno = 0 ;\n\t\t\t\t\tl_band-&gt;x0 = opj_int_ceildivpow2(l_tilec-&gt;x0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band-&gt;y0 = opj_int_ceildivpow2(l_tilec-&gt;y0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band-&gt;x1 = opj_int_ceildivpow2(l_tilec-&gt;x1, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band-&gt;y1 = opj_int_ceildivpow2(l_tilec-&gt;y1, (OPJ_INT32)l_level_no);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl_band-&gt;bandno = bandno + 1;\n\t\t\t\t\t/* x0b = 1 if bandno = 1 or 3 */\n\t\t\t\t\tl_x0b = l_band-&gt;bandno&amp;1;\n\t\t\t\t\t/* y0b = 1 if bandno = 2 or 3 */\n\t\t\t\t\tl_y0b = (OPJ_INT32)((l_band-&gt;bandno)&gt;&gt;1);\n\t\t\t\t\t/* l_band border (global) */\n\t\t\t\t\tl_band-&gt;x0 = opj_int_ceildivpow2(l_tilec-&gt;x0 - (1 &lt;&lt; l_level_no) * l_x0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band-&gt;y0 = opj_int_ceildivpow2(l_tilec-&gt;y0 - (1 &lt;&lt; l_level_no) * l_y0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band-&gt;x1 = opj_int_ceildivpow2(l_tilec-&gt;x1 - (1 &lt;&lt; l_level_no) * l_x0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band-&gt;y1 = opj_int_ceildivpow2(l_tilec-&gt;y1 - (1 &lt;&lt; l_level_no) * l_y0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/** avoid an if with storing function pointer */\n\t\t\t\tl_gain = (*l_gain_ptr) (l_band-&gt;bandno);\n\t\t\t\tnumbps = (OPJ_INT32)(l_image_comp-&gt;prec + l_gain);\n\t\t\t\tl_band-&gt;stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size-&gt;mant / 2048.0) * pow(2.0, (OPJ_INT32) (numbps - l_step_size-&gt;expn)))) * fraction;\n\t\t\t\tl_band-&gt;numbps = l_step_size-&gt;expn + (OPJ_INT32)l_tccp-&gt;numgbits - 1;      /* WHY -1 ? */\n\t\t\t\t\n\t\t\t\tif (! l_band-&gt;precincts) {\n\t\t\t\t\tl_band-&gt;precincts = (opj_tcd_precinct_t *) opj_malloc( /*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! l_band-&gt;precincts) {\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/*fprintf(stderr, "\\t\\t\\t\\tAllocate precincts of a band (opj_tcd_precinct_t): %d\\n",l_nb_precinct_size);     */\n\t\t\t\t\tmemset(l_band-&gt;precincts,0,l_nb_precinct_size);\n\t\t\t\t\tl_band-&gt;precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\telse if (l_band-&gt;precincts_data_size &lt; l_nb_precinct_size) {\n\t\t\t\t\t\n\t\t\t\t\topj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(l_band-&gt;precincts,/*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! new_precincts) {\n\t\t\t\t\t\t/* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to handle band precints\\n");                                                                    */\n\t\t\t\t\t\tfprintf(stderr, "Not enough memory to handle band precints\\n");\n\t\t\t\t\t\topj_free(l_band-&gt;precincts);\n\t\t\t\t\t\tl_band-&gt;precincts = NULL;\n\t\t\t\t\t\tl_band-&gt;precincts_data_size = 0;\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tl_band-&gt;precincts = new_precincts;\n\t\t\t\t\t/*fprintf(stderr, "\\t\\t\\t\\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\\n",l_band-&gt;precincts_data_size, l_nb_precinct_size);*/\n\t\t\t\t\tmemset(((OPJ_BYTE *) l_band-&gt;precincts) + l_band-&gt;precincts_data_size,0,l_nb_precinct_size - l_band-&gt;precincts_data_size);\n\t\t\t\t\tl_band-&gt;precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tl_current_precinct = l_band-&gt;precincts;\n\t\t\t\tfor (precno = 0; precno &lt; l_nb_precincts; ++precno) {\n\t\t\t\t\tOPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;\n\t\t\t\t\tOPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res-&gt;pw) * (1 &lt;&lt; cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res-&gt;pw) * (1 &lt;&lt; cbgheightexpn);\n\t\t\t\t\tOPJ_INT32 cbgxend = cbgxstart + (1 &lt;&lt; cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgyend = cbgystart + (1 &lt;&lt; cbgheightexpn);\n\t\t\t\t\t/*fprintf(stderr, "\\t precno=%d; bandno=%d, resno=%d; compno=%d\\n", precno, bandno , resno, compno);*/\n\t\t\t\t\t/*fprintf(stderr, "\\t tlcbgxstart(=%d) + (precno(=%d) percent res-&gt;pw(=%d)) * (1 &lt;&lt; cbgwidthexpn(=%d)) \\n",tlcbgxstart,precno,l_res-&gt;pw,cbgwidthexpn);*/\n\t\t\t\t\t\n\t\t\t\t\t/* precinct size (global) */\n\t\t\t\t\t/*fprintf(stderr, "\\t cbgxstart=%d, l_band-&gt;x0 = %d \\n",cbgxstart, l_band-&gt;x0);*/\n\t\t\t\t\t\n\t\t\t\t\tl_current_precinct-&gt;x0 = opj_int_max(cbgxstart, l_band-&gt;x0);\n\t\t\t\t\tl_current_precinct-&gt;y0 = opj_int_max(cbgystart, l_band-&gt;y0);\n\t\t\t\t\tl_current_precinct-&gt;x1 = opj_int_min(cbgxend, l_band-&gt;x1);\n\t\t\t\t\tl_current_precinct-&gt;y1 = opj_int_min(cbgyend, l_band-&gt;y1);\n\t\t\t\t\t/*fprintf(stderr, "\\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\\n",l_current_precinct-&gt;x0, l_current_precinct-&gt;y0 ,l_current_precinct-&gt;x1, l_current_precinct-&gt;y1);*/\n\t\t\t\t\t\n\t\t\t\t\ttlcblkxstart = opj_int_floordivpow2(l_current_precinct-&gt;x0, (OPJ_INT32)cblkwidthexpn) &lt;&lt; cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, "\\t tlcblkxstart =%d\\n",tlcblkxstart );*/\n\t\t\t\t\ttlcblkystart = opj_int_floordivpow2(l_current_precinct-&gt;y0, (OPJ_INT32)cblkheightexpn) &lt;&lt; cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, "\\t tlcblkystart =%d\\n",tlcblkystart );*/\n\t\t\t\t\tbrcblkxend = opj_int_ceildivpow2(l_current_precinct-&gt;x1, (OPJ_INT32)cblkwidthexpn) &lt;&lt; cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, "\\t brcblkxend =%d\\n",brcblkxend );*/\n\t\t\t\t\tbrcblkyend = opj_int_ceildivpow2(l_current_precinct-&gt;y1, (OPJ_INT32)cblkheightexpn) &lt;&lt; cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, "\\t brcblkyend =%d\\n",brcblkyend );*/\n\t\t\t\t\tl_current_precinct-&gt;cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) &gt;&gt; cblkwidthexpn);\n\t\t\t\t\tl_current_precinct-&gt;ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) &gt;&gt; cblkheightexpn);\n\t\t\t\t\t\n\t\t\t\t\tl_nb_code_blocks = l_current_precinct-&gt;cw * l_current_precinct-&gt;ch;\n\t\t\t\t\t/*fprintf(stderr, "\\t\\t\\t\\t precinct_cw = %d x recinct_ch = %d\\n",l_current_precinct-&gt;cw, l_current_precinct-&gt;ch);      */\n\t\t\t\t\tl_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;\n\t\t\t\t\t\n\t\t\t\t\tif (! l_current_precinct-&gt;cblks.blocks) {\n\t\t\t\t\t\tl_current_precinct-&gt;cblks.blocks = opj_malloc(l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! l_current_precinct-&gt;cblks.blocks ) {\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*fprintf(stderr, "\\t\\t\\t\\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\\n",l_nb_code_blocks_size);*/\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(l_current_precinct-&gt;cblks.blocks,0,l_nb_code_blocks_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct-&gt;block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\telse if (l_nb_code_blocks_size &gt; l_current_precinct-&gt;block_size) {\n\t\t\t\t\t\tvoid *new_blocks = opj_realloc(l_current_precinct-&gt;cblks.blocks, l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! new_blocks) {\n\t\t\t\t\t\t\topj_free(l_current_precinct-&gt;cblks.blocks);\n\t\t\t\t\t\t\tl_current_precinct-&gt;cblks.blocks = NULL;\n\t\t\t\t\t\t\tl_current_precinct-&gt;block_size = 0;\n\t\t\t\t\t\t\t/* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory for current precinct codeblock element\\n");                                              */\n\t\t\t\t\t\t\tfprintf(stderr, "Not enough memory for current precinct codeblock element\\n");\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl_current_precinct-&gt;cblks.blocks = new_blocks;\n\t\t\t\t\t\t/*fprintf(stderr, "\\t\\t\\t\\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\\n",l_current_precinct-&gt;block_size, l_nb_code_blocks_size);     */\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(((OPJ_BYTE *) l_current_precinct-&gt;cblks.blocks) + l_current_precinct-&gt;block_size\n\t\t\t\t\t\t\t\t\t ,0\n\t\t\t\t\t\t\t\t\t ,l_nb_code_blocks_size - l_current_precinct-&gt;block_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct-&gt;block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (! l_current_precinct-&gt;incltree) {\n\t\t\t\t\t\tl_current_precinct-&gt;incltree = opj_tgt_create(l_current_precinct-&gt;cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct-&gt;ch);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tl_current_precinct-&gt;incltree = opj_tgt_init(l_current_precinct-&gt;incltree,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct-&gt;cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct-&gt;ch);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct-&gt;incltree)     {\n\t\t\t\t\t\tfprintf(stderr, "WARNING: No incltree created.\\n");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct-&gt;imsbtree) {\n\t\t\t\t\t\tl_current_precinct-&gt;imsbtree = opj_tgt_create(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct-&gt;cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct-&gt;ch);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl_current_precinct-&gt;imsbtree = opj_tgt_init(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct-&gt;imsbtree,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct-&gt;cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct-&gt;ch);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct-&gt;imsbtree) {\n\t\t\t\t\t\tfprintf(stderr, "WARNING: No imsbtree created.\\n");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (cblkno = 0; cblkno &lt; l_nb_code_blocks; ++cblkno) {\n\t\t\t\t\t\tOPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno % l_current_precinct-&gt;cw) * (1 &lt;&lt; cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno / l_current_precinct-&gt;cw) * (1 &lt;&lt; cblkheightexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkxend = cblkxstart + (1 &lt;&lt; cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkyend = cblkystart + (1 &lt;&lt; cblkheightexpn);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isEncoder) {\n\t\t\t\t\t\t\topj_tcd_cblk_enc_t* l_code_block = l_current_precinct-&gt;cblks.enc + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block-&gt;x0 = opj_int_max(cblkxstart, l_current_precinct-&gt;x0);\n\t\t\t\t\t\t\tl_code_block-&gt;y0 = opj_int_max(cblkystart, l_current_precinct-&gt;y0);\n\t\t\t\t\t\t\tl_code_block-&gt;x1 = opj_int_min(cblkxend, l_current_precinct-&gt;x1);\n\t\t\t\t\t\t\tl_code_block-&gt;y1 = opj_int_min(cblkyend, l_current_precinct-&gt;y1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topj_tcd_cblk_dec_t* l_code_block = l_current_precinct-&gt;cblks.dec + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_dec_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block-&gt;x0 = opj_int_max(cblkxstart, l_current_precinct-&gt;x0);\n\t\t\t\t\t\t\tl_code_block-&gt;y0 = opj_int_max(cblkystart, l_current_precinct-&gt;y0);\n\t\t\t\t\t\t\tl_code_block-&gt;x1 = opj_int_min(cblkxend, l_current_precinct-&gt;x1);\n\t\t\t\t\t\t\tl_code_block-&gt;y1 = opj_int_min(cblkyend, l_current_precinct-&gt;y1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++l_current_precinct;\n\t\t\t\t} /* precno */\n\t\t\t\t++l_band;\n\t\t\t\t++l_step_size;\n\t\t\t} /* bandno */\n\t\t\t++l_res;\n\t\t\t--l_level_no;\n\t\t} /* resno */\n\t\t++l_tccp;\n\t\t++l_tilec;\n\t\t++l_image_comp;\n\t} /* compno */\n\treturn OPJ_TRUE;\n}',
 'log2vis_unicode (PyObject * unicode, FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t/* input string encoded in utf-8 */\n\tPyObject *visual = NULL;\t/* output string encoded in utf-8 */\n\tPyObject *result = NULL;\t/* unicode output string */\n\n\tint length = PyUnicode_GET_SIZE (unicode);\n\n\tlogical = PyUnicode_AsUTF8String (unicode);\n\tif (logical == NULL)\n\t\tgoto cleanup;\n\n\tvisual = log2vis_utf8 (logical, length, base_direction, clean, reordernsm);\n\tif (visual == NULL)\n\t\tgoto cleanup;\n\n\tresult = PyUnicode_DecodeUTF8 (PyString_AS_STRING (visual),\n\t\t\t\t       PyString_GET_SIZE (visual), "strict");\n\n      cleanup:\n\tPy_XDECREF (logical);\n\tPy_XDECREF (visual);\n\n\treturn result;\n}',
 'int ssl_init(void) { /* init TLS before parsing configuration file */\n#if OPENSSL_VERSION_NUMBER&gt;=0x10100000L\n    OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS |\n        OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#else\n    OPENSSL_config(NULL);\n    SSL_load_error_strings();\n    SSL_library_init();\n#endif\n    index_ssl_cli=SSL_get_ex_new_index(0,\n        "CLI pointer", NULL, NULL, NULL);\n    index_ssl_ctx_opt=SSL_CTX_get_ex_new_index(0,\n        "SERVICE_OPTIONS pointer", NULL, NULL, NULL);\n    index_session_authenticated=SSL_SESSION_get_ex_new_index(0,\n        "session authenticated", NULL, NULL, NULL);\n    index_session_connect_address=SSL_SESSION_get_ex_new_index(0,\n        "session connect address", NULL, cb_dup_addr, cb_free_addr);\n    if(index_ssl_cli&lt;0 || index_ssl_ctx_opt&lt;0 ||\n            index_session_authenticated&lt;0 ||\n            index_session_connect_address&lt;0) {\n        s_log(LOG_ERR, "Application specific data initialization failed");\n        return 1;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_load_builtin_engines();\n#endif\n#ifndef OPENSSL_NO_DH\n    dh_params=get_dh2048();\n    if(!dh_params) {\n        s_log(LOG_ERR, "Failed to get default DH parameters");\n        return 1;\n    }\n#endif /* OPENSSL_NO_DH */\n    return 0;\n}',
 'extract_header_length(uint16_t fc)\n{\n\tint len = 0;\n\n\tswitch ((fc &gt;&gt; 10) &amp; 0x3) {\n\tcase 0x00:\n\t\tif (fc &amp; (1 &lt;&lt; 6)) /* intra-PAN with none dest addr */\n\t\t\treturn -1;\n\t\tbreak;\n\tcase 0x01:\n\t\treturn -1;\n\tcase 0x02:\n\t\tlen += 4;\n\t\tbreak;\n\tcase 0x03:\n\t\tlen += 10;\n\t\tbreak;\n\t}\n\n\tswitch ((fc &gt;&gt; 14) &amp; 0x3) {\n\tcase 0x00:\n\t\tbreak;\n\tcase 0x01:\n\t\treturn -1;\n\tcase 0x02:\n\t\tlen += 4;\n\t\tbreak;\n\tcase 0x03:\n\t\tlen += 10;\n\t\tbreak;\n\t}\n\n\tif (fc &amp; (1 &lt;&lt; 6)) {\n\t\tif (len &lt; 2)\n\t\t\treturn -1;\n\t\tlen -= 2;\n\t}\n\n\treturn len;\n}',
 "static void add_offer_options(uint8_t *option_start_address)\n{\n\tuint8_t *temp_option_addr;\n\t/* add DHCP options 1. \n\tThe subnet mask option specifies the client's subnet mask */\n\ttemp_option_addr = fill_one_option_content(option_start_address,\n\t\t\tDHCP_OPTION_CODE_SUBNET_MASK, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&amp;dhcps_local_mask);\n\t\n        /* add DHCP options 3 (i.e router(gateway)). The time server option \n        specifies a list of RFC 868 [6] time servers available to the client. */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_ROUTER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&amp;dhcps_local_address);\n\n\t/* add DHCP options 6 (i.e DNS). \n        The option specifies a list of DNS servers available to the client. */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_DNS_SERVER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&amp;dhcps_local_address);\t\n\t/* add DHCP options 51.\n\tThis option is used to request a lease time for the IP address. */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_LEASE_TIME, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&amp;dhcp_option_lease_time);\n\t/* add DHCP options 54. \n\tThe identifier is the IP address of the selected server. */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_SERVER_ID, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&amp;dhcps_local_address);\n\t/* add DHCP options 28. \n\tThis option specifies the broadcast address in use on client's subnet.*/\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_BROADCAST_ADDRESS, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&amp;dhcps_subnet_broadcast);\n\t/* add DHCP options 26. \n\tThis option specifies the Maximum transmission unit to use */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_INTERFACE_MTU, DHCP_OPTION_LENGTH_TWO,\n\t\t\t\t\t(void *) &amp;dhcp_option_interface_mtu);//dhcp_option_interface_mtu_576);\n\t/* add DHCP options 31.\n\tThis option specifies whether or not the client should solicit routers */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY, DHCP_OPTION_LENGTH_ONE,\n\t\t\t\t\t\t\t\tNULL);\n\t*temp_option_addr++ = DHCP_OPTION_CODE_END;\n\n}",
 "fp_readl(char *s, int size, struct tok_state *tok)\n{\n    PyObject* bufobj;\n    const char *buf;\n    Py_ssize_t buflen;\n\n    /* Ask for one less byte so we can terminate it */\n    assert(size &gt; 0);\n    size--;\n\n    if (tok-&gt;decoding_buffer) {\n        bufobj = tok-&gt;decoding_buffer;\n        Py_INCREF(bufobj);\n    }\n    else\n    {\n        bufobj = PyObject_CallObject(tok-&gt;decoding_readline, NULL);\n        if (bufobj == NULL)\n            goto error;\n    }\n    if (PyUnicode_CheckExact(bufobj))\n    {\n        buf = PyUnicode_AsUTF8AndSize(bufobj, &amp;buflen);\n        if (buf == NULL) {\n            goto error;\n        }\n    }\n    else\n    {\n        buf = PyByteArray_AsString(bufobj);\n        if (buf == NULL) {\n            goto error;\n        }\n        buflen = PyByteArray_GET_SIZE(bufobj);\n    }\n\n    Py_XDECREF(tok-&gt;decoding_buffer);\n    if (buflen &gt; size) {\n        /* Too many chars, the rest goes into tok-&gt;decoding_buffer */\n        tok-&gt;decoding_buffer = PyByteArray_FromStringAndSize(buf+size,\n                                                         buflen-size);\n        if (tok-&gt;decoding_buffer == NULL)\n            goto error;\n        buflen = size;\n    }\n    else\n        tok-&gt;decoding_buffer = NULL;\n\n    memcpy(s, buf, buflen);\n    s[buflen] = '\\0';\n    if (buflen == 0) /* EOF */\n        s = NULL;\n    Py_DECREF(bufobj);\n    return s;\n\nerror:\n    Py_XDECREF(bufobj);\n    return error_ret(tok);\n}",
 '  virtual void requestInit() {\n    m_use_error = false;\n    m_errors.reset();\n    m_entity_loader_disabled = false;\n    xmlParserInputBufferCreateFilenameDefault(hphp_libxml_input_buffer);\n  }',
 '  ~ChaChaPolyDecipher() {\n    clear();\n  }',
 'struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct ieee80211_local *local = sdata-&gt;local;\n\tstruct sta_info *sta;\n\tstruct timespec uptime;\n\tstruct ieee80211_tx_latency_bin_ranges *tx_latency;\n\tint i;\n\n\tsta = kzalloc(sizeof(*sta) + local-&gt;hw.sta_data_size, gfp);\n\tif (!sta)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttx_latency = rcu_dereference(local-&gt;tx_latency);\n\t/* init stations Tx latency statistics &amp;&amp; TID bins */\n\tif (tx_latency) {\n\t\tsta-&gt;tx_lat = kzalloc(IEEE80211_NUM_TIDS *\n\t\t\t\t      sizeof(struct ieee80211_tx_latency_stat),\n\t\t\t\t      GFP_ATOMIC);\n\t\tif (!sta-&gt;tx_lat) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (tx_latency-&gt;n_ranges) {\n\t\t\tfor (i = 0; i &lt; IEEE80211_NUM_TIDS; i++) {\n\t\t\t\t/* size of bins is size of the ranges +1 */\n\t\t\t\tsta-&gt;tx_lat[i].bin_count =\n\t\t\t\t\ttx_latency-&gt;n_ranges + 1;\n\t\t\t\tsta-&gt;tx_lat[i].bins =\n\t\t\t\t\tkcalloc(sta-&gt;tx_lat[i].bin_count,\n\t\t\t\t\t\tsizeof(u32), GFP_ATOMIC);\n\t\t\t\tif (!sta-&gt;tx_lat[i].bins) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tspin_lock_init(&amp;sta-&gt;lock);\n\tspin_lock_init(&amp;sta-&gt;ps_lock);\n\tINIT_WORK(&amp;sta-&gt;drv_unblock_wk, sta_unblock);\n\tINIT_WORK(&amp;sta-&gt;ampdu_mlme.work, ieee80211_ba_session_work);\n\tmutex_init(&amp;sta-&gt;ampdu_mlme.mtx);\n#ifdef CONFIG_MAC80211_MESH\n\tif (ieee80211_vif_is_mesh(&amp;sdata-&gt;vif) &amp;&amp;\n\t    !sdata-&gt;u.mesh.user_mpm)\n\t\tinit_timer(&amp;sta-&gt;plink_timer);\n\tsta-&gt;nonpeer_pm = NL80211_MESH_POWER_ACTIVE;\n#endif\n\n\tmemcpy(sta-&gt;sta.addr, addr, ETH_ALEN);\n\tsta-&gt;local = local;\n\tsta-&gt;sdata = sdata;\n\tsta-&gt;last_rx = jiffies;\n\n\tsta-&gt;sta_state = IEEE80211_STA_NONE;\n\n\tdo_posix_clock_monotonic_gettime(&amp;uptime);\n\tsta-&gt;last_connected = uptime.tv_sec;\n\tewma_init(&amp;sta-&gt;avg_signal, 1024, 8);\n\tfor (i = 0; i &lt; ARRAY_SIZE(sta-&gt;chain_signal_avg); i++)\n\t\tewma_init(&amp;sta-&gt;chain_signal_avg[i], 1024, 8);\n\n\tif (sta_prepare_rate_control(local, sta, gfp))\n\t\tgoto free;\n\n\tfor (i = 0; i &lt; IEEE80211_NUM_TIDS; i++) {\n\t\t/*\n\t\t * timer_to_tid must be initialized with identity mapping\n\t\t * to enable session_timer\'s data differentiation. See\n\t\t * sta_rx_agg_session_timer_expired for usage.\n\t\t */\n\t\tsta-&gt;timer_to_tid[i] = i;\n\t}\n\tfor (i = 0; i &lt; IEEE80211_NUM_ACS; i++) {\n\t\tskb_queue_head_init(&amp;sta-&gt;ps_tx_buf[i]);\n\t\tskb_queue_head_init(&amp;sta-&gt;tx_filtered[i]);\n\t}\n\n\tfor (i = 0; i &lt; IEEE80211_NUM_TIDS; i++)\n\t\tsta-&gt;last_seq_ctrl[i] = cpu_to_le16(USHRT_MAX);\n\n\tsta-&gt;sta.smps_mode = IEEE80211_SMPS_OFF;\n\tif (sdata-&gt;vif.type == NL80211_IFTYPE_AP ||\n\t    sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\tlocal-&gt;hw.wiphy-&gt;bands[ieee80211_get_sdata_band(sdata)];\n\t\tu8 smps = (sband-&gt;ht_cap.cap &amp; IEEE80211_HT_CAP_SM_PS) &gt;&gt;\n\t\t\t\tIEEE80211_HT_CAP_SM_PS_SHIFT;\n\t\t/*\n\t\t * Assume that hostapd advertises our caps in the beacon and\n\t\t * this is the known_smps_mode for a station that just assciated\n\t\t */\n\t\tswitch (smps) {\n\t\tcase WLAN_HT_SMPS_CONTROL_DISABLED:\n\t\t\tsta-&gt;known_smps_mode = IEEE80211_SMPS_OFF;\n\t\t\tbreak;\n\t\tcase WLAN_HT_SMPS_CONTROL_STATIC:\n\t\t\tsta-&gt;known_smps_mode = IEEE80211_SMPS_STATIC;\n\t\t\tbreak;\n\t\tcase WLAN_HT_SMPS_CONTROL_DYNAMIC:\n\t\t\tsta-&gt;known_smps_mode = IEEE80211_SMPS_DYNAMIC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\n\tsta_dbg(sdata, "Allocated STA %pM\\n", sta-&gt;sta.addr);\n\treturn sta;\n\nfree:\n\tif (sta-&gt;tx_lat) {\n\t\tfor (i = 0; i &lt; IEEE80211_NUM_TIDS; i++)\n\t\t\tkfree(sta-&gt;tx_lat[i].bins);\n\t\tkfree(sta-&gt;tx_lat);\n\t}\n\tkfree(sta);\n\treturn NULL;\n}',
 'static void do_viewlog(HttpRequest req, HttpResponse res) {\n        if (is_readonly(req)) {\n                send_error(req, res, SC_FORBIDDEN, "You do not have sufficient privileges to access this page");\n                return;\n        }\n        do_head(res, "_viewlog", "View log", 100);\n        if ((Run.flags &amp; Run_Log) &amp;&amp; ! (Run.flags &amp; Run_UseSyslog)) {\n                FILE *f = fopen(Run.files.log, "r");\n                if (f) {\n                        size_t n;\n                        char buf[512];\n                        StringBuffer_append(res-&gt;outputbuffer, "&lt;br&gt;&lt;p&gt;&lt;form&gt;&lt;textarea cols=120 rows=30 readonly&gt;");\n                        while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) &gt; 0) {\n                                buf[n] = 0;\n                                StringBuffer_append(res-&gt;outputbuffer, "%s", buf);\n                        }\n                        fclose(f);\n                        StringBuffer_append(res-&gt;outputbuffer, "&lt;/textarea&gt;&lt;/form&gt;");\n                } else {\n                        StringBuffer_append(res-&gt;outputbuffer, "Error opening logfile: %s", STRERROR);\n                }\n        } else {\n                StringBuffer_append(res-&gt;outputbuffer,\n                                    "&lt;b&gt;Cannot view logfile:&lt;/b&gt;&lt;br&gt;");\n                if (! (Run.flags &amp; Run_Log))\n                        StringBuffer_append(res-&gt;outputbuffer, "Monit was started without logging");\n                else\n                        StringBuffer_append(res-&gt;outputbuffer, "Monit uses syslog");\n        }\n        do_foot(res);\n}',
 'void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\n\tfor (tidno = 0, tid = &amp;an-&gt;tid[tidno];\n\t     tidno &lt; IEEE80211_NUM_TIDS; tidno++, tid++) {\n\n\t\tac = tid-&gt;ac;\n\t\ttxq = ac-&gt;txq;\n\n\t\tath_txq_lock(sc, txq);\n\n\t\tif (!tid-&gt;sched) {\n\t\t\tath_txq_unlock(sc, txq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuffered = ath_tid_has_buffered(tid);\n\n\t\ttid-&gt;sched = false;\n\t\tlist_del(&amp;tid-&gt;list);\n\n\t\tif (ac-&gt;sched) {\n\t\t\tac-&gt;sched = false;\n\t\t\tlist_del(&amp;ac-&gt;list);\n\t\t}\n\n\t\tath_txq_unlock(sc, txq);\n\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}',
 '  void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                        const Tensor&amp; in, Tensor* out) {\n    // Create the axes (which are always trailing).\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx-&gt;eigen_device&lt;CPUDevice&gt;();\n    auto input = Tensor(in).flat_inner_dims&lt;RealT, FFTRank + 1&gt;();\n    const auto input_dims = input.dimensions();\n\n    // Slice input to fft_shape on its inner-most dimensions.\n    Eigen::DSizes&lt;Eigen::DenseIndex, FFTRank + 1&gt; input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape temp_shape{input_dims[0]};\n    for (int i = 1; i &lt;= FFTRank; ++i) {\n      input_slice_sizes[i] = fft_shape[i - 1];\n      temp_shape.AddDim(fft_shape[i - 1]);\n    }\n    OP_REQUIRES(ctx, temp_shape.num_elements() &gt; 0,\n                errors::InvalidArgument("Obtained a FFT shape of 0 elements: ",\n                                        temp_shape.DebugString()));\n\n    auto output = out-&gt;flat_inner_dims&lt;ComplexT, FFTRank + 1&gt;();\n    const Eigen::DSizes&lt;Eigen::DenseIndex, FFTRank + 1&gt; zero_start_indices;\n\n    // Compute the full FFT using a temporary tensor.\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx-&gt;allocate_temp(DataTypeToEnum&lt;ComplexT&gt;::v(),\n                                           temp_shape, &amp;temp));\n    auto full_fft = temp.flat_inner_dims&lt;ComplexT, FFTRank + 1&gt;();\n    full_fft.device(device) =\n        input.slice(zero_start_indices, input_slice_sizes)\n            .template fft&lt;Eigen::BothParts, Eigen::FFT_FORWARD&gt;(axes);\n\n    // Slice away the negative frequency components.\n    output.device(device) =\n        full_fft.slice(zero_start_indices, output.dimensions());\n  }',
 'static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\n\tif (!netif_running(br-&gt;dev) || br-&gt;multicast_disabled)\n\t\treturn -EINVAL;\n\n\tif (timer_pending(&amp;br-&gt;multicast_querier_timer))\n\t\treturn -EBUSY;\n\n\tip.proto = entry-&gt;addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry-&gt;addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry-&gt;addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&amp;br-&gt;multicast_lock);\n\tmdb = mlock_dereference(br-&gt;mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &amp;ip);\n\tif (!mp)\n\t\tgoto unlock;\n\n\tfor (pp = &amp;mp-&gt;ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &amp;p-&gt;next) {\n\t\tif (!p-&gt;port || p-&gt;port-&gt;dev-&gt;ifindex != entry-&gt;ifindex)\n\t\t\tcontinue;\n\n\t\tif (p-&gt;port-&gt;state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\n\t\trcu_assign_pointer(*pp, p-&gt;next);\n\t\thlist_del_init(&amp;p-&gt;mglist);\n\t\tdel_timer(&amp;p-&gt;timer);\n\t\tcall_rcu_bh(&amp;p-&gt;rcu, br_multicast_free_pg);\n\t\terr = 0;\n\n\t\tif (!mp-&gt;ports &amp;&amp; !mp-&gt;mglist &amp;&amp;\n\t\t    netif_running(br-&gt;dev))\n\t\t\tmod_timer(&amp;mp-&gt;timer, jiffies);\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&amp;br-&gt;multicast_lock);\n\treturn err;\n}',
 '  void * alloc_bottom(size_t size, size_t align) \n  {loop:\n    align_bottom(align);\n    byte * tmp = bottom;\n    bottom += size;\n    if (bottom &gt; top) {new_chunk(); goto loop;}\n    return tmp;\n  }',
 'static __init int sctp_init(void)\n{\n\tint i;\n\tint status = -EINVAL;\n\tunsigned long goal;\n\tunsigned long limit;\n\tint max_share;\n\tint order;\n\n\tsock_skb_cb_check_size(sizeof(struct sctp_ulpevent));\n\n\t/* Allocate bind_bucket and chunk caches. */\n\tstatus = -ENOBUFS;\n\tsctp_bucket_cachep = kmem_cache_create("sctp_bind_bucket",\n\t\t\t\t\t       sizeof(struct sctp_bind_bucket),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_bucket_cachep)\n\t\tgoto out;\n\n\tsctp_chunk_cachep = kmem_cache_create("sctp_chunk",\n\t\t\t\t\t       sizeof(struct sctp_chunk),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_chunk_cachep)\n\t\tgoto err_chunk_cachep;\n\n\tstatus = percpu_counter_init(&amp;sctp_sockets_allocated, 0, GFP_KERNEL);\n\tif (status)\n\t\tgoto err_percpu_counter_init;\n\n\t/* Implementation specific variables. */\n\n\t/* Initialize default stream count setup information. */\n\tsctp_max_instreams    \t\t= SCTP_DEFAULT_INSTREAMS;\n\tsctp_max_outstreams   \t\t= SCTP_DEFAULT_OUTSTREAMS;\n\n\t/* Initialize handle used for association ids. */\n\tidr_init(&amp;sctp_assocs_id);\n\n\tlimit = nr_free_buffer_pages() / 8;\n\tlimit = max(limit, 128UL);\n\tsysctl_sctp_mem[0] = limit / 4 * 3;\n\tsysctl_sctp_mem[1] = limit;\n\tsysctl_sctp_mem[2] = sysctl_sctp_mem[0] * 2;\n\n\t/* Set per-socket limits to no more than 1/128 the pressure threshold*/\n\tlimit = (sysctl_sctp_mem[1]) &lt;&lt; (PAGE_SHIFT - 7);\n\tmax_share = min(4UL*1024*1024, limit);\n\n\tsysctl_sctp_rmem[0] = SK_MEM_QUANTUM; /* give each asoc 1 page min */\n\tsysctl_sctp_rmem[1] = 1500 * SKB_TRUESIZE(1);\n\tsysctl_sctp_rmem[2] = max(sysctl_sctp_rmem[1], max_share);\n\n\tsysctl_sctp_wmem[0] = SK_MEM_QUANTUM;\n\tsysctl_sctp_wmem[1] = 16*1024;\n\tsysctl_sctp_wmem[2] = max(64*1024, max_share);\n\n\t/* Size and allocate the association hash table.\n\t * The methodology is similar to that of the tcp hash tables.\n\t */\n\tif (totalram_pages &gt;= (128 * 1024))\n\t\tgoal = totalram_pages &gt;&gt; (22 - PAGE_SHIFT);\n\telse\n\t\tgoal = totalram_pages &gt;&gt; (24 - PAGE_SHIFT);\n\n\tfor (order = 0; (1UL &lt;&lt; order) &lt; goal; order++)\n\t\t;\n\n\tdo {\n\t\tsctp_assoc_hashsize = (1UL &lt;&lt; order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_hashbucket);\n\t\tif ((sctp_assoc_hashsize &gt; (64 * 1024)) &amp;&amp; order &gt; 0)\n\t\t\tcontinue;\n\t\tsctp_assoc_hashtable = (struct sctp_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_assoc_hashtable &amp;&amp; --order &gt; 0);\n\tif (!sctp_assoc_hashtable) {\n\t\tpr_err("Failed association hash alloc\\n");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ahash_alloc;\n\t}\n\tfor (i = 0; i &lt; sctp_assoc_hashsize; i++) {\n\t\trwlock_init(&amp;sctp_assoc_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&amp;sctp_assoc_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the endpoint hash table.  */\n\tsctp_ep_hashsize = 64;\n\tsctp_ep_hashtable =\n\t\tkmalloc(64 * sizeof(struct sctp_hashbucket), GFP_KERNEL);\n\tif (!sctp_ep_hashtable) {\n\t\tpr_err("Failed endpoint_hash alloc\\n");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ehash_alloc;\n\t}\n\tfor (i = 0; i &lt; sctp_ep_hashsize; i++) {\n\t\trwlock_init(&amp;sctp_ep_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&amp;sctp_ep_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the SCTP port hash table.  */\n\tdo {\n\t\tsctp_port_hashsize = (1UL &lt;&lt; order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_bind_hashbucket);\n\t\tif ((sctp_port_hashsize &gt; (64 * 1024)) &amp;&amp; order &gt; 0)\n\t\t\tcontinue;\n\t\tsctp_port_hashtable = (struct sctp_bind_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_port_hashtable &amp;&amp; --order &gt; 0);\n\tif (!sctp_port_hashtable) {\n\t\tpr_err("Failed bind hash alloc\\n");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_bhash_alloc;\n\t}\n\tfor (i = 0; i &lt; sctp_port_hashsize; i++) {\n\t\tspin_lock_init(&amp;sctp_port_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&amp;sctp_port_hashtable[i].chain);\n\t}\n\n\tpr_info("Hash tables configured (established %d bind %d)\\n",\n\t\tsctp_assoc_hashsize, sctp_port_hashsize);\n\n\tsctp_sysctl_register();\n\n\tINIT_LIST_HEAD(&amp;sctp_address_families);\n\tsctp_v4_pf_init();\n\tsctp_v6_pf_init();\n\n\tstatus = sctp_v4_protosw_init();\n\n\tif (status)\n\t\tgoto err_protosw_init;\n\n\tstatus = sctp_v6_protosw_init();\n\tif (status)\n\t\tgoto err_v6_protosw_init;\n\n\tstatus = register_pernet_subsys(&amp;sctp_net_ops);\n\tif (status)\n\t\tgoto err_register_pernet_subsys;\n\n\tstatus = sctp_v4_add_protocol();\n\tif (status)\n\t\tgoto err_add_protocol;\n\n\t/* Register SCTP with inet6 layer.  */\n\tstatus = sctp_v6_add_protocol();\n\tif (status)\n\t\tgoto err_v6_add_protocol;\n\nout:\n\treturn status;\nerr_v6_add_protocol:\n\tsctp_v4_del_protocol();\nerr_add_protocol:\n\tunregister_pernet_subsys(&amp;sctp_net_ops);\nerr_register_pernet_subsys:\n\tsctp_v6_protosw_exit();\nerr_v6_protosw_init:\n\tsctp_v4_protosw_exit();\nerr_protosw_init:\n\tsctp_v4_pf_exit();\n\tsctp_v6_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\nerr_bhash_alloc:\n\tkfree(sctp_ep_hashtable);\nerr_ehash_alloc:\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\nerr_ahash_alloc:\n\tpercpu_counter_destroy(&amp;sctp_sockets_allocated);\nerr_percpu_counter_init:\n\tkmem_cache_destroy(sctp_chunk_cachep);\nerr_chunk_cachep:\n\tkmem_cache_destroy(sctp_bucket_cachep);\n\tgoto out;\n}',
 'static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &amp;st );\n    mongo_md5_append( &amp;st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &amp;st, ( const mongo_md5_byte_t * )":mongo:", 7 );\n    mongo_md5_append( &amp;st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &amp;st, digest );\n    digest2hex( digest, hex_digest );\n}',
 'static void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\t// memcpy (res, dbg_data, nb10sz);\n\t// res-&gt;file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}',
 'error_t rawSocketReceiveEthPacket(Socket *socket, SocketMsg *message,\n   uint_t flags)\n{\n   error_t error;\n   SocketQueueItem *queueItem;\n\n   //The SOCKET_FLAG_DONT_WAIT enables non-blocking operation\n   if((flags &amp; SOCKET_FLAG_DONT_WAIT) == 0)\n   {\n      //Check whether the receive queue is empty\n      if(socket-&gt;receiveQueue == NULL)\n      {\n         //Set the events the application is interested in\n         socket-&gt;eventMask = SOCKET_EVENT_RX_READY;\n\n         //Reset the event object\n         osResetEvent(&amp;socket-&gt;event);\n\n         //Release exclusive access\n         osReleaseMutex(&amp;netMutex);\n         //Wait until an event is triggered\n         osWaitForEvent(&amp;socket-&gt;event, socket-&gt;timeout);\n         //Get exclusive access\n         osAcquireMutex(&amp;netMutex);\n      }\n   }\n\n   //Any packet received?\n   if(socket-&gt;receiveQueue != NULL)\n   {\n      //Point to the first item in the receive queue\n      queueItem = socket-&gt;receiveQueue;\n\n      //Copy data to user buffer\n      message-&gt;length = netBufferRead(message-&gt;data, queueItem-&gt;buffer,\n         queueItem-&gt;offset, message-&gt;size);\n\n      //Network interface where the packet was received\n      message-&gt;interface = queueItem-&gt;interface;\n\n#if (ETH_SUPPORT == ENABLED)\n      //Save source and destination MAC addresses\n      message-&gt;srcMacAddr = queueItem-&gt;ancillary.srcMacAddr;\n      message-&gt;destMacAddr = queueItem-&gt;ancillary.destMacAddr;\n#endif\n\n#if (ETH_PORT_TAGGING_SUPPORT == ENABLED)\n      //Save switch port identifier\n      message-&gt;switchPort = queueItem-&gt;ancillary.port;\n#endif\n\n#if (ETH_TIMESTAMP_SUPPORT == ENABLED)\n      //Save captured time stamp\n      message-&gt;timestamp = queueItem-&gt;ancillary.timestamp;\n#endif\n\n      //If the SOCKET_FLAG_PEEK flag is set, the data is copied into the\n      //buffer but is not removed from the input queue\n      if((flags &amp; SOCKET_FLAG_PEEK) == 0)\n      {\n         //Remove the item from the receive queue\n         socket-&gt;receiveQueue = queueItem-&gt;next;\n\n         //Deallocate memory buffer\n         netBufferFree(queueItem-&gt;buffer);\n      }\n\n      //Update the state of events\n      rawSocketUpdateEvents(socket);\n\n      //Successful read operation\n      error = NO_ERROR;\n   }\n   else\n   {\n      //Total number of data that have been received\n      message-&gt;length = 0;\n\n      //Report a timeout error\n      error = ERROR_TIMEOUT;\n   }\n\n   //Return status code\n   return error;\n}',
 "static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct request_sock *req,\n\t\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *treq;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\n\tif (skb-&gt;protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst);\n\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)-&gt;pinet6 = &amp;newtcp6sk-&gt;inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet-&gt;inet_daddr, &amp;newnp-&gt;daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet-&gt;inet_saddr, &amp;newnp-&gt;saddr);\n\n\t\tipv6_addr_copy(&amp;newnp-&gt;rcv_saddr, &amp;newnp-&gt;saddr);\n\n\t\tinet_csk(newsk)-&gt;icsk_af_ops = &amp;ipv6_mapped;\n\t\tnewsk-&gt;sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp-&gt;af_specific = &amp;tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp-&gt;pktoptions  = NULL;\n\t\tnewnp-&gt;opt\t   = NULL;\n\t\tnewnp-&gt;mcast_oif   = inet6_iif(skb);\n\t\tnewnp-&gt;mcast_hops  = ipv6_hdr(skb)-&gt;hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)-&gt;icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\ttreq = inet6_rsk(req);\n\topt = np-&gt;opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, req);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk-&gt;sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)-&gt;pinet6 = &amp;newtcp6sk-&gt;inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&amp;newnp-&gt;daddr, &amp;treq-&gt;rmt_addr);\n\tipv6_addr_copy(&amp;newnp-&gt;saddr, &amp;treq-&gt;loc_addr);\n\tipv6_addr_copy(&amp;newnp-&gt;rcv_saddr, &amp;treq-&gt;loc_addr);\n\tnewsk-&gt;sk_bound_dev_if = treq-&gt;iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet-&gt;opt = NULL;\n\tnewnp-&gt;ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp-&gt;rxopt.all = np-&gt;rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp-&gt;pktoptions = NULL;\n\tif (treq-&gt;pktopts != NULL) {\n\t\tnewnp-&gt;pktoptions = skb_clone(treq-&gt;pktopts, GFP_ATOMIC);\n\t\tkfree_skb(treq-&gt;pktopts);\n\t\ttreq-&gt;pktopts = NULL;\n\t\tif (newnp-&gt;pktoptions)\n\t\t\tskb_set_owner_r(newnp-&gt;pktoptions, newsk);\n\t}\n\tnewnp-&gt;opt\t  = NULL;\n\tnewnp-&gt;mcast_oif  = inet6_iif(skb);\n\tnewnp-&gt;mcast_hops = ipv6_hdr(skb)-&gt;hop_limit;\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\tif (opt) {\n\t\tnewnp-&gt;opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np-&gt;opt)\n\t\t\tsock_kfree_s(sk, opt, opt-&gt;tot_len);\n\t}\n\n\tinet_csk(newsk)-&gt;icsk_ext_hdr_len = 0;\n\tif (newnp-&gt;opt)\n\t\tinet_csk(newsk)-&gt;icsk_ext_hdr_len = (newnp-&gt;opt-&gt;opt_nflen +\n\t\t\t\t\t\t     newnp-&gt;opt-&gt;opt_flen);\n\n\ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp-&gt;advmss = dst_metric_advmss(dst);\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet-&gt;inet_daddr = newinet-&gt;inet_saddr = LOOPBACK4_IPV6;\n\tnewinet-&gt;inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tif ((key = tcp_v6_md5_do_lookup(sk, &amp;newnp-&gt;daddr)) != NULL) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key-&gt;key, key-&gt;keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v6_md5_do_add(newsk, &amp;newnp-&gt;daddr,\n\t\t\t\t\t  newkey, key-&gt;keylen);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) &lt; 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tif (opt &amp;&amp; opt != np-&gt;opt)\n\t\tsock_kfree_s(sk, opt, opt-&gt;tot_len);\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}",
 'static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,\n\t\tstruct nfs4_state_owner *sp, int flags,\n\t\tconst struct iattr *attrs)\n{\n\tstruct dentry *parent = dget_parent(path-&gt;dentry);\n\tstruct inode *dir = parent-&gt;d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\tgoto err;\n\tp-&gt;o_arg.seqid = nfs_alloc_seqid(&amp;sp-&gt;so_seqid);\n\tif (p-&gt;o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tp-&gt;path.mnt = mntget(path-&gt;mnt);\n\tp-&gt;path.dentry = dget(path-&gt;dentry);\n\tp-&gt;dir = parent;\n\tp-&gt;owner = sp;\n\tatomic_inc(&amp;sp-&gt;so_count);\n\tp-&gt;o_arg.fh = NFS_FH(dir);\n\tp-&gt;o_arg.open_flags = flags,\n\tp-&gt;o_arg.clientid = server-&gt;nfs_client-&gt;cl_clientid;\n\tp-&gt;o_arg.id = sp-&gt;so_owner_id.id;\n\tp-&gt;o_arg.name = &amp;p-&gt;path.dentry-&gt;d_name;\n\tp-&gt;o_arg.server = server;\n\tp-&gt;o_arg.bitmask = server-&gt;attr_bitmask;\n\tp-&gt;o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (flags &amp; O_EXCL) {\n\t\tu32 *s = (u32 *) p-&gt;o_arg.u.verifier.data;\n\t\ts[0] = jiffies;\n\t\ts[1] = current-&gt;pid;\n\t} else if (flags &amp; O_CREAT) {\n\t\tp-&gt;o_arg.u.attrs = &amp;p-&gt;attrs;\n\t\tmemcpy(&amp;p-&gt;attrs, attrs, sizeof(p-&gt;attrs));\n\t}\n\tp-&gt;c_arg.fh = &amp;p-&gt;o_res.fh;\n\tp-&gt;c_arg.stateid = &amp;p-&gt;o_res.stateid;\n\tp-&gt;c_arg.seqid = p-&gt;o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&amp;p-&gt;kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}',
 'int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep-&gt;datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen &lt;= 0 || datalen &gt; 32767 || !prep-&gt;data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload-&gt;datalen = datalen;\n\tmemcpy(upayload-&gt;data, prep-&gt;data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key-&gt;payload.data[0];\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey-&gt;expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}',
 'bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i &gt;= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value &amp; mask) &gt;&gt; j);\n      byte[i] |= 0x80;\n      mask = mask &lt;&lt; 7;\n    }\n  for (i = 0; i &lt; 4; i++)\n    if (byte[i] &amp; 0x7f)\n      break;\n\n  if (byte[i] &amp; 0x40)\n    i--;\n  byte[i] &amp;= 0x7f;\n  for (j = 4; j &gt;= i; j--)\n    bit_write_RC (dat, byte[j]);\n}',
 'static bool hasSymbolicPart (const File&amp; root, const File&amp; f)\r\n{\r\n    jassert (root == f || f.isAChildOf (root));\r\n\r\n    for (auto p = f; p != root; p = p.getParentDirectory())\r\n    {\r\n        if (p.isSymbolicLink())\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n}\r',
 "void gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;\n\tint wid;\n\tint w, wstart;\n\tint thick = im-&gt;thick;\n\n\tif (color == gdAntiAliased) {\n\t\t/*\n\t\t   gdAntiAliased passed as color: use the much faster, much cheaper\n\t\t   and equally attractive gdImageAALine implementation. That\n\t\t   clips too, so don't clip twice.\n\t\t   */\n\t\tgdImageAALine(im, x1, y1, x2, y2, im-&gt;AA_color);\n\t\treturn;\n\t}\n\n\t/* 2.0.10: Nick Atty: clip to edges of drawing rectangle, return if no points need to be drawn */\n\tif (!clip_1d(&amp;x1,&amp;y1,&amp;x2,&amp;y2,gdImageSX(im)) || !clip_1d(&amp;y1,&amp;x1,&amp;y2,&amp;x2,gdImageSY(im))) {\n\t\treturn;\n\t}\n\n\tdx = abs (x2 - x1);\n\tdy = abs (y2 - y1);\n\n\tif (dx == 0) {\n\t\tgdImageVLine(im, x1, y1, y2, color);\n\t\treturn;\n\t} else if (dy == 0) {\n\t\tgdImageHLine(im, y1, x1, x2, color);\n\t\treturn;\n\t}\n\n\tif (dy &lt;= dx) {\n\t\t/* More-or-less horizontal. use wid for vertical stroke */\n\t\t/* Doug Claar: watch out for NaN in atan2 (2.0.5) */\n\t\tif ((dx == 0) &amp;&amp; (dy == 0)) {\n\t\t\twid = 1;\n\t\t} else {\n\t\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\nTBB: but watch out for /0! */\n\t\t\tdouble ac = cos (atan2 (dy, dx));\n\t\t\tif (ac != 0) {\n\t\t\t\twid = thick / ac;\n\t\t\t} else {\n\t\t\t\twid = 1;\n\t\t\t}\n\t\t\tif (wid == 0) {\n\t\t\t\twid = 1;\n\t\t\t}\n\t\t}\n\t\td = 2 * dy - dx;\n\t\tincr1 = 2 * dy;\n\t\tincr2 = 2 * (dy - dx);\n\t\tif (x1 &gt; x2) {\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\tydirflag = (-1);\n\t\t\txend = x1;\n\t\t} else {\n\t\t\tx = x1;\n\t\t\ty = y1;\n\t\t\tydirflag = 1;\n\t\t\txend = x2;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = y - wid / 2;\n\t\tfor (w = wstart; w &lt; wstart + wid; w++) {\n\t\t\tgdImageSetPixel(im, x, w, color);\n\t\t}\n\n\t\tif (((y2 - y1) * ydirflag) &gt; 0) {\n\t\t\twhile (x &lt; xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d &lt; 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w &lt; wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (x &lt; xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d &lt; 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w &lt; wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* More-or-less vertical. use wid for horizontal stroke */\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0) {\n\t\t\twid = 1;\n\t\t}\n\n\t\td = 2 * dx - dy;\n\t\tincr1 = 2 * dx;\n\t\tincr2 = 2 * (dx - dy);\n\t\tif (y1 &gt; y2) {\n\t\t\ty = y2;\n\t\t\tx = x2;\n\t\t\tyend = y1;\n\t\t\txdirflag = (-1);\n\t\t} else {\n\t\t\ty = y1;\n\t\t\tx = x1;\n\t\t\tyend = y2;\n\t\t\txdirflag = 1;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = x - wid / 2;\n\t\tfor (w = wstart; w &lt; wstart + wid; w++) {\n\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t}\n\n\t\tif (((x2 - x1) * xdirflag) &gt; 0) {\n\t\t\twhile (y &lt; yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d &lt; 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w &lt; wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (y &lt; yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d &lt; 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w &lt; wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
 'snmp_ber_decode_unsigned_integer(unsigned char *buf, uint32_t *buff_len, uint8_t expected_type, uint32_t *num)\n{\n  uint8_t i, len, type;\n\n  buf = snmp_ber_decode_type(buf, buff_len, &amp;type);\n\n  if(buf == NULL || type != expected_type) {\n    /*\n     * Sanity check\n     * Invalid type in buffer\n     */\n    return NULL;\n  }\n\n  buf = snmp_ber_decode_length(buf, buff_len, &amp;len);\n\n  if(buf == NULL || len &gt; 4) {\n    /*\n     * Sanity check\n     * It will not fit in the uint32_t\n     */\n    return NULL;\n  }\n\n  if(*buff_len &lt; len) {\n    return NULL;\n  }\n\n  *num = (uint32_t)(*buf++ &amp; 0xFF);\n  (*buff_len)--;\n  for(i = 1; i &lt; len; ++i) {\n    *num &lt;&lt;= 8;\n    *num |= (uint8_t)(*buf++ &amp; 0xFF);\n    (*buff_len)--;\n  }\n\n  return buf;\n}',
 'pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)\n{\n\tint error;\n\tstruct pci_emul_dummy *dummy;\n\n\tdummy = calloc(1, sizeof(struct pci_emul_dummy));\n\n\tdev-&gt;arg = dummy;\n\n\tpci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001);\n\tpci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD);\n\tpci_set_cfgdata8(dev, PCIR_CLASS, 0x02);\n\n\terror = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);\n\tassert(error == 0);\n\n\terror = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);\n\tassert(error == 0);\n\n\terror = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\n\terror = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\n\treturn 0;\n}',
 'finish_process_as_req(struct as_req_state *state, krb5_error_code errcode)\n{\n    krb5_key_data *server_key;\n    krb5_keyblock *as_encrypting_key = NULL;\n    krb5_data *response = NULL;\n    const char *emsg = 0;\n    int did_log = 0;\n    loop_respond_fn oldrespond;\n    void *oldarg;\n    kdc_realm_t *kdc_active_realm = state-&gt;active_realm;\n    krb5_audit_state *au_state = state-&gt;au_state;\n\n    assert(state);\n    oldrespond = state-&gt;respond;\n    oldarg = state-&gt;arg;\n\n    if (errcode)\n        goto egress;\n\n    au_state-&gt;stage = ENCR_REP;\n\n    if ((errcode = validate_forwardable(state-&gt;request, *state-&gt;client,\n                                        *state-&gt;server, state-&gt;kdc_time,\n                                        &amp;state-&gt;status))) {\n        errcode += ERROR_TABLE_BASE_krb5;\n        goto egress;\n    }\n\n    errcode = check_indicators(kdc_context, state-&gt;server,\n                               state-&gt;auth_indicators);\n    if (errcode) {\n        state-&gt;status = "HIGHER_AUTHENTICATION_REQUIRED";\n        goto egress;\n    }\n\n    state-&gt;ticket_reply.enc_part2 = &amp;state-&gt;enc_tkt_reply;\n\n    /*\n     * Find the server key\n     */\n    if ((errcode = krb5_dbe_find_enctype(kdc_context, state-&gt;server,\n                                         -1, /* ignore keytype   */\n                                         -1, /* Ignore salttype  */\n                                         0,  /* Get highest kvno */\n                                         &amp;server_key))) {\n        state-&gt;status = "FINDING_SERVER_KEY";\n        goto egress;\n    }\n\n    /*\n     * Convert server-&gt;key into a real key\n     * (it may be encrypted in the database)\n     *\n     *  server_keyblock is later used to generate auth data signatures\n     */\n    if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                             server_key,\n                                             &amp;state-&gt;server_keyblock,\n                                             NULL))) {\n        state-&gt;status = "DECRYPT_SERVER_KEY";\n        goto egress;\n    }\n\n    /* Start assembling the response */\n    state-&gt;reply.msg_type = KRB5_AS_REP;\n    state-&gt;reply.client = state-&gt;enc_tkt_reply.client; /* post canonization */\n    state-&gt;reply.ticket = &amp;state-&gt;ticket_reply;\n    state-&gt;reply_encpart.session = &amp;state-&gt;session_key;\n    if ((errcode = fetch_last_req_info(state-&gt;client,\n                                       &amp;state-&gt;reply_encpart.last_req))) {\n        state-&gt;status = "FETCH_LAST_REQ";\n        goto egress;\n    }\n    state-&gt;reply_encpart.nonce = state-&gt;request-&gt;nonce;\n    state-&gt;reply_encpart.key_exp = get_key_exp(state-&gt;client);\n    state-&gt;reply_encpart.flags = state-&gt;enc_tkt_reply.flags;\n    state-&gt;reply_encpart.server = state-&gt;ticket_reply.server;\n\n    /* copy the time fields EXCEPT for authtime; it\'s location\n     *  is used for ktime\n     */\n    state-&gt;reply_encpart.times = state-&gt;enc_tkt_reply.times;\n    state-&gt;reply_encpart.times.authtime = state-&gt;authtime = state-&gt;kdc_time;\n\n    state-&gt;reply_encpart.caddrs = state-&gt;enc_tkt_reply.caddrs;\n    state-&gt;reply_encpart.enc_padata = NULL;\n\n    /* Fetch the padata info to be returned (do this before\n     *  authdata to handle possible replacement of reply key\n     */\n    errcode = return_padata(kdc_context, &amp;state-&gt;rock, state-&gt;req_pkt,\n                            state-&gt;request, &amp;state-&gt;reply,\n                            &amp;state-&gt;client_keyblock, &amp;state-&gt;pa_context);\n    if (errcode) {\n        state-&gt;status = "KDC_RETURN_PADATA";\n        goto egress;\n    }\n\n    /* If we didn\'t find a client long-term key and no preauth mechanism\n     * replaced the reply key, error out now. */\n    if (state-&gt;client_keyblock.enctype == ENCTYPE_NULL) {\n        state-&gt;status = "CANT_FIND_CLIENT_KEY";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto egress;\n    }\n\n    errcode = handle_authdata(kdc_context,\n                              state-&gt;c_flags,\n                              state-&gt;client,\n                              state-&gt;server,\n                              NULL,\n                              state-&gt;local_tgt,\n                              &amp;state-&gt;client_keyblock,\n                              &amp;state-&gt;server_keyblock,\n                              NULL,\n                              state-&gt;req_pkt,\n                              state-&gt;request,\n                              NULL, /* for_user_princ */\n                              NULL, /* enc_tkt_request */\n                              state-&gt;auth_indicators,\n                              &amp;state-&gt;enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _("AS_REQ : handle_authdata (%d)"),\n                         errcode);\n        state-&gt;status = "HANDLE_AUTHDATA";\n        goto egress;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &amp;state-&gt;server_keyblock,\n                                    &amp;state-&gt;ticket_reply);\n    if (errcode) {\n        state-&gt;status = "ENCRYPT_TICKET";\n        goto egress;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &amp;state-&gt;ticket_reply,\n                              &amp;au_state-&gt;tkt_out_id);\n    if (errcode) {\n        state-&gt;status = "GENERATE_TICKET_ID";\n        goto egress;\n    }\n\n    state-&gt;ticket_reply.enc_part.kvno = server_key-&gt;key_data_kvno;\n    errcode = kdc_fast_response_handle_padata(state-&gt;rstate,\n                                              state-&gt;request,\n                                              &amp;state-&gt;reply,\n                                              state-&gt;client_keyblock.enctype);\n    if (errcode) {\n        state-&gt;status = "MAKE_FAST_RESPONSE";\n        goto egress;\n    }\n\n    /* now encode/encrypt the response */\n\n    state-&gt;reply.enc_part.enctype = state-&gt;client_keyblock.enctype;\n\n    errcode = kdc_fast_handle_reply_key(state-&gt;rstate, &amp;state-&gt;client_keyblock,\n                                        &amp;as_encrypting_key);\n    if (errcode) {\n        state-&gt;status = "MAKE_FAST_REPLY_KEY";\n        goto egress;\n    }\n    errcode = return_enc_padata(kdc_context, state-&gt;req_pkt, state-&gt;request,\n                                as_encrypting_key, state-&gt;server,\n                                &amp;state-&gt;reply_encpart, FALSE);\n    if (errcode) {\n        state-&gt;status = "KDC_RETURN_ENC_PADATA";\n        goto egress;\n    }\n\n    if (kdc_fast_hide_client(state-&gt;rstate))\n        state-&gt;reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_AS_REP,\n                                  &amp;state-&gt;reply_encpart, 0,\n                                  as_encrypting_key,\n                                  &amp;state-&gt;reply, &amp;response);\n    if (state-&gt;client_key != NULL)\n        state-&gt;reply.enc_part.kvno = state-&gt;client_key-&gt;key_data_kvno;\n    if (errcode) {\n        state-&gt;status = "ENCODE_KDC_REP";\n        goto egress;\n    }\n\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don\'t... */\n    memset(state-&gt;reply.enc_part.ciphertext.data, 0,\n           state-&gt;reply.enc_part.ciphertext.length);\n    free(state-&gt;reply.enc_part.ciphertext.data);\n\n    log_as_req(kdc_context, state-&gt;local_addr, state-&gt;remote_addr,\n               state-&gt;request, &amp;state-&gt;reply, state-&gt;client, state-&gt;cname,\n               state-&gt;server, state-&gt;sname, state-&gt;authtime, 0, 0, 0);\n    did_log = 1;\n\negress:\n    if (errcode != 0)\n        assert (state-&gt;status != 0);\n\n    au_state-&gt;status = state-&gt;status;\n    au_state-&gt;reply = &amp;state-&gt;reply;\n    kau_as_req(kdc_context,\n              (errcode || state-&gt;preauth_err) ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    free_padata_context(kdc_context, state-&gt;pa_context);\n    if (as_encrypting_key)\n        krb5_free_keyblock(kdc_context, as_encrypting_key);\n    if (errcode)\n        emsg = krb5_get_error_message(kdc_context, errcode);\n\n    if (state-&gt;status) {\n        log_as_req(kdc_context, state-&gt;local_addr, state-&gt;remote_addr,\n                   state-&gt;request, &amp;state-&gt;reply, state-&gt;client,\n                   state-&gt;cname, state-&gt;server, state-&gt;sname, state-&gt;authtime,\n                   state-&gt;status, errcode, emsg);\n        did_log = 1;\n    }\n    if (errcode) {\n        if (state-&gt;status == 0) {\n            state-&gt;status = emsg;\n        }\n        if (errcode != KRB5KDC_ERR_DISCARD) {\n            errcode -= ERROR_TABLE_BASE_krb5;\n            if (errcode &lt; 0 || errcode &gt; KRB_ERR_MAX)\n                errcode = KRB_ERR_GENERIC;\n\n            errcode = prepare_error_as(state-&gt;rstate, state-&gt;request,\n                                       state-&gt;local_tgt, errcode,\n                                       state-&gt;e_data, state-&gt;typed_e_data,\n                                       ((state-&gt;client != NULL) ?\n                                        state-&gt;client-&gt;princ : NULL),\n                                       &amp;response, state-&gt;status);\n            state-&gt;status = 0;\n        }\n    }\n\n    if (emsg)\n        krb5_free_error_message(kdc_context, emsg);\n    if (state-&gt;enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context,\n                           state-&gt;enc_tkt_reply.authorization_data);\n    if (state-&gt;server_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &amp;state-&gt;server_keyblock);\n    if (state-&gt;client_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &amp;state-&gt;client_keyblock);\n    if (state-&gt;reply.padata != NULL)\n        krb5_free_pa_data(kdc_context, state-&gt;reply.padata);\n    if (state-&gt;reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, state-&gt;reply_encpart.enc_padata);\n\n    if (state-&gt;cname != NULL)\n        free(state-&gt;cname);\n    if (state-&gt;sname != NULL)\n        free(state-&gt;sname);\n    krb5_db_free_principal(kdc_context, state-&gt;client);\n    krb5_db_free_principal(kdc_context, state-&gt;server);\n    krb5_db_free_principal(kdc_context, state-&gt;local_tgt_storage);\n    if (state-&gt;session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &amp;state-&gt;session_key);\n    if (state-&gt;ticket_reply.enc_part.ciphertext.data != NULL) {\n        memset(state-&gt;ticket_reply.enc_part.ciphertext.data , 0,\n               state-&gt;ticket_reply.enc_part.ciphertext.length);\n        free(state-&gt;ticket_reply.enc_part.ciphertext.data);\n    }\n\n    krb5_free_pa_data(kdc_context, state-&gt;e_data);\n    krb5_free_data(kdc_context, state-&gt;inner_body);\n    kdc_free_rstate(state-&gt;rstate);\n    krb5_free_kdc_req(kdc_context, state-&gt;request);\n    k5_free_data_ptr_list(state-&gt;auth_indicators);\n    assert(did_log != 0);\n\n    free(state);\n    (*oldrespond)(oldarg, errcode, response);\n}',
 'static int __init big_key_init(void)\n{\n\treturn register_key_type(&amp;key_type_big_key);\n}',
 'bool DISOpticalFlowImpl::ocl_calc(InputArray I0, InputArray I1, InputOutputArray flow)\n{\n    UMat I0Mat = I0.getUMat();\n    UMat I1Mat = I1.getUMat();\n    bool use_input_flow = false;\n    if (flow.sameSize(I0) &amp;&amp; flow.depth() == CV_32F &amp;&amp; flow.channels() == 2)\n        use_input_flow = true;\n    else\n        flow.create(I1Mat.size(), CV_32FC2);\n    UMat &amp;u_flowMat = flow.getUMatRef();\n    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code serach for maximal movement of width/4 */\n                         (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n\n    ocl_prepareBuffers(I0Mat, I1Mat, u_flowMat, use_input_flow);\n    u_Ux[coarsest_scale].setTo(0.0f);\n    u_Uy[coarsest_scale].setTo(0.0f);\n\n    for (int i = coarsest_scale; i &gt;= finest_scale; i--)\n    {\n        w = u_I0s[i].cols;\n        h = u_I0s[i].rows;\n        ws = 1 + (w - patch_size) / patch_stride;\n        hs = 1 + (h - patch_size) / patch_stride;\n\n        if (!ocl_precomputeStructureTensor(u_I0xx_buf, u_I0yy_buf, u_I0xy_buf,\n                                           u_I0x_buf, u_I0y_buf, u_I0xs[i], u_I0ys[i]))\n            return false;\n\n        if (!ocl_PatchInverseSearch(u_Ux[i], u_Uy[i], u_I0s[i], u_I1s_ext[i], u_I0xs[i], u_I0ys[i], 2, i))\n            return false;\n\n        if (!ocl_Densification(u_Ux[i], u_Uy[i], u_Sx, u_Sy, u_I0s[i], u_I1s[i]))\n            return false;\n\n        if (variational_refinement_iter &gt; 0)\n            variational_refinement_processors[i]-&gt;calcUV(u_I0s[i], u_I1s[i],\n                                                         u_Ux[i].getMat(ACCESS_WRITE), u_Uy[i].getMat(ACCESS_WRITE));\n\n        if (i &gt; finest_scale)\n        {\n            resize(u_Ux[i], u_Ux[i - 1], u_Ux[i - 1].size());\n            resize(u_Uy[i], u_Uy[i - 1], u_Uy[i - 1].size());\n            multiply(u_Ux[i - 1], 2, u_Ux[i - 1]);\n            multiply(u_Uy[i - 1], 2, u_Uy[i - 1]);\n        }\n    }\n    vector&lt;UMat&gt; uxy(2);\n    uxy[0] = u_Ux[finest_scale];\n    uxy[1] = u_Uy[finest_scale];\n    merge(uxy, u_U);\n    resize(u_U, u_flowMat, u_flowMat.size());\n    multiply(u_flowMat, 1 &lt;&lt; finest_scale, u_flowMat);\n\n    return true;\n}',
 'static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev-&gt;hdev;\n\tu8 *buf = dev-&gt;in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&amp;dev-&gt;lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, "error requesting GPIO config: %d\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &amp;= ~(1 &lt;&lt; offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret &lt; 0) {\n\t\thid_err(hdev, "error setting GPIO config: %d\\n", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tmutex_unlock(&amp;dev-&gt;lock);\n\treturn ret &lt; 0 ? ret : -EIO;\n}',
 'static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h-&gt;priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s-&gt;buf_end - s-&gt;buf_ptr;\n    if (len &gt; 0) {\n        if (len &gt; size)\n            len = size;\n        memcpy(buf, s-&gt;buf_ptr, len);\n        s-&gt;buf_ptr += len;\n    } else {\n        int64_t target_end = s-&gt;end_off ? s-&gt;end_off : s-&gt;filesize;\n        if ((!s-&gt;willclose || s-&gt;chunksize &lt; 0) &amp;&amp;\n            target_end &gt;= 0 &amp;&amp; s-&gt;off &gt;= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s-&gt;hd, buf, size);\n        if (!len &amp;&amp; (!s-&gt;willclose || s-&gt;chunksize &lt; 0) &amp;&amp;\n            target_end &gt;= 0 &amp;&amp; s-&gt;off &lt; target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   "Stream ends prematurely at %"PRId64", should be %"PRId64"\\n",\n                   s-&gt;off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len &gt; 0) {\n        s-&gt;off += len;\n        if (s-&gt;chunksize &gt; 0)\n            s-&gt;chunksize -= len;\n    }\n    return len;\n}',
 'bool ConstantFolding::IsSimplifiableReshape(\n    const NodeDef&amp; node, const GraphProperties&amp; properties) const {\n  if (!IsReshape(node)) {\n    return false;\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_-&gt;GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return false;\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&amp;outputs] {\n    for (const auto&amp; output : outputs) {\n      delete output.tensor;\n    }\n  });\n\n  Status s = EvaluateNode(*new_shape, TensorVector(), &amp;outputs);\n  if (!s.ok()) {\n    return false;\n  }\n  CHECK_EQ(1, outputs.size());\n\n  const std::vector&lt;OpInfo::TensorProperties&gt;&amp; props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return false;\n  }\n  const OpInfo::TensorProperties&amp; prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return false;\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return false;\n  }\n\n  PartialTensorShape new_dims;\n  if (outputs[0]-&gt;dtype() == DT_INT32) {\n    std::vector&lt;int32&gt; shp;\n    for (int i = 0; i &lt; outputs[0]-&gt;NumElements(); ++i) {\n      int32_t dim = outputs[0]-&gt;flat&lt;int32&gt;()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &amp;new_dims));\n  } else {\n    std::vector&lt;int64_t&gt; shp;\n    for (int i = 0; i &lt; outputs[0]-&gt;NumElements(); ++i) {\n      int64_t dim = outputs[0]-&gt;flat&lt;int64_t&gt;()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &amp;new_dims));\n  }\n\n  return shape.IsCompatibleWith(new_dims);\n}',
 'void RegKey::getBinary(const TCHAR* valname, void** data, size_t* length, void* def, size_t deflen) const {\n  try {\n    getBinary(valname, data, length);\n  } catch(rdr::Exception&amp;) {\n    if (deflen) {\n      *data = new char[deflen];\n      memcpy(*data, def, deflen);\n    } else\n      *data = 0;\n    *length = deflen;\n  }\n}',
 'MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {\n    if (!result) {\n        debug_print("Result structure is null%s", "\\n");\n        return MOBI_PARAM_ERR;\n    }\n    result-&gt;start = result-&gt;end = NULL;\n    *(result-&gt;value) = \'\\0\';\n    if (!data_start || !data_end) {\n        debug_print("Data is null%s", "\\n");\n        return MOBI_PARAM_ERR;\n    }\n    size_t needle_length = strlen(needle);\n    if (needle_length &gt; MOBI_ATTRNAME_MAXSIZE) {\n        debug_print("Attribute too long: %zu\\n", needle_length);\n        return MOBI_PARAM_ERR;\n    }\n    if (data_start + needle_length &gt; data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    unsigned char tag_open;\n    unsigned char tag_close;\n    if (type == T_CSS) {\n        tag_open = \'{\';\n        tag_close = \'}\';\n    } else {\n        tag_open = \'&lt;\';\n        tag_close = \'&gt;\';\n    }\n    unsigned char last_border = tag_close;\n    while (data &lt;= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length &lt;= data_end &amp;&amp; memcmp(data, needle, needle_length) == 0) {\n            /* found match */\n            if (last_border != tag_open) {\n                /* opening char not found, not an attribute */\n                data += needle_length;\n                continue;\n            }\n            /* go to attribute value beginning */\n            while (data &gt;= data_start &amp;&amp; !isspace(*data) &amp;&amp; *data != tag_open &amp;&amp; *data != \'=\' &amp;&amp; *data != \'(\') {\n                data--;\n            }\n            result-&gt;is_url = (*data == \'(\');\n            result-&gt;start = ++data;\n            /* now go forward */\n            int i = 0;\n            while (data &lt;= data_end &amp;&amp; !isspace(*data) &amp;&amp; *data != tag_close &amp;&amp; *data != \')\' &amp;&amp; i &lt; MOBI_ATTRVALUE_MAXSIZE) {\n                result-&gt;value[i++] = (char) *data++;\n            }\n            /* self closing tag \'/&gt;\' */\n            if (data &lt;= data_end &amp;&amp; *(data - 1) == \'/\' &amp;&amp; *data == \'&gt;\') {\n                --data; --i;\n            }\n            result-&gt;end = data;\n            result-&gt;value[i] = \'\\0\';\n            return MOBI_SUCCESS;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}',
 '    int32_t audio_io_osx::shutdown_audio_unit() {\n        // Close and delete AU\n        OSStatus result = -1;\n        if (NULL != au_rec_) {\n            result = AudioOutputUnitStop(au_rec_);\n            if (0 != result) {\n                error("audio_io_osx: Error stopping Audio Unit (result=%d) \\n", result);\n            }\n            result = AudioComponentInstanceDispose(au_rec_);\n            if (0 != result) {\n                error("audio_io_osx: Error disposing Audio Unit (result=%d) \\n", result);\n            }\n            au_rec_ = NULL;\n        }\n        if (NULL != au_play_) {\n            result = AudioOutputUnitStop(au_play_);\n            if (0 != result) {\n                error("audio_io_osx: Error stopping Audio Unit (result=%d) \\n", result);\n            }\n            result = AudioComponentInstanceDispose(au_play_);\n            if (0 != result) {\n                error("audio_io_osx: Error disposing Audio Unit (result=%d) \\n", result);\n            }\n            au_play_ = NULL;\n        }\n\n        return 0;\n    }',
 "void FontData::Bound(int32_t offset, int32_t length) {\n  // Inputs should not be negative.\n  CHECK(offset &gt;= 0);\n  CHECK(length &gt;= 0);\n\n  // Check to make sure |bound_offset_| will not overflow.\n  CHECK(bound_offset_ &lt;= std::numeric_limits&lt;int32_t&gt;::max() - offset);\n  const int32_t new_offset = bound_offset_ + offset;\n\n  if (length == GROWABLE_SIZE) {\n    // When |length| has the special value of GROWABLE_SIZE, it means the size\n    // should not have any artificial limits, thus it is just the underlying\n    // |array_|'s size. Just make sure |new_offset| is still within bounds.\n    CHECK(new_offset &lt;= array_-&gt;Size());\n  } else {\n    // When |length| has any other value, |new_offset| + |length| points to the\n    // end of the array. Make sure that is within bounds, but use subtraction to\n    // avoid an integer overflow.\n    CHECK(new_offset &lt;= array_-&gt;Size() - length);\n  }\n\n  bound_offset_ = new_offset;\n  bound_length_ = length;\n}",
 'static ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\treturn sprintf(buf, "%s\\n", pdev-&gt;driver_override);\n}',
 'TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  optimized_ops::Round(GetTensorShape(input), GetTensorData&lt;float&gt;(input),\n                       GetTensorShape(output), GetTensorData&lt;float&gt;(output));\n\n  return kTfLiteOk;\n}',
 '  void Compute(OpKernelContext* context) override {\n    const Tensor&amp; filter = context-&gt;input(1);\n    const TensorShape&amp; filter_shape = filter.shape();\n\n    const Tensor&amp; out_backprop = context-&gt;input(2);\n    const TensorShape&amp; out_backprop_shape = out_backprop.shape();\n\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor&amp; input_sizes = context-&gt;input(0);\n      // tensor::MakeShape is able to handle both DT_INT32 and DT_INT64 for\n      // input_sizes.\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &amp;input_shape));\n    } else {\n      input_shape = context-&gt;input(0).shape();\n    }\n\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument("input and filter_sizes must have the same "\n                                "number of channels. Got ",\n                                input_shape.dim_size(4), " for input and ",\n                                filter_shape.dim_size(3), " for filter_sizes"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument("out_backprop and filter_sizes must have the "\n                                "same number of channels. Got ",\n                                out_backprop_shape.dim_size(4),\n                                " for out_backprop and ",\n                                filter_shape.dim_size(4), " for filter_sizes"));\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                "Conv3DBackpropInputOp", /*num_spatial_dims=*/3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &amp;dims));\n\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context-&gt;allocate_output(0, input_shape, &amp;in_backprop));\n\n    int64 top_pad_planes, bottom_pad_planes;\n    int64 top_pad_rows, bottom_pad_rows;\n    int64 left_pad_cols, right_pad_cols;\n\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[0].input_size,\n                                dims.spatial_dims[0].filter_size,\n                                dims.spatial_dims[0].stride, padding_,\n                                &amp;dims.spatial_dims[0].output_size,\n                                &amp;top_pad_planes, &amp;bottom_pad_planes));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[1].input_size,\n                                dims.spatial_dims[1].filter_size,\n                                dims.spatial_dims[1].stride, padding_,\n                                &amp;dims.spatial_dims[1].output_size,\n                                &amp;top_pad_rows, &amp;bottom_pad_rows));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[2].input_size,\n                                dims.spatial_dims[2].filter_size,\n                                dims.spatial_dims[2].stride, padding_,\n                                &amp;dims.spatial_dims[2].output_size,\n                                &amp;left_pad_cols, &amp;right_pad_cols));\n\n    // TODO(ezhulenev): Extract work size and shard estimation to shared\n    // functions in conv_grad_ops, and update 2d convolution backprop.\n\n    // The total dimension size of each kernel.\n    const int64 filter_total_size =\n        dims.spatial_dims[0].filter_size * dims.spatial_dims[1].filter_size *\n        dims.spatial_dims[2].filter_size * dims.in_depth;\n\n    // The output image size is the spatial size of the output.\n    const int64 output_image_size = dims.spatial_dims[0].output_size *\n                                    dims.spatial_dims[1].output_size *\n                                    dims.spatial_dims[2].output_size;\n\n    const auto cache_sizes = Eigen::internal::CacheSizes();\n    const ptrdiff_t l3_cache_size = cache_sizes.m_l3;\n\n    // Use L3 cache size as target working set size.\n    const size_t target_working_set_size = l3_cache_size / sizeof(T);\n\n    // Calculate size of matrices involved in MatMul: C = A x B.\n    const int64 size_A = output_image_size * dims.out_depth;\n\n    const int64 size_B = filter_total_size * dims.out_depth;\n\n    const int64 size_C = output_image_size * filter_total_size;\n\n    const int64 work_unit_size = size_A + size_B + size_C;\n\n    auto worker_threads = *(context-&gt;device()-&gt;tensorflow_cpu_worker_threads());\n\n    // Use parallel tensor contractions if there is no batching.\n    //\n    // Compared to Conv2D code, this version is missing work size estimation. In\n    // benchmarks I didn\'t find a case when it\'s beneficial to run parallel\n    // contraction compared to sharding and matmuls.\n    const bool use_parallel_contraction = dims.batch_size == 1;\n\n    const size_t shard_size =\n        use_parallel_contraction\n            ? 1\n            : (target_working_set_size + work_unit_size - 1) / work_unit_size;\n\n    // Total number of elements in all the tensors used by this kernel.\n    int64 total_tensor_elements = input_shape.num_elements() +\n                                  filter_shape.num_elements() +\n                                  out_backprop_shape.num_elements();\n\n    // Shape of the temporary workspace buffer.\n    TensorShape col_buffer_shape = {static_cast&lt;int64&gt;(shard_size),\n                                    static_cast&lt;int64&gt;(output_image_size),\n                                    static_cast&lt;int64&gt;(filter_total_size)};\n    int64 col_buffer_elements = col_buffer_shape.num_elements();\n\n    // If the temporary allocation overhead is too large, fallback on Eigen\n    // implementation which requires much less memory.\n    int64 col_buffer_overhead = col_buffer_elements / total_tensor_elements;\n    if (col_buffer_overhead &gt; kMaxTempAllocationOverhead) {\n      VLOG(2) &lt;&lt; "Fallback on Eigen implementation of Conv3DBackpropInputOp: "\n                 "col_buffer_overhead="\n              &lt;&lt; col_buffer_overhead;\n\n      functor::CuboidConvolutionBackwardInput&lt;Device, T&gt;()(\n          context-&gt;eigen_device&lt;Device&gt;(),\n          in_backprop-&gt;tensor&lt;T, 5&gt;(),                     // input_backward\n          filter.tensor&lt;T, 5&gt;(),                           // filter\n          out_backprop.tensor&lt;T, 5&gt;(),                     // output_backward\n          static_cast&lt;int&gt;(dims.spatial_dims[0].stride),   // stride_planes\n          static_cast&lt;int&gt;(dims.spatial_dims[1].stride),   // stride_rows\n          static_cast&lt;int&gt;(dims.spatial_dims[2].stride));  // stride_cols\n\n      return;\n    }\n\n    Tensor col_buffer;\n    OP_REQUIRES_OK(context,\n                   context-&gt;allocate_temp(DataTypeToEnum&lt;T&gt;::value,\n                                          col_buffer_shape, &amp;col_buffer));\n\n    // The input offset corresponding to a single input image.\n    const int64 input_offset = dims.spatial_dims[0].input_size *\n                               dims.spatial_dims[1].input_size *\n                               dims.spatial_dims[2].input_size * dims.in_depth;\n\n    // The output offset corresponding to a single output image.\n    const int64 output_offset =\n        dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size *\n        dims.spatial_dims[2].output_size * dims.out_depth;\n\n    const T* filter_data = filter.template flat&lt;T&gt;().data();\n    T* col_buffer_data = col_buffer.template flat&lt;T&gt;().data();\n    const T* out_backprop_data = out_backprop.template flat&lt;T&gt;().data();\n\n    auto in_backprop_flat = in_backprop-&gt;template flat&lt;T&gt;();\n    T* input_backprop_data = in_backprop_flat.data();\n    in_backprop_flat.device(context-&gt;eigen_device&lt;Device&gt;()) =\n        in_backprop_flat.constant(T(0));\n\n    if (use_parallel_contraction) {\n      typedef Eigen::TensorMap&lt;Eigen::Tensor&lt;T, 2, Eigen::RowMajor&gt;,\n                               Eigen::Unaligned&gt;\n          TensorMap;\n      typedef Eigen::TensorMap&lt;Eigen::Tensor&lt;const T, 2, Eigen::RowMajor&gt;,\n                               Eigen::Unaligned&gt;\n          ConstTensorMap;\n\n      // Initialize contraction dims (we need to transpose \'B\' below).\n      Eigen::array&lt;Eigen::IndexPair&lt;Eigen::DenseIndex&gt;, 1&gt; contract_dims;\n      contract_dims[0].first = 1;\n      contract_dims[0].second = 1;\n\n      for (int image_id = 0; image_id &lt; dims.batch_size; ++image_id) {\n        // Compute gradient into col_buffer.\n        TensorMap C(col_buffer_data, output_image_size, filter_total_size);\n\n        ConstTensorMap A(out_backprop_data + output_offset * image_id,\n                         output_image_size, dims.out_depth);\n        ConstTensorMap B(filter_data, filter_total_size, dims.out_depth);\n\n        C.device(context-&gt;eigen_cpu_device()) = A.contract(B, contract_dims);\n\n        Col2im&lt;T&gt;(col_buffer_data, dims.in_depth,\n                  // Input spatial dimensions.\n                  dims.spatial_dims[0].input_size,  // input planes\n                  dims.spatial_dims[1].input_size,  // input rows\n                  dims.spatial_dims[2].input_size,  // input cols\n                  // Filter spatial dimensions.\n                  dims.spatial_dims[0].filter_size,  // filter planes\n                  dims.spatial_dims[1].filter_size,  // filter rows\n                  dims.spatial_dims[2].filter_size,  // filter cols\n                  // Spatial padding.\n                  top_pad_planes, top_pad_rows, left_pad_cols,\n                  bottom_pad_planes, bottom_pad_rows, right_pad_cols,\n                  // Spatial striding.\n                  dims.spatial_dims[0].stride,  // stride planes\n                  dims.spatial_dims[1].stride,  // stride rows\n                  dims.spatial_dims[2].stride,  // stride cols\n                  input_backprop_data);\n\n        input_backprop_data += input_offset;\n      }\n    } else {\n      typedef Eigen::Map&lt;\n          Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;&gt;\n          MatrixMap;\n      typedef Eigen::Map&lt;const Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic,\n                                             Eigen::RowMajor&gt;&gt;\n          ConstMatrixMap;\n\n      for (int image_id = 0; image_id &lt; dims.batch_size;\n           image_id += shard_size) {\n        const int shard_limit =\n            std::min(static_cast&lt;int&gt;(shard_size),\n                     static_cast&lt;int&gt;(dims.batch_size) - image_id);\n\n        auto shard = [&amp;dims, &amp;top_pad_planes, &amp;top_pad_rows, &amp;left_pad_cols,\n                      &amp;bottom_pad_planes, &amp;bottom_pad_rows, &amp;right_pad_cols,\n                      &amp;output_image_size, &amp;filter_total_size,\n                      &amp;input_backprop_data, &amp;col_buffer_data,\n                      &amp;out_backprop_data, &amp;filter_data, &amp;input_offset,\n                      &amp;output_offset, &amp;size_C](int64 start, int64 limit) {\n          for (int shard_id = start; shard_id &lt; limit; ++shard_id) {\n            T* im2col_buf = col_buffer_data + shard_id * size_C;\n            T* input_data = input_backprop_data + shard_id * input_offset;\n            const T* out_data = out_backprop_data + shard_id * output_offset;\n\n            // Compute gradient into \'im2col_buf\'.\n            MatrixMap C(im2col_buf, output_image_size, filter_total_size);\n\n            ConstMatrixMap A(out_data, output_image_size, dims.out_depth);\n            ConstMatrixMap B(filter_data, filter_total_size, dims.out_depth);\n\n            C.noalias() = A * B.transpose();\n\n            Col2im&lt;T&gt;(im2col_buf, dims.in_depth,\n                      // Input spatial dimensions.\n                      dims.spatial_dims[0].input_size,  // input planes\n                      dims.spatial_dims[1].input_size,  // input rows\n                      dims.spatial_dims[2].input_size,  // input cols\n                      // Filter spatial dimensions.\n                      dims.spatial_dims[0].filter_size,  // filter planes\n                      dims.spatial_dims[1].filter_size,  // filter rows\n                      dims.spatial_dims[2].filter_size,  // filter cols\n                      // Spatial padding.\n                      top_pad_planes, top_pad_rows, left_pad_cols,\n                      bottom_pad_planes, bottom_pad_rows, right_pad_cols,\n                      // Spatial striding.\n                      dims.spatial_dims[0].stride,  // stride planes\n                      dims.spatial_dims[1].stride,  // stride rows\n                      dims.spatial_dims[2].stride,  // stride cols\n                      input_data);\n          }\n        };\n        Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,\n              work_unit_size, shard);\n\n        input_backprop_data += input_offset * shard_limit;\n        out_backprop_data += output_offset * shard_limit;\n      }\n    }\n  }',
 'UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u\'-\');\n    }\n    if (precision == 0) {\n        result.append(u"0E+0", -1);\n        return result;\n    }\n    // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from\n    // rOptPos (aka -maxFrac) due to overflow.\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u\'0\' + getDigitPos(p));\n    if ((--p) &gt;= lowerPos) {\n        result.append(u\'.\');\n        for (; p &gt;= lowerPos; p--) {\n            result.append(u\'0\' + getDigitPos(p));\n        }\n    }\n    result.append(u\'E\');\n    int32_t _scale = upperPos + scale;\n    if (_scale &lt; 0) {\n        _scale *= -1;\n        result.append(u\'-\');\n    } else {\n        result.append(u\'+\');\n    }\n    if (_scale == 0) {\n        result.append(u\'0\');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale &gt; 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u\'0\' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}',
 'static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (action &amp; CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta-&gt;old_file.path, delta-&gt;old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, "cannot remove invalid path \'%s\'", delta-&gt;old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action &amp; ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta-&gt;new_file.path, delta-&gt;new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, "cannot checkout to invalid path \'%s\'", delta-&gt;new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}',
 '  void operator()(OpKernelContext* ctx, const CPUDevice&amp; d, const T* rate_flat,\n                  int num_rate, int num_samples,\n                  const random::PhiloxRandom&amp; rng, U* samples_flat) {\n    // Two different algorithms are employed, depending on the size of\n    // rate.\n    // If rate &lt; 10, we use an algorithm attributed to Knuth:\n    // Seminumerical Algorithms. Art of Computer Programming, Volume 2.\n    //\n    // This algorithm runs in O(rate) time, and will require O(rate)\n    // uniform variates.\n    //\n    // If rate &gt;= 10 we use a transformation-rejection algorithm from\n    // pairs of uniform random variables due to Hormann.\n    // http://www.sciencedirect.com/science/article/pii/0167668793909974\n    //\n    // The algorithm has an acceptance rate of ~89% for the smallest rate\n    // (~10),\n    // and higher accept rates for higher rate, so runtime is\n    // O(NumRate * NumSamples * k) with k ~ 1 / 0.89.\n    //\n    // We partition work first across rates then across\n    // samples-per-rate to\n    // avoid a couple flops which can be done on a per-rate basis.\n\n    typedef random::UniformDistribution&lt;random::PhiloxRandom, CT&gt; Uniform;\n\n    auto DoWork = [num_samples, num_rate, &amp;rng, samples_flat, rate_flat](\n                      int64 start_output, int64 limit_output) {\n      // Capturing "rng" by value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // "rng" by reference and explicitly do a copy assignment.\n\n      Uniform uniform;\n      typename Uniform::ResultType uniform_result;\n      for (int64 output_idx = start_output; output_idx &lt; limit_output;\n           /* output_idx incremented within inner loop below */) {\n        const int64 rate_idx = output_idx / num_samples;\n\n        // Several calculations can be done on a per-rate basis.\n        const CT rate = CT(rate_flat[rate_idx]);\n\n        auto samples_rate_output = samples_flat + rate_idx;\n\n        if (rate &lt; CT(10)) {\n          // Knuth\'s algorithm for generating Poisson random variates.\n          // Given a Poisson process, the time between events is exponentially\n          // distributed. If we have a Poisson process with rate lambda, then,\n          // the time between events is distributed Exp(lambda). If X ~\n          // Uniform(0, 1), then Y ~ Exp(lambda), where Y = -log(X) / lambda.\n          // Thus to simulate a Poisson draw, we can draw X_i ~ Exp(lambda),\n          // and N ~ Poisson(lambda), where N is the least number such that\n          // \\sum_i^N X_i &gt; 1.\n          const CT exp_neg_rate = Eigen::numext::exp(-rate);\n\n          // Compute the rest of the samples for the current rate value.\n          for (int64 sample_idx = output_idx % num_samples;\n               sample_idx &lt; num_samples &amp;&amp; output_idx &lt; limit_output;\n               sample_idx++, output_idx++) {\n            random::PhiloxRandom gen = rng;\n            gen.Skip(kReservedSamplesPerOutput * output_idx);\n            int16 uniform_remaining = 0;\n\n            CT prod = 1;\n            CT x = 0;\n\n            // Keep trying until we surpass e^(-rate). This will take\n            // expected time proportional to rate.\n            while (true) {\n              UNIFORM(u);\n              prod = prod * u;\n              if (prod &lt;= exp_neg_rate &amp;&amp;\n                  x &lt;= CT(Eigen::NumTraits&lt;U&gt;::highest())) {\n                samples_rate_output[sample_idx * num_rate] = U(x);\n                break;\n              }\n              x += 1;\n            }\n          }\n          continue;\n        }\n        // Transformed rejection due to Hormann.\n        //\n        // Given a CDF F(x), and G(x), a dominating distribution chosen such\n        // that it is close to the inverse CDF F^-1(x), compute the following\n        // steps:\n        //\n        // 1) Generate U and V, two independent random variates. Set U = U - 0.5\n        // (this step isn\'t strictly necessary, but is done to make some\n        // calculations symmetric and convenient. Henceforth, G is defined on\n        // [-0.5, 0.5]).\n        //\n        // 2) If V &lt;= alpha * F\'(G(U)) * G\'(U), return floor(G(U)), else return\n        // to step 1. alpha is the acceptance probability of the rejection\n        // algorithm.\n        //\n        // For more details on transformed rejection, see:\n        // http://citeseer.ist.psu.edu/viewdoc/citations;jsessionid=1BEB35946CC807879F55D42512E5490C?doi=10.1.1.48.3054.\n        //\n        // The dominating distribution in this case:\n        //\n        // G(u) = (2 * a / (2 - |u|) + b) * u + c\n\n        using Eigen::numext::log;\n        const CT log_rate = log(rate);\n\n        // Constants used to define the dominating distribution. Names taken\n        // from Hormann\'s paper. Constants were chosen to define the tightest\n        // G(u) for the inverse Poisson CDF.\n        const CT b = CT(0.931) + CT(2.53) * Eigen::numext::sqrt(rate);\n        const CT a = CT(-0.059) + CT(0.02483) * b;\n\n        // This is the inverse acceptance rate. At a minimum (when rate = 10),\n        // this corresponds to ~75% acceptance. As the rate becomes larger, this\n        // approaches ~89%.\n        const CT inv_alpha = CT(1.1239) + CT(1.1328) / (b - CT(3.4));\n\n        // Compute the rest of the samples for the current rate value.\n        for (int64 sample_idx = output_idx % num_samples;\n             sample_idx &lt; num_samples &amp;&amp; output_idx &lt; limit_output;\n             sample_idx++, output_idx++) {\n          random::PhiloxRandom gen = rng;\n          gen.Skip(kReservedSamplesPerOutput * output_idx);\n          int16 uniform_remaining = 0;\n\n          while (true) {\n            UNIFORM(u);\n            u -= CT(0.5);\n            UNIFORM(v);\n\n            CT u_shifted = CT(0.5) - Eigen::numext::abs(u);\n            CT k = Eigen::numext::floor((CT(2) * a / u_shifted + b) * u + rate +\n                                        CT(0.43));\n\n            if (k &gt; CT(Eigen::NumTraits&lt;U&gt;::highest())) {\n              // retry in case of overflow.\n              continue;\n            }\n\n            // When alpha * f(G(U)) * G\'(U) is close to 1, it is possible to\n            // find a rectangle (-u_r, u_r) x (0, v_r) under the curve, such\n            // that if v &lt;= v_r and |u| &lt;= u_r, then we can accept.\n            // Here v_r = 0.9227 - 3.6224 / (b - 2) and u_r = 0.43.\n            if (u_shifted &gt;= CT(0.07) &amp;&amp;\n                v &lt;= CT(0.9277) - CT(3.6224) / (b - CT(2))) {\n              samples_rate_output[sample_idx * num_rate] = U(k);\n              break;\n            }\n\n            if (k &lt; 0 || (u_shifted &lt; CT(0.013) &amp;&amp; v &gt; u_shifted)) {\n              continue;\n            }\n\n            // The expression below is equivalent to the computation of step 2)\n            // in transformed rejection (v &lt;= alpha * F\'(G(u)) * G\'(u)).\n            CT s = log(v * inv_alpha / (a / (u_shifted * u_shifted) + b));\n            CT t = -rate + k * log_rate - Eigen::numext::lgamma(k + 1);\n            if (s &lt;= t) {\n              samples_rate_output[sample_idx * num_rate] = U(k);\n              break;\n            }\n          }\n        }\n      }\n    };\n\n    // This will depend on rate.\n    // For rate &lt; 10, on average, O(rate) calls to uniform are\n    // needed, with that\n    // many multiplies. ~10 uniform calls on average with ~25 cost op calls.\n    //\n    // Very roughly, for rate &gt;= 10, the single call to log + call to\n    // lgamma\n    // occur for ~60 percent of samples.\n    // 2 x 100 (64-bit cycles per log) * 0.62 = ~124\n    // Additionally, there are ~10 other ops (+, *, /, ...) at 3-6 cycles each:\n    // 40 * .62  = ~25.\n    //\n    // Finally, there are several other ops that are done every loop along with\n    // 2 uniform generations along with 5 other ops at 3-6 cycles each.\n    // ~15 / .89 = ~16\n    //\n    // In total this should be ~165 + 2 * Uniform::kElementCost.\n    // We assume that half the tensor has rate &lt; 10, so on average 6\n    // uniform\'s\n    // will be needed. We will upper bound the other op cost by the one for\n    // rate &gt; 10.\n    static const int kElementCost = 165 + 6 * Uniform::kElementCost +\n                                    6 * random::PhiloxRandom::kElementCost;\n    auto worker_threads = *(ctx-&gt;device()-&gt;tensorflow_cpu_worker_threads());\n    Shard(worker_threads.num_threads, worker_threads.workers,\n          num_rate * num_samples, kElementCost, DoWork);\n  }',
 'bool DNP3_Base::AddToBuffer(Endpoint* endp, int target_len, const u_char** data, int* len)\n\t{\n\tif ( ! target_len )\n\t\treturn true;\n\n\tint to_copy = min(*len, target_len - endp-&gt;buffer_len);\n\n\tmemcpy(endp-&gt;buffer + endp-&gt;buffer_len, *data, to_copy);\n\t*data += to_copy;\n\t*len -= to_copy;\n\tendp-&gt;buffer_len += to_copy;\n\n\treturn endp-&gt;buffer_len == target_len;\n\t}',
 'static int xdp_umem_reg(struct xdp_umem *umem, struct xdp_umem_reg *mr)\n{\n\tbool unaligned_chunks = mr-&gt;flags &amp; XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n\tu32 chunk_size = mr-&gt;chunk_size, headroom = mr-&gt;headroom;\n\tunsigned int chunks, chunks_per_page;\n\tu64 addr = mr-&gt;addr, size = mr-&gt;len;\n\tint err;\n\n\tif (chunk_size &lt; XDP_UMEM_MIN_CHUNK_SIZE || chunk_size &gt; PAGE_SIZE) {\n\t\t/* Strictly speaking we could support this, if:\n\t\t * - huge pages, or*\n\t\t * - using an IOMMU, or\n\t\t * - making sure the memory area is consecutive\n\t\t * but for now, we simply say "computer says no".\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif (mr-&gt;flags &amp; ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG |\n\t\t\tXDP_UMEM_USES_NEED_WAKEUP))\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks &amp;&amp; !is_power_of_2(chunk_size))\n\t\treturn -EINVAL;\n\n\tif (!PAGE_ALIGNED(addr)) {\n\t\t/* Memory area has to be page size aligned. For\n\t\t * simplicity, this might change.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif ((addr + size) &lt; addr)\n\t\treturn -EINVAL;\n\n\tchunks = (unsigned int)div_u64(size, chunk_size);\n\tif (chunks == 0)\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks) {\n\t\tchunks_per_page = PAGE_SIZE / chunk_size;\n\t\tif (chunks &lt; chunks_per_page || chunks % chunks_per_page)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (headroom &gt;= chunk_size - XDP_PACKET_HEADROOM)\n\t\treturn -EINVAL;\n\n\tumem-&gt;address = (unsigned long)addr;\n\tumem-&gt;chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK\n\t\t\t\t\t    : ~((u64)chunk_size - 1);\n\tumem-&gt;size = size;\n\tumem-&gt;headroom = headroom;\n\tumem-&gt;chunk_size_nohr = chunk_size - headroom;\n\tumem-&gt;npgs = size / PAGE_SIZE;\n\tumem-&gt;pgs = NULL;\n\tumem-&gt;user = NULL;\n\tumem-&gt;flags = mr-&gt;flags;\n\tINIT_LIST_HEAD(&amp;umem-&gt;xsk_list);\n\tspin_lock_init(&amp;umem-&gt;xsk_list_lock);\n\n\trefcount_set(&amp;umem-&gt;users, 1);\n\n\terr = xdp_umem_account_pages(umem);\n\tif (err)\n\t\treturn err;\n\n\terr = xdp_umem_pin_pages(umem);\n\tif (err)\n\t\tgoto out_account;\n\n\tumem-&gt;pages = kvcalloc(umem-&gt;npgs, sizeof(*umem-&gt;pages),\n\t\t\t       GFP_KERNEL_ACCOUNT);\n\tif (!umem-&gt;pages) {\n\t\terr = -ENOMEM;\n\t\tgoto out_pin;\n\t}\n\n\terr = xdp_umem_map_pages(umem);\n\tif (!err)\n\t\treturn 0;\n\n\tkvfree(umem-&gt;pages);\n\nout_pin:\n\txdp_umem_unpin_pages(umem);\nout_account:\n\txdp_umem_unaccount_pages(umem);\n\treturn err;\n}',
 'TEST(DefaultCertValidatorTest, TestMatchSubjectAltNameURIMatched) {\n  bssl::UniquePtr&lt;X509&gt; cert = readCertFromFile(TestEnvironment::substitute(\n      "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem"));\n  envoy::type::matcher::v3::StringMatcher matcher;\n  matcher.MergeFrom(TestUtility::createRegexMatcher(R"raw(spiffe://lyft.com/[^/]*-team)raw"));\n  std::vector&lt;SanMatcherPtr&gt; subject_alt_name_matchers;\n  subject_alt_name_matchers.push_back(\n      SanMatcherPtr{std::make_unique&lt;StringSanMatcher&gt;(GEN_URI, matcher)});\n  EXPECT_TRUE(DefaultCertValidator::matchSubjectAltName(cert.get(), subject_alt_name_matchers));\n}',
 'static inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)\n{\n\tswitch (endian) {\n\tdefault:\n\t\t*s = (wchar_t) c;\n\t\tbreak;\n\tcase UTF16_LITTLE_ENDIAN:\n\t\t*s = __cpu_to_le16(c);\n\t\tbreak;\n\tcase UTF16_BIG_ENDIAN:\n\t\t*s = __cpu_to_be16(c);\n\t\tbreak;\n\t}\n}',
 'log2vis_encoded_string (PyObject * string, const char *encoding,\n\t\t\tFriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t/* logical unicode object */\n\tPyObject *result = NULL;\t/* output string object */\n\n\t/* Always needed for the string length */\n\tlogical = PyUnicode_Decode (PyString_AS_STRING (string),\n\t\t\t\t    PyString_GET_SIZE (string),\n\t\t\t\t    encoding, "strict");\n\tif (logical == NULL)\n\t\treturn NULL;\n\n\tif (strcmp (encoding, "utf-8") == 0)\n\t\t/* Shortcut for utf8 strings (little faster) */\n\t\tresult = log2vis_utf8 (string,\n\t\t\t\t       PyUnicode_GET_SIZE (logical),\n\t\t\t\t       base_direction, clean, reordernsm);\n\telse\n\t{\n\t\t/* Invoke log2vis_unicode and encode back to encoding */\n\n\t\tPyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);\n\n\t\tif (visual)\n\t\t{\n\t\t\tresult = PyUnicode_Encode (PyUnicode_AS_UNICODE\n\t\t\t\t\t\t   (visual),\n\t\t\t\t\t\t   PyUnicode_GET_SIZE (visual),\n\t\t\t\t\t\t   encoding, "strict");\n\t\t\tPy_DECREF (visual);\n\t\t}\n\t}\n\n\tPy_DECREF (logical);\n\n\treturn result;\n}',
 'static int xar_get_toc_data_values(xmlTextReaderPtr reader, long *length, long *offset, long *size, int *encoding,\n                                   unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)\n{\n    const xmlChar *name;\n    int indata = 0, inea = 0;\n    int rc, gotoffset=0, gotlength=0, gotsize=0;\n\n    *a_cksum = NULL;\n    *a_hash = XAR_CKSUM_NONE;\n    *e_cksum = NULL;\n    *e_hash = XAR_CKSUM_NONE;\n    *encoding = CL_TYPE_ANY;\n\n    rc = xmlTextReaderRead(reader);\n    while (rc == 1) {\n        name = xmlTextReaderConstLocalName(reader);\n        if (indata || inea) {\n            /*  cli_dbgmsg("cli_scanxar: xmlTextReaderRead read %s\\n", name); */\n            if (xmlStrEqual(name, (const xmlChar *)"offset") &amp;&amp; \n                xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, offset))\n                    gotoffset=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)"length") &amp;&amp;\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, length))\n                    gotlength=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)"size") &amp;&amp;\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, size))\n                    gotsize=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)"archived-checksum") &amp;&amp;\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                cli_dbgmsg("cli_scanxar: &lt;archived-checksum&gt;:\\n");\n                xar_get_checksum_values(reader, a_cksum, a_hash);\n                \n            } else if ((xmlStrEqual(name, (const xmlChar *)"extracted-checksum") ||\n                        xmlStrEqual(name, (const xmlChar *)"unarchived-checksum")) &amp;&amp;\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                cli_dbgmsg("cli_scanxar: &lt;extracted-checksum&gt;:\\n");\n                xar_get_checksum_values(reader, e_cksum, e_hash);\n\n            } else if (xmlStrEqual(name, (const xmlChar *)"encoding") &amp;&amp;\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)"style");\n                if (style == NULL) {\n                    cli_dbgmsg("cli_scaxar: xmlTextReaderGetAttribute no style attribute "\n                               "for encoding element\\n");\n                    *encoding = CL_TYPE_ANY;\n                } else if (xmlStrEqual(style, (const xmlChar *)"application/x-gzip")) {\n                    cli_dbgmsg("cli_scanxar: encoding = application/x-gzip.\\n");\n                    *encoding = CL_TYPE_GZ; \n                } else if (xmlStrEqual(style, (const xmlChar *)"application/octet-stream")) {\n                    cli_dbgmsg("cli_scanxar: encoding = application/octet-stream.\\n");\n                    *encoding = CL_TYPE_ANY; \n                } else if (xmlStrEqual(style, (const xmlChar *)"application/x-bzip2")) {\n                    cli_dbgmsg("cli_scanxar: encoding = application/x-bzip2.\\n");\n                    *encoding = CL_TYPE_BZ;\n                } else if (xmlStrEqual(style, (const xmlChar *)"application/x-lzma")) {\n                    cli_dbgmsg("cli_scanxar: encoding = application/x-lzma.\\n");\n                    *encoding = CL_TYPE_7Z;\n                 } else if (xmlStrEqual(style, (const xmlChar *)"application/x-xz")) {\n                    cli_dbgmsg("cli_scanxar: encoding = application/x-xz.\\n");\n                    *encoding = CL_TYPE_XZ;\n                } else {\n                    cli_dbgmsg("cli_scaxar: unknown style value=%s for encoding element\\n", style);\n                    *encoding = CL_TYPE_ANY;\n                }\n                if (style != NULL)\n                    xmlFree(style);\n\n           } else if (indata &amp;&amp; xmlStrEqual(name, (const xmlChar *)"data") &amp;&amp;\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {\n                break;\n\n            } else if (inea &amp;&amp; xmlStrEqual(name, (const xmlChar *)"ea") &amp;&amp;\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {\n                break;\n            }\n            \n        } else {\n            if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (xmlStrEqual(name, (const xmlChar *)"data")) {\n                    cli_dbgmsg("cli_scanxar: xmlTextReaderRead read &lt;data&gt;\\n");\n                    indata = 1;\n                } else if (xmlStrEqual(name, (const xmlChar *)"ea")) {\n                    cli_dbgmsg("cli_scanxar: xmlTextReaderRead read &lt;ea&gt;\\n");\n                    inea = 1;\n                }\n            } else if ((xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) &amp;&amp;\n                       xmlStrEqual(name, (const xmlChar *)"xar")) {\n                cli_dbgmsg("cli_scanxar: finished parsing xar TOC.\\n");   \n                break;\n            }\n        }\n        rc = xmlTextReaderRead(reader);\n    }\n    \n    if (gotoffset &amp;&amp; gotlength &amp;&amp; gotsize) {\n        rc = CL_SUCCESS;\n    }\n    else if (0 == gotoffset + gotlength + gotsize)\n        rc = CL_BREAK;\n    else\n        rc = CL_EFORMAT;\n\n    return rc;\n}',
 'int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n\tstruct ieee80211_radiotap_header *radiotap_header,\n\tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n{\n\t/* Linux only supports version 0 radiotap format */\n\tif (radiotap_header-&gt;it_version)\n\t\treturn -EINVAL;\n\n\t/* sanity check for allowed length and radiotap length field */\n\tif (max_length &lt; get_unaligned_le16(&amp;radiotap_header-&gt;it_len))\n\t\treturn -EINVAL;\n\n\titerator-&gt;_rtheader = radiotap_header;\n\titerator-&gt;_max_length = get_unaligned_le16(&amp;radiotap_header-&gt;it_len);\n\titerator-&gt;_arg_index = 0;\n\titerator-&gt;_bitmap_shifter = get_unaligned_le32(&amp;radiotap_header-&gt;it_present);\n\titerator-&gt;_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator-&gt;_reset_on_ext = 0;\n\titerator-&gt;_next_bitmap = &amp;radiotap_header-&gt;it_present;\n\titerator-&gt;_next_bitmap++;\n\titerator-&gt;_vns = vns;\n\titerator-&gt;current_namespace = &amp;radiotap_ns;\n\titerator-&gt;is_radiotap_ns = 1;\n\n\t/* find payload start allowing for extended bitmap(s) */\n\n\tif (iterator-&gt;_bitmap_shifter &amp; (1&lt;&lt;IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator-&gt;_arg) &amp;\n\t\t\t\t\t(1 &lt;&lt; IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator-&gt;_arg += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * check for insanity where the present bitmaps\n\t\t\t * keep claiming to extend up to or even beyond the\n\t\t\t * stated radiotap header length\n\t\t\t */\n\n\t\t\tif ((unsigned long)iterator-&gt;_arg -\n\t\t\t    (unsigned long)iterator-&gt;_rtheader &gt;\n\t\t\t    (unsigned long)iterator-&gt;_max_length)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\titerator-&gt;_arg += sizeof(uint32_t);\n\n\t\t/*\n\t\t * no need to check again for blowing past stated radiotap\n\t\t * header length, because ieee80211_radiotap_iterator_next\n\t\t * checks it before it is dereferenced\n\t\t */\n\t}\n\n\titerator-&gt;this_arg = iterator-&gt;_arg;\n\n\t/* we are all initialized happily */\n\n\treturn 0;\n}',
 'wb_id(netdissect_options *ndo,\n      const struct pkt_id *id, u_int len)\n{\n\tint i;\n\tconst char *cp;\n\tconst struct id_off *io;\n\tchar c;\n\tint nid;\n\n\tND_PRINT((ndo, " wb-id:"));\n\tif (len &lt; sizeof(*id) || !ND_TTEST(*id))\n\t\treturn (-1);\n\tlen -= sizeof(*id);\n\n\tND_PRINT((ndo, " %u/%s:%u (max %u/%s:%u) ",\n\t       EXTRACT_32BITS(&amp;id-&gt;pi_ps.slot),\n\t       ipaddr_string(ndo, &amp;id-&gt;pi_ps.page.p_sid),\n\t       EXTRACT_32BITS(&amp;id-&gt;pi_ps.page.p_uid),\n\t       EXTRACT_32BITS(&amp;id-&gt;pi_mslot),\n\t       ipaddr_string(ndo, &amp;id-&gt;pi_mpage.p_sid),\n\t       EXTRACT_32BITS(&amp;id-&gt;pi_mpage.p_uid)));\n\n\tnid = EXTRACT_16BITS(&amp;id-&gt;pi_ps.nid);\n\tlen -= sizeof(*io) * nid;\n\tio = (struct id_off *)(id + 1);\n\tcp = (char *)(io + nid);\n\tif (!ND_TTEST2(cp, len)) {\n\t\tND_PRINT((ndo, "\\""));\n\t\tfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\n\t\tND_PRINT((ndo, "\\""));\n\t}\n\n\tc = \'&lt;\';\n\tfor (i = 0; i &lt; nid &amp;&amp; ND_TTEST(*io); ++io, ++i) {\n\t\tND_PRINT((ndo, "%c%s:%u",\n\t\t    c, ipaddr_string(ndo, &amp;io-&gt;id), EXTRACT_32BITS(&amp;io-&gt;off)));\n\t\tc = \',\';\n\t}\n\tif (i &gt;= nid) {\n\t\tND_PRINT((ndo, "&gt;"));\n\t\treturn (0);\n\t}\n\treturn (-1);\n}',
 'void TRI_InitV8ServerUtils(v8::Isolate* isolate) {\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, "SYS_CLUSTER_API_JWT_POLICY"), JS_ClusterApiJwtPolicy, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, "SYS_IS_FOXX_API_DISABLED"), JS_IsFoxxApiDisabled, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, "SYS_IS_FOXX_STORE_DISABLED"), JS_IsFoxxStoreDisabled, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, "SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE"), JS_FoxxAllowInstallFromRemote, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, "SYS_RUN_IN_RESTRICTED_CONTEXT"), JS_RunInRestrictedContext, true);\n  \n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   "SYS_CREATE_HOTBACKUP"),\n                               JS_CreateHotbackup);\n\n  // debugging functions\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   "SYS_DEBUG_CLEAR_FAILAT"),\n                               JS_DebugClearFailAt);\n\n#ifdef ARANGODB_ENABLE_FAILURE_TESTS\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, "SYS_DEBUG_TERMINATE"), JS_DebugTerminate);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   "SYS_DEBUG_SET_FAILAT"),\n                               JS_DebugSetFailAt);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   "SYS_DEBUG_REMOVE_FAILAT"),\n                               JS_DebugRemoveFailAt);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   "SYS_DEBUG_SHOULD_FAILAT"),\n                               JS_DebugShouldFailAt);\n#endif\n\n  // poll interval for Foxx queues\n  TRI_GET_GLOBALS();\n  FoxxFeature&amp; foxxFeature = v8g-&gt;_server.getFeature&lt;FoxxFeature&gt;();\n\n  isolate-&gt;GetCurrentContext()\n      -&gt;Global()\n      -&gt;DefineOwnProperty(\n          TRI_IGETC, TRI_V8_ASCII_STRING(isolate, "FOXX_QUEUES_POLL_INTERVAL"),\n          v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n\n  isolate-&gt;GetCurrentContext()\n      -&gt;Global()\n      -&gt;DefineOwnProperty(\n          TRI_IGETC,\n          TRI_V8_ASCII_STRING(isolate, "FOXX_STARTUP_WAIT_FOR_SELF_HEAL"),\n          v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n}',
 'ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)\n{\n    int x;\n    int chunk;\n    UINT8* out;\n    UINT8* ptr;\n\n    ptr = buf;\n\n    chunk = 3 * state-&gt;xsize;\n\n    for (;;) {\n\n\t/* We need data for two full lines before we can do anything */\n\tif (bytes &lt; chunk)\n\t    return ptr - buf;\n\n\t/* Unpack first line */\n\tout = state-&gt;buffer;\n\tfor (x = 0; x &lt; state-&gt;xsize; x++) {\n\t    out[0] = ptr[x];\n\t    out[1] = ptr[(x+4*state-&gt;xsize)/2];\n\t    out[2] = ptr[(x+5*state-&gt;xsize)/2];\n\t    out += 3;\n\t}\n\n\tstate-&gt;shuffle((UINT8*) im-&gt;image[state-&gt;y],\n\t\t       state-&gt;buffer, state-&gt;xsize);\n\n\tif (++state-&gt;y &gt;= state-&gt;ysize)\n\t    return -1; /* This can hardly happen */\n\n\t/* Unpack second line */\n\tout = state-&gt;buffer;\n\tfor (x = 0; x &lt; state-&gt;xsize; x++) {\n\t    out[0] = ptr[x+state-&gt;xsize];\n\t    out[1] = ptr[(x+4*state-&gt;xsize)/2];\n\t    out[2] = ptr[(x+5*state-&gt;xsize)/2];\n\t    out += 3;\n\t}\n\n\tstate-&gt;shuffle((UINT8*) im-&gt;image[state-&gt;y],\n\t\t       state-&gt;buffer, state-&gt;xsize);\n\n\tif (++state-&gt;y &gt;= state-&gt;ysize)\n\t    return -1;\n\n\tptr += chunk;\n\tbytes -= chunk;\n\n    }\n}',
 'bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)\n{\n\tuid_t v_uid, tmpuid;\n\tgid_t v_gid;\n\n\tif (r == v)\n\t\treturn true;\n\tif (r_uid == 0)\n\t\treturn true;\n\tget_pid_creds(v, &amp;v_uid, &amp;v_gid);\n\tif (r_uid == v_uid)\n\t\treturn true;\n\tif (hostuid_to_ns(r_uid, r, &amp;tmpuid) &amp;&amp; tmpuid == 0\n\t\t\t&amp;&amp; hostuid_to_ns(v_uid, r, &amp;tmpuid))\n\t\treturn true;\n\treturn false;\n}',
 'static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap-&gt;card) &lt; sizeof(dev-&gt;card_label)) ?\n\t\t\t       sizeof(cap-&gt;card) :\n\t\t\t\t     sizeof(dev-&gt;card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev-&gt;vdev))\n\t\t\t-&gt;device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\n\tstrlcpy(cap-&gt;driver, "v4l2 loopback", sizeof(cap-&gt;driver));\n\tsnprintf(cap-&gt;card, labellen, dev-&gt;card_label);\n\tsnprintf(cap-&gt;bus_info, sizeof(cap-&gt;bus_info),\n\t\t "platform:v4l2loopback-%03d", device_nr);\n\n#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(3, 1, 0)\n\t/* since 3.1.0, the v4l2-core system is supposed to set the version */\n\tcap-&gt;version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif /* V4L2_CAP_VIDEO_M2M */\n\n\tif (dev-&gt;announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev-&gt;ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev-&gt;ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n\n#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 7, 0)\n\tdev-&gt;vdev-&gt;device_caps =\n#endif /* &gt;=linux-4.7.0 */\n\t\tcap-&gt;device_caps = cap-&gt;capabilities = capabilities;\n\n#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 3, 0)\n\tcap-&gt;capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\n\tmemset(cap-&gt;reserved, 0, sizeof(cap-&gt;reserved));\n\treturn 0;\n}',
 'static bool valid_filetype(char_u *val)\n{\n  for (char_u *s = val; *s != NUL; s++) {\n    if (!ASCII_ISALNUM(*s) &amp;&amp; vim_strchr((char_u *)".-_", *s) == NULL) {\n      return false;\n    }\n  }\n  return true;\n}',
 'static void bt_tags_for_each(struct blk_mq_tags *tags,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_tag_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tif (!tags-&gt;rqs)\n\t\treturn;\n\tfor (i = 0; i &lt; bt-&gt;map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &amp;bt-&gt;map[i];\n\n\t\tfor (bit = find_first_bit(&amp;bm-&gt;word, bm-&gt;depth);\n\t\t     bit &lt; bm-&gt;depth;\n\t\t     bit = find_next_bit(&amp;bm-&gt;word, bm-&gt;depth, bit + 1)) {\n\t\t\trq = blk_mq_tag_to_rq(tags, off + bit);\n\t\t\tfn(rq, data, reserved);\n\t\t}\n\n\t\toff += (1 &lt;&lt; bt-&gt;bits_per_word);\n\t}\n}',
 "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  int num_inputs = NumInputs(node);\n  TF_LITE_ENSURE(context, num_inputs &gt;= 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output-&gt;type = input1-&gt;type;\n\n  // Check that all input tensors have the same shape and type.\n  for (int i = kInputTensor1 + 1; i &lt; num_inputs; ++i) {\n    const TfLiteTensor* input = GetInput(context, node, i);\n    TF_LITE_ENSURE(context, HaveSameShapes(input1, input));\n    TF_LITE_ENSURE_TYPES_EQ(context, input1-&gt;type, input-&gt;type);\n  }\n\n  // Use the first input node's dimension to be the dimension of the output\n  // node.\n  TfLiteIntArray* input1_dims = input1-&gt;dims;\n  TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input1_dims);\n  return context-&gt;ResizeTensor(context, output, output_dims);\n}",
 "void ZydisFormatterBufferInit(ZydisFormatterBuffer* buffer, char* user_buffer,\n    ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n\n    buffer-&gt;is_token_list              = ZYAN_FALSE;\n    buffer-&gt;string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer-&gt;string.vector.allocator    = ZYAN_NULL;\n    buffer-&gt;string.vector.element_size = sizeof(char);\n    buffer-&gt;string.vector.size         = 1;\n    buffer-&gt;string.vector.capacity     = length;\n    buffer-&gt;string.vector.data         = user_buffer;\n    *user_buffer = '\\0';\n}",
 'static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tstrncpy(rpcomp.type, "pcomp", sizeof(rpcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &amp;rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}',
 'static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n\n    if (numHardlinks &gt; 1) {\n\t/* Create first hardlinked file empty */\n\tif (*firsthardlink &lt; 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);\n\t} else {\n\t    /* Create hard links for others */\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc &lt; 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    /* Write normal files or fill the last hardlinked (already\n       existing) file with content */\n    if (numHardlinks&lt;=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n\n    return rc;\n}',
 'ip_printts(netdissect_options *ndo,\n           register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tint hoplen;\n\tconst char *type;\n\n\tif (length &lt; 4) {\n\t\tND_PRINT((ndo, "[bad length %u]", length));\n\t\treturn (0);\n\t}\n\tND_PRINT((ndo, " TS{"));\n\thoplen = ((cp[3]&amp;0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n\tif ((length - 4) &amp; (hoplen-1))\n\t\tND_PRINT((ndo, "[bad length %u]", length));\n\tND_TCHECK(cp[2]);\n\tptr = cp[2] - 1;\n\tlen = 0;\n\tif (ptr &lt; 4 || ((ptr - 4) &amp; (hoplen-1)) || ptr &gt; length + 1)\n\t\tND_PRINT((ndo, "[bad ptr %u]", cp[2]));\n\tND_TCHECK(cp[3]);\n\tswitch (cp[3]&amp;0xF) {\n\tcase IPOPT_TS_TSONLY:\n\t\tND_PRINT((ndo, "TSONLY"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t\tND_PRINT((ndo, "TS+ADDR"));\n\t\tbreak;\n\t/*\n\t * prespecified should really be 3, but some ones might send 2\n\t * instead, and the IPOPT_TS_PRESPEC constant can apparently\n\t * have both values, so we have to hard-code it here.\n\t */\n\n\tcase 2:\n\t\tND_PRINT((ndo, "PRESPEC2.0"));\n\t\tbreak;\n\tcase 3:\t\t\t/* IPOPT_TS_PRESPEC */\n\t\tND_PRINT((ndo, "PRESPEC"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, "[bad ts type %d]", cp[3]&amp;0xF));\n\t\tgoto done;\n\t}\n\n\ttype = " ";\n\tfor (len = 4; len &lt; length; len += hoplen) {\n\t\tif (ptr == len)\n\t\t\ttype = " ^ ";\n\t\tND_TCHECK2(cp[len], hoplen);\n\t\tND_PRINT((ndo, "%s%d@%s", type, EXTRACT_32BITS(&amp;cp[len+hoplen-4]),\n\t\t       hoplen!=8 ? "" : ipaddr_string(ndo, &amp;cp[len])));\n\t\ttype = " ";\n\t}\n\ndone:\n\tND_PRINT((ndo, "%s", ptr == len ? " ^ " : ""));\n\n\tif (cp[3]&gt;&gt;4)\n\t\tND_PRINT((ndo, " [%d hops not recorded]} ", cp[3]&gt;&gt;4));\n\telse\n\t\tND_PRINT((ndo, "}"));\n\treturn (0);\n\ntrunc:\n\treturn (-1);\n}',
 'ast_for_atom_expr(struct compiling *c, const node *n)\n{\n    int i, nch, start = 0;\n    expr_ty e, tmp;\n\n    REQ(n, atom_expr);\n    nch = NCH(n);\n\n    if (TYPE(CHILD(n, 0)) == AWAIT) {\n        if (c-&gt;c_feature_version &lt; 5) {\n            ast_error(c, n,\n                    "Await expressions are only supported in Python 3.5 and greater");\n            return NULL;\n        }\n        start = 1;\n        assert(nch &gt; 1);\n    }\n\n    e = ast_for_atom(c, CHILD(n, start));\n    if (!e)\n        return NULL;\n    if (nch == 1)\n        return e;\n    if (start &amp;&amp; nch == 2) {\n        return Await(e, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n    }\n\n    for (i = start + 1; i &lt; nch; i++) {\n        node *ch = CHILD(n, i);\n        if (TYPE(ch) != trailer)\n            break;\n        tmp = ast_for_trailer(c, ch, e);\n        if (!tmp)\n            return NULL;\n        tmp-&gt;lineno = e-&gt;lineno;\n        tmp-&gt;col_offset = e-&gt;col_offset;\n        e = tmp;\n    }\n\n    if (start) {\n        /* there was an \'await\' */\n        return Await(e, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);\n    }\n    else {\n        return e;\n    }\n}',
 'int main(void)\n{\n\tint fd, len, sock_opt;\n\tint error;\n\tstruct cn_msg *message;\n\tstruct pollfd pfd;\n\tstruct nlmsghdr *incoming_msg;\n\tstruct cn_msg\t*incoming_cn_msg;\n\tstruct hv_kvp_msg *hv_msg;\n\tchar\t*p;\n\tchar\t*key_value;\n\tchar\t*key_name;\n\tint\top;\n\tint\tpool;\n\tchar\t*if_name;\n\tstruct hv_kvp_ipaddr_value *kvp_ip_val;\n\n\tdaemon(1, 0);\n\topenlog("KVP", 0, LOG_USER);\n\tsyslog(LOG_INFO, "KVP starting; pid is:%d", getpid());\n\t/*\n\t * Retrieve OS release information.\n\t */\n\tkvp_get_os_info();\n\n\tif (kvp_file_init()) {\n\t\tsyslog(LOG_ERR, "Failed to initialize the pools");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\n\tif (fd &lt; 0) {\n\t\tsyslog(LOG_ERR, "netlink socket creation failed; error:%d", fd);\n\t\texit(EXIT_FAILURE);\n\t}\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_pad = 0;\n\taddr.nl_pid = 0;\n\taddr.nl_groups = CN_KVP_IDX;\n\n\n\terror = bind(fd, (struct sockaddr *)&amp;addr, sizeof(addr));\n\tif (error &lt; 0) {\n\t\tsyslog(LOG_ERR, "bind failed; error:%d", error);\n\t\tclose(fd);\n\t\texit(EXIT_FAILURE);\n\t}\n\tsock_opt = addr.nl_groups;\n\tsetsockopt(fd, 270, 1, &amp;sock_opt, sizeof(sock_opt));\n\t/*\n\t * Register ourselves with the kernel.\n\t */\n\tmessage = (struct cn_msg *)kvp_send_buffer;\n\tmessage-&gt;id.idx = CN_KVP_IDX;\n\tmessage-&gt;id.val = CN_KVP_VAL;\n\n\thv_msg = (struct hv_kvp_msg *)message-&gt;data;\n\thv_msg-&gt;kvp_hdr.operation = KVP_OP_REGISTER1;\n\tmessage-&gt;ack = 0;\n\tmessage-&gt;len = sizeof(struct hv_kvp_msg);\n\n\tlen = netlink_send(fd, message);\n\tif (len &lt; 0) {\n\t\tsyslog(LOG_ERR, "netlink_send failed; error:%d", len);\n\t\tclose(fd);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpfd.fd = fd;\n\n\twhile (1) {\n\t\tstruct sockaddr *addr_p = (struct sockaddr *) &amp;addr;\n\t\tsocklen_t addr_l = sizeof(addr);\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\t\tpoll(&amp;pfd, 1, -1);\n\n\t\tlen = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,\n\t\t\t\taddr_p, &amp;addr_l);\n\n\t\tif (len &lt; 0) {\n\t\t\tsyslog(LOG_ERR, "recvfrom failed; pid:%u error:%d %s",\n\t\t\t\t\taddr.nl_pid, errno, strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (addr.nl_pid) {\n\t\t\tsyslog(LOG_WARNING, "Received packet from untrusted pid:%u",\n\t\t\t\t\taddr.nl_pid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\n\t\tincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg-&gt;data;\n\n\t\t/*\n\t\t * We will use the KVP header information to pass back\n\t\t * the error from this daemon. So, first copy the state\n\t\t * and set the error code to success.\n\t\t */\n\t\top = hv_msg-&gt;kvp_hdr.operation;\n\t\tpool = hv_msg-&gt;kvp_hdr.pool;\n\t\thv_msg-&gt;error = HV_S_OK;\n\n\t\tif ((in_hand_shake) &amp;&amp; (op == KVP_OP_REGISTER1)) {\n\t\t\t/*\n\t\t\t * Driver is registering with us; stash away the version\n\t\t\t * information.\n\t\t\t */\n\t\t\tin_hand_shake = 0;\n\t\t\tp = (char *)hv_msg-&gt;body.kvp_register.version;\n\t\t\tlic_version = malloc(strlen(p) + 1);\n\t\t\tif (lic_version) {\n\t\t\t\tstrcpy(lic_version, p);\n\t\t\t\tsyslog(LOG_INFO, "KVP LIC Version: %s",\n\t\t\t\t\tlic_version);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, "malloc failed");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (op) {\n\t\tcase KVP_OP_GET_IP_INFO:\n\t\t\tkvp_ip_val = &amp;hv_msg-&gt;body.kvp_ip_val;\n\t\t\tif_name =\n\t\t\tkvp_mac_to_if_name((char *)kvp_ip_val-&gt;adapter_id);\n\n\t\t\tif (if_name == NULL) {\n\t\t\t\t/*\n\t\t\t\t * We could not map the mac address to an\n\t\t\t\t * interface name; return error.\n\t\t\t\t */\n\t\t\t\thv_msg-&gt;error = HV_E_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terror = kvp_get_ip_info(\n\t\t\t\t\t\t0, if_name, KVP_OP_GET_IP_INFO,\n\t\t\t\t\t\tkvp_ip_val,\n\t\t\t\t\t\t(MAX_IP_ADDR_SIZE * 2));\n\n\t\t\tif (error)\n\t\t\t\thv_msg-&gt;error = error;\n\n\t\t\tfree(if_name);\n\t\t\tbreak;\n\n\t\tcase KVP_OP_SET_IP_INFO:\n\t\t\tkvp_ip_val = &amp;hv_msg-&gt;body.kvp_ip_val;\n\t\t\tif_name = kvp_get_if_name(\n\t\t\t\t\t(char *)kvp_ip_val-&gt;adapter_id);\n\t\t\tif (if_name == NULL) {\n\t\t\t\t/*\n\t\t\t\t * We could not map the guid to an\n\t\t\t\t * interface name; return error.\n\t\t\t\t */\n\t\t\t\thv_msg-&gt;error = HV_GUID_NOTFOUND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terror = kvp_set_ip_info(if_name, kvp_ip_val);\n\t\t\tif (error)\n\t\t\t\thv_msg-&gt;error = error;\n\n\t\t\tfree(if_name);\n\t\t\tbreak;\n\n\t\tcase KVP_OP_SET:\n\t\t\tif (kvp_key_add_or_modify(pool,\n\t\t\t\t\thv_msg-&gt;body.kvp_set.data.key,\n\t\t\t\t\thv_msg-&gt;body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg-&gt;body.kvp_set.data.value,\n\t\t\t\t\thv_msg-&gt;body.kvp_set.data.value_size))\n\t\t\t\t\thv_msg-&gt;error = HV_S_CONT;\n\t\t\tbreak;\n\n\t\tcase KVP_OP_GET:\n\t\t\tif (kvp_get_value(pool,\n\t\t\t\t\thv_msg-&gt;body.kvp_set.data.key,\n\t\t\t\t\thv_msg-&gt;body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg-&gt;body.kvp_set.data.value,\n\t\t\t\t\thv_msg-&gt;body.kvp_set.data.value_size))\n\t\t\t\t\thv_msg-&gt;error = HV_S_CONT;\n\t\t\tbreak;\n\n\t\tcase KVP_OP_DELETE:\n\t\t\tif (kvp_key_delete(pool,\n\t\t\t\t\thv_msg-&gt;body.kvp_delete.key,\n\t\t\t\t\thv_msg-&gt;body.kvp_delete.key_size))\n\t\t\t\t\thv_msg-&gt;error = HV_S_CONT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (op != KVP_OP_ENUMERATE)\n\t\t\tgoto kvp_done;\n\n\t\t/*\n\t\t * If the pool is KVP_POOL_AUTO, dynamically generate\n\t\t * both the key and the value; if not read from the\n\t\t * appropriate pool.\n\t\t */\n\t\tif (pool != KVP_POOL_AUTO) {\n\t\t\tif (kvp_pool_enumerate(pool,\n\t\t\t\t\thv_msg-&gt;body.kvp_enum_data.index,\n\t\t\t\t\thv_msg-&gt;body.kvp_enum_data.data.key,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_KEY_SIZE,\n\t\t\t\t\thv_msg-&gt;body.kvp_enum_data.data.value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE))\n\t\t\t\t\thv_msg-&gt;error = HV_S_CONT;\n\t\t\tgoto kvp_done;\n\t\t}\n\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg-&gt;data;\n\t\tkey_name = (char *)hv_msg-&gt;body.kvp_enum_data.data.key;\n\t\tkey_value = (char *)hv_msg-&gt;body.kvp_enum_data.data.value;\n\n\t\tswitch (hv_msg-&gt;body.kvp_enum_data.index) {\n\t\tcase FullyQualifiedDomainName:\n\t\t\tkvp_get_domain_name(key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, "FullyQualifiedDomainName");\n\t\t\tbreak;\n\t\tcase IntegrationServicesVersion:\n\t\t\tstrcpy(key_name, "IntegrationServicesVersion");\n\t\t\tstrcpy(key_value, lic_version);\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv4:\n\t\t\tkvp_get_ip_info(AF_INET, NULL, KVP_OP_ENUMERATE,\n\t\t\t\tkey_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, "NetworkAddressIPv4");\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv6:\n\t\t\tkvp_get_ip_info(AF_INET6, NULL, KVP_OP_ENUMERATE,\n\t\t\t\tkey_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, "NetworkAddressIPv6");\n\t\t\tbreak;\n\t\tcase OSBuildNumber:\n\t\t\tstrcpy(key_value, os_build);\n\t\t\tstrcpy(key_name, "OSBuildNumber");\n\t\t\tbreak;\n\t\tcase OSName:\n\t\t\tstrcpy(key_value, os_name);\n\t\t\tstrcpy(key_name, "OSName");\n\t\t\tbreak;\n\t\tcase OSMajorVersion:\n\t\t\tstrcpy(key_value, os_major);\n\t\t\tstrcpy(key_name, "OSMajorVersion");\n\t\t\tbreak;\n\t\tcase OSMinorVersion:\n\t\t\tstrcpy(key_value, os_minor);\n\t\t\tstrcpy(key_name, "OSMinorVersion");\n\t\t\tbreak;\n\t\tcase OSVersion:\n\t\t\tstrcpy(key_value, os_version);\n\t\t\tstrcpy(key_name, "OSVersion");\n\t\t\tbreak;\n\t\tcase ProcessorArchitecture:\n\t\t\tstrcpy(key_value, processor_arch);\n\t\t\tstrcpy(key_name, "ProcessorArchitecture");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thv_msg-&gt;error = HV_S_CONT;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Send the value back to the kernel. The response is\n\t\t * already in the receive buffer. Update the cn_msg header to\n\t\t * reflect the key value that has been added to the message\n\t\t */\nkvp_done:\n\n\t\tincoming_cn_msg-&gt;id.idx = CN_KVP_IDX;\n\t\tincoming_cn_msg-&gt;id.val = CN_KVP_VAL;\n\t\tincoming_cn_msg-&gt;ack = 0;\n\t\tincoming_cn_msg-&gt;len = sizeof(struct hv_kvp_msg);\n\n\t\tlen = netlink_send(fd, incoming_cn_msg);\n\t\tif (len &lt; 0) {\n\t\t\tsyslog(LOG_ERR, "net_link send failed; error:%d", len);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n}',
 'aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n{\n\tconst struct aodv_hello *ah;\n\n\tND_TCHECK(*ep);\n\tswitch (ep-&gt;type) {\n\tcase AODV_EXT_HELLO:\n\t\tah = (const struct aodv_hello *)(const void *)ep;\n\t\tND_TCHECK(*ah);\n\t\tif (length &lt; sizeof(struct aodv_hello))\n\t\t\tgoto trunc;\n\t\tif (ep-&gt;length &lt; 4) {\n\t\t\tND_PRINT((ndo, "\\n\\text HELLO - bad length %u", ep-&gt;length));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, "\\n\\text HELLO %ld ms",\n\t\t    (unsigned long)EXTRACT_32BITS(&amp;ah-&gt;interval)));\n\t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, "\\n\\text %u %u", ep-&gt;type, ep-&gt;length));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, " [|hello]"));\n}',
 'void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\n\tw = image-&gt;comps[0].w;\n\th = image-&gt;comps[0].h;\n\n\tif(image-&gt;numcomps &lt; 4) return;\n\n\tmax = w * h;\n\t\n\tsC = 1.0F / (float)((1 &lt;&lt; image-&gt;comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 &lt;&lt; image-&gt;comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 &lt;&lt; image-&gt;comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 &lt;&lt; image-&gt;comps[3].prec) - 1);\n\n\tfor(i = 0; i &lt; max; ++i)\n\t{\n\t\t/* CMYK values from 0 to 1 */\n\t\tC = (float)(image-&gt;comps[0].data[i]) * sC;\n\t\tM = (float)(image-&gt;comps[1].data[i]) * sM;\n\t\tY = (float)(image-&gt;comps[2].data[i]) * sY;\n\t\tK = (float)(image-&gt;comps[3].data[i]) * sK;\n\t\t\n\t\t/* Invert all CMYK values */\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\n\t\t/* CMYK -&gt; RGB : RGB results from 0 to 255 */\n\t\timage-&gt;comps[0].data[i] = (int)(255.0F * C * K); /* R */\n\t\timage-&gt;comps[1].data[i] = (int)(255.0F * M * K); /* G */\n\t\timage-&gt;comps[2].data[i] = (int)(255.0F * Y * K); /* B */\n\t}\n\n\tfree(image-&gt;comps[3].data); image-&gt;comps[3].data = NULL;\n\timage-&gt;comps[0].prec = 8;\n\timage-&gt;comps[1].prec = 8;\n\timage-&gt;comps[2].prec = 8;\n\timage-&gt;numcomps -= 1;\n\timage-&gt;color_space = OPJ_CLRSPC_SRGB;\n\t\n\tfor (i = 3; i &lt; image-&gt;numcomps; ++i) {\n\t\tmemcpy(&amp;(image-&gt;comps[i]), &amp;(image-&gt;comps[i+1]), sizeof(image-&gt;comps[i]));\n\t}\n\n}/* color_cmyk_to_rgb() */',
 'vrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data-&gt;vrrp))\n\t\treturn;\n\n\tfile = fopen_safe("/tmp/keepalived.json", "w");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, "Can\'t open /tmp/keepalived.json (%d: %s)",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data-&gt;vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, "iname",\n\t\t\tjson_object_new_string(vrrp-&gt;iname));\n\t\tjson_object_object_add(json_data, "dont_track_primary",\n\t\t\tjson_object_new_int(vrrp-&gt;dont_track_primary));\n\t\tjson_object_object_add(json_data, "skip_check_adv_addr",\n\t\t\tjson_object_new_int(vrrp-&gt;skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, "strict_mode",\n\t\t\tjson_object_new_int((int)vrrp-&gt;strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, "vmac_ifname",\n\t\t\tjson_object_new_string(vrrp-&gt;vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp-&gt;track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp-&gt;track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp-&gt;ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, "track_ifp", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp-&gt;track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp-&gt;track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc-&gt;scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&amp;vscript-&gt;script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, "track_script", track_script);\n\n\t\tjson_object_object_add(json_data, "ifp_ifname",\n\t\t\tjson_object_new_string(vrrp-&gt;ifp-&gt;ifname));\n\t\tjson_object_object_add(json_data, "master_priority",\n\t\t\tjson_object_new_int(vrrp-&gt;master_priority));\n\t\tjson_object_object_add(json_data, "last_transition",\n\t\t\tjson_object_new_double(timeval_to_double(&amp;vrrp-&gt;last_transition)));\n\t\tjson_object_object_add(json_data, "garp_delay",\n\t\t\tjson_object_new_double(vrrp-&gt;garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, "garp_refresh",\n\t\t\tjson_object_new_int((int)vrrp-&gt;garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, "garp_rep",\n\t\t\tjson_object_new_int((int)vrrp-&gt;garp_rep));\n\t\tjson_object_object_add(json_data, "garp_refresh_rep",\n\t\t\tjson_object_new_int((int)vrrp-&gt;garp_refresh_rep));\n\t\tjson_object_object_add(json_data, "garp_lower_prio_delay",\n\t\t\tjson_object_new_int((int)(vrrp-&gt;garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, "garp_lower_prio_rep",\n\t\t\tjson_object_new_int((int)vrrp-&gt;garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, "lower_prio_no_advert",\n\t\t\tjson_object_new_int((int)vrrp-&gt;lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, "higher_prio_send_advert",\n\t\t\tjson_object_new_int((int)vrrp-&gt;higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, "vrid",\n\t\t\tjson_object_new_int(vrrp-&gt;vrid));\n\t\tjson_object_object_add(json_data, "base_priority",\n\t\t\tjson_object_new_int(vrrp-&gt;base_priority));\n\t\tjson_object_object_add(json_data, "effective_priority",\n\t\t\tjson_object_new_int(vrrp-&gt;effective_priority));\n\t\tjson_object_object_add(json_data, "vipset",\n\t\t\tjson_object_new_boolean(vrrp-&gt;vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp-&gt;vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp-&gt;vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp-&gt;family, &amp;(vip-&gt;u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, "vips", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp-&gt;evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp-&gt;evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp-&gt;family, &amp;(evip-&gt;u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, "evips", evips);\n\n\t\tjson_object_object_add(json_data, "promote_secondaries",\n\t\t\tjson_object_new_boolean(vrrp-&gt;promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp-&gt;vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp-&gt;vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, "vroutes", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp-&gt;vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp-&gt;vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, "vrules", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, "adver_int",\n\t\t\tjson_object_new_double(vrrp-&gt;adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, "master_adver_int",\n\t\t\tjson_object_new_double(vrrp-&gt;master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, "accept",\n\t\t\tjson_object_new_int((int)vrrp-&gt;accept));\n\t\tjson_object_object_add(json_data, "nopreempt",\n\t\t\tjson_object_new_boolean(vrrp-&gt;nopreempt));\n\t\tjson_object_object_add(json_data, "preempt_delay",\n\t\t\tjson_object_new_int((int)(vrrp-&gt;preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, "state",\n\t\t\tjson_object_new_int(vrrp-&gt;state));\n\t\tjson_object_object_add(json_data, "wantstate",\n\t\t\tjson_object_new_int(vrrp-&gt;wantstate));\n\t\tjson_object_object_add(json_data, "version",\n\t\t\tjson_object_new_int(vrrp-&gt;version));\n\t\tif (vrrp-&gt;script_backup)\n\t\t\tjson_object_object_add(json_data, "script_backup",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp-&gt;script_backup)));\n\t\tif (vrrp-&gt;script_master)\n\t\t\tjson_object_object_add(json_data, "script_master",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp-&gt;script_master)));\n\t\tif (vrrp-&gt;script_fault)\n\t\t\tjson_object_object_add(json_data, "script_fault",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp-&gt;script_fault)));\n\t\tif (vrrp-&gt;script_stop)\n\t\t\tjson_object_object_add(json_data, "script_stop",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp-&gt;script_stop)));\n\t\tif (vrrp-&gt;script)\n\t\t\tjson_object_object_add(json_data, "script",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp-&gt;script)));\n\t\tif (vrrp-&gt;script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, "script_master_rx_lower_pri",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp-&gt;script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, "smtp_alert",\n\t\t\tjson_object_new_boolean(vrrp-&gt;smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp-&gt;auth_type) {\n\t\t\tjson_object_object_add(json_data, "auth_type",\n\t\t\t\tjson_object_new_int(vrrp-&gt;auth_type));\n\n\t\t\tif (vrrp-&gt;auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp-&gt;auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp-&gt;auth_data, sizeof(vrrp-&gt;auth_data));\n\t\t\t\tauth_data[sizeof(vrrp-&gt;auth_data)] = \'\\0\';\n\t\t\t\tjson_object_object_add(json_data, "auth_data",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, "auth_type",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, "advert_rcvd",\n\t\t\tjson_object_new_int64((int64_t)vrrp-&gt;stats-&gt;advert_rcvd));\n\t\tjson_object_object_add(json_stats, "advert_sent",\n\t\t\tjson_object_new_int64(vrrp-&gt;stats-&gt;advert_sent));\n\t\tjson_object_object_add(json_stats, "become_master",\n\t\t\tjson_object_new_int64(vrrp-&gt;stats-&gt;become_master));\n\t\tjson_object_object_add(json_stats, "release_master",\n\t\t\tjson_object_new_int64(vrrp-&gt;stats-&gt;release_master));\n\t\tjson_object_object_add(json_stats, "packet_len_err",\n\t\t\tjson_object_new_int64((int64_t)vrrp-&gt;stats-&gt;packet_len_err));\n\t\tjson_object_object_add(json_stats, "advert_interval_err",\n\t\t\tjson_object_new_int64((int64_t)vrrp-&gt;stats-&gt;advert_interval_err));\n\t\tjson_object_object_add(json_stats, "ip_ttl_err",\n\t\t\tjson_object_new_int64((int64_t)vrrp-&gt;stats-&gt;ip_ttl_err));\n\t\tjson_object_object_add(json_stats, "invalid_type_rcvd",\n\t\t\tjson_object_new_int64((int64_t)vrrp-&gt;stats-&gt;invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, "addr_list_err",\n\t\t\tjson_object_new_int64((int64_t)vrrp-&gt;stats-&gt;addr_list_err));\n\t\tjson_object_object_add(json_stats, "invalid_authtype",\n\t\t\tjson_object_new_int64(vrrp-&gt;stats-&gt;invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, "authtype_mismatch",\n\t\t\tjson_object_new_int64(vrrp-&gt;stats-&gt;authtype_mismatch));\n\t\tjson_object_object_add(json_stats, "auth_failure",\n\t\t\tjson_object_new_int64(vrrp-&gt;stats-&gt;auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, "pri_zero_rcvd",\n\t\t\tjson_object_new_int64((int64_t)vrrp-&gt;stats-&gt;pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, "pri_zero_sent",\n\t\t\tjson_object_new_int64((int64_t)vrrp-&gt;stats-&gt;pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, "data", json_data);\n\t\tjson_object_object_add(instance_json, "stats", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, "%s", json_object_to_json_string(array));\n\tfclose(file);\n}',
 'static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port-&gt;serial;\n\tunsigned long flags;\n\tint result = 0;\n\n\tif (!priv-&gt;comm_is_ok)\n\t\treturn -EIO;\n\n\t/* clear halts before open */\n\tusb_clear_halt(serial-&gt;dev, 0x81);\n\tusb_clear_halt(serial-&gt;dev, 0x02);\n\n\tspin_lock_irqsave(&amp;priv-&gt;lock, flags);\n\t/* reset read/write statistics */\n\tpriv-&gt;bytes_in = 0;\n\tpriv-&gt;bytes_out = 0;\n\tpriv-&gt;cmd_count = 0;\n\tpriv-&gt;rx_flags = 0;\n\tspin_unlock_irqrestore(&amp;priv-&gt;lock, flags);\n\n\t/* Set termios */\n\tcypress_send(port);\n\n\tif (tty)\n\t\tcypress_set_termios(tty, port, &amp;priv-&gt;tmp_termios);\n\n\t/* setup the port and start reading from the device */\n\tif (!port-&gt;interrupt_in_urb) {\n\t\tdev_err(&amp;port-&gt;dev, "%s - interrupt_in_urb is empty!\\n",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n\n\tusb_fill_int_urb(port-&gt;interrupt_in_urb, serial-&gt;dev,\n\t\tusb_rcvintpipe(serial-&gt;dev, port-&gt;interrupt_in_endpointAddress),\n\t\tport-&gt;interrupt_in_urb-&gt;transfer_buffer,\n\t\tport-&gt;interrupt_in_urb-&gt;transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv-&gt;read_urb_interval);\n\tresult = usb_submit_urb(port-&gt;interrupt_in_urb, GFP_KERNEL);\n\n\tif (result) {\n\t\tdev_err(&amp;port-&gt;dev,\n\t\t\t"%s - failed submitting read urb, error %d\\n",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\n\treturn result;\n} /* cypress_open */',
 'get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt;\n\tstruct usb_host_endpoint\t*in, *out;\n\tstruct usb_host_endpoint\t*iso_in, *iso_out;\n\tstruct usb_host_endpoint\t*int_in, *int_out;\n\tstruct usb_device\t\t*udev;\n\n\tfor (tmp = 0; tmp &lt; intf-&gt;num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = NULL;\n\t\tiso_in = iso_out = NULL;\n\t\tint_in = int_out = NULL;\n\t\talt = intf-&gt;altsetting + tmp;\n\n\t\tif (override_alt &gt;= 0 &amp;&amp;\n\t\t\t\toverride_alt != alt-&gt;desc.bAlternateSetting)\n\t\t\tcontinue;\n\n\t\t/* take the first altsetting with in-bulk + out-bulk;\n\t\t * ignore other endpoints and altsettings.\n\t\t */\n\t\tfor (ep = 0; ep &lt; alt-&gt;desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint edi;\n\n\t\t\te = alt-&gt;endpoint + ep;\n\t\t\tedi = usb_endpoint_dir_in(&amp;e-&gt;desc);\n\n\t\t\tswitch (usb_endpoint_type(&amp;e-&gt;desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tendpoint_update(edi, &amp;in, &amp;out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (dev-&gt;info-&gt;intr)\n\t\t\t\t\tendpoint_update(edi, &amp;int_in, &amp;int_out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t\tif (dev-&gt;info-&gt;iso)\n\t\t\t\t\tendpoint_update(edi, &amp;iso_in, &amp;iso_out, e);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((in &amp;&amp; out)  ||  iso_in || iso_out || int_in || int_out)\n\t\t\tgoto found;\n\t}\n\treturn -EINVAL;\n\nfound:\n\tudev = testdev_to_usbdev(dev);\n\tdev-&gt;info-&gt;alt = alt-&gt;desc.bAlternateSetting;\n\tif (alt-&gt;desc.bAlternateSetting != 0) {\n\t\ttmp = usb_set_interface(udev,\n\t\t\t\talt-&gt;desc.bInterfaceNumber,\n\t\t\t\talt-&gt;desc.bAlternateSetting);\n\t\tif (tmp &lt; 0)\n\t\t\treturn tmp;\n\t}\n\n\tif (in) {\n\t\tdev-&gt;in_pipe = usb_rcvbulkpipe(udev,\n\t\t\tin-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);\n\t\tdev-&gt;out_pipe = usb_sndbulkpipe(udev,\n\t\t\tout-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);\n\t}\n\tif (iso_in) {\n\t\tdev-&gt;iso_in = &amp;iso_in-&gt;desc;\n\t\tdev-&gt;in_iso_pipe = usb_rcvisocpipe(udev,\n\t\t\t\tiso_in-&gt;desc.bEndpointAddress\n\t\t\t\t\t&amp; USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (iso_out) {\n\t\tdev-&gt;iso_out = &amp;iso_out-&gt;desc;\n\t\tdev-&gt;out_iso_pipe = usb_sndisocpipe(udev,\n\t\t\t\tiso_out-&gt;desc.bEndpointAddress\n\t\t\t\t\t&amp; USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_in) {\n\t\tdev-&gt;int_in = &amp;int_in-&gt;desc;\n\t\tdev-&gt;in_int_pipe = usb_rcvintpipe(udev,\n\t\t\t\tint_in-&gt;desc.bEndpointAddress\n\t\t\t\t\t&amp; USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_out) {\n\t\tdev-&gt;int_out = &amp;int_out-&gt;desc;\n\t\tdev-&gt;out_int_pipe = usb_sndintpipe(udev,\n\t\t\t\tint_out-&gt;desc.bEndpointAddress\n\t\t\t\t\t&amp; USB_ENDPOINT_NUMBER_MASK);\n\t}\n\treturn 0;\n}',
 'psf_bump_header_allocation (SF_PRIVATE * psf, sf_count_t needed)\n{\n\tsf_count_t newlen, smallest = INITAL_HEADER_SIZE ;\n\tvoid * ptr ;\n\n\tnewlen = (needed &gt; psf-&gt;header.len) ? 2 * SF_MAX (needed, smallest) : 2 * psf-&gt;header.len ;\n\n\tif (newlen &gt; 100 * 1024)\n\t{\tpsf_log_printf (psf, "Request for header allocation of %D denined.\\n", newlen) ;\n\t\treturn 1 ;\n\t\t}\n\n\tif ((ptr = realloc (psf-&gt;header.ptr, newlen)) == NULL)\n\t{\tpsf_log_printf (psf, "realloc (%p, %D) failed\\n", psf-&gt;header.ptr, newlen) ;\n\t\tpsf-&gt;error = SFE_MALLOC_FAILED ;\n\t\treturn 1 ;\n\t\t} ;\n\n\tpsf-&gt;header.ptr = ptr ;\n\tpsf-&gt;header.len = newlen ;\n\treturn 0 ;\n} /* psf_bump_header_allocation */',
 'static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tsize_t maxw, maxh, max, i;\n\tint offset, upb;\n\n\tupb = (int)img-&gt;comps[0].prec;\n\toffset = 1&lt;&lt;(upb - 1); upb = (1&lt;&lt;upb)-1;\n\n\tmaxw = (size_t)img-&gt;comps[0].w; maxh = (size_t)img-&gt;comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img-&gt;comps[0].data;\n\tcb = img-&gt;comps[1].data;\n\tcr = img-&gt;comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * max);\n\td1 = g = (int*)malloc(sizeof(int) * max);\n\td2 = b = (int*)malloc(sizeof(int) * max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\tfor(i = 0U; i &lt; max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img-&gt;comps[0].data); img-&gt;comps[0].data = d0;\n\tfree(img-&gt;comps[1].data); img-&gt;comps[1].data = d1;\n\tfree(img-&gt;comps[2].data); img-&gt;comps[2].data = d2;\n\timg-&gt;color_space = OPJ_CLRSPC_SRGB;\n\treturn;\n\nfails:\n\tfree(r);\n\tfree(g);\n\tfree(b);\n}/* sycc444_to_rgb() */',
 'sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\n\t/* Ultimate sanity check. */\n\tassert (sizeof (sf_count_t) == 8) ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf_log_printf (psf, "File : %s\\n", path) ;\n\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf-&gt;error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf-&gt;file.mode = mode ;\n\tif (strcmp (path, "-") == 0)\n\t\tpsf-&gt;error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf-&gt;error = psf_fopen (psf) ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open */',
 'PUBLIC MprKey *mprAddKey(MprHash *hash, cvoid *key, cvoid *ptr)\n{\n    MprKey      *sp, *prevSp;\n    int         index;\n\n    if (hash == 0) {\n        assert(hash);\n        return 0;\n    }\n    lock(hash);\n    if ((sp = lookupHash(&amp;index, &amp;prevSp, hash, key)) != 0) {\n        if (hash-&gt;flags &amp; MPR_HASH_UNIQUE) {\n            unlock(hash);\n            return 0;\n        }\n        /*\n            Already exists. Just update the data.\n         */\n        sp-&gt;data = ptr;\n        unlock(hash);\n        return sp;\n    }\n    /*\n        Hash entries are managed by manageHashTable\n     */\n    if ((sp = mprAllocStructNoZero(MprKey)) == 0) {\n        unlock(hash);\n        return 0;\n    }\n    sp-&gt;data = ptr;\n    if (!(hash-&gt;flags &amp; MPR_HASH_STATIC_KEYS)) {\n        sp-&gt;key = dupKey(hash, key);\n    } else {\n        sp-&gt;key = (void*) key;\n    }\n    sp-&gt;type = 0;\n    sp-&gt;bucket = index;\n    sp-&gt;next = hash-&gt;buckets[index];\n    hash-&gt;buckets[index] = sp;\n    hash-&gt;length++;\n    unlock(hash);\n    return sp;\n}',
 'string_object_to_c_ast(const char *s, PyObject *filename, int start,\n                             PyCompilerFlags *flags, int feature_version,\n                             PyArena *arena)\n{\n    mod_ty mod;\n    PyCompilerFlags localflags;\n    perrdetail err;\n    int iflags = PARSER_FLAGS(flags);\n    node *n;\n\n    if (feature_version &gt;= 7)\n        iflags |= PyPARSE_ASYNC_ALWAYS;\n    n = Ta3Parser_ParseStringObject(s, filename,\n                                    &amp;_Ta3Parser_Grammar, start, &amp;err,\n                                    &amp;iflags);\n    if (flags == NULL) {\n        localflags.cf_flags = 0;\n        flags = &amp;localflags;\n    }\n    if (n) {\n        flags-&gt;cf_flags |= iflags &amp; PyCF_MASK;\n        mod = Ta3AST_FromNodeObject(n, flags, filename, feature_version, arena);\n        Ta3Node_Free(n);\n    }\n    else {\n        err_input(&amp;err);\n        mod = NULL;\n    }\n    err_free(&amp;err);\n    return mod;\n}',
 'void pointZZ_pAdd(PointZZ_p * rop, const PointZZ_p * op1, const PointZZ_p * op2, const CurveZZ_p * curve) {\n    mpz_t xdiff, ydiff, lambda;\n    mpz_inits(xdiff, ydiff, lambda, NULL);\n\n    // calculate lambda\n    mpz_sub(ydiff, op2-&gt;y, op1-&gt;y);\n    mpz_sub(xdiff, op2-&gt;x, op1-&gt;x);\n    mpz_invert(xdiff, xdiff, curve-&gt;p);  // TODO check status\n    mpz_mul(lambda, ydiff, xdiff);\n    mpz_mod(lambda, lambda, curve-&gt;p);\n\n    // calculate resulting x coord\n    mpz_mul(rop-&gt;x, lambda, lambda);\n    mpz_sub(rop-&gt;x, rop-&gt;x, op1-&gt;x);\n    mpz_sub(rop-&gt;x, rop-&gt;x, op2-&gt;x);\n    mpz_mod(rop-&gt;x, rop-&gt;x, curve-&gt;p);\n\n    //calculate resulting y coord\n    mpz_sub(rop-&gt;y, op1-&gt;x, rop-&gt;x);\n    mpz_mul(rop-&gt;y, lambda, rop-&gt;y);\n    mpz_sub(rop-&gt;y, rop-&gt;y, op1-&gt;y);\n    mpz_mod(rop-&gt;y, rop-&gt;y, curve-&gt;p);\n\n    mpz_clears(xdiff, ydiff, lambda, NULL);\n}',
 'static bool php_mb_parse_encoding(const Variant&amp; encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list &amp;&amp; *return_list) {\n      req::free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}',
 'TfLiteStatus PrepareAny(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input-&gt;type, kTfLiteBool);\n  return PrepareSimple(context, node);\n}',
 '  void Compute(OpKernelContext* context) override {\n    // boxes: [num_boxes, 4]\n    const Tensor&amp; boxes = context-&gt;input(0);\n    // scores: [num_boxes]\n    const Tensor&amp; scores = context-&gt;input(1);\n    // max_output_size: scalar\n    const Tensor&amp; max_output_size = context-&gt;input(2);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(max_output_size.shape()),\n        errors::InvalidArgument("max_output_size must be 0-D, got shape ",\n                                max_output_size.shape().DebugString()));\n    // iou_threshold: scalar\n    const Tensor&amp; iou_threshold = context-&gt;input(3);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(iou_threshold.shape()),\n                errors::InvalidArgument("iou_threshold must be 0-D, got shape ",\n                                        iou_threshold.shape().DebugString()));\n    const T iou_threshold_val = iou_threshold.scalar&lt;T&gt;()();\n    OP_REQUIRES(context,\n                iou_threshold_val &gt;= static_cast&lt;T&gt;(0.0) &amp;&amp;\n                    iou_threshold_val &lt;= static_cast&lt;T&gt;(1.0),\n                errors::InvalidArgument("iou_threshold must be in [0, 1]"));\n    // score_threshold: scalar\n    const Tensor&amp; score_threshold = context-&gt;input(4);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(score_threshold.shape()),\n        errors::InvalidArgument("score_threshold must be 0-D, got shape ",\n                                score_threshold.shape().DebugString()));\n    const T score_threshold_val = score_threshold.scalar&lt;T&gt;()();\n\n    // soft_nms_sigma: scalar\n    const Tensor&amp; soft_nms_sigma = context-&gt;input(5);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(soft_nms_sigma.shape()),\n        errors::InvalidArgument("soft_nms_sigma must be 0-D, got shape ",\n                                soft_nms_sigma.shape().DebugString()));\n    const T soft_nms_sigma_val = soft_nms_sigma.scalar&lt;T&gt;()();\n    OP_REQUIRES(context, soft_nms_sigma_val &gt;= static_cast&lt;T&gt;(0.0),\n                errors::InvalidArgument("soft_nms_sigma_val must be &gt;= 0"));\n\n    int num_boxes = 0;\n    ParseAndCheckBoxSizes(context, boxes, &amp;num_boxes);\n    CheckScoreSizes(context, num_boxes, scores);\n    if (!context-&gt;status().ok()) {\n      return;\n    }\n\n    auto similarity_fn = CreateIOUSimilarityFn&lt;T&gt;(boxes);\n    int num_valid_outputs;\n\n    // For NonMaxSuppressionV5Op, we always return a second output holding\n    // corresponding scores, so `return_scores_tensor` should never be false.\n    const bool return_scores_tensor_ = true;\n    DoNonMaxSuppressionOp&lt;T&gt;(\n        context, scores, num_boxes, max_output_size, iou_threshold_val,\n        score_threshold_val, soft_nms_sigma_val, similarity_fn,\n        return_scores_tensor_, pad_to_max_output_size_, &amp;num_valid_outputs);\n    if (!context-&gt;status().ok()) {\n      return;\n    }\n\n    // Allocate scalar output tensor for number of indices computed.\n    Tensor* num_outputs_t = nullptr;\n    OP_REQUIRES_OK(context, context-&gt;allocate_output(\n                                2, tensorflow::TensorShape{} &amp;num_outputs_t));\n    num_outputs_t-&gt;scalar&lt;int32&gt;().setConstant(num_valid_outputs);\n  }',
 'static void prekey_handler(const char *userid,\n\t\t\t   const uint8_t *key, size_t key_len,\n\t\t\t   uint16_t id, const char *clientid,\n\t\t\t   bool last, void *arg)\n{\n\tstruct session *sess;\n\tchar lclientid[64];\n\tint err;\n\n\toutput("prekey_handler: %zu bytes, user:%s[%u] -&gt; %s\\n",\n\t       key_len, userid, id, clientid);\n\n\terr = client_id_load(lclientid, sizeof(lclientid));\n\tif (err) {\n\t\tdebug("my clientid not set -- cannot store prekeys\\n");\n\t\treturn;\n\t}\n\n\tsess = cryptobox_session_find(g_cryptobox, userid, clientid, lclientid);\n\tif (sess) {\n\t\toutput("prekey: session found\\n");\n\t}\n\telse {\n\t\tinfo("conv: adding key to cryptobox for clientid=%s\\n",\n\t\t     clientid);\n\n\t\terr = cryptobox_session_add_send(g_cryptobox, userid, clientid, lclientid,\n\t\t\t\t\t\t key, key_len);\n\t\tif (err) {\n\t\t\twarning("cryptobox_session_add_send failed (%m)\\n",\n\t\t\t\terr);\n\t\t}\n\t}\n\n\tif (last) {\n\t\toutput("prekey_handler: all prekeys fetched\\n");\n\t}\n}',
 'static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt-&gt;ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\n\t/* inject #GP if in real mode or Virtual 8086 mode */\n\tif (ctxt-&gt;mode == X86EMUL_MODE_REAL ||\n\t    ctxt-&gt;mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tsetup_syscalls_segments(ctxt, &amp;cs, &amp;ss);\n\n\tif ((ctxt-&gt;rex_prefix &amp; 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops-&gt;get_msr(ctxt, MSR_IA32_SYSENTER_CS, &amp;msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data &amp; 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tbreak;\n\t}\n\tcs_sel |= SELECTOR_RPL_MASK;\n\tss_sel |= SELECTOR_RPL_MASK;\n\n\tops-&gt;set_segment(ctxt, cs_sel, &amp;cs, 0, VCPU_SREG_CS);\n\tops-&gt;set_segment(ctxt, ss_sel, &amp;ss, 0, VCPU_SREG_SS);\n\n\tctxt-&gt;_eip = reg_read(ctxt, VCPU_REGS_RDX);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = reg_read(ctxt, VCPU_REGS_RCX);\n\n\treturn X86EMUL_CONTINUE;\n}',
 'SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    "Error: SQL_INVALID_HANDLE" );\n\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -&gt; msg, "\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -&gt; msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -&gt; connection -&gt; state &lt; STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                "Error: HY010" );\n\n        __post_internal_error( &amp;descriptor -&gt; error,\n                ERROR_HY010, NULL,\n                descriptor -&gt; connection -&gt; environment -&gt; requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                "Error: HY010" );\n\n        __post_internal_error( &amp;descriptor -&gt; error,\n                ERROR_HY010, NULL,\n                descriptor -&gt; connection -&gt; environment -&gt; requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n\n    if ( rec_number &lt; 0 )\n    {\n        __post_internal_error( &amp;descriptor -&gt; error,\n                ERROR_07009, NULL,\n                descriptor -&gt; connection -&gt; environment -&gt; requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER &amp;&amp; buffer_length != SQL_IS_INTEGER\n            &amp;&amp; buffer_length != SQL_IS_UINTEGER &amp;&amp; buffer_length != SQL_IS_SMALLINT &amp;&amp;\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField &amp;&amp; buffer_length &lt; 0 &amp;&amp; buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &amp;descriptor -&gt; error,\n            ERROR_HY090, NULL,\n            descriptor -&gt; connection -&gt; environment -&gt; requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_COUNT &amp;&amp; (SQLINTEGER)value &lt; 0 )\n    {\n        __post_internal_error( &amp;descriptor -&gt; error,\n                ERROR_07009, NULL,\n                descriptor -&gt; connection -&gt; environment -&gt; requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n    \n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE &amp;&amp; value != SQL_PARAM_INPUT\n        &amp;&amp; value != SQL_PARAM_OUTPUT &amp;&amp; value != SQL_PARAM_INPUT_OUTPUT &amp;&amp;\n        value != SQL_PARAM_INPUT_OUTPUT_STREAM &amp;&amp; value != SQL_PARAM_OUTPUT_STREAM )\n    {\n        __post_internal_error( &amp;descriptor -&gt; error,\n                ERROR_HY105, NULL,\n                descriptor -&gt; connection -&gt; environment -&gt; requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( CHECK_SQLSETDESCFIELD( descriptor -&gt; connection ))\n    {\n      ret = SQLSETDESCFIELD( descriptor -&gt; connection,\n              descriptor -&gt; driver_desc,\n              rec_number, \n              field_identifier,\n              value, \n              buffer_length );\n    }\n    else if ( CHECK_SQLSETDESCFIELDW( descriptor -&gt; connection ))\n    {\n      SQLWCHAR *s1 = NULL;\n\n        if (isStrField)\n      {\n        s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -&gt; connection, NULL );\n            if (SQL_NTS != buffer_length)\n            {\n                buffer_length *= sizeof(SQLWCHAR);\n            }\n      }\n      else\n      {\n              s1 = value;\n      }\n      ret = SQLSETDESCFIELDW( descriptor -&gt; connection,\n                descriptor -&gt; driver_desc,\n                rec_number, \n                field_identifier,\n                s1, \n                buffer_length );\n       \n        if (isStrField)\n       {\n        if (s1)\n          free(s1); \n       }\n    }\n    else \n\t{\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                "Error: IM001" );\n\n        __post_internal_error( &amp;descriptor -&gt; error,\n                ERROR_IM001, NULL,\n                descriptor -&gt; connection -&gt; environment -&gt; requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -&gt; msg, \n                "\\n\\t\\tExit:[%s]",\n                    __get_return_status( ret, s1 ));\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -&gt; msg );\n    }\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}',
 'static void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci_i, lci_o;\n\n\twhile ((skb = skb_dequeue(&amp;loopback_queue)) != NULL) {\n\t\tlci_i     = ((skb-&gt;data[0] &lt;&lt; 8) &amp; 0xF00) + ((skb-&gt;data[1] &lt;&lt; 0) &amp; 0x0FF);\n\t\tframetype = skb-&gt;data[2];\n\t\tdest      = (rose_address *)(skb-&gt;data + 4);\n\t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n\n\t\tskb_reset_transport_header(skb);\n\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}',
 'R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr-&gt;type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr-&gt;info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr-&gt;info.line_number_table_attr.line_number_table = r_list_newf (free);\n\n\tut32 linenum_len = attr-&gt;info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr-&gt;info.line_number_table_attr.line_number_table;\n\tif (linenum_len &gt; sz) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i &lt; linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\t// printf ("%llx %llx \\n", curpos, sz);\n\t\t// XXX if (curpos + 8 &gt;= sz) break;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr-&gt;start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr-&gt;line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr-&gt;file_offset = curpos;\n\t\tlnattr-&gt;size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr-&gt;size = offset;\n\treturn attr;\n}',
 'void HeaderTable::setCapacity(uint32_t capacity) {\n  // TODO: ddmello - the below is a little dangerous as we update the\n  // capacity right away.  Some properties of the class utilize that variable\n  // and so might be better to refactor and update capacity at the end of the\n  // method (and update other methods)\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ == oldCapacity) {\n    return;\n  } else if (capacity_ &lt; oldCapacity) {\n    // NOTE: currently no actual resizing is performed...\n    evict(0);\n  } else {\n    // NOTE: due to the above lack of resizing, we must determine whether a\n    // resize is actually appropriate (to handle cases where the underlying\n    // vector is still &gt;= to the size related to the new capacity requested)\n    uint32_t newLength = (capacity_ &gt;&gt; 5) + 1;\n    if (newLength &gt; table_.size()) {\n      auto oldTail = tail();\n      auto oldLength = table_.size();\n      table_.resize(newLength);\n      if (size_ &gt; 0 &amp;&amp; oldTail &gt; head_) {\n        // the list wrapped around, need to move oldTail..oldLength to the end\n        // of the now-larger table_\n        std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                  table_.begin() + newLength - (oldLength - oldTail));\n        // Update the names indecies that pointed to the old range\n        for (auto&amp; names_it: names_) {\n          for (auto&amp; idx: names_it.second) {\n            if (idx &gt;= oldTail) {\n              DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n              idx += (table_.size() - oldLength);\n            } else {\n              // remaining indecies in the list were smaller than oldTail, so\n              // should be indexed from 0\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n}',
 "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast&lt;TfLiteConcatenationParams*&gt;(node-&gt;builtin_data);\n  int axis = params-&gt;axis;\n  int num_inputs = node-&gt;inputs-&gt;size;\n\n  // The number of dimensions of the input tensors must match, and all\n  // dimensions except 'axis' must be equal.\n  const TfLiteTensor* t0;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &amp;t0));\n  TfLiteType input_type = t0-&gt;type;\n  if (axis &lt; 0) axis += t0-&gt;dims-&gt;size;\n  TF_LITE_ENSURE(context, axis &gt;= 0);\n  TF_LITE_ENSURE(context, axis &lt; t0-&gt;dims-&gt;size);\n\n  TF_LITE_ENSURE_EQ(context, params-&gt;activation, kTfLiteActNone);\n  TF_LITE_ENSURE(context,\n                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                     input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||\n                     input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ||\n                     input_type == kTfLiteBool);\n\n  // Output dimensions will match input dimensions, except 'axis', which\n  // will be the sum of inputs\n  int sum_axis = t0-&gt;dims-&gt;data[axis];\n  for (int i = 1; i &lt; num_inputs; ++i) {\n    const TfLiteTensor* t;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &amp;t));\n    TF_LITE_ENSURE_EQ(context, t-&gt;dims-&gt;size, t0-&gt;dims-&gt;size);\n    TF_LITE_ENSURE_EQ(context, t-&gt;type, input_type);\n    for (int d = 0; d &lt; t0-&gt;dims-&gt;size; ++d) {\n      if (d == axis) {\n        // Avoid integer overflow in sum_axis below\n        TF_LITE_ENSURE(context, t-&gt;dims-&gt;data[axis] &gt;= 0);\n        TF_LITE_ENSURE(context, t-&gt;dims-&gt;data[axis] &lt;=\n                                    std::numeric_limits&lt;int&gt;::max() - sum_axis);\n        sum_axis += t-&gt;dims-&gt;data[axis];\n      } else {\n        TF_LITE_ENSURE_EQ(context, t-&gt;dims-&gt;data[d], t0-&gt;dims-&gt;data[d]);\n      }\n    }\n  }\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(t0-&gt;dims-&gt;size);\n  for (int d = 0; d &lt; t0-&gt;dims-&gt;size; ++d) {\n    output_size-&gt;data[d] = (d == axis) ? sum_axis : t0-&gt;dims-&gt;data[d];\n  }\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &amp;output));\n  TF_LITE_ENSURE_TYPES_EQ(context, output-&gt;type, input_type);\n\n  if (input_type == kTfLiteInt8) {\n    // Make sure there is no re-scaling needed for Int8 quantized kernel. This\n    // is a restriction we introduced to Int8 kernels.\n    VectorOfTensors&lt;int8_t&gt; all_inputs(*context, *node-&gt;inputs);\n    for (int i = 0; i &lt; node-&gt;inputs-&gt;size; ++i) {\n      const TfLiteTensor* t;\n      TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &amp;t));\n      TF_LITE_ENSURE_EQ(context, t-&gt;params.scale, output-&gt;params.scale);\n      TF_LITE_ENSURE_EQ(context, t-&gt;params.zero_point,\n                        output-&gt;params.zero_point);\n    }\n  }\n\n  if (input_type == kTfLiteInt16) {\n    // Make sure that all Int16 inputs have a null zero-point.\n    for (int i = 0; i &lt; node-&gt;inputs-&gt;size; ++i) {\n      const TfLiteTensor* t = GetInput(context, node, i);\n      TF_LITE_ENSURE_EQ(context, t-&gt;params.zero_point, 0);\n    }\n    TF_LITE_ENSURE_EQ(context, output-&gt;params.zero_point, 0);\n  }\n\n  return context-&gt;ResizeTensor(context, output, output_size);\n}",
 'static void Sp_split_regexp(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint limit, len, k;\n\tconst char *p, *a, *b, *c, *e;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\tre = js_toregexp(J, 1);\n\tlimit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 &lt;&lt; 30;\n\n\tjs_newarray(J);\n\tlen = 0;\n\n\te = text + strlen(text);\n\n\t/* splitting the empty string */\n\tif (e == text) {\n\t\tif (js_doregexec(J, re-&gt;prog, text, &amp;m, 0)) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushliteral(J, "");\n\t\t\tjs_setindex(J, -2, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tp = a = text;\n\twhile (a &lt; e) {\n\t\tif (js_doregexec(J, re-&gt;prog, a, &amp;m, a &gt; text ? REG_NOTBOL : 0))\n\t\t\tbreak; /* no match */\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\n\t\t/* empty string at end of last match */\n\t\tif (b == p) {\n\t\t\t++a;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (len == limit) return;\n\t\tjs_pushlstring(J, p, b - p);\n\t\tjs_setindex(J, -2, len++);\n\n\t\tfor (k = 1; k &lt; m.nsub; ++k) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);\n\t\t\tjs_setindex(J, -2, len++);\n\t\t}\n\n\t\ta = p = c;\n\t}\n\n\tif (len == limit) return;\n\tjs_pushstring(J, p);\n\tjs_setindex(J, -2, len);\n}',
 'void mutt_socket_empty(struct Connection *conn)\n{\n  if (!conn)\n    return;\n\n  char buf[1024];\n  int bytes;\n\n  while ((bytes = mutt_socket_poll(conn, 0)) &gt; 0)\n  {\n    mutt_socket_read(conn, buf, MIN(bytes, sizeof(buf)));\n  }\n}',
 'static int lookupName(\n  Parse *pParse,       /* The parsing context */\n  const char *zDb,     /* Name of the database containing table, or NULL */\n  const char *zTab,    /* Name of table containing column, or NULL */\n  const char *zCol,    /* Name of the column. */\n  NameContext *pNC,    /* The name context used to resolve the name */\n  Expr *pExpr          /* Make this EXPR node point to the selected column */\n){\n  int i, j;                         /* Loop counters */\n  int cnt = 0;                      /* Number of matching column names */\n  int cntTab = 0;                   /* Number of matching table names */\n  int nSubquery = 0;                /* How many levels of subquery */\n  sqlite3 *db = pParse-&gt;db;         /* The database connection */\n  struct SrcList_item *pItem;       /* Use for looping over pSrcList items */\n  struct SrcList_item *pMatch = 0;  /* The matching pSrcList item */\n  NameContext *pTopNC = pNC;        /* First namecontext in the list */\n  Schema *pSchema = 0;              /* Schema of the expression */\n  int eNewExprOp = TK_COLUMN;       /* New value for pExpr-&gt;op on success */\n  Table *pTab = 0;                  /* Table hold the row */\n  Column *pCol;                     /* A column of pTab */\n\n  assert( pNC );     /* the name context cannot be NULL. */\n  assert( zCol );    /* The Z in X.Y.Z cannot be NULL */\n  assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n\n  /* Initialize the node to no-match */\n  pExpr-&gt;iTable = -1;\n  ExprSetVVAProperty(pExpr, EP_NoReduce);\n\n  /* Translate the schema name in zDb into a pointer to the corresponding\n  ** schema.  If not found, pSchema will remain NULL and nothing will match\n  ** resulting in an appropriate error message toward the end of this routine\n  */\n  if( zDb ){\n    testcase( pNC-&gt;ncFlags &amp; NC_PartIdx );\n    testcase( pNC-&gt;ncFlags &amp; NC_IsCheck );\n    if( (pNC-&gt;ncFlags &amp; (NC_PartIdx|NC_IsCheck))!=0 ){\n      /* Silently ignore database qualifiers inside CHECK constraints and\n      ** partial indices.  Do not raise errors because that might break\n      ** legacy and because it does not hurt anything to just ignore the\n      ** database name. */\n      zDb = 0;\n    }else{\n      for(i=0; i&lt;db-&gt;nDb; i++){\n        assert( db-&gt;aDb[i].zDbSName );\n        if( sqlite3StrICmp(db-&gt;aDb[i].zDbSName,zDb)==0 ){\n          pSchema = db-&gt;aDb[i].pSchema;\n          break;\n        }\n      }\n    }\n  }\n\n  /* Start at the inner-most context and move outward until a match is found */\n  assert( pNC &amp;&amp; cnt==0 );\n  do{\n    ExprList *pEList;\n    SrcList *pSrcList = pNC-&gt;pSrcList;\n\n    if( pSrcList ){\n      for(i=0, pItem=pSrcList-&gt;a; i&lt;pSrcList-&gt;nSrc; i++, pItem++){\n        pTab = pItem-&gt;pTab;\n        assert( pTab!=0 &amp;&amp; pTab-&gt;zName!=0 );\n        assert( pTab-&gt;nCol&gt;0 );\n        if( pItem-&gt;pSelect &amp;&amp; (pItem-&gt;pSelect-&gt;selFlags &amp; SF_NestedFrom)!=0 ){\n          int hit = 0;\n          pEList = pItem-&gt;pSelect-&gt;pEList;\n          for(j=0; j&lt;pEList-&gt;nExpr; j++){\n            if( sqlite3MatchSpanName(pEList-&gt;a[j].zSpan, zCol, zTab, zDb) ){\n              cnt++;\n              cntTab = 2;\n              pMatch = pItem;\n              pExpr-&gt;iColumn = j;\n              hit = 1;\n            }\n          }\n          if( hit || zTab==0 ) continue;\n        }\n        if( zDb &amp;&amp; pTab-&gt;pSchema!=pSchema ){\n          continue;\n        }\n        if( zTab ){\n          const char *zTabName = pItem-&gt;zAlias ? pItem-&gt;zAlias : pTab-&gt;zName;\n          assert( zTabName!=0 );\n          if( sqlite3StrICmp(zTabName, zTab)!=0 ){\n            continue;\n          }\n          if( IN_RENAME_OBJECT &amp;&amp; pItem-&gt;zAlias ){\n            sqlite3RenameTokenRemap(pParse, 0, (void*)&amp;pExpr-&gt;y.pTab);\n          }\n        }\n        if( 0==(cntTab++) ){\n          pMatch = pItem;\n        }\n        for(j=0, pCol=pTab-&gt;aCol; j&lt;pTab-&gt;nCol; j++, pCol++){\n          if( sqlite3StrICmp(pCol-&gt;zName, zCol)==0 ){\n            /* If there has been exactly one prior match and this match\n            ** is for the right-hand table of a NATURAL JOIN or is in a \n            ** USING clause, then skip this match.\n            */\n            if( cnt==1 ){\n              if( pItem-&gt;fg.jointype &amp; JT_NATURAL ) continue;\n              if( nameInUsingClause(pItem-&gt;pUsing, zCol) ) continue;\n            }\n            cnt++;\n            pMatch = pItem;\n            /* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY */\n            pExpr-&gt;iColumn = j==pTab-&gt;iPKey ? -1 : (i16)j;\n            break;\n          }\n        }\n      }\n      if( pMatch ){\n        pExpr-&gt;iTable = pMatch-&gt;iCursor;\n        pExpr-&gt;y.pTab = pMatch-&gt;pTab;\n        /* RIGHT JOIN not (yet) supported */\n        assert( (pMatch-&gt;fg.jointype &amp; JT_RIGHT)==0 );\n        if( (pMatch-&gt;fg.jointype &amp; JT_LEFT)!=0 ){\n          ExprSetProperty(pExpr, EP_CanBeNull);\n        }\n        pSchema = pExpr-&gt;y.pTab-&gt;pSchema;\n      }\n    } /* if( pSrcList ) */\n\n#if !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT)\n    /* If we have not already resolved the name, then maybe \n    ** it is a new.* or old.* trigger argument reference.  Or\n    ** maybe it is an excluded.* from an upsert.\n    */\n    if( zDb==0 &amp;&amp; zTab!=0 &amp;&amp; cntTab==0 ){\n      pTab = 0;\n#ifndef SQLITE_OMIT_TRIGGER\n      if( pParse-&gt;pTriggerTab!=0 ){\n        int op = pParse-&gt;eTriggerOp;\n        assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );\n        if( op!=TK_DELETE &amp;&amp; sqlite3StrICmp("new",zTab) == 0 ){\n          pExpr-&gt;iTable = 1;\n          pTab = pParse-&gt;pTriggerTab;\n        }else if( op!=TK_INSERT &amp;&amp; sqlite3StrICmp("old",zTab)==0 ){\n          pExpr-&gt;iTable = 0;\n          pTab = pParse-&gt;pTriggerTab;\n        }\n      }\n#endif /* SQLITE_OMIT_TRIGGER */\n#ifndef SQLITE_OMIT_UPSERT\n      if( (pNC-&gt;ncFlags &amp; NC_UUpsert)!=0 ){\n        Upsert *pUpsert = pNC-&gt;uNC.pUpsert;\n        if( pUpsert &amp;&amp; sqlite3StrICmp("excluded",zTab)==0 ){\n          pTab = pUpsert-&gt;pUpsertSrc-&gt;a[0].pTab;\n          pExpr-&gt;iTable = 2;\n        }\n      }\n#endif /* SQLITE_OMIT_UPSERT */\n\n      if( pTab ){ \n        int iCol;\n        pSchema = pTab-&gt;pSchema;\n        cntTab++;\n        for(iCol=0, pCol=pTab-&gt;aCol; iCol&lt;pTab-&gt;nCol; iCol++, pCol++){\n          if( sqlite3StrICmp(pCol-&gt;zName, zCol)==0 ){\n            if( iCol==pTab-&gt;iPKey ){\n              iCol = -1;\n            }\n            break;\n          }\n        }\n        if( iCol&gt;=pTab-&gt;nCol &amp;&amp; sqlite3IsRowid(zCol) &amp;&amp; VisibleRowid(pTab) ){\n          /* IMP: R-51414-32910 */\n          iCol = -1;\n        }\n        if( iCol&lt;pTab-&gt;nCol ){\n          cnt++;\n#ifndef SQLITE_OMIT_UPSERT\n          if( pExpr-&gt;iTable==2 ){\n            testcase( iCol==(-1) );\n            if( IN_RENAME_OBJECT ){\n              pExpr-&gt;iColumn = iCol;\n              pExpr-&gt;y.pTab = pTab;\n              eNewExprOp = TK_COLUMN;\n            }else{\n              pExpr-&gt;iTable = pNC-&gt;uNC.pUpsert-&gt;regData + iCol;\n              eNewExprOp = TK_REGISTER;\n              ExprSetProperty(pExpr, EP_Alias);\n            }\n          }else\n#endif /* SQLITE_OMIT_UPSERT */\n          {\n#ifndef SQLITE_OMIT_TRIGGER\n            if( iCol&lt;0 ){\n              pExpr-&gt;affExpr = SQLITE_AFF_INTEGER;\n            }else if( pExpr-&gt;iTable==0 ){\n              testcase( iCol==31 );\n              testcase( iCol==32 );\n              pParse-&gt;oldmask |= (iCol&gt;=32 ? 0xffffffff : (((u32)1)&lt;&lt;iCol));\n            }else{\n              testcase( iCol==31 );\n              testcase( iCol==32 );\n              pParse-&gt;newmask |= (iCol&gt;=32 ? 0xffffffff : (((u32)1)&lt;&lt;iCol));\n            }\n            pExpr-&gt;y.pTab = pTab;\n            pExpr-&gt;iColumn = (i16)iCol;\n            eNewExprOp = TK_TRIGGER;\n#endif /* SQLITE_OMIT_TRIGGER */\n          }\n        }\n      }\n    }\n#endif /* !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT) */\n\n    /*\n    ** Perhaps the name is a reference to the ROWID\n    */\n    if( cnt==0\n     &amp;&amp; cntTab==1\n     &amp;&amp; pMatch\n     &amp;&amp; (pNC-&gt;ncFlags &amp; (NC_IdxExpr|NC_GenCol))==0\n     &amp;&amp; sqlite3IsRowid(zCol)\n     &amp;&amp; VisibleRowid(pMatch-&gt;pTab)\n    ){\n      cnt = 1;\n      pExpr-&gt;iColumn = -1;\n      pExpr-&gt;affExpr = SQLITE_AFF_INTEGER;\n    }\n\n    /*\n    ** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z\n    ** might refer to an result-set alias.  This happens, for example, when\n    ** we are resolving names in the WHERE clause of the following command:\n    **\n    **     SELECT a+b AS x FROM table WHERE x&lt;10;\n    **\n    ** In cases like this, replace pExpr with a copy of the expression that\n    ** forms the result set entry ("a+b" in the example) and return immediately.\n    ** Note that the expression in the result set should have already been\n    ** resolved by the time the WHERE clause is resolved.\n    **\n    ** The ability to use an output result-set column in the WHERE, GROUP BY,\n    ** or HAVING clauses, or as part of a larger expression in the ORDER BY\n    ** clause is not standard SQL.  This is a (goofy) SQLite extension, that\n    ** is supported for backwards compatibility only. Hence, we issue a warning\n    ** on sqlite3_log() whenever the capability is used.\n    */\n    if( (pNC-&gt;ncFlags &amp; NC_UEList)!=0\n     &amp;&amp; cnt==0\n     &amp;&amp; zTab==0\n    ){\n      pEList = pNC-&gt;uNC.pEList;\n      assert( pEList!=0 );\n      for(j=0; j&lt;pEList-&gt;nExpr; j++){\n        char *zAs = pEList-&gt;a[j].zName;\n        if( zAs!=0 &amp;&amp; sqlite3StrICmp(zAs, zCol)==0 ){\n          Expr *pOrig;\n          assert( pExpr-&gt;pLeft==0 &amp;&amp; pExpr-&gt;pRight==0 );\n          assert( pExpr-&gt;x.pList==0 );\n          assert( pExpr-&gt;x.pSelect==0 );\n          pOrig = pEList-&gt;a[j].pExpr;\n          if( (pNC-&gt;ncFlags&amp;NC_AllowAgg)==0 &amp;&amp; ExprHasProperty(pOrig, EP_Agg) ){\n            sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);\n            return WRC_Abort;\n          }\n          if( (pNC-&gt;ncFlags&amp;NC_AllowWin)==0 &amp;&amp; ExprHasProperty(pOrig, EP_Win) ){\n            sqlite3ErrorMsg(pParse, "misuse of aliased window function %s",zAs);\n            return WRC_Abort;\n          }\n          if( sqlite3ExprVectorSize(pOrig)!=1 ){\n            sqlite3ErrorMsg(pParse, "row value misused");\n            return WRC_Abort;\n          }\n          resolveAlias(pParse, pEList, j, pExpr, "", nSubquery);\n          cnt = 1;\n          pMatch = 0;\n          assert( zTab==0 &amp;&amp; zDb==0 );\n          if( IN_RENAME_OBJECT ){\n            sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);\n          }\n          goto lookupname_end;\n        }\n      } \n    }\n\n    /* Advance to the next name context.  The loop will exit when either\n    ** we have a match (cnt&gt;0) or when we run out of name contexts.\n    */\n    if( cnt ) break;\n    pNC = pNC-&gt;pNext;\n    nSubquery++;\n  }while( pNC );\n\n\n  /*\n  ** If X and Y are NULL (in other words if only the column name Z is\n  ** supplied) and the value of Z is enclosed in double-quotes, then\n  ** Z is a string literal if it doesn\'t match any column names.  In that\n  ** case, we need to return right away and not make any changes to\n  ** pExpr.\n  **\n  ** Because no reference was made to outer contexts, the pNC-&gt;nRef\n  ** fields are not changed in any context.\n  */\n  if( cnt==0 &amp;&amp; zTab==0 ){\n    assert( pExpr-&gt;op==TK_ID );\n    if( ExprHasProperty(pExpr,EP_DblQuoted)\n     &amp;&amp; areDoubleQuotedStringsEnabled(db, pTopNC)\n    ){\n      /* If a double-quoted identifier does not match any known column name,\n      ** then treat it as a string.\n      **\n      ** This hack was added in the early days of SQLite in a misguided attempt\n      ** to be compatible with MySQL 3.x, which used double-quotes for strings.\n      ** I now sorely regret putting in this hack. The effect of this hack is\n      ** that misspelled identifier names are silently converted into strings\n      ** rather than causing an error, to the frustration of countless\n      ** programmers. To all those frustrated programmers, my apologies.\n      **\n      ** Someday, I hope to get rid of this hack. Unfortunately there is\n      ** a huge amount of legacy SQL that uses it. So for now, we just\n      ** issue a warning.\n      */\n      sqlite3_log(SQLITE_WARNING,\n        "double-quoted string literal: \\"%w\\"", zCol);\n#ifdef SQLITE_ENABLE_NORMALIZE\n      sqlite3VdbeAddDblquoteStr(db, pParse-&gt;pVdbe, zCol);\n#endif\n      pExpr-&gt;op = TK_STRING;\n      pExpr-&gt;y.pTab = 0;\n      return WRC_Prune;\n    }\n    if( sqlite3ExprIdToTrueFalse(pExpr) ){\n      return WRC_Prune;\n    }\n  }\n\n  /*\n  ** cnt==0 means there was not match.  cnt&gt;1 means there were two or\n  ** more matches.  Either way, we have an error.\n  */\n  if( cnt!=1 ){\n    const char *zErr;\n    zErr = cnt==0 ? "no such column" : "ambiguous column name";\n    if( zDb ){\n      sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);\n    }else if( zTab ){\n      sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);\n    }else{\n      sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);\n    }\n    pParse-&gt;checkSchema = 1;\n    pTopNC-&gt;nErr++;\n  }\n\n  /* If a column from a table in pSrcList is referenced, then record\n  ** this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes\n  ** bit 0 to be set.  Column 1 sets bit 1.  And so forth.\n  **\n  ** The colUsed mask is an optimization used to help determine if an\n  ** index is a covering index.  The correct answer is still obtained\n  ** if the mask contains extra bits.  But omitting bits from the mask\n  ** might result in an incorrect answer.\n  **\n  ** The high-order bit of the mask is a "we-use-them-all" bit.\n  ** If the column number is greater than the number of bits in the bitmask\n  ** then set the high-order bit of the bitmask.  Also set the high-order\n  ** bit if the column is a generated column, as that adds dependencies\n  ** that are difficult to track, so we assume that all columns are used.\n  */\n  if( pExpr-&gt;iColumn&gt;=0 &amp;&amp; pMatch!=0 ){\n    int n = pExpr-&gt;iColumn;\n    testcase( n==BMS-1 );\n    if( n&gt;=BMS ){\n      n = BMS-1;\n    }\n    assert( pExpr-&gt;y.pTab!=0 );\n    assert( pMatch-&gt;iCursor==pExpr-&gt;iTable );\n    if( pExpr-&gt;y.pTab-&gt;tabFlags &amp; TF_HasGenerated ){\n      Column *pCol = pExpr-&gt;y.pTab-&gt;aCol + pExpr-&gt;iColumn;\n      if( pCol-&gt;colFlags &amp; COLFLAG_GENERATED ) n = BMS-1;\n    }\n    pMatch-&gt;colUsed |= ((Bitmask)1)&lt;&lt;n;\n  }\n\n  /* Clean up and return\n  */\n  sqlite3ExprDelete(db, pExpr-&gt;pLeft);\n  pExpr-&gt;pLeft = 0;\n  sqlite3ExprDelete(db, pExpr-&gt;pRight);\n  pExpr-&gt;pRight = 0;\n  pExpr-&gt;op = eNewExprOp;\n  ExprSetProperty(pExpr, EP_Leaf);\nlookupname_end:\n  if( cnt==1 ){\n    assert( pNC!=0 );\n    if( !ExprHasProperty(pExpr, EP_Alias) ){\n      sqlite3AuthRead(pParse, pExpr, pSchema, pNC-&gt;pSrcList);\n    }\n    /* Increment the nRef value on all name contexts from TopNC up to\n    ** the point where the name matched. */\n    for(;;){\n      assert( pTopNC!=0 );\n      pTopNC-&gt;nRef++;\n      if( pTopNC==pNC ) break;\n      pTopNC = pTopNC-&gt;pNext;\n    }\n    return WRC_Prune;\n  } else {\n    return WRC_Abort;\n  }\n}',
 'initpyfribidi (void)\n{\n\tPyObject *module;\n\n\t/* XXX What should be done if we fail here? */\n\n\tmodule = Py_InitModule3 ("pyfribidi", PyfribidiMethods,\n\t\t\t\t _pyfribidi__doc__);\n\n\tPyModule_AddIntConstant (module, "RTL", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, "LTR", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, "ON", (long) FRIBIDI_TYPE_ON);\n\n\tPyModule_AddStringConstant (module, "__author__",\n\t\t\t\t    "Yaacov Zamir and Nir Soffer");\n}',
 'int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n\n    while (*data != AMF_DATA_TYPE_OBJECT &amp;&amp; data &lt; data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len &lt; 0)\n            len = data_end - data;\n        data += len;\n    }\n    if (data_end - data &lt; 3)\n        return -1;\n    data++;\n    for (;;) {\n        int size = bytestream_get_be16(&amp;data);\n        if (!size)\n            break;\n        if (size &lt; 0 || size &gt;= data_end - data)\n            return -1;\n        data += size;\n        if (size == namelen &amp;&amp; !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, "%g", av_int2double(AV_RB64(data)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, "%s", *data ? "true" : "false");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&amp;data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = ff_amf_tag_size(data, data_end);\n        if (len &lt; 0 || len &gt;= data_end - data)\n            return -1;\n        data += len;\n    }\n    return -1;\n}',
 "\tCmdResult Handle (const std::vector&lt;std::string&gt;&amp; parameters, User *user)\n\t{\n\t\t/* Only allow AUTHENTICATE on unregistered clients */\n\t\tif (user-&gt;registered != REG_ALL)\n\t\t{\n\t\t\tif (!cap.ext.get(user))\n\t\t\t\treturn CMD_FAILURE;\n\n\t\t\tif (parameters[0].find(' ') != std::string::npos || parameters[0][0] == ':')\n\t\t\t\treturn CMD_FAILURE;\n\n\t\t\tSaslAuthenticator *sasl = authExt.get(user);\n\t\t\tif (!sasl)\n\t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0]));\n\t\t\telse if (sasl-&gt;SendClientMessage(parameters) == false)\t// IAL abort extension --nenolod\n\t\t\t{\n\t\t\t\tsasl-&gt;AnnounceState();\n\t\t\t\tauthExt.unset(user);\n\t\t\t}\n\t\t}\n\t\treturn CMD_FAILURE;\n\t}",
 'xfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the "old" attr\n\t */\n\terror = xfs_attr3_leaf_read(args-&gt;trans, args-&gt;dp, args-&gt;blkno, -1, &amp;bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the "new" attr, if it is different\n\t */\n\tif (args-&gt;blkno2 != args-&gt;blkno) {\n\t\terror = xfs_attr3_leaf_read(args-&gt;trans, args-&gt;dp, args-&gt;blkno2,\n\t\t\t\t\t   -1, &amp;bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1-&gt;b_addr;\n\tentry1 = &amp;xfs_attr3_leaf_entryp(leaf1)[args-&gt;index];\n\n\tleaf2 = bp2-&gt;b_addr;\n\tentry2 = &amp;xfs_attr3_leaf_entryp(leaf2)[args-&gt;index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&amp;ichdr1, leaf1);\n\tASSERT(args-&gt;index &lt; ichdr1.count);\n\tASSERT(args-&gt;index &gt;= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&amp;ichdr2, leaf2);\n\tASSERT(args-&gt;index2 &lt; ichdr2.count);\n\tASSERT(args-&gt;index2 &gt;= 0);\n\n\tif (entry1-&gt;flags &amp; XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args-&gt;index);\n\t\tnamelen1 = name_loc-&gt;namelen;\n\t\tname1 = (char *)name_loc-&gt;nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args-&gt;index);\n\t\tnamelen1 = name_rmt-&gt;namelen;\n\t\tname1 = (char *)name_rmt-&gt;name;\n\t}\n\tif (entry2-&gt;flags &amp; XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args-&gt;index2);\n\t\tnamelen2 = name_loc-&gt;namelen;\n\t\tname2 = (char *)name_loc-&gt;nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args-&gt;index2);\n\t\tnamelen2 = name_rmt-&gt;namelen;\n\t\tname2 = (char *)name_rmt-&gt;name;\n\t}\n\tASSERT(be32_to_cpu(entry1-&gt;hashval) == be32_to_cpu(entry2-&gt;hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1-&gt;flags &amp; XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2-&gt;flags &amp; XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1-&gt;flags &amp;= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args-&gt;trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args-&gt;rmtblkno) {\n\t\tASSERT((entry1-&gt;flags &amp; XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args-&gt;index);\n\t\tname_rmt-&gt;valueblk = cpu_to_be32(args-&gt;rmtblkno);\n\t\tname_rmt-&gt;valuelen = cpu_to_be32(args-&gt;rmtvaluelen);\n\t\txfs_trans_log_buf(args-&gt;trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2-&gt;flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args-&gt;trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2-&gt;flags &amp; XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args-&gt;index2);\n\t\tname_rmt-&gt;valueblk = 0;\n\t\tname_rmt-&gt;valuelen = 0;\n\t\txfs_trans_log_buf(args-&gt;trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&amp;args-&gt;trans, args-&gt;dp);\n\n\treturn error;\n}',
 'MOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print("%s\\n", "Initialization failed");\n        return MOBI_INIT_FAILED;\n    }\n    opf-&gt;metadata = calloc(1, sizeof(OPFmetadata));\n    if (opf-&gt;metadata == NULL) {\n        debug_print("%s\\n", "Memory allocation failed");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* initialize metadata sub-elements */\n    opf-&gt;metadata-&gt;meta = calloc(OPF_META_MAX_TAGS, sizeof(OPFmeta*));\n    if (opf-&gt;metadata-&gt;meta == NULL) {\n        debug_print("%s\\n", "Memory allocation failed");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf-&gt;metadata-&gt;dc_meta = calloc(1, sizeof(OPFdcmeta));\n    if (opf-&gt;metadata-&gt;dc_meta == NULL) {\n        debug_print("%s\\n", "Memory allocation failed");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf-&gt;metadata-&gt;x_meta = calloc(1, sizeof(OPFxmeta));\n    if (opf-&gt;metadata-&gt;x_meta == NULL) {\n        debug_print("%s\\n", "Memory allocation failed");\n        return MOBI_MALLOC_FAILED;\n    }\n    if (m-&gt;eh) {\n        MOBI_RET ret = mobi_get_opf_from_exth(opf-&gt;metadata, m);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    /* check for required elements */\n    if (opf-&gt;metadata-&gt;dc_meta-&gt;identifier == NULL) {\n        /* default id will be "0" */\n        char uid_string[11] = "0";\n        if (m-&gt;mh &amp;&amp; m-&gt;mh-&gt;uid) {\n            snprintf(uid_string, 11, "%u", *m-&gt;mh-&gt;uid);\n        }\n        mobi_opf_set_tagtype(OPFidentifier, opf-&gt;metadata-&gt;dc_meta-&gt;identifier, value, uid_string);\n        mobi_opf_set_tagtype(OPFidentifier, opf-&gt;metadata-&gt;dc_meta-&gt;identifier, id, "uid");\n    } else {\n        opf-&gt;metadata-&gt;dc_meta-&gt;identifier[0]-&gt;id = strdup("uid");\n    }\n    if (opf-&gt;metadata-&gt;dc_meta-&gt;title == NULL) {\n        opf-&gt;metadata-&gt;dc_meta-&gt;title = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf-&gt;metadata-&gt;dc_meta-&gt;title == NULL) {\n            debug_print("%s\\n", "Memory allocation failed");\n            return MOBI_MALLOC_FAILED;\n        }\n        char *title = mobi_meta_get_title(m);\n        if (title == NULL) {\n            title = strdup("Unknown");\n        }\n        opf-&gt;metadata-&gt;dc_meta-&gt;title[0] = title;\n    }\n    if (opf-&gt;metadata-&gt;dc_meta-&gt;language == NULL) {\n        opf-&gt;metadata-&gt;dc_meta-&gt;language = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf-&gt;metadata-&gt;dc_meta-&gt;language == NULL) {\n            debug_print("%s\\n", "Memory allocation failed");\n            return MOBI_MALLOC_FAILED;\n        }\n        const char *lang_string = NULL;\n        if (m-&gt;mh &amp;&amp; m-&gt;mh-&gt;locale) {\n            uint32_t lang_code = *m-&gt;mh-&gt;locale;\n            lang_string = mobi_get_locale_string(lang_code);\n        }\n        if (lang_string) {\n            opf-&gt;metadata-&gt;dc_meta-&gt;language[0] = strdup(lang_string);\n        } else {\n            opf-&gt;metadata-&gt;dc_meta-&gt;language[0] = strdup("en");\n        }\n    }\n    /* write optional elements */\n    if (mobi_is_dictionary(m)) {\n        if (opf-&gt;metadata-&gt;x_meta-&gt;dictionary_in_lang == NULL) {\n            if (m-&gt;mh &amp;&amp; m-&gt;mh-&gt;dict_input_lang) {\n                opf-&gt;metadata-&gt;x_meta-&gt;dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf-&gt;metadata-&gt;x_meta-&gt;dictionary_in_lang == NULL) {\n                    debug_print("%s\\n", "Memory allocation failed");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m-&gt;mh-&gt;dict_input_lang;\n                opf-&gt;metadata-&gt;x_meta-&gt;dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (opf-&gt;metadata-&gt;x_meta-&gt;dictionary_out_lang == NULL) {\n            if (m-&gt;mh &amp;&amp; m-&gt;mh-&gt;dict_output_lang) {\n                opf-&gt;metadata-&gt;x_meta-&gt;dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf-&gt;metadata-&gt;x_meta-&gt;dictionary_out_lang == NULL) {\n                    debug_print("%s\\n", "Memory allocation failed");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m-&gt;mh-&gt;dict_output_lang;\n                opf-&gt;metadata-&gt;x_meta-&gt;dictionary_out_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (rawml-&gt;orth-&gt;orth_index_name) {\n            opf-&gt;metadata-&gt;x_meta-&gt;default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf-&gt;metadata-&gt;x_meta-&gt;default_lookup_index == NULL) {\n                debug_print("%s\\n", "Memory allocation failed");\n                return MOBI_MALLOC_FAILED;\n            }\n            opf-&gt;metadata-&gt;x_meta-&gt;default_lookup_index[0] = strdup(rawml-&gt;orth-&gt;orth_index_name);\n        }\n    }\n    return MOBI_SUCCESS;\n}',
 'swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tuint32* wp = (uint32*) cp0;\n\ttmsize_t wc = cc / 4;\n\n        TIFFSwabArrayOfLong(wp, wc);\n\treturn horAcc32(tif, cp0, cc);\n}',
 "buf_copy_options(buf_T *buf, int flags)\n{\n    int\t\tshould_copy = TRUE;\n    char_u\t*save_p_isk = NULL;\t    // init for GCC\n    int\t\tdont_do_help;\n    int\t\tdid_isk = FALSE;\n\n    /*\n     * Skip this when the option defaults have not been set yet.  Happens when\n     * main() allocates the first buffer.\n     */\n    if (p_cpo != NULL)\n    {\n\t/*\n\t * Always copy when entering and 'cpo' contains 'S'.\n\t * Don't copy when already initialized.\n\t * Don't copy when 'cpo' contains 's' and not entering.\n\t * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n\t * yes\t  yes\t       X\t X\tTRUE\n\t * yes\t  no\t      yes\t X\tFALSE\n\t * no\t   X\t      yes\t X\tFALSE\n\t *  X\t  no\t      no\tyes\tFALSE\n\t *  X\t  no\t      no\tno\tTRUE\n\t * no\t  yes\t      no\t X\tTRUE\n\t */\n\tif ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags &amp; BCO_ENTER))\n\t\t&amp;&amp; (buf-&gt;b_p_initialized\n\t\t    || (!(flags &amp; BCO_ENTER)\n\t\t\t&amp;&amp; vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n\t    should_copy = FALSE;\n\n\tif (should_copy || (flags &amp; BCO_ALWAYS))\n\t{\n#ifdef FEAT_EVAL\n\t    CLEAR_FIELD(buf-&gt;b_p_script_ctx);\n\t    init_buf_opt_idx();\n#endif\n\t    // Don't copy the options specific to a help buffer when\n\t    // BCO_NOHELP is given or the options were initialized already\n\t    // (jumping back to a help file with CTRL-T or CTRL-O)\n\t    dont_do_help = ((flags &amp; BCO_NOHELP) &amp;&amp; buf-&gt;b_help)\n\t\t\t\t\t\t       || buf-&gt;b_p_initialized;\n\t    if (dont_do_help)\t\t// don't free b_p_isk\n\t    {\n\t\tsave_p_isk = buf-&gt;b_p_isk;\n\t\tbuf-&gt;b_p_isk = NULL;\n\t    }\n\t    /*\n\t     * Always free the allocated strings.  If not already initialized,\n\t     * reset 'readonly' and copy 'fileformat'.\n\t     */\n\t    if (!buf-&gt;b_p_initialized)\n\t    {\n\t\tfree_buf_options(buf, TRUE);\n\t\tbuf-&gt;b_p_ro = FALSE;\t\t// don't copy readonly\n\t\tbuf-&gt;b_p_tx = p_tx;\n\t\tbuf-&gt;b_p_fenc = vim_strsave(p_fenc);\n\t\tswitch (*p_ffs)\n\t\t{\n\t\t    case 'm':\n\t\t\tbuf-&gt;b_p_ff = vim_strsave((char_u *)FF_MAC); break;\n\t\t    case 'd':\n\t\t\tbuf-&gt;b_p_ff = vim_strsave((char_u *)FF_DOS); break;\n\t\t    case 'u':\n\t\t\tbuf-&gt;b_p_ff = vim_strsave((char_u *)FF_UNIX); break;\n\t\t    default:\n\t\t\tbuf-&gt;b_p_ff = vim_strsave(p_ff);\n\t\t}\n\t\tif (buf-&gt;b_p_ff != NULL)\n\t\t    buf-&gt;b_start_ffc = *buf-&gt;b_p_ff;\n\t\tbuf-&gt;b_p_bh = empty_option;\n\t\tbuf-&gt;b_p_bt = empty_option;\n\t    }\n\t    else\n\t\tfree_buf_options(buf, FALSE);\n\n\t    buf-&gt;b_p_ai = p_ai;\n\t    COPY_OPT_SCTX(buf, BV_AI);\n\t    buf-&gt;b_p_ai_nopaste = p_ai_nopaste;\n\t    buf-&gt;b_p_sw = p_sw;\n\t    COPY_OPT_SCTX(buf, BV_SW);\n\t    buf-&gt;b_p_tw = p_tw;\n\t    COPY_OPT_SCTX(buf, BV_TW);\n\t    buf-&gt;b_p_tw_nopaste = p_tw_nopaste;\n\t    buf-&gt;b_p_tw_nobin = p_tw_nobin;\n\t    buf-&gt;b_p_wm = p_wm;\n\t    COPY_OPT_SCTX(buf, BV_WM);\n\t    buf-&gt;b_p_wm_nopaste = p_wm_nopaste;\n\t    buf-&gt;b_p_wm_nobin = p_wm_nobin;\n\t    buf-&gt;b_p_bin = p_bin;\n\t    COPY_OPT_SCTX(buf, BV_BIN);\n\t    buf-&gt;b_p_bomb = p_bomb;\n\t    COPY_OPT_SCTX(buf, BV_BOMB);\n\t    buf-&gt;b_p_fixeol = p_fixeol;\n\t    COPY_OPT_SCTX(buf, BV_FIXEOL);\n\t    buf-&gt;b_p_et = p_et;\n\t    COPY_OPT_SCTX(buf, BV_ET);\n\t    buf-&gt;b_p_et_nobin = p_et_nobin;\n\t    buf-&gt;b_p_et_nopaste = p_et_nopaste;\n\t    buf-&gt;b_p_ml = p_ml;\n\t    COPY_OPT_SCTX(buf, BV_ML);\n\t    buf-&gt;b_p_ml_nobin = p_ml_nobin;\n\t    buf-&gt;b_p_inf = p_inf;\n\t    COPY_OPT_SCTX(buf, BV_INF);\n\t    if (cmdmod.cmod_flags &amp; CMOD_NOSWAPFILE)\n\t\tbuf-&gt;b_p_swf = FALSE;\n\t    else\n\t    {\n\t\tbuf-&gt;b_p_swf = p_swf;\n\t\tCOPY_OPT_SCTX(buf, BV_INF);\n\t    }\n\t    buf-&gt;b_p_cpt = vim_strsave(p_cpt);\n\t    COPY_OPT_SCTX(buf, BV_CPT);\n#ifdef BACKSLASH_IN_FILENAME\n\t    buf-&gt;b_p_csl = vim_strsave(p_csl);\n\t    COPY_OPT_SCTX(buf, BV_CSL);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\t    buf-&gt;b_p_cfu = vim_strsave(p_cfu);\n\t    COPY_OPT_SCTX(buf, BV_CFU);\n\t    buf-&gt;b_p_ofu = vim_strsave(p_ofu);\n\t    COPY_OPT_SCTX(buf, BV_OFU);\n#endif\n#ifdef FEAT_EVAL\n\t    buf-&gt;b_p_tfu = vim_strsave(p_tfu);\n\t    COPY_OPT_SCTX(buf, BV_TFU);\n#endif\n\t    buf-&gt;b_p_sts = p_sts;\n\t    COPY_OPT_SCTX(buf, BV_STS);\n\t    buf-&gt;b_p_sts_nopaste = p_sts_nopaste;\n#ifdef FEAT_VARTABS\n\t    buf-&gt;b_p_vsts = vim_strsave(p_vsts);\n\t    COPY_OPT_SCTX(buf, BV_VSTS);\n\t    if (p_vsts &amp;&amp; p_vsts != empty_option)\n\t\t(void)tabstop_set(p_vsts, &amp;buf-&gt;b_p_vsts_array);\n\t    else\n\t\tbuf-&gt;b_p_vsts_array = 0;\n\t    buf-&gt;b_p_vsts_nopaste = p_vsts_nopaste\n\t\t\t\t ? vim_strsave(p_vsts_nopaste) : NULL;\n#endif\n\t    buf-&gt;b_p_sn = p_sn;\n\t    COPY_OPT_SCTX(buf, BV_SN);\n\t    buf-&gt;b_p_com = vim_strsave(p_com);\n\t    COPY_OPT_SCTX(buf, BV_COM);\n#ifdef FEAT_FOLDING\n\t    buf-&gt;b_p_cms = vim_strsave(p_cms);\n\t    COPY_OPT_SCTX(buf, BV_CMS);\n#endif\n\t    buf-&gt;b_p_fo = vim_strsave(p_fo);\n\t    COPY_OPT_SCTX(buf, BV_FO);\n\t    buf-&gt;b_p_flp = vim_strsave(p_flp);\n\t    COPY_OPT_SCTX(buf, BV_FLP);\n\t    // NOTE: Valgrind may report a bogus memory leak for 'nrformats'\n\t    // when it is set to 8 bytes in defaults.vim.\n\t    buf-&gt;b_p_nf = vim_strsave(p_nf);\n\t    COPY_OPT_SCTX(buf, BV_NF);\n\t    buf-&gt;b_p_mps = vim_strsave(p_mps);\n\t    COPY_OPT_SCTX(buf, BV_MPS);\n#ifdef FEAT_SMARTINDENT\n\t    buf-&gt;b_p_si = p_si;\n\t    COPY_OPT_SCTX(buf, BV_SI);\n#endif\n\t    buf-&gt;b_p_ci = p_ci;\n\t    COPY_OPT_SCTX(buf, BV_CI);\n#ifdef FEAT_CINDENT\n\t    buf-&gt;b_p_cin = p_cin;\n\t    COPY_OPT_SCTX(buf, BV_CIN);\n\t    buf-&gt;b_p_cink = vim_strsave(p_cink);\n\t    COPY_OPT_SCTX(buf, BV_CINK);\n\t    buf-&gt;b_p_cino = vim_strsave(p_cino);\n\t    COPY_OPT_SCTX(buf, BV_CINO);\n#endif\n\t    // Don't copy 'filetype', it must be detected\n\t    buf-&gt;b_p_ft = empty_option;\n\t    buf-&gt;b_p_pi = p_pi;\n\t    COPY_OPT_SCTX(buf, BV_PI);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    buf-&gt;b_p_cinw = vim_strsave(p_cinw);\n\t    COPY_OPT_SCTX(buf, BV_CINW);\n#endif\n#ifdef FEAT_LISP\n\t    buf-&gt;b_p_lisp = p_lisp;\n\t    COPY_OPT_SCTX(buf, BV_LISP);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // Don't copy 'syntax', it must be set\n\t    buf-&gt;b_p_syn = empty_option;\n\t    buf-&gt;b_p_smc = p_smc;\n\t    COPY_OPT_SCTX(buf, BV_SMC);\n\t    buf-&gt;b_s.b_syn_isk = empty_option;\n#endif\n#ifdef FEAT_SPELL\n\t    buf-&gt;b_s.b_p_spc = vim_strsave(p_spc);\n\t    COPY_OPT_SCTX(buf, BV_SPC);\n\t    (void)compile_cap_prog(&amp;buf-&gt;b_s);\n\t    buf-&gt;b_s.b_p_spf = vim_strsave(p_spf);\n\t    COPY_OPT_SCTX(buf, BV_SPF);\n\t    buf-&gt;b_s.b_p_spl = vim_strsave(p_spl);\n\t    COPY_OPT_SCTX(buf, BV_SPL);\n\t    buf-&gt;b_s.b_p_spo = vim_strsave(p_spo);\n\t    COPY_OPT_SCTX(buf, BV_SPO);\n#endif\n#if defined(FEAT_CINDENT) &amp;&amp; defined(FEAT_EVAL)\n\t    buf-&gt;b_p_inde = vim_strsave(p_inde);\n\t    COPY_OPT_SCTX(buf, BV_INDE);\n\t    buf-&gt;b_p_indk = vim_strsave(p_indk);\n\t    COPY_OPT_SCTX(buf, BV_INDK);\n#endif\n\t    buf-&gt;b_p_fp = empty_option;\n#if defined(FEAT_EVAL)\n\t    buf-&gt;b_p_fex = vim_strsave(p_fex);\n\t    COPY_OPT_SCTX(buf, BV_FEX);\n#endif\n#ifdef FEAT_CRYPT\n\t    buf-&gt;b_p_key = vim_strsave(p_key);\n\t    COPY_OPT_SCTX(buf, BV_KEY);\n#endif\n#ifdef FEAT_SEARCHPATH\n\t    buf-&gt;b_p_sua = vim_strsave(p_sua);\n\t    COPY_OPT_SCTX(buf, BV_SUA);\n#endif\n#ifdef FEAT_KEYMAP\n\t    buf-&gt;b_p_keymap = vim_strsave(p_keymap);\n\t    COPY_OPT_SCTX(buf, BV_KMAP);\n\t    buf-&gt;b_kmap_state |= KEYMAP_INIT;\n#endif\n#ifdef FEAT_TERMINAL\n\t    buf-&gt;b_p_twsl = p_twsl;\n\t    COPY_OPT_SCTX(buf, BV_TWSL);\n#endif\n\t    // This isn't really an option, but copying the langmap and IME\n\t    // state from the current buffer is better than resetting it.\n\t    buf-&gt;b_p_iminsert = p_iminsert;\n\t    COPY_OPT_SCTX(buf, BV_IMI);\n\t    buf-&gt;b_p_imsearch = p_imsearch;\n\t    COPY_OPT_SCTX(buf, BV_IMS);\n\n\t    // options that are normally global but also have a local value\n\t    // are not copied, start using the global value\n\t    buf-&gt;b_p_ar = -1;\n\t    buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    buf-&gt;b_p_bkc = empty_option;\n\t    buf-&gt;b_bkc_flags = 0;\n#ifdef FEAT_QUICKFIX\n\t    buf-&gt;b_p_gp = empty_option;\n\t    buf-&gt;b_p_mp = empty_option;\n\t    buf-&gt;b_p_efm = empty_option;\n#endif\n\t    buf-&gt;b_p_ep = empty_option;\n\t    buf-&gt;b_p_kp = empty_option;\n\t    buf-&gt;b_p_path = empty_option;\n\t    buf-&gt;b_p_tags = empty_option;\n\t    buf-&gt;b_p_tc = empty_option;\n\t    buf-&gt;b_tc_flags = 0;\n#ifdef FEAT_FIND_ID\n\t    buf-&gt;b_p_def = empty_option;\n\t    buf-&gt;b_p_inc = empty_option;\n# ifdef FEAT_EVAL\n\t    buf-&gt;b_p_inex = vim_strsave(p_inex);\n\t    COPY_OPT_SCTX(buf, BV_INEX);\n# endif\n#endif\n\t    buf-&gt;b_p_dict = empty_option;\n\t    buf-&gt;b_p_tsr = empty_option;\n#ifdef FEAT_TEXTOBJ\n\t    buf-&gt;b_p_qe = vim_strsave(p_qe);\n\t    COPY_OPT_SCTX(buf, BV_QE);\n#endif\n#if defined(FEAT_BEVAL) &amp;&amp; defined(FEAT_EVAL)\n\t    buf-&gt;b_p_bexpr = empty_option;\n#endif\n#if defined(FEAT_CRYPT)\n\t    buf-&gt;b_p_cm = empty_option;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t    buf-&gt;b_p_udf = p_udf;\n\t    COPY_OPT_SCTX(buf, BV_UDF);\n#endif\n#ifdef FEAT_LISP\n\t    buf-&gt;b_p_lw = empty_option;\n#endif\n\t    buf-&gt;b_p_menc = empty_option;\n\n\t    /*\n\t     * Don't copy the options set by ex_help(), use the saved values,\n\t     * when going from a help buffer to a non-help buffer.\n\t     * Don't touch these at all when BCO_NOHELP is used and going from\n\t     * or to a help buffer.\n\t     */\n\t    if (dont_do_help)\n\t    {\n\t\tbuf-&gt;b_p_isk = save_p_isk;\n#ifdef FEAT_VARTABS\n\t\tif (p_vts &amp;&amp; p_vts != empty_option &amp;&amp; !buf-&gt;b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &amp;buf-&gt;b_p_vts_array);\n\t\telse\n\t\t    buf-&gt;b_p_vts_array = NULL;\n#endif\n\t    }\n\t    else\n\t    {\n\t\tbuf-&gt;b_p_isk = vim_strsave(p_isk);\n\t\tCOPY_OPT_SCTX(buf, BV_ISK);\n\t\tdid_isk = TRUE;\n\t\tbuf-&gt;b_p_ts = p_ts;\n#ifdef FEAT_VARTABS\n\t\tbuf-&gt;b_p_vts = vim_strsave(p_vts);\n\t\tCOPY_OPT_SCTX(buf, BV_VTS);\n\t\tif (p_vts &amp;&amp; p_vts != empty_option &amp;&amp; !buf-&gt;b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &amp;buf-&gt;b_p_vts_array);\n\t\telse\n\t\t    buf-&gt;b_p_vts_array = NULL;\n#endif\n\t\tbuf-&gt;b_help = FALSE;\n\t\tif (buf-&gt;b_p_bt[0] == 'h')\n\t\t    clear_string_option(&amp;buf-&gt;b_p_bt);\n\t\tbuf-&gt;b_p_ma = p_ma;\n\t\tCOPY_OPT_SCTX(buf, BV_MA);\n\t    }\n\t}\n\n\t/*\n\t * When the options should be copied (ignoring BCO_ALWAYS), set the\n\t * flag that indicates that the options have been initialized.\n\t */\n\tif (should_copy)\n\t    buf-&gt;b_p_initialized = TRUE;\n    }\n\n    check_buf_options(buf);\t    // make sure we don't have NULLs\n    if (did_isk)\n\t(void)buf_init_chartab(buf, FALSE);\n}",
 'TfLiteStatus PrepareHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 0);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  TF_LITE_ENSURE(context, node-&gt;user_data != nullptr);\n  const auto* params =\n      reinterpret_cast&lt;const TfLiteHashtableParams*&gt;(node-&gt;user_data);\n\n  TF_LITE_ENSURE(context, !params-&gt;table_name.empty());\n  TF_LITE_ENSURE(context, (params-&gt;key_dtype == kTfLiteInt64 &amp;&amp;\n                           params-&gt;value_dtype == kTfLiteString) ||\n                              (params-&gt;key_dtype == kTfLiteString &amp;&amp;\n                               params-&gt;value_dtype == kTfLiteInt64));\n\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  TF_LITE_ENSURE(context, resource_handle_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, resource_handle_tensor-&gt;type, kTfLiteInt32);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize-&gt;data[0] = 1;\n  return context-&gt;ResizeTensor(context, resource_handle_tensor, outputSize);\n}',
 "static void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\n\tif (!skb-&gt;data_len)\n\t\tgoto done;\n\n\t/* Don't forget the fragments. */\n\tfor (frag = skb_shinfo(skb)-&gt;frag_list; frag; frag = frag-&gt;next)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\n\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}",
 'irc_mode_channel_update (struct t_irc_server *server,\n                         struct t_irc_channel *channel,\n                         char set_flag,\n                         char chanmode,\n                         const char *argument)\n{\n    char *pos_args, *str_modes, **argv, *pos, *ptr_arg;\n    char *new_modes, *new_args, str_mode[2], *str_temp;\n    int argc, current_arg, chanmode_found, length;\n\n    if (!channel-&gt;modes)\n        channel-&gt;modes = strdup ("+");\n    if (!channel-&gt;modes)\n        return;\n\n    argc = 0;\n    argv = NULL;\n    pos_args = strchr (channel-&gt;modes, \' \');\n    if (pos_args)\n    {\n        str_modes = weechat_strndup (channel-&gt;modes, pos_args - channel-&gt;modes);\n        if (!str_modes)\n            return;\n        pos_args++;\n        while (pos_args[0] == \' \')\n            pos_args++;\n        argv = weechat_string_split (pos_args, " ", NULL,\n                                     WEECHAT_STRING_SPLIT_STRIP_LEFT\n                                     | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n                                     | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n                                     0, &amp;argc);\n    }\n    else\n    {\n        str_modes = strdup (channel-&gt;modes);\n        if (!str_modes)\n            return;\n    }\n\n    new_modes = malloc (strlen (channel-&gt;modes) + 1 + 1);\n    new_args = malloc (((pos_args) ? strlen (pos_args) : 0)\n                       + ((argument) ? 1 + strlen (argument) : 0) + 1);\n    if (new_modes &amp;&amp; new_args)\n    {\n        new_modes[0] = \'\\0\';\n        new_args[0] = \'\\0\';\n\n        /* loop on current modes and build "new_modes" + "new_args" */\n        current_arg = 0;\n        chanmode_found = 0;\n        pos = str_modes;\n        while (pos &amp;&amp; pos[0])\n        {\n            if ((pos[0] == \'+\') || (pos[0] == \'-\'))\n            {\n                str_mode[0] = pos[0];\n                str_mode[1] = \'\\0\';\n                strcat (new_modes, str_mode);\n            }\n            else\n            {\n                ptr_arg = NULL;\n                switch (irc_mode_get_chanmode_type (server, pos[0]))\n                {\n                    case \'A\': /* always argument */\n                    case \'B\': /* always argument */\n                    case \'C\': /* argument if set */\n                        ptr_arg = (current_arg &lt; argc) ?\n                            argv[current_arg] : NULL;\n                        break;\n                    case \'D\': /* no argument */\n                        break;\n                }\n                if (ptr_arg)\n                    current_arg++;\n                if (pos[0] == chanmode)\n                {\n                    chanmode_found = 1;\n                    if (set_flag == \'+\')\n                    {\n                        str_mode[0] = pos[0];\n                        str_mode[1] = \'\\0\';\n                        strcat (new_modes, str_mode);\n                        if (argument)\n                        {\n                            if (new_args[0])\n                                strcat (new_args, " ");\n                            strcat (new_args, argument);\n                        }\n                    }\n                }\n                else\n                {\n                    str_mode[0] = pos[0];\n                    str_mode[1] = \'\\0\';\n                    strcat (new_modes, str_mode);\n                    if (ptr_arg)\n                    {\n                        if (new_args[0])\n                            strcat (new_args, " ");\n                        strcat (new_args, ptr_arg);\n                    }\n                }\n            }\n            pos++;\n        }\n        if (!chanmode_found)\n        {\n            /*\n             * chanmode was not in channel modes: if set_flag is \'+\', add\n             * it to channel modes\n             */\n            if (set_flag == \'+\')\n            {\n                if (argument)\n                {\n                    /* add mode with argument at the end of modes */\n                    str_mode[0] = chanmode;\n                    str_mode[1] = \'\\0\';\n                    strcat (new_modes, str_mode);\n                    if (new_args[0])\n                        strcat (new_args, " ");\n                    strcat (new_args, argument);\n                }\n                else\n                {\n                    /* add mode without argument at the beginning of modes */\n                    pos = new_modes;\n                    while (pos[0] == \'+\')\n                        pos++;\n                    memmove (pos + 1, pos, strlen (pos) + 1);\n                    pos[0] = chanmode;\n                }\n            }\n        }\n        if (new_args[0])\n        {\n            length = strlen (new_modes) + 1 + strlen (new_args) + 1;\n            str_temp = malloc (length);\n            if (str_temp)\n            {\n                snprintf (str_temp, length, "%s %s", new_modes, new_args);\n                if (channel-&gt;modes)\n                    free (channel-&gt;modes);\n                channel-&gt;modes = str_temp;\n            }\n        }\n        else\n        {\n            if (channel-&gt;modes)\n                free (channel-&gt;modes);\n            channel-&gt;modes = strdup (new_modes);\n        }\n    }\n\n    if (new_modes)\n        free (new_modes);\n    if (new_args)\n        free (new_args);\n    if (str_modes)\n        free (str_modes);\n    if (argv)\n        weechat_string_free_split (argv);\n}',
 'static inline int file_list_cpu(struct file *file)\n{\n#ifdef CONFIG_SMP\n\treturn file-&gt;f_sb_list_cpu;\n#else\n\treturn smp_processor_id();\n#endif\n}',
 'TEST(DefaultCertValidatorTest, TestMultiLevelMatch) {\n  // san_multiple_dns_cert matches *.example.com\n  bssl::UniquePtr&lt;X509&gt; cert = readCertFromFile(TestEnvironment::substitute(\n      "{{ test_rundir "\n      "}}/test/extensions/transport_sockets/tls/test_data/san_multiple_dns_cert.pem"));\n  envoy::type::matcher::v3::StringMatcher matcher;\n  matcher.set_exact("foo.api.example.com");\n  std::vector&lt;Matchers::StringMatcherImpl&lt;envoy::type::matcher::v3::StringMatcher&gt;&gt;\n      subject_alt_name_matchers;\n  subject_alt_name_matchers.push_back(Matchers::StringMatcherImpl(matcher));\n  EXPECT_FALSE(DefaultCertValidator::matchSubjectAltName(cert.get(), subject_alt_name_matchers));\n}',
 'static void Np_toString(js_State *J)\n{\n\tchar buf[32];\n\tjs_Object *self = js_toobject(J, 0);\n\tint radix = js_isundefined(J, 1) ? 10 : js_tointeger(J, 1);\n\tif (self-&gt;type != JS_CNUMBER)\n\t\tjs_typeerror(J, "not a number");\n\tif (radix == 10) {\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, self-&gt;u.number));\n\t\treturn;\n\t}\n\tif (radix &lt; 2 || radix &gt; 36)\n\t\tjs_rangeerror(J, "invalid radix");\n\n\t/* lame number to string conversion for any radix from 2 to 36 */\n\t{\n\t\tstatic const char digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";\n\t\tchar buf[100];\n\t\tdouble number = self-&gt;u.number;\n\t\tint sign = self-&gt;u.number &lt; 0;\n\t\tjs_Buffer *sb = NULL;\n\t\tuint64_t u, limit = ((uint64_t)1&lt;&lt;52);\n\n\t\tint ndigits, exp, point;\n\n\t\tif (number == 0) { js_pushstring(J, "0"); return; }\n\t\tif (isnan(number)) { js_pushstring(J, "NaN"); return; }\n\t\tif (isinf(number)) { js_pushstring(J, sign ? "-Infinity" : "Infinity"); return; }\n\n\t\tif (sign)\n\t\t\tnumber = -number;\n\n\t\t/* fit as many digits as we want in an int */\n\t\texp = 0;\n\t\twhile (number * pow(radix, exp) &gt; limit)\n\t\t\t--exp;\n\t\twhile (number * pow(radix, exp+1) &lt; limit)\n\t\t\t++exp;\n\t\tu = number * pow(radix, exp) + 0.5;\n\n\t\t/* trim trailing zeros */\n\t\twhile (u &gt; 0 &amp;&amp; (u % radix) == 0) {\n\t\t\tu /= radix;\n\t\t\t--exp;\n\t\t}\n\n\t\t/* serialize digits */\n\t\tndigits = 0;\n\t\twhile (u &gt; 0) {\n\t\t\tbuf[ndigits++] = digits[u % radix];\n\t\t\tu /= radix;\n\t\t}\n\t\tpoint = ndigits - exp;\n\n\t\tif (js_try(J)) {\n\t\t\tjs_free(J, sb);\n\t\t\tjs_throw(J);\n\t\t}\n\n\t\tif (sign)\n\t\t\tjs_putc(J, &amp;sb, \'-\');\n\n\t\tif (point &lt;= 0) {\n\t\t\tjs_putc(J, &amp;sb, \'0\');\n\t\t\tjs_putc(J, &amp;sb, \'.\');\n\t\t\twhile (point++ &lt; 0)\n\t\t\t\tjs_putc(J, &amp;sb, \'0\');\n\t\t\twhile (ndigits-- &gt; 0)\n\t\t\t\tjs_putc(J, &amp;sb, buf[ndigits]);\n\t\t} else {\n\t\t\twhile (ndigits-- &gt; 0) {\n\t\t\t\tjs_putc(J, &amp;sb, buf[ndigits]);\n\t\t\t\tif (--point == 0 &amp;&amp; ndigits &gt; 0)\n\t\t\t\t\tjs_putc(J, &amp;sb, \'.\');\n\t\t\t}\n\t\t\twhile (point-- &gt; 0)\n\t\t\t\tjs_putc(J, &amp;sb, \'0\');\n\t\t}\n\n\t\tjs_putc(J, &amp;sb, 0);\n\t\tjs_pushstring(J, sb-&gt;s);\n\n\t\tjs_endtry(J);\n\t\tjs_free(J, sb);\n\t}\n}',
 '  static NAN_METHOD(Free) {\n    GenericDecipher* obj = ObjectWrap::Unwrap&lt;GenericDecipher&gt;(info.Holder());\n    obj-&gt;clear();\n  }',
 'static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\n\tupb = (int)img-&gt;comps[0].prec;\n\toffset = 1&lt;&lt;(upb - 1); upb = (1&lt;&lt;upb)-1;\n\n\tmaxw = (unsigned int)img-&gt;comps[0].w; maxh = (unsigned int)img-&gt;comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img-&gt;comps[0].data;\n\tcb = img-&gt;comps[1].data;\n\tcr = img-&gt;comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\tfor(i = 0U; i &lt; max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img-&gt;comps[0].data); img-&gt;comps[0].data = d0;\n\tfree(img-&gt;comps[1].data); img-&gt;comps[1].data = d1;\n\tfree(img-&gt;comps[2].data); img-&gt;comps[2].data = d2;\n\treturn;\n\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n\n}/* sycc444_to_rgb() */',
 'static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\n\t/* TH55 registers 2 ports.\n\t   Communication in from the UX50/TH55 uses bulk_in_endpointAddress\n\t   from port 0. Communication out to the UX50/TH55 uses\n\t   bulk_out_endpointAddress from port 1\n\n\t   Lets do a quick and dirty mapping\n\t */\n\n\t/* some sanity check */\n\tif (serial-&gt;num_ports &lt; 2)\n\t\treturn -1;\n\n\t/* port 0 now uses the modified endpoint Address */\n\tport = serial-&gt;port[0];\n\tport-&gt;bulk_out_endpointAddress =\n\t\t\t\tserial-&gt;port[1]-&gt;bulk_out_endpointAddress;\n\n\tpipe = usb_sndbulkpipe(serial-&gt;dev, port-&gt;bulk_out_endpointAddress);\n\tfor (j = 0; j &lt; ARRAY_SIZE(port-&gt;write_urbs); ++j)\n\t\tport-&gt;write_urbs[j]-&gt;pipe = pipe;\n\n\treturn 0;\n}',
 'static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {\n\tint vA, vB, vC, payload = 0, i = (int) buf[0];\n\tint size = dalvik_opcodes[i].len;\n\tchar str[1024], *strasm;\n\tut64 offset;\n\tconst char *flag_str; \n\n\top-&gt;buf_asm[0] = 0;\n\tif (buf[0] == 0x00) { /* nop */\n\t\tswitch (buf[1]) {\n\t\tcase 0x01: /* packed-switch-payload */\n\t\t\t// ushort size\n\t\t\t// int first_key\n\t\t\t// int[size] = relative offsets\n\t\t\t{\n\t\t\t\tunsigned short array_size = buf[2] | (buf[3] &lt;&lt; 8);\n\t\t\t\tint first_key = buf[4] | (buf[5] &lt;&lt; 8) | (buf[6] &lt;&lt; 16) | (buf[7] &lt;&lt; 24);\n\t\t\t\tsprintf (op-&gt;buf_asm, "packed-switch-payload %d, %d", array_size, first_key);\n\t\t\t\tsize = 8;\n\t\t\t\tpayload = 2 * (array_size * 2);\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x02: /* sparse-switch-payload */\n\t\t\t// ushort size\n\t\t\t// int[size] keys\n\t\t\t// int[size] relative offsets\n\t\t\t{\n\t\t\t\tunsigned short array_size = buf[2] | (buf[3] &lt;&lt; 8);\n\t\t\t\tsprintf (op-&gt;buf_asm, "sparse-switch-payload %d", array_size);\n\t\t\t\tsize = 4;\n\t\t\t\tpayload = 2 * (array_size*4);\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* fill-array-data-payload */\n\t\t\t// element_width = 2 bytes ushort little endian\n\t\t\t// size = 4 bytes uint\n\t\t\t// ([size*element_width+1)/2)+4\n\t\t\tif (len &gt; 7) {\n\t\t\t\tunsigned short elem_width = buf[2] | (buf[3] &lt;&lt; 8);\n\t\t\t\tunsigned int array_size = buf[4] | (buf[5] &lt;&lt; 8) | (buf[6] &lt;&lt; 16) | (buf[7] &lt;&lt; 24);\n\t\t\t\tsnprintf (op-&gt;buf_asm, sizeof (op-&gt;buf_asm),\n\t\t\t\t\t"fill-array-data-payload %d, %d",\n\t\t\t\t\telem_width, array_size);\n\t\t\t\tpayload = 2 * ((array_size * elem_width+1)/2);\n\t\t\t}\n\t\t\tsize = 8;\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* nop */\n\t\t\tbreak;\n\t\t}\n\t}\n\tstrasm = NULL;\n\tif (size &lt;= len) {\n\t\tstrncpy (op-&gt;buf_asm, dalvik_opcodes[i].name, sizeof (op-&gt;buf_asm) - 1);\n\t\tstrasm = strdup (op-&gt;buf_asm);\n\t\tsize = dalvik_opcodes[i].len;\n\t\tswitch (dalvik_opcodes[i].fmt) {\n\t\tcase fmtop: break;\n\t\tcase fmtopvAvB:\n\t\t\tvA = buf[1] &amp; 0x0f;\n\t\t\tvB = (buf[1] &amp; 0xf0) &gt;&gt; 4;\n\t\t\tsprintf (str, " v%i, v%i", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAvBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\tsprintf (str, " v%i, v%i", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAAAvBBBB: // buf[1] seems useless :/\n\t\t\tvA = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\tvB = (buf[5] &lt;&lt; 8) | buf[4];\n\t\t\tsprintf (str, " v%i, v%i", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAA:\n\t\t\tvA = (int) buf[1];\n\t\t\tsprintf (str, " v%i", vA);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAcB:\n\t\t\tvA = buf[1] &amp; 0x0f;\n\t\t\tvB = (buf[1] &amp; 0xf0) &gt;&gt; 4;\n\t\t\tsprintf (str, " v%i, %#x", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\t{\n\t\t\t\tshort sB = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\t\tsprintf (str, " v%i, %#04hx", vA, sB);\n\t\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = buf[2] | (buf[3] &lt;&lt; 8) | (buf[4] &lt;&lt; 16) | (buf[5] &lt;&lt; 24);\n\t\t\tif (buf[0] == 0x17) { //const-wide/32\n\t\t\t\tsnprintf (str, sizeof (str), " v%i:v%i, 0x%08x", vA, vA + 1, vB);\n\t\t\t} else { //const\n\t\t\t\tsnprintf (str, sizeof (str), " v%i, 0x%08x", vA, vB);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBB0000:\n\t\t\tvA = (int) buf[1];\n\t\t\t// vB = 0|(buf[3]&lt;&lt;16)|(buf[2]&lt;&lt;24);\n\t\t\tvB = 0 | (buf[2] &lt;&lt; 16) | (buf[3] &lt;&lt; 24);\n\t\t\tif (buf[0] == 0x19) { // const-wide/high16\n\t\t\t\tsnprintf (str, sizeof (str), " v%i:v%i, 0x%08x", vA, vA + 1, vB);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof (str), " v%i, 0x%08x", vA, vB);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBBBBBBBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\t#define llint long long int\n\t\t\tllint lB = (llint)buf[2] | ((llint)buf[3] &lt;&lt; 8)|\n\t\t\t\t((llint)buf[4] &lt;&lt; 16) | ((llint)buf[5] &lt;&lt; 24)|\n\t\t\t\t((llint)buf[6] &lt;&lt; 32) | ((llint)buf[7] &lt;&lt; 40)|\n\t\t\t\t((llint)buf[8] &lt;&lt; 48) | ((llint)buf[9] &lt;&lt; 56);\n\t\t\t#undef llint\n\t\t\tsprintf (str, " v%i:v%i, 0x%"PFMT64x, vA, vA + 1, lB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAvBBvCC:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) buf[2];\n\t\t\tvC = (int) buf[3];\n\t\t\tsprintf (str, " v%i, v%i, v%i", vA, vB, vC);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAvBBcCC:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) buf[2];\n\t\t\tvC = (int) buf[3];\n\t\t\tsprintf (str, " v%i, v%i, %#x", vA, vB, vC);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAvBcCCCC:\n\t\t\tvA = buf[1] &amp; 0x0f;\n\t\t\tvB = (buf[1] &amp; 0xf0) &gt;&gt; 4;\n\t\t\tvC = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\tsprintf (str, " v%i, v%i, %#x", vA, vB, vC);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoppAA:\n\t\t\tvA = (char) buf[1];\n\t\t\t//sprintf (str, " %i", vA*2); // vA : word -&gt; byte\n\t\t\tsnprintf (str, sizeof (str), " 0x%08"PFMT64x, a-&gt;pc + (vA * 2)); // vA : word -&gt; byte\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoppAAAA:\n\t\t\tvA = (short) (buf[3] &lt;&lt; 8 | buf[2]);\n\t\t\tsnprintf (str, sizeof (str), " 0x%08"PFMT64x, a-&gt;pc + (vA * 2)); // vA : word -&gt; byte\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAApBBBB: // if-*z\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) (buf[3] &lt;&lt; 8 | buf[2]);\n\t\t\t//sprintf (str, " v%i, %i", vA, vB);\n\t\t\tsnprintf (str, sizeof (str), " v%i, 0x%08"PFMT64x, vA, a-&gt;pc + (vB * 2));\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoppAAAAAAAA:\n\t\t\tvA = (int) (buf[2] | (buf[3] &lt;&lt; 8) | (buf[4] &lt;&lt; 16) | (buf[5] &lt;&lt; 24));\n\t\t\t//sprintf (str, " %#08x", vA*2); // vA: word -&gt; byte\n\t\t\tsnprintf (str, sizeof (str), " 0x%08"PFMT64x, a-&gt;pc + (vA*2)); // vA : word -&gt; byte\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAvBpCCCC: // if-*\n\t\t\tvA = buf[1] &amp; 0x0f;\n\t\t\tvB = (buf[1] &amp; 0xf0) &gt;&gt; 4;\n\t\t\tvC = (int) (buf[3] &lt;&lt; 8 | buf[2]);\n\t\t\t//sprintf (str, " v%i, v%i, %i", vA, vB, vC);\n\t\t\tsnprintf (str, sizeof (str)," v%i, v%i, 0x%08"PFMT64x, vA, vB, a-&gt;pc + (vC * 2));\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAApBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) (buf[2] | (buf[3] &lt;&lt; 8) | (buf[4] &lt;&lt; 16) | (buf[5] &lt;&lt; 24));\n\t\t\tsnprintf (str, sizeof (str), " v%i, 0x%08"PFMT64x, vA, a-&gt;pc + vB); // + (vB*2));\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinlineI:\n\t\t\tvA = (int) (buf[1] &amp; 0x0f);\n\t\t\tvB = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\t*str = 0;\n\t\t\tswitch (vA) {\n\t\t\tcase 1:\n\t\t\t\tsprintf (str, " {v%i}", buf[4] &amp; 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsprintf (str, " {v%i, v%i}", buf[4] &amp; 0x0f, (buf[4] &amp; 0xf0) &gt;&gt; 4);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsprintf (str, " {v%i, v%i, v%i}", buf[4] &amp; 0x0f, (buf[4] &amp; 0xf0) &gt;&gt; 4, buf[5] &amp; 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tsprintf (str, " {v%i, v%i, v%i, v%i}", buf[4] &amp; 0x0f,\n\t\t\t\t\t\t(buf[4] &amp; 0xf0) &gt;&gt; 4, buf[5] &amp; 0x0f, (buf[5] &amp; 0xf0) &gt;&gt; 4);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf (str, " {}");\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tsprintf (str, ", [%04x]", vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinlineIR:\n\t\tcase fmtoptinvokeVSR:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\tvC = (buf[5] &lt;&lt; 8) | buf[4];\n\t\t\tsprintf (str, " {v%i..v%i} [%04x]", vC, vC + vA - 1, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinvokeVS:\n\t\t\tvA = (int) (buf[1] &amp; 0xf0) &gt;&gt; 4;\n\t\t\tvB = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\tswitch (vA) {\n\t\t\tcase 1:\n\t\t\t\tsprintf (str, " {v%i}", buf[4] &amp; 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsprintf (str, " {v%i, v%i}", buf[4] &amp; 0x0f, (buf[4] &amp; 0xf0) &gt;&gt; 4);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsprintf (str, " {v%i, v%i, v%i}", buf[4] &amp; 0x0f,\n\t\t\t\t\t\t(buf[4] &amp; 0xf0) &gt;&gt; 4, buf[5] &amp; 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tsprintf (str, " {v%i, v%i, v%i, v%i}", buf[4] &amp; 0x0f,\n\t\t\t\t\t\t(buf[4] &amp; 0xf0) &gt;&gt; 4, buf[5] &amp; 0x0f, (buf[5] &amp; 0xf0) &gt;&gt; 4);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf (str, " {}");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tsprintf (str, ", [%04x]", vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAtBBBB: // "sput-*"\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\tif (buf[0] == 0x1a) {\n\t\t\t\toffset = R_ASM_GET_OFFSET (a, \'s\', vB);\n\t\t\t\tif (offset == -1) {\n\t\t\t\t\tsprintf (str, " v%i, string+%i", vA, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf (str, " v%i, 0x%"PFMT64x, vA, offset);\n\t\t\t\t}\n\t\t\t} else if (buf[0] == 0x1c || buf[0] == 0x1f || buf[0] == 0x22) {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, \'c\', vB);\n\t\t\t\tif (!flag_str) {\n\t\t\t\t\tsprintf (str, " v%i, class+%i", vA, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf (str, " v%i, %s", vA, flag_str);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, \'f\', vB);\n\t\t\t\tif (!flag_str) {\n\t\t\t\t\tsprintf (str, " v%i, field+%i", vA, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf (str, " v%i, %s", vA, flag_str);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptopvAvBoCCCC:\n\t\t\tvA = (buf[1] &amp; 0x0f);\n\t\t\tvB = (buf[1] &amp; 0xf0) &gt;&gt; 4;\n\t\t\tvC = (buf[3]&lt;&lt;8) | buf[2];\n\t\t\toffset = R_ASM_GET_OFFSET (a, \'o\', vC);\n\t\t\tif (offset == -1) {\n\t\t\t\tsprintf (str, " v%i, v%i, [obj+%04x]", vA, vB, vC);\n\t\t\t} else {\n\t\t\t\tsprintf (str, " v%i, v%i, [0x%"PFMT64x"]", vA, vB, offset);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopAAtBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\toffset = R_ASM_GET_OFFSET (a, \'t\', vB);\n\t\t\tif (offset == -1) {\n\t\t\t\tsprintf (str, " v%i, thing+%i", vA, vB);\n\t\t\t} else {\n\t\t\t\tsprintf (str, " v%i, 0x%"PFMT64x, vA, offset);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAvBtCCCC:\n\t\t\tvA = (buf[1] &amp; 0x0f);\n\t\t\tvB = (buf[1] &amp; 0xf0) &gt;&gt; 4;\n\t\t\tvC = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\tif (buf[0] == 0x20 || buf[0] == 0x23) { //instance-of &amp; new-array\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, \'c\', vC);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, " v%i, v%i, %s", vA, vB, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsprintf (str, " v%i, v%i, class+%i", vA, vB, vC);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, \'f\', vC);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, " v%i, v%i, %s", vA, vB, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsprintf (str, " v%i, v%i, field+%i", vA, vB, vC);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAtBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) (buf[5] | (buf[4] &lt;&lt; 8) | (buf[3] &lt;&lt; 16) | (buf[2] &lt;&lt; 24));\n\t\t\toffset = R_ASM_GET_OFFSET (a, \'s\', vB);\n\t\t\tif (offset == -1) {\n\t\t\t\tsprintf (str, " v%i, string+%i", vA, vB);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf (str, " v%i, 0x%"PFMT64x, vA, offset);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvCCCCmBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\tvC = (buf[5] &lt;&lt; 8) | buf[4];\n\t\t\tif (buf[0] == 0x25) { // filled-new-array/range\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, \'c\', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, " {v%i..v%i} %s", vC, vC + vA - 1, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsprintf (str, " {v%i..v%i} class+%i", vC, vC + vA - 1, vB);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, \'m\', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, " {v%i..v%i} %s", vC, vC + vA - 1, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsprintf (str, " {v%i..v%i} method+%i", vC, vC + vA - 1, vB);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvXtBBBB:\n\t\t\tvA = (int) (buf[1] &amp; 0xf0) &gt;&gt; 4;\n\t\t\tvB = (buf[3] &lt;&lt; 8) | buf[2];\n\t\t\tswitch (vA) {\n\t\t\t\tcase 1:\n\t\t\t\t\tsprintf (str, " {v%i}", buf[4] &amp; 0x0f);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsprintf (str, " {v%i, v%i}", buf[4] &amp; 0x0f, (buf[4] &amp; 0xf0) &gt;&gt; 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tsprintf (str, " {v%i, v%i, v%i}", buf[4] &amp; 0x0f,\n\t\t\t\t\t\t\t(buf[4] &amp; 0xf0) &gt;&gt; 4, buf[5] &amp; 0x0f);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tsprintf (str, " {v%i, v%i, v%i, v%i}", buf[4] &amp; 0x0f,\n\t\t\t\t\t\t\t(buf[4] &amp; 0xf0) &gt;&gt; 4, buf[5] &amp; 0x0f, (buf[5] &amp; 0xf0) &gt;&gt; 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tsprintf (str, " {v%i, v%i, v%i, v%i, v%i}", buf[4] &amp; 0x0f,\n\t\t\t\t\t\t\t(buf[4] &amp; 0xf0) &gt;&gt; 4, buf[5] &amp; 0x0f, (buf[5] &amp; 0xf0) &gt;&gt; 4, buf[1] &amp; 0x0f); // TOODO: recheck this\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsprintf (str, " {}");\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tif (buf[0] == 0x24) { // filled-new-array\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, \'c\', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, ", %s ; 0x%x", flag_str, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf (str, ", class+%i", vB);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, \'m\', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, ", %s ; 0x%x", flag_str, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf (str, ", method+%i", vB);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinvokeI: // Any opcode has this formats\n\t\tcase fmtoptinvokeIR:\n\t\tcase fmt00:\n\t\tdefault:\n\t\t\tstrcpy (op-&gt;buf_asm, "invalid ");\n\t\t\tfree (strasm);\n\t\t\tstrasm = NULL;\n\t\t\tsize = 2;\n\t\t}\n\t\tif (strasm) {\n\t\t\tstrncpy (op-&gt;buf_asm, strasm, sizeof (op-&gt;buf_asm) - 1);\n\t\t\top-&gt;buf_asm[sizeof (op-&gt;buf_asm) - 1] = 0;\n\t\t} else {\n\t\t\t//op-&gt;buf_asm[0] = 0;\n\t\t\tstrcpy (op-&gt;buf_asm , "invalid");\n\t\t}\n\t} else if (len &gt; 0) {\n\t\tstrcpy (op-&gt;buf_asm, "invalid ");\n\t\top-&gt;size = len;\n\t\tsize = len;\n\t}\n\top-&gt;payload = payload;\n\tsize += payload; // XXX\n\t// align to 2\n\top-&gt;size = size;\n\tfree (strasm);\n\treturn size;\n}',
 "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast&lt;TfLitePoolParams*&gt;(node-&gt;builtin_data);\n  OpData* data = reinterpret_cast&lt;OpData*&gt;(node-&gt;user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_TYPES_EQ(context, input-&gt;type, output-&gt;type);\n\n  int batches = input-&gt;dims-&gt;data[0];\n  int height = input-&gt;dims-&gt;data[1];\n  int width = input-&gt;dims-&gt;data[2];\n  int channels_out = input-&gt;dims-&gt;data[3];\n\n  // Matching GetWindowedOutputSize in TensorFlow.\n  auto padding = params-&gt;padding;\n  int out_width, out_height;\n\n  data-&gt;padding = ComputePaddingHeightWidth(\n      params-&gt;stride_height, params-&gt;stride_width, 1, 1, height, width,\n      params-&gt;filter_height, params-&gt;filter_width, padding, &amp;out_height,\n      &amp;out_width);\n\n  if (input-&gt;type == kTfLiteUInt8 || input-&gt;type == kTfLiteInt8) {\n    if (pool_type == kAverage || pool_type == kMax) {\n      TFLITE_DCHECK_LE(std::abs(input-&gt;params.scale - output-&gt;params.scale),\n                       1.0e-6);\n      TFLITE_DCHECK_EQ(input-&gt;params.zero_point, output-&gt;params.zero_point);\n    }\n    if (pool_type == kL2) {\n      // We currently don't have a quantized implementation of L2Pool\n      TF_LITE_ENSURE_TYPES_EQ(context, input-&gt;type, kTfLiteFloat32);\n    }\n  }\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size-&gt;data[0] = batches;\n  output_size-&gt;data[1] = out_height;\n  output_size-&gt;data[2] = out_width;\n  output_size-&gt;data[3] = channels_out;\n  return context-&gt;ResizeTensor(context, output, output_size);\n}",
 'static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\n\tret = kern_path(pathname-&gt;name, LOOKUP_FOLLOW, &amp;path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode-&gt;i_private, *type);\n\ttouch_atime(&amp;path);\n\n\tpath_put(&amp;path);\n\treturn raw;\nout:\n\tpath_put(&amp;path);\n\treturn ERR_PTR(ret);\n}',
 'Status NestedStackRaggedTensors(\n    const std::vector&lt;RaggedTensorVariant&gt;&amp; ragged_components,\n    const std::vector&lt;int&gt;&amp; nested_dim_sizes, const int input_ragged_rank,\n    const int output_ragged_rank, RaggedTensorVariant* output_ragged) {\n  output_ragged-&gt;mutable_nested_splits()-&gt;reserve(output_ragged_rank);\n  const int dims = nested_dim_sizes.size();\n\n  // Populate first `dims - 1` splits.\n  for (int i = 0; i &lt; dims - 1; i++) {\n    int dims_splits_size = nested_dim_sizes[i] + 1;\n    output_ragged-&gt;append_splits(Tensor(DataTypeToEnum&lt;SPLIT_TYPE&gt;::value,\n                                        TensorShape({dims_splits_size})));\n    auto splits_vec = output_ragged-&gt;mutable_splits(i)-&gt;vec&lt;SPLIT_TYPE&gt;();\n    int split_diff = nested_dim_sizes[i + 1];\n    for (int j = 0; j &lt; dims_splits_size; j++) {\n      splits_vec(j) = j * split_diff;\n    }\n  }\n\n  // Populate `dims`-th split.\n  int splits_size = ragged_components.size() + 1;\n  output_ragged-&gt;append_splits(\n      Tensor(DataTypeToEnum&lt;SPLIT_TYPE&gt;::value, TensorShape({splits_size})));\n  auto dims_splits_vec =\n      output_ragged-&gt;mutable_splits(dims - 1)-&gt;vec&lt;SPLIT_TYPE&gt;();\n  dims_splits_vec(0) = 0;\n  for (int i = 0; i &lt; ragged_components.size(); i++) {\n    int split_val = ragged_components[i].values().shape().dim_size(0);\n    if (input_ragged_rank != 0 &amp;&amp; ragged_components[i].ragged_rank() &gt; 0) {\n      split_val = ragged_components[i].splits(0).NumElements() - 1;\n    }\n    dims_splits_vec(i + 1) = dims_splits_vec(i) + split_val;\n  }\n\n  // Populate last `input_ragged_rank` splits.\n  for (int i = 0; i &lt; input_ragged_rank; i++) {\n    int split_index = dims + i;\n    int split_size = 1;\n    for (int j = 0; j &lt; ragged_components.size(); j++) {\n      if (!ragged_components[j].nested_splits().empty()) {\n        split_size += ragged_components[j].splits(i).NumElements() - 1;\n      }\n    }\n    output_ragged-&gt;append_splits(\n        Tensor(DataTypeToEnum&lt;SPLIT_TYPE&gt;::value, TensorShape({split_size})));\n    auto splits_vec =\n        output_ragged-&gt;mutable_splits(split_index)-&gt;vec&lt;SPLIT_TYPE&gt;();\n    splits_vec(0) = 0;\n    SPLIT_TYPE last_split_value = 0;\n    int index = 1;\n    for (int j = 0; j &lt; ragged_components.size(); j++) {\n      if (ragged_components[j].nested_splits().empty()) {\n        // Corner case: empty row. e.g [ [[x], [x]], [] ]\n        continue;\n      }\n      auto component_splits_vec =\n          ragged_components[j].splits(i).vec&lt;SPLIT_TYPE&gt;();\n      for (int k = 1; k &lt; component_splits_vec.size(); k++, index++) {\n        splits_vec(index) = component_splits_vec(k) + last_split_value;\n      }\n      last_split_value = splits_vec(index - 1);\n    }\n  }\n\n  // If the variant tensor input is empty, then we have no way to determine\n  // the correct shape for the dense_values.  (It must have rank&gt;=1, and its\n  // outer dimension must be 0, but we don\'t know its shape beyond that.)\n  // For now, we just use a shape of `[0]` in this case.\n  // TODO(edloper): Update this op with an attribute containing information\n  // about dense_values shape.  If it\'s `None`, then we\'ll probably still have\n  // to use shape=[0] here, but if we have more info, then we can use it.\n  // E.g., in map_fn, we may have shape info from the RaggedTensorSpec.\n  TensorShape component_values_shape;\n  if (ragged_components.empty()) {\n    component_values_shape = TensorShape({0});\n  } else {\n    component_values_shape = ragged_components[0].values().shape();\n  }\n\n  // Populate values.\n  int values_size = component_values_shape.dim_size(0);\n  for (int i = 1; i &lt; ragged_components.size(); i++) {\n    if (ragged_components[i].values().dims() != component_values_shape.dims()) {\n      return errors::InvalidArgument(\n          "Rank of values must match for all "\n          "components; values shape at index 0: ",\n          component_values_shape.DebugString(), ", values shape at index ", i,\n          ": ", ragged_components[i].values().shape().DebugString());\n    }\n    values_size += ragged_components[i].values().shape().dim_size(0);\n  }\n  component_values_shape.set_dim(0, values_size);\n  output_ragged-&gt;set_values(\n      Tensor(DataTypeToEnum&lt;VALUE_TYPE&gt;::value, component_values_shape));\n  auto output_values_flat =\n      output_ragged-&gt;mutable_values()-&gt;flat_outer_dims&lt;VALUE_TYPE, 2&gt;();\n  int values_index = 0;\n\n  TensorShape expected_value_shape = component_values_shape;\n  expected_value_shape.RemoveDim(0);\n\n  for (int i = 0; i &lt; ragged_components.size(); i++) {\n    // Check that the flat_values tensor shape is compatible.\n    TensorShape value_shape = ragged_components[i].values().shape();\n    value_shape.RemoveDim(0);\n    if (value_shape != expected_value_shape) {\n      return errors::InvalidArgument(\n          "All flat_values must have compatible shapes.  Shape at index 0: ",\n          expected_value_shape, ".  Shape at index ", i, ": ", value_shape,\n          ".  If you are using tf.map_fn, then you may need to specify an "\n          "explicit fn_output_signature with appropriate ragged_rank, and/or "\n          "convert output tensors to RaggedTensors.");\n    }\n\n    auto component_values_flat =\n        ragged_components[i].values().flat_outer_dims&lt;VALUE_TYPE, 2&gt;();\n    int num_inner_elements = ragged_components[i].values().NumElements();\n    if (ragged_components[i].values().dim_size(0) &gt; 0) {\n      num_inner_elements /= ragged_components[i].values().dim_size(0);\n    }\n    for (int j = 0; j &lt; ragged_components[i].values().dim_size(0);\n         j++, values_index++) {\n      for (int k = 0; k &lt; num_inner_elements; k++) {\n        output_values_flat(values_index, k) = component_values_flat(j, k);\n      }\n    }\n  }\n  return Status::OK();\n}',
 'static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat,\n\t\t\t\t     struct iov_iter *iter)\n{\n\tssize_t ret;\n\n\t*nr_segs = *len;\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret &lt; 0)\n\t\treturn ret;\n\n\t/* len now reflect bytes instead of segs */\n\t*len = ret;\n\tiov_iter_init(iter, rw, *iovec, *nr_segs, *len);\n\treturn 0;\n}',
 'static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct ib_qp_init_attr *init_attr,\n\t\t\t    struct ib_udata *udata, struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_resources *devr = &amp;dev-&gt;devr;\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev-&gt;mdev;\n\tstruct mlx5_ib_create_qp_resp resp = {};\n\tstruct mlx5_ib_cq *send_cq;\n\tstruct mlx5_ib_cq *recv_cq;\n\tunsigned long flags;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tstruct mlx5_ib_create_qp ucmd;\n\tstruct mlx5_ib_qp_base *base;\n\tint mlx5_st;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tmutex_init(&amp;qp-&gt;mutex);\n\tspin_lock_init(&amp;qp-&gt;sq.lock);\n\tspin_lock_init(&amp;qp-&gt;rq.lock);\n\n\tmlx5_st = to_mlx5_st(init_attr-&gt;qp_type);\n\tif (mlx5_st &lt; 0)\n\t\treturn -EINVAL;\n\n\tif (init_attr-&gt;rwq_ind_tbl) {\n\t\tif (!udata)\n\t\t\treturn -ENOSYS;\n\n\t\terr = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);\n\t\treturn err;\n\t}\n\n\tif (init_attr-&gt;create_flags &amp; IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {\n\t\tif (!MLX5_CAP_GEN(mdev, block_lb_mc)) {\n\t\t\tmlx5_ib_dbg(dev, "block multicast loopback isn\'t supported\\n");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tqp-&gt;flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n\t\t}\n\t}\n\n\tif (init_attr-&gt;create_flags &amp;\n\t\t\t(IB_QP_CREATE_CROSS_CHANNEL |\n\t\t\t IB_QP_CREATE_MANAGED_SEND |\n\t\t\t IB_QP_CREATE_MANAGED_RECV)) {\n\t\tif (!MLX5_CAP_GEN(mdev, cd)) {\n\t\t\tmlx5_ib_dbg(dev, "cross-channel isn\'t supported\\n");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (init_attr-&gt;create_flags &amp; IB_QP_CREATE_CROSS_CHANNEL)\n\t\t\tqp-&gt;flags |= MLX5_IB_QP_CROSS_CHANNEL;\n\t\tif (init_attr-&gt;create_flags &amp; IB_QP_CREATE_MANAGED_SEND)\n\t\t\tqp-&gt;flags |= MLX5_IB_QP_MANAGED_SEND;\n\t\tif (init_attr-&gt;create_flags &amp; IB_QP_CREATE_MANAGED_RECV)\n\t\t\tqp-&gt;flags |= MLX5_IB_QP_MANAGED_RECV;\n\t}\n\n\tif (init_attr-&gt;qp_type == IB_QPT_UD &amp;&amp;\n\t    (init_attr-&gt;create_flags &amp; IB_QP_CREATE_IPOIB_UD_LSO))\n\t\tif (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {\n\t\t\tmlx5_ib_dbg(dev, "ipoib UD lso qp isn\'t supported\\n");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\tif (init_attr-&gt;create_flags &amp; IB_QP_CREATE_SCATTER_FCS) {\n\t\tif (init_attr-&gt;qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tmlx5_ib_dbg(dev, "Scatter FCS is supported only for Raw Packet QPs");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!MLX5_CAP_GEN(dev-&gt;mdev, eth_net_offloads) ||\n\t\t    !MLX5_CAP_ETH(dev-&gt;mdev, scatter_fcs)) {\n\t\t\tmlx5_ib_dbg(dev, "Scatter FCS isn\'t supported\\n");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tqp-&gt;flags |= MLX5_IB_QP_CAP_SCATTER_FCS;\n\t}\n\n\tif (init_attr-&gt;sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp-&gt;sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tif (init_attr-&gt;create_flags &amp; IB_QP_CREATE_CVLAN_STRIPPING) {\n\t\tif (!(MLX5_CAP_GEN(dev-&gt;mdev, eth_net_offloads) &amp;&amp;\n\t\t      MLX5_CAP_ETH(dev-&gt;mdev, vlan_cap)) ||\n\t\t    (init_attr-&gt;qp_type != IB_QPT_RAW_PACKET))\n\t\t\treturn -EOPNOTSUPP;\n\t\tqp-&gt;flags |= MLX5_IB_QP_CVLAN_STRIPPING;\n\t}\n\n\tif (pd &amp;&amp; pd-&gt;uobject) {\n\t\tif (ib_copy_from_udata(&amp;ucmd, udata, sizeof(ucmd))) {\n\t\t\tmlx5_ib_dbg(dev, "copy failed\\n");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = get_qp_user_index(to_mucontext(pd-&gt;uobject-&gt;context),\n\t\t\t\t\t&amp;ucmd, udata-&gt;inlen, &amp;uidx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tqp-&gt;wq_sig = !!(ucmd.flags &amp; MLX5_QP_FLAG_SIGNATURE);\n\t\tqp-&gt;scat_cqe = !!(ucmd.flags &amp; MLX5_QP_FLAG_SCATTER_CQE);\n\t\tif (ucmd.flags &amp; MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\n\t\t\tif (init_attr-&gt;qp_type != IB_QPT_RAW_PACKET ||\n\t\t\t    !tunnel_offload_supported(mdev)) {\n\t\t\t\tmlx5_ib_dbg(dev, "Tunnel offload isn\'t supported\\n");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tqp-&gt;tunnel_offload_en = true;\n\t\t}\n\n\t\tif (init_attr-&gt;create_flags &amp; IB_QP_CREATE_SOURCE_QPN) {\n\t\t\tif (init_attr-&gt;qp_type != IB_QPT_UD ||\n\t\t\t    (MLX5_CAP_GEN(dev-&gt;mdev, port_type) !=\n\t\t\t     MLX5_CAP_PORT_TYPE_IB) ||\n\t\t\t    !mlx5_get_flow_namespace(dev-&gt;mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {\n\t\t\t\tmlx5_ib_dbg(dev, "Source QP option isn\'t supported\\n");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tqp-&gt;flags |= MLX5_IB_QP_UNDERLAY;\n\t\t\tqp-&gt;underlay_qpn = init_attr-&gt;source_qpn;\n\t\t}\n\t} else {\n\t\tqp-&gt;wq_sig = !!wq_signature;\n\t}\n\n\tbase = (init_attr-&gt;qp_type == IB_QPT_RAW_PACKET ||\n\t\tqp-&gt;flags &amp; MLX5_IB_QP_UNDERLAY) ?\n\t       &amp;qp-&gt;raw_packet_qp.rq.base :\n\t       &amp;qp-&gt;trans_qp.base;\n\n\tqp-&gt;has_rq = qp_has_rq(init_attr);\n\terr = set_rq_size(dev, &amp;init_attr-&gt;cap, qp-&gt;has_rq,\n\t\t\t  qp, (pd &amp;&amp; pd-&gt;uobject) ? &amp;ucmd : NULL);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, "err %d\\n", err);\n\t\treturn err;\n\t}\n\n\tif (pd) {\n\t\tif (pd-&gt;uobject) {\n\t\t\t__u32 max_wqes =\n\t\t\t\t1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_qp_sz);\n\t\t\tmlx5_ib_dbg(dev, "requested sq_wqe_count (%d)\\n", ucmd.sq_wqe_count);\n\t\t\tif (ucmd.rq_wqe_shift != qp-&gt;rq.wqe_shift ||\n\t\t\t    ucmd.rq_wqe_count != qp-&gt;rq.wqe_cnt) {\n\t\t\t\tmlx5_ib_dbg(dev, "invalid rq params\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ucmd.sq_wqe_count &gt; max_wqes) {\n\t\t\t\tmlx5_ib_dbg(dev, "requested sq_wqe_count (%d) &gt; max allowed (%d)\\n",\n\t\t\t\t\t    ucmd.sq_wqe_count, max_wqes);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (init_attr-&gt;create_flags &amp;\n\t\t\t    mlx5_ib_create_qp_sqpn_qp1()) {\n\t\t\t\tmlx5_ib_dbg(dev, "user-space is not allowed to create UD QPs spoofing as QP1\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = create_user_qp(dev, pd, qp, udata, init_attr, &amp;in,\n\t\t\t\t\t     &amp;resp, &amp;inlen, base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, "err %d\\n", err);\n\t\t} else {\n\t\t\terr = create_kernel_qp(dev, init_attr, qp, &amp;in, &amp;inlen,\n\t\t\t\t\t       base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, "err %d\\n", err);\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tin = kvzalloc(inlen, GFP_KERNEL);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\n\t\tqp-&gt;create_type = MLX5_QP_EMPTY;\n\t}\n\n\tif (is_sqp(init_attr-&gt;qp_type))\n\t\tqp-&gt;port = init_attr-&gt;port_num;\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\n\tif (init_attr-&gt;qp_type != MLX5_IB_QPT_REG_UMR)\n\t\tMLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr-&gt;p0)-&gt;pdn);\n\telse\n\t\tMLX5_SET(qpc, qpc, latency_sensitive, 1);\n\n\n\tif (qp-&gt;wq_sig)\n\t\tMLX5_SET(qpc, qpc, wq_signature, 1);\n\n\tif (qp-&gt;flags &amp; MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\n\t\tMLX5_SET(qpc, qpc, block_lb_mc, 1);\n\n\tif (qp-&gt;flags &amp; MLX5_IB_QP_CROSS_CHANNEL)\n\t\tMLX5_SET(qpc, qpc, cd_master, 1);\n\tif (qp-&gt;flags &amp; MLX5_IB_QP_MANAGED_SEND)\n\t\tMLX5_SET(qpc, qpc, cd_slave_send, 1);\n\tif (qp-&gt;flags &amp; MLX5_IB_QP_MANAGED_RECV)\n\t\tMLX5_SET(qpc, qpc, cd_slave_receive, 1);\n\n\tif (qp-&gt;scat_cqe &amp;&amp; is_connected(init_attr-&gt;qp_type)) {\n\t\tint rcqe_sz;\n\t\tint scqe_sz;\n\n\t\trcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr-&gt;recv_cq);\n\t\tscqe_sz = mlx5_ib_get_cqe_size(dev, init_attr-&gt;send_cq);\n\n\t\tif (rcqe_sz == 128)\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);\n\t\telse\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);\n\n\t\tif (init_attr-&gt;sq_sig_type == IB_SIGNAL_ALL_WR) {\n\t\t\tif (scqe_sz == 128)\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);\n\t\t\telse\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);\n\t\t}\n\t}\n\n\tif (qp-&gt;rq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_rq_stride, qp-&gt;rq.wqe_shift - 4);\n\t\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp-&gt;rq.wqe_cnt));\n\t}\n\n\tMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\n\n\tif (qp-&gt;sq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp-&gt;sq.wqe_cnt));\n\t} else {\n\t\tMLX5_SET(qpc, qpc, no_sq, 1);\n\t\tif (init_attr-&gt;srq &amp;&amp;\n\t\t    init_attr-&gt;srq-&gt;srq_type == IB_SRQT_TM)\n\t\t\tMLX5_SET(qpc, qpc, offload_type,\n\t\t\t\t MLX5_QPC_OFFLOAD_TYPE_RNDV);\n\t}\n\n\t/* Set default resources */\n\tswitch (init_attr-&gt;qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr-&gt;c0)-&gt;mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr-&gt;c0)-&gt;mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr-&gt;s0)-&gt;msrq.srqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr-&gt;xrcd)-&gt;xrcdn);\n\t\tbreak;\n\tcase IB_QPT_XRC_INI:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr-&gt;c0)-&gt;mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr-&gt;x1)-&gt;xrcdn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr-&gt;s0)-&gt;msrq.srqn);\n\t\tbreak;\n\tdefault:\n\t\tif (init_attr-&gt;srq) {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr-&gt;x0)-&gt;xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr-&gt;srq)-&gt;msrq.srqn);\n\t\t} else {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr-&gt;x1)-&gt;xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr-&gt;s1)-&gt;msrq.srqn);\n\t\t}\n\t}\n\n\tif (init_attr-&gt;send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr-&gt;send_cq)-&gt;mcq.cqn);\n\n\tif (init_attr-&gt;recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr-&gt;recv_cq)-&gt;mcq.cqn);\n\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp-&gt;db.dma);\n\n\t/* 0xffffff means we ask to work with cqe version 0 */\n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\t/* we use IB_QP_CREATE_IPOIB_UD_LSO to indicates ipoib qp */\n\tif (init_attr-&gt;qp_type == IB_QPT_UD &amp;&amp;\n\t    (init_attr-&gt;create_flags &amp; IB_QP_CREATE_IPOIB_UD_LSO)) {\n\t\tMLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);\n\t\tqp-&gt;flags |= MLX5_IB_QP_LSO;\n\t}\n\n\tif (init_attr-&gt;create_flags &amp; IB_QP_CREATE_PCI_WRITE_END_PADDING) {\n\t\tif (!MLX5_CAP_GEN(dev-&gt;mdev, end_pad)) {\n\t\t\tmlx5_ib_dbg(dev, "scatter end padding is not supported\\n");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t} else if (init_attr-&gt;qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tMLX5_SET(qpc, qpc, end_padding_mode,\n\t\t\t\t MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t} else {\n\t\t\tqp-&gt;flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;\n\t\t}\n\t}\n\n\tif (inlen &lt; 0) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (init_attr-&gt;qp_type == IB_QPT_RAW_PACKET ||\n\t    qp-&gt;flags &amp; MLX5_IB_QP_UNDERLAY) {\n\t\tqp-&gt;raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;\n\t\traw_packet_qp_copy_info(qp, &amp;qp-&gt;raw_packet_qp);\n\t\terr = create_raw_packet_qp(dev, qp, in, inlen, pd);\n\t} else {\n\t\terr = mlx5_core_create_qp(dev-&gt;mdev, &amp;base-&gt;mqp, in, inlen);\n\t}\n\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, "create qp failed\\n");\n\t\tgoto err_create;\n\t}\n\n\tkvfree(in);\n\n\tbase-&gt;container_mibqp = qp;\n\tbase-&gt;mqp.event = mlx5_ib_qp_event;\n\n\tget_cqs(init_attr-&gt;qp_type, init_attr-&gt;send_cq, init_attr-&gt;recv_cq,\n\t\t&amp;send_cq, &amp;recv_cq);\n\tspin_lock_irqsave(&amp;dev-&gt;reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t/* Maintain device to QPs access, needed for further handling via reset\n\t * flow\n\t */\n\tlist_add_tail(&amp;qp-&gt;qps_list, &amp;dev-&gt;qp_list);\n\t/* Maintain CQ to QPs access, needed for further handling via reset flow\n\t */\n\tif (send_cq)\n\t\tlist_add_tail(&amp;qp-&gt;cq_send_list, &amp;send_cq-&gt;list_send_qp);\n\tif (recv_cq)\n\t\tlist_add_tail(&amp;qp-&gt;cq_recv_list, &amp;recv_cq-&gt;list_recv_qp);\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&amp;dev-&gt;reset_flow_resource_lock, flags);\n\n\treturn 0;\n\nerr_create:\n\tif (qp-&gt;create_type == MLX5_QP_USER)\n\t\tdestroy_qp_user(dev, pd, qp, base);\n\telse if (qp-&gt;create_type == MLX5_QP_KERNEL)\n\t\tdestroy_qp_kernel(dev, qp);\n\nerr:\n\tkvfree(in);\n\treturn err;\n}']</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=74fc15aa">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">AutoTokenizer</span><span class="p">,</span> <span class="n">AutoModelForSequenceClassification</span>

<span class="n">model_name</span> <span class="o">=</span> <span class="s2">"microsoft/codebert-base"</span>
<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">AutoTokenizer</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">AutoModelForSequenceClassification</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">num_labels</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>Some weights of RobertaForSequenceClassification were not initialized from the model checkpoint at microsoft/codebert-base and are newly initialized: ['classifier.dense.bias', 'classifier.dense.weight', 'classifier.out_proj.bias', 'classifier.out_proj.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=1f8c3553">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">datasets</span> <span class="kn">import</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">concatenate_datasets</span>


<span class="c1"># The maximum total input sequence length after tokenization.</span>
<span class="c1"># Sequences longer than this will be truncated, sequences shorter will be padded.</span>
<span class="n">tokenized_inputs</span> <span class="o">=</span> <span class="n">concatenate_datasets</span><span class="p">([</span><span class="n">dataset</span><span class="p">[</span><span class="s2">"train"</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">"test"</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">"validation"</span><span class="p">]])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">"text"</span><span class="p">],</span> <span class="n">truncation</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">batched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">remove_columns</span><span class="o">=</span><span class="p">[</span><span class="s1">'text'</span><span class="p">,</span> <span class="s1">'label'</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">max_source_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tokenized_inputs</span><span class="p">[</span><span class="s2">"input_ids"</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Max source length: </span><span class="si">{</span><span class="n">max_source_length</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1"># Calculate the average input length</span>
<span class="n">average_source_length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tokenized_inputs</span><span class="p">[</span><span class="s2">"input_ids"</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokenized_inputs</span><span class="p">[</span><span class="s2">"input_ids"</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Average source length: </span><span class="si">{</span><span class="n">average_source_length</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>c:\Users\tiago\anaconda3\envs\LLMs_DiverseVul_ENV\Lib\site-packages\datasets\table.py:1395: FutureWarning: promote has been superseded by promote_options='default'.
  block_group = [InMemoryTable(cls._concat_blocks(list(block_group), axis=axis))]
c:\Users\tiago\anaconda3\envs\LLMs_DiverseVul_ENV\Lib\site-packages\datasets\table.py:1421: FutureWarning: promote has been superseded by promote_options='default'.
  table = cls._concat_blocks(blocks, axis=0)
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>Max source length: 512
Average source length: 374.1322636600174
</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell jp-mod-noOutputs" id="cell-id=af84d45e">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">calendar</span> <span class="kn">import</span> <span class="n">IllegalWeekdayError</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">def</span> <span class="nf">tokenize_function</span><span class="p">(</span><span class="n">examples</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">examples</span><span class="p">[</span><span class="s2">"text"</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="s2">"max_length"</span><span class="p">,</span> <span class="n">truncation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="n">max_source_length</span><span class="p">)</span>

<span class="n">tokenized_datasets</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">tokenize_function</span><span class="p">,</span> <span class="n">batched</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell jp-mod-noOutputs" id="cell-id=ea5c2bb6">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">evaluate</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">metric</span> <span class="o">=</span> <span class="n">evaluate</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">"f1"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">compute_metrics</span><span class="p">(</span><span class="n">eval_pred</span><span class="p">):</span>
    <span class="n">logits</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">eval_pred</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">metric</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">predictions</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span> <span class="n">references</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=29a9759c">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h1 id="Configure-LoRA-(Optional)">Configure LoRA (Optional)<a class="anchor-link" href="#Configure-LoRA-(Optional)">¶</a></h1>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=63b89236">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">peft</span> <span class="kn">import</span> <span class="n">LoraConfig</span><span class="p">,</span> <span class="n">TaskType</span>

<span class="n">lora_config</span> <span class="o">=</span> <span class="n">LoraConfig</span><span class="p">(</span><span class="n">inference_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
<span class="n">lora_alpha</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
<span class="n">lora_dropout</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
<span class="n">task_type</span><span class="o">=</span><span class="n">TaskType</span><span class="o">.</span><span class="n">SEQ_CLS</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">peft</span> <span class="kn">import</span> <span class="n">get_peft_model</span>
<span class="n">model_peft</span> <span class="o">=</span> <span class="n">get_peft_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">lora_config</span><span class="p">)</span>
<span class="n">model_peft</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child jp-OutputArea-executeResult">
<div class="jp-OutputPrompt jp-OutputArea-prompt">Out[ ]:</div>
<div class="jp-RenderedText jp-OutputArea-output jp-OutputArea-executeResult" data-mime-type="text/plain" tabindex="0">
<pre>PeftModelForSequenceClassification(
  (base_model): LoraModel(
    (model): RobertaForSequenceClassification(
      (roberta): RobertaModel(
        (embeddings): RobertaEmbeddings(
          (word_embeddings): Embedding(50265, 768, padding_idx=1)
          (position_embeddings): Embedding(514, 768, padding_idx=1)
          (token_type_embeddings): Embedding(1, 768)
          (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
          (dropout): Dropout(p=0.1, inplace=False)
        )
        (encoder): RobertaEncoder(
          (layer): ModuleList(
            (0-11): 12 x RobertaLayer(
              (attention): RobertaAttention(
                (self): RobertaSelfAttention(
                  (query): lora.Linear(
                    (base_layer): Linear(in_features=768, out_features=768, bias=True)
                    (lora_dropout): ModuleDict(
                      (default): Dropout(p=0.05, inplace=False)
                    )
                    (lora_A): ModuleDict(
                      (default): Linear(in_features=768, out_features=8, bias=False)
                    )
                    (lora_B): ModuleDict(
                      (default): Linear(in_features=8, out_features=768, bias=False)
                    )
                    (lora_embedding_A): ParameterDict()
                    (lora_embedding_B): ParameterDict()
                  )
                  (key): Linear(in_features=768, out_features=768, bias=True)
                  (value): lora.Linear(
                    (base_layer): Linear(in_features=768, out_features=768, bias=True)
                    (lora_dropout): ModuleDict(
                      (default): Dropout(p=0.05, inplace=False)
                    )
                    (lora_A): ModuleDict(
                      (default): Linear(in_features=768, out_features=8, bias=False)
                    )
                    (lora_B): ModuleDict(
                      (default): Linear(in_features=8, out_features=768, bias=False)
                    )
                    (lora_embedding_A): ParameterDict()
                    (lora_embedding_B): ParameterDict()
                  )
                  (dropout): Dropout(p=0.1, inplace=False)
                )
                (output): RobertaSelfOutput(
                  (dense): Linear(in_features=768, out_features=768, bias=True)
                  (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
                  (dropout): Dropout(p=0.1, inplace=False)
                )
              )
              (intermediate): RobertaIntermediate(
                (dense): Linear(in_features=768, out_features=3072, bias=True)
                (intermediate_act_fn): GELUActivation()
              )
              (output): RobertaOutput(
                (dense): Linear(in_features=3072, out_features=768, bias=True)
                (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
                (dropout): Dropout(p=0.1, inplace=False)
              )
            )
          )
        )
      )
      (classifier): ModulesToSaveWrapper(
        (original_module): RobertaClassificationHead(
          (dense): Linear(in_features=768, out_features=768, bias=True)
          (dropout): Dropout(p=0.1, inplace=False)
          (out_proj): Linear(in_features=768, out_features=2, bias=True)
        )
        (modules_to_save): ModuleDict(
          (default): RobertaClassificationHead(
            (dense): Linear(in_features=768, out_features=768, bias=True)
            (dropout): Dropout(p=0.1, inplace=False)
            (out_proj): Linear(in_features=768, out_features=2, bias=True)
          )
        )
      )
    )
  )
)</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=22b7760a">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">Trainer</span><span class="p">,</span> <span class="n">TrainingArguments</span><span class="p">,</span> <span class="n">DataCollatorWithPadding</span>
<span class="kn">import</span> <span class="nn">evaluate</span>

<span class="n">training_args</span> <span class="o">=</span> <span class="n">TrainingArguments</span><span class="p">(</span>
    <span class="n">output_dir</span><span class="o">=</span><span class="s2">"./CodeBERT_Original_CVE_Fixes_5050_no_errors_opt_lora_batch_16"</span><span class="p">,</span>
    <span class="n">overwrite_output_dir</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">per_device_train_batch_size</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">2e-5</span><span class="p">,</span>
    <span class="n">weight_decay</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
    <span class="n">num_train_epochs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">logging_steps</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="n">save_steps</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="n">warmup_steps</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="n">evaluation_strategy</span><span class="o">=</span><span class="s2">"steps"</span><span class="p">,</span>
    <span class="n">eval_steps</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="n">logging_dir</span><span class="o">=</span><span class="n">RESULTS_DIR</span> <span class="o">+</span> <span class="s2">"/logs"</span><span class="p">,</span>  <span class="c1"># Replace with your desired logging directory</span>
    <span class="n">report_to</span><span class="o">=</span><span class="s2">"wandb"</span><span class="p">,</span>
    <span class="n">run_name</span> <span class="o">=</span> <span class="n">RESULTS_DIR</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
<span class="p">)</span>

<span class="n">data_collator</span> <span class="o">=</span> <span class="n">DataCollatorWithPadding</span><span class="p">(</span><span class="n">tokenizer</span><span class="o">=</span><span class="n">tokenizer</span><span class="p">)</span>

<span class="c1"># Define a Trainer instance with the prepared datasets</span>
<span class="n">trainer</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
    <span class="n">args</span><span class="o">=</span><span class="n">training_args</span><span class="p">,</span>
    <span class="n">train_dataset</span><span class="o">=</span><span class="n">tokenized_datasets</span><span class="p">[</span><span class="s2">"train"</span><span class="p">],</span>
    <span class="n">eval_dataset</span><span class="o">=</span><span class="n">tokenized_datasets</span><span class="p">[</span><span class="s2">"validation"</span><span class="p">],</span>
    <span class="n">compute_metrics</span><span class="o">=</span><span class="n">compute_metrics</span><span class="p">,</span>
    <span class="n">data_collator</span><span class="o">=</span><span class="n">data_collator</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"### STARTING TRAINING ###"</span><span class="p">)</span>
<span class="n">train_output</span> <span class="o">=</span> <span class="n">trainer</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>

<span class="n">trainer</span><span class="o">.</span><span class="n">save_model</span><span class="p">(</span><span class="n">RESULTS_DIR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>c:\Users\tiago\anaconda3\envs\LLMs_DiverseVul_ENV\Lib\site-packages\accelerate\accelerator.py:432: FutureWarning: Passing the following arguments to `Accelerator` is deprecated and will be removed in version 1.0 of Accelerate: dict_keys(['dispatch_batches', 'split_batches', 'even_batches', 'use_seedable_sampler']). Please pass an `accelerate.DataLoaderConfiguration` instead: 
dataloader_config = DataLoaderConfiguration(dispatch_batches=None, split_batches=False, even_batches=True, use_seedable_sampler=True)
  warnings.warn(
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>### STARTING TRAINING ###
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output" data-mime-type="text/html" tabindex="0">
Changes to your `wandb` environment variables will be ignored because your `wandb` session has already started. For more information on how to modify your settings with `wandb.init()` arguments, please refer to <a href="https://wandb.me/wandb-init" target="_blank">the W&amp;B docs</a>.
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output" data-mime-type="text/html" tabindex="0">
wandb version 0.16.6 is available!  To upgrade, please run:
 $ pip install wandb --upgrade
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output" data-mime-type="text/html" tabindex="0">
Tracking run with wandb version 0.16.3
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output" data-mime-type="text/html" tabindex="0">
Run data is saved locally in <code>c:\Users\tiago\OneDrive - Instituto Superior de Engenharia do Porto\Documents\GECAD\DiverseVul LLMs Analysis\DiverseVul Code\CodeBERT\wandb\run-20240406_122417-edn0r963</code>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output" data-mime-type="text/html" tabindex="0">
Syncing run <strong><a href="https://wandb.ai/1180939/huggingface/runs/edn0r963" target="_blank">CodeBERT_Original_CVE_Fixes_5050_no_errors_opt_lora_batch_16</a></strong> to <a href="https://wandb.ai/1180939/huggingface" target="_blank">Weights &amp; Biases</a> (<a href="https://wandb.me/run" target="_blank">docs</a>)<br/>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output" data-mime-type="text/html" tabindex="0">
 View project at <a href="https://wandb.ai/1180939/huggingface" target="_blank">https://wandb.ai/1180939/huggingface</a>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output" data-mime-type="text/html" tabindex="0">
 View run at <a href="https://wandb.ai/1180939/huggingface/runs/edn0r963" target="_blank">https://wandb.ai/1180939/huggingface/runs/edn0r963</a>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>  5%|▍         | 200/4040 [02:20&lt;44:14,  1.45it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.704, 'grad_norm': 1.6469228267669678, 'learning_rate': 2e-05, 'epoch': 0.5}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                  
  5%|▍         | 200/4040 [02:39&lt;44:14,  1.45it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6936721801757812, 'eval_f1': 0.6586284853051997, 'eval_runtime': 19.0464, 'eval_samples_per_second': 48.461, 'eval_steps_per_second': 6.09, 'epoch': 0.5}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 10%|▉         | 400/4040 [05:02&lt;43:06,  1.41it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.699, 'grad_norm': 1.5041100978851318, 'learning_rate': 1.8958333333333334e-05, 'epoch': 0.99}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                  
 10%|▉         | 400/4040 [05:21&lt;43:06,  1.41it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6937400102615356, 'eval_f1': 0.004310344827586207, 'eval_runtime': 19.495, 'eval_samples_per_second': 47.346, 'eval_steps_per_second': 5.95, 'epoch': 0.99}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 15%|█▍        | 600/4040 [07:52&lt;43:54,  1.31it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6978, 'grad_norm': 2.0111522674560547, 'learning_rate': 1.7916666666666667e-05, 'epoch': 1.49}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                  
 15%|█▍        | 600/4040 [08:12&lt;43:54,  1.31it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6927103400230408, 'eval_f1': 0.4583835946924005, 'eval_runtime': 20.6346, 'eval_samples_per_second': 44.731, 'eval_steps_per_second': 5.622, 'epoch': 1.49}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 20%|█▉        | 800/4040 [10:44&lt;39:21,  1.37it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6969, 'grad_norm': 5.535262584686279, 'learning_rate': 1.6875e-05, 'epoch': 1.98}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                  
 20%|█▉        | 800/4040 [11:05&lt;39:21,  1.37it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6954497694969177, 'eval_f1': 0.0, 'eval_runtime': 20.3031, 'eval_samples_per_second': 45.461, 'eval_steps_per_second': 5.713, 'epoch': 1.98}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 25%|██▍       | 1000/4040 [13:38&lt;38:01,  1.33it/s] </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6971, 'grad_norm': 4.035704612731934, 'learning_rate': 1.5833333333333333e-05, 'epoch': 2.48}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 25%|██▍       | 1000/4040 [14:14&lt;38:01,  1.33it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6926795840263367, 'eval_f1': 0.6144578313253012, 'eval_runtime': 35.5677, 'eval_samples_per_second': 25.95, 'eval_steps_per_second': 3.261, 'epoch': 2.48}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 30%|██▉       | 1200/4040 [16:39&lt;33:09,  1.43it/s]   </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6957, 'grad_norm': 1.4162617921829224, 'learning_rate': 1.479166666666667e-05, 'epoch': 2.97}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 30%|██▉       | 1200/4040 [16:58&lt;33:09,  1.43it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6924439668655396, 'eval_f1': 0.4301606922126082, 'eval_runtime': 19.0218, 'eval_samples_per_second': 48.523, 'eval_steps_per_second': 6.098, 'epoch': 2.97}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 35%|███▍      | 1400/4040 [19:21&lt;30:32,  1.44it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6949, 'grad_norm': 2.3144524097442627, 'learning_rate': 1.375e-05, 'epoch': 3.47}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 35%|███▍      | 1400/4040 [19:40&lt;30:32,  1.44it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6936743855476379, 'eval_f1': 0.64, 'eval_runtime': 19.2487, 'eval_samples_per_second': 47.951, 'eval_steps_per_second': 6.026, 'epoch': 3.47}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 40%|███▉      | 1600/4040 [22:04&lt;29:32,  1.38it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6986, 'grad_norm': 2.579261541366577, 'learning_rate': 1.2708333333333333e-05, 'epoch': 3.96}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 40%|███▉      | 1600/4040 [22:23&lt;29:32,  1.38it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.692092776298523, 'eval_f1': 0.547595682041217, 'eval_runtime': 19.2043, 'eval_samples_per_second': 48.062, 'eval_steps_per_second': 6.04, 'epoch': 3.96}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 45%|████▍     | 1800/4040 [24:49&lt;26:15,  1.42it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6942, 'grad_norm': 1.8786706924438477, 'learning_rate': 1.1666666666666668e-05, 'epoch': 4.46}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 45%|████▍     | 1800/4040 [25:08&lt;26:15,  1.42it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.707314133644104, 'eval_f1': 0.0, 'eval_runtime': 19.299, 'eval_samples_per_second': 47.826, 'eval_steps_per_second': 6.011, 'epoch': 4.46}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 50%|████▉     | 2000/4040 [27:41&lt;25:02,  1.36it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6948, 'grad_norm': 1.3764344453811646, 'learning_rate': 1.0625e-05, 'epoch': 4.95}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 50%|████▉     | 2000/4040 [28:01&lt;25:02,  1.36it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6915770173072815, 'eval_f1': 0.5746478873239437, 'eval_runtime': 20.339, 'eval_samples_per_second': 45.381, 'eval_steps_per_second': 5.703, 'epoch': 4.95}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 54%|█████▍    | 2200/4040 [30:34&lt;23:10,  1.32it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6928, 'grad_norm': 2.6451239585876465, 'learning_rate': 9.583333333333335e-06, 'epoch': 5.45}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 54%|█████▍    | 2200/4040 [30:54&lt;23:10,  1.32it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6916581392288208, 'eval_f1': 0.40745672436751, 'eval_runtime': 20.5696, 'eval_samples_per_second': 44.872, 'eval_steps_per_second': 5.639, 'epoch': 5.45}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 59%|█████▉    | 2400/4040 [33:25&lt;20:04,  1.36it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6942, 'grad_norm': 1.5036994218826294, 'learning_rate': 8.541666666666666e-06, 'epoch': 5.94}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 59%|█████▉    | 2400/4040 [33:45&lt;20:04,  1.36it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6913356184959412, 'eval_f1': 0.506050605060506, 'eval_runtime': 20.0843, 'eval_samples_per_second': 45.956, 'eval_steps_per_second': 5.776, 'epoch': 5.94}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 64%|██████▍   | 2600/4040 [36:09&lt;17:38,  1.36it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6939, 'grad_norm': 2.728184700012207, 'learning_rate': 7.500000000000001e-06, 'epoch': 6.44}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 64%|██████▍   | 2600/4040 [36:29&lt;17:38,  1.36it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6911323666572571, 'eval_f1': 0.5788018433179724, 'eval_runtime': 20.1777, 'eval_samples_per_second': 45.744, 'eval_steps_per_second': 5.749, 'epoch': 6.44}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 69%|██████▉   | 2800/4040 [38:55&lt;15:12,  1.36it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6932, 'grad_norm': 1.7159444093704224, 'learning_rate': 6.458333333333334e-06, 'epoch': 6.93}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 69%|██████▉   | 2800/4040 [39:17&lt;15:12,  1.36it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6912453174591064, 'eval_f1': 0.5962399283795882, 'eval_runtime': 21.1521, 'eval_samples_per_second': 43.636, 'eval_steps_per_second': 5.484, 'epoch': 6.93}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 74%|███████▍  | 3000/4040 [41:50&lt;12:56,  1.34it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6903, 'grad_norm': 2.3770041465759277, 'learning_rate': 5.416666666666667e-06, 'epoch': 7.43}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 74%|███████▍  | 3000/4040 [42:11&lt;12:56,  1.34it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6913447380065918, 'eval_f1': 0.4516129032258065, 'eval_runtime': 20.39, 'eval_samples_per_second': 45.267, 'eval_steps_per_second': 5.689, 'epoch': 7.43}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 79%|███████▉  | 3200/4040 [44:45&lt;10:36,  1.32it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6939, 'grad_norm': 2.8182263374328613, 'learning_rate': 4.3750000000000005e-06, 'epoch': 7.92}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 79%|███████▉  | 3200/4040 [45:07&lt;10:36,  1.32it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6912177801132202, 'eval_f1': 0.6129597197898423, 'eval_runtime': 21.1199, 'eval_samples_per_second': 43.703, 'eval_steps_per_second': 5.492, 'epoch': 7.92}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 84%|████████▍ | 3400/4040 [47:37&lt;08:00,  1.33it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.694, 'grad_norm': 2.780134439468384, 'learning_rate': 3.3333333333333333e-06, 'epoch': 8.42}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 84%|████████▍ | 3400/4040 [47:58&lt;08:00,  1.33it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6910640001296997, 'eval_f1': 0.4276401564537158, 'eval_runtime': 20.7918, 'eval_samples_per_second': 44.392, 'eval_steps_per_second': 5.579, 'epoch': 8.42}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 89%|████████▉ | 3600/4040 [50:29&lt;05:18,  1.38it/s]  </pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6926, 'grad_norm': 1.801100254058838, 'learning_rate': 2.2916666666666666e-06, 'epoch': 8.91}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 89%|████████▉ | 3600/4040 [50:49&lt;05:18,  1.38it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6906830668449402, 'eval_f1': 0.5754451733833177, 'eval_runtime': 20.0198, 'eval_samples_per_second': 46.104, 'eval_steps_per_second': 5.794, 'epoch': 8.91}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 94%|█████████▍| 3800/4040 [53:23&lt;03:00,  1.33it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6907, 'grad_norm': 2.7365074157714844, 'learning_rate': 1.25e-06, 'epoch': 9.41}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 94%|█████████▍| 3800/4040 [53:43&lt;03:00,  1.33it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6906414031982422, 'eval_f1': 0.5686839577329491, 'eval_runtime': 20.5524, 'eval_samples_per_second': 44.91, 'eval_steps_per_second': 5.644, 'epoch': 9.41}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre> 99%|█████████▉| 4000/4040 [56:17&lt;00:29,  1.34it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'loss': 0.6914, 'grad_norm': 4.8527936935424805, 'learning_rate': 2.0833333333333333e-07, 'epoch': 9.9}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>                                                   
 99%|█████████▉| 4000/4040 [56:38&lt;00:29,  1.34it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'eval_loss': 0.6906518936157227, 'eval_f1': 0.494407158836689, 'eval_runtime': 21.618, 'eval_samples_per_second': 42.696, 'eval_steps_per_second': 5.366, 'epoch': 9.9}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>100%|██████████| 4040/4040 [57:11&lt;00:00,  1.58it/s]c:\Users\tiago\anaconda3\envs\LLMs_DiverseVul_ENV\Lib\site-packages\accelerate\accelerator.py:432: FutureWarning: Passing the following arguments to `Accelerator` is deprecated and will be removed in version 1.0 of Accelerate: dict_keys(['dispatch_batches', 'split_batches', 'even_batches', 'use_seedable_sampler']). Please pass an `accelerate.DataLoaderConfiguration` instead: 
dataloader_config = DataLoaderConfiguration(dispatch_batches=None, split_batches=False, even_batches=True, use_seedable_sampler=True)
  warnings.warn(
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>{'train_runtime': 3437.0543, 'train_samples_per_second': 18.784, 'train_steps_per_second': 1.175, 'train_loss': 0.6949784831245347, 'epoch': 10.0}
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>100%|██████████| 4040/4040 [57:15&lt;00:00,  1.18it/s]
</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=1368dfbb">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h1 id="Evaluation">Evaluation<a class="anchor-link" href="#Evaluation">¶</a></h1>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=2a17c33a">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span><span class="p">,</span> <span class="n">accuracy_score</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">import</span> <span class="nn">evaluate</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Evaluate the model on the test dataset."""</span>
    <span class="n">predictions_list</span><span class="p">,</span> <span class="n">labels_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="c1"># Make predictions on the test set</span>
    <span class="n">test_results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">tokenized_datasets</span><span class="p">[</span><span class="s2">"test"</span><span class="p">])</span>
    <span class="n">predictions_list</span> <span class="o">=</span> <span class="n">test_results</span><span class="o">.</span><span class="n">predictions</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">labels_list</span> <span class="o">=</span> <span class="n">tokenized_datasets</span><span class="p">[</span><span class="s2">"test"</span><span class="p">][</span><span class="s2">"label"</span><span class="p">]</span>

    <span class="n">report</span> <span class="o">=</span> <span class="n">classification_report</span><span class="p">(</span><span class="n">labels_list</span><span class="p">,</span> <span class="n">predictions_list</span><span class="p">)</span>
    <span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">labels_list</span><span class="p">,</span> <span class="n">predictions_list</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">report</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">accuracy</span><span class="p">)</span>

<span class="n">evaluate</span><span class="p">(</span><span class="n">trainer</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>100%|██████████| 231/231 [00:38&lt;00:00,  5.96it/s]</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>              precision    recall  f1-score   support

           0       0.52      0.52      0.52       923
           1       0.52      0.53      0.53       922

    accuracy                           0.52      1845
   macro avg       0.52      0.52      0.52      1845
weighted avg       0.52      0.52      0.52      1845

0.5235772357723577
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>
</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell jp-mod-noOutputs" id="cell-id=fe0afc09">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span> 
</pre></div>
</div>
</div>
</div>
</div>
</div>
</main>
</body>
</html>
